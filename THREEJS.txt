# three.js 

> JavaScript 3D Library. 

<a name="AnimationClipCreator"></a>

## AnimationClipCreator
A utility class with factory methods for creating basic animation clips.

**Kind**: global class  

* [AnimationClipCreator](#AnimationClipCreator)
    * [.CreateRotationAnimation(period, [axis])](#AnimationClipCreator.CreateRotationAnimation) ⇒ <code>AnimationClip</code>
    * [.CreateScaleAxisAnimation(period, [axis])](#AnimationClipCreator.CreateScaleAxisAnimation) ⇒ <code>AnimationClip</code>
    * [.CreateShakeAnimation(duration, shakeScale)](#AnimationClipCreator.CreateShakeAnimation) ⇒ <code>AnimationClip</code>
    * [.CreatePulsationAnimation(duration, pulseScale)](#AnimationClipCreator.CreatePulsationAnimation) ⇒ <code>AnimationClip</code>
    * [.CreateVisibilityAnimation(duration)](#AnimationClipCreator.CreateVisibilityAnimation) ⇒ <code>AnimationClip</code>
    * [.CreateMaterialColorAnimation(duration, colors)](#AnimationClipCreator.CreateMaterialColorAnimation) ⇒ <code>AnimationClip</code>

<a name="AnimationClipCreator.CreateRotationAnimation"></a>

### AnimationClipCreator.CreateRotationAnimation(period, [axis]) ⇒ <code>AnimationClip</code>
Creates an animation clip that rotates a 3D object 360 degrees
in the given period of time around the given axis.

**Kind**: static method of [<code>AnimationClipCreator</code>](#AnimationClipCreator)  
**Returns**: <code>AnimationClip</code> - The created animation clip.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| period | <code>number</code> |  | The duration of the animation. |
| [axis] | <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code> | <code>&#x27;x&#x27;</code> | The axis of rotation. |

<a name="AnimationClipCreator.CreateScaleAxisAnimation"></a>

### AnimationClipCreator.CreateScaleAxisAnimation(period, [axis]) ⇒ <code>AnimationClip</code>
Creates an animation clip that scales a 3D object from `0` to `1`
in the given period of time along the given axis.

**Kind**: static method of [<code>AnimationClipCreator</code>](#AnimationClipCreator)  
**Returns**: <code>AnimationClip</code> - The created animation clip.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| period | <code>number</code> |  | The duration of the animation. |
| [axis] | <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code> | <code>&#x27;x&#x27;</code> | The axis to scale the 3D object along. |

<a name="AnimationClipCreator.CreateShakeAnimation"></a>

### AnimationClipCreator.CreateShakeAnimation(duration, shakeScale) ⇒ <code>AnimationClip</code>
Creates an animation clip that translates a 3D object in a shake pattern
in the given period.

**Kind**: static method of [<code>AnimationClipCreator</code>](#AnimationClipCreator)  
**Returns**: <code>AnimationClip</code> - The created animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| duration | <code>number</code> | The duration of the animation. |
| shakeScale | <code>Vector3</code> | The scale of the shake. |

<a name="AnimationClipCreator.CreatePulsationAnimation"></a>

### AnimationClipCreator.CreatePulsationAnimation(duration, pulseScale) ⇒ <code>AnimationClip</code>
Creates an animation clip that scales a 3D object in a pulse pattern
in the given period.

**Kind**: static method of [<code>AnimationClipCreator</code>](#AnimationClipCreator)  
**Returns**: <code>AnimationClip</code> - The created animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| duration | <code>number</code> | The duration of the animation. |
| pulseScale | <code>number</code> | The scale of the pulse. |

<a name="AnimationClipCreator.CreateVisibilityAnimation"></a>

### AnimationClipCreator.CreateVisibilityAnimation(duration) ⇒ <code>AnimationClip</code>
Creates an animation clip that toggles the visibility of a 3D object.

**Kind**: static method of [<code>AnimationClipCreator</code>](#AnimationClipCreator)  
**Returns**: <code>AnimationClip</code> - The created animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| duration | <code>number</code> | The duration of the animation. |

<a name="AnimationClipCreator.CreateMaterialColorAnimation"></a>

### AnimationClipCreator.CreateMaterialColorAnimation(duration, colors) ⇒ <code>AnimationClip</code>
Creates an animation clip that animates the `color` property of a 3D object's
material.

**Kind**: static method of [<code>AnimationClipCreator</code>](#AnimationClipCreator)  
**Returns**: <code>AnimationClip</code> - The created animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| duration | <code>number</code> | The duration of the animation. |
| colors | <code>Array.&lt;Color&gt;</code> | An array of colors that should be sequentially animated. |

## Classes

<dl>
<dt><a href="#CCDIKSolver">CCDIKSolver</a></dt>
<dd><p>This class solves the Inverse Kinematics Problem with a <a href="https://web.archive.org/web/20221206080850/https://sites.google.com/site/auraliusproject/ccd-algorithm">CCD Algorithm</a>.</p>
<p><code>CCDIKSolver</code> is designed to work with instances of <a href="SkinnedMesh">SkinnedMesh</a>.</p>
</dd>
<dt><a href="#CCDIKHelper">CCDIKHelper</a> ⇐ <code>Object3D</code></dt>
<dd><p>Helper for visualizing IK bones.</p>
</dd>
</dl>

<a name="CCDIKSolver"></a>

## CCDIKSolver
This class solves the Inverse Kinematics Problem with a [CCD Algorithm](https://web.archive.org/web/20221206080850/https://sites.google.com/site/auraliusproject/ccd-algorithm).

`CCDIKSolver` is designed to work with instances of [SkinnedMesh](SkinnedMesh).

**Kind**: global class  

* [CCDIKSolver](#CCDIKSolver)
    * [new CCDIKSolver(mesh, [iks])](#new_CCDIKSolver_new)
    * _instance_
        * [.mesh](#CCDIKSolver+mesh) : <code>SkinnedMesh</code>
        * [.iks](#CCDIKSolver+iks) : <code>SkinnedMesh</code>
        * [.update([globalBlendFactor])](#CCDIKSolver+update) ⇒ [<code>CCDIKSolver</code>](#CCDIKSolver)
        * [.updateOne(ik, [overrideBlend])](#CCDIKSolver+updateOne) ⇒ [<code>CCDIKSolver</code>](#CCDIKSolver)
        * [.createHelper(sphereSize)](#CCDIKSolver+createHelper) ⇒ [<code>CCDIKHelper</code>](#CCDIKHelper)
    * _inner_
        * [~IK](#CCDIKSolver..IK) : <code>Object</code>
        * [~BoneLink](#CCDIKSolver..BoneLink) : <code>Object</code>

<a name="new_CCDIKSolver_new"></a>

### new CCDIKSolver(mesh, [iks])

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>SkinnedMesh</code> |  | The skinned mesh. |
| [iks] | [<code>Array.&lt;IK&gt;</code>](#CCDIKSolver..IK) | <code>[]</code> | The IK objects. |

<a name="CCDIKSolver+mesh"></a>

### ccdikSolver.mesh : <code>SkinnedMesh</code>
The skinned mesh.

**Kind**: instance property of [<code>CCDIKSolver</code>](#CCDIKSolver)  
<a name="CCDIKSolver+iks"></a>

### ccdikSolver.iks : <code>SkinnedMesh</code>
The IK objects.

**Kind**: instance property of [<code>CCDIKSolver</code>](#CCDIKSolver)  
<a name="CCDIKSolver+update"></a>

### ccdikSolver.update([globalBlendFactor]) ⇒ [<code>CCDIKSolver</code>](#CCDIKSolver)
Updates all IK bones by solving the CCD algorithm.

**Kind**: instance method of [<code>CCDIKSolver</code>](#CCDIKSolver)  
**Returns**: [<code>CCDIKSolver</code>](#CCDIKSolver) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [globalBlendFactor] | <code>number</code> | <code>1.0</code> | Blend factor applied if an IK chain doesn't have its own .blendFactor. |

<a name="CCDIKSolver+updateOne"></a>

### ccdikSolver.updateOne(ik, [overrideBlend]) ⇒ [<code>CCDIKSolver</code>](#CCDIKSolver)
Updates one IK bone solving the CCD algorithm.

**Kind**: instance method of [<code>CCDIKSolver</code>](#CCDIKSolver)  
**Returns**: [<code>CCDIKSolver</code>](#CCDIKSolver) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| ik | [<code>IK</code>](#CCDIKSolver..IK) |  | The IK to update. |
| [overrideBlend] | <code>number</code> | <code>1.0</code> | If the IK object does not define `blendFactor`, this value is used. |

<a name="CCDIKSolver+createHelper"></a>

### ccdikSolver.createHelper(sphereSize) ⇒ [<code>CCDIKHelper</code>](#CCDIKHelper)
Creates a helper for visualizing the CCDIK.

**Kind**: instance method of [<code>CCDIKSolver</code>](#CCDIKSolver)  
**Returns**: [<code>CCDIKHelper</code>](#CCDIKHelper) - The created helper.  

| Param | Type | Description |
| --- | --- | --- |
| sphereSize | <code>number</code> | The sphere size. |

<a name="CCDIKSolver..IK"></a>

### CCDIKSolver~IK : <code>Object</code>
This type represents IK configuration objects.

**Kind**: inner typedef of [<code>CCDIKSolver</code>](#CCDIKSolver)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| target | <code>number</code> |  | The target bone index which refers to a bone in the `Skeleton.bones` array. |
| effector | <code>number</code> |  | The effector bone index which refers to a bone in the `Skeleton.bones` array. |
| links | [<code>Array.&lt;BoneLink&gt;</code>](#CCDIKSolver..BoneLink) |  | An array of bone links. |
| [iteration] | <code>number</code> | <code>1</code> | Iteration number of calculation. Smaller is faster but less precise. |
| [minAngle] | <code>number</code> |  | Minimum rotation angle in a step in radians. |
| [maxAngle] | <code>number</code> |  | Minimum rotation angle in a step in radians. |
| [blendFactor] | <code>number</code> |  | The blend factor. |

<a name="CCDIKSolver..BoneLink"></a>

### CCDIKSolver~BoneLink : <code>Object</code>
This type represents bone links.

**Kind**: inner typedef of [<code>CCDIKSolver</code>](#CCDIKSolver)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| index | <code>number</code> |  | The index of a linked bone which refers to a bone in the `Skeleton.bones` array. |
| [limitation] | <code>number</code> |  | Rotation axis. |
| [rotationMin] | <code>number</code> |  | Rotation minimum limit. |
| [rotationMax] | <code>number</code> |  | Rotation maximum limit. |
| [enabled] | <code>boolean</code> | <code>true</code> | Whether the link is enabled or not. |

<a name="CCDIKHelper"></a>

## CCDIKHelper ⇐ <code>Object3D</code>
Helper for visualizing IK bones.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [CCDIKHelper](#CCDIKHelper) ⇐ <code>Object3D</code>
    * [new CCDIKHelper(mesh, [iks], [sphereSize])](#new_CCDIKHelper_new)
    * [.root](#CCDIKHelper+root) : <code>SkinnedMesh</code>
    * [.iks](#CCDIKHelper+iks) : [<code>Array.&lt;IK&gt;</code>](#CCDIKSolver..IK)
    * [.sphereGeometry](#CCDIKHelper+sphereGeometry) : <code>SkinnedMesh</code>
    * [.targetSphereMaterial](#CCDIKHelper+targetSphereMaterial) : <code>MeshBasicMaterial</code>
    * [.effectorSphereMaterial](#CCDIKHelper+effectorSphereMaterial) : <code>MeshBasicMaterial</code>
    * [.linkSphereMaterial](#CCDIKHelper+linkSphereMaterial) : <code>MeshBasicMaterial</code>
    * [.lineMaterial](#CCDIKHelper+lineMaterial) : <code>LineBasicMaterial</code>
    * [.dispose()](#CCDIKHelper+dispose)

<a name="new_CCDIKHelper_new"></a>

### new CCDIKHelper(mesh, [iks], [sphereSize])

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>SkinnedMesh</code> |  | The skinned mesh. |
| [iks] | [<code>Array.&lt;IK&gt;</code>](#CCDIKSolver..IK) | <code>[]</code> | The IK objects. |
| [sphereSize] | <code>number</code> | <code>0.25</code> | The sphere size. |

<a name="CCDIKHelper+root"></a>

### ccdikHelper.root : <code>SkinnedMesh</code>
The skinned mesh this helper refers to.

**Kind**: instance property of [<code>CCDIKHelper</code>](#CCDIKHelper)  
<a name="CCDIKHelper+iks"></a>

### ccdikHelper.iks : [<code>Array.&lt;IK&gt;</code>](#CCDIKSolver..IK)
The IK objects.

**Kind**: instance property of [<code>CCDIKHelper</code>](#CCDIKHelper)  
<a name="CCDIKHelper+sphereGeometry"></a>

### ccdikHelper.sphereGeometry : <code>SkinnedMesh</code>
The helpers sphere geometry.

**Kind**: instance property of [<code>CCDIKHelper</code>](#CCDIKHelper)  
<a name="CCDIKHelper+targetSphereMaterial"></a>

### ccdikHelper.targetSphereMaterial : <code>MeshBasicMaterial</code>
The material for the target spheres.

**Kind**: instance property of [<code>CCDIKHelper</code>](#CCDIKHelper)  
<a name="CCDIKHelper+effectorSphereMaterial"></a>

### ccdikHelper.effectorSphereMaterial : <code>MeshBasicMaterial</code>
The material for the effector spheres.

**Kind**: instance property of [<code>CCDIKHelper</code>](#CCDIKHelper)  
<a name="CCDIKHelper+linkSphereMaterial"></a>

### ccdikHelper.linkSphereMaterial : <code>MeshBasicMaterial</code>
The material for the link spheres.

**Kind**: instance property of [<code>CCDIKHelper</code>](#CCDIKHelper)  
<a name="CCDIKHelper+lineMaterial"></a>

### ccdikHelper.lineMaterial : <code>LineBasicMaterial</code>
A global line material.

**Kind**: instance property of [<code>CCDIKHelper</code>](#CCDIKHelper)  
<a name="CCDIKHelper+dispose"></a>

### ccdikHelper.dispose()
Frees the GPU-related resources allocated by this instance.
Call this method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>CCDIKHelper</code>](#CCDIKHelper)  
<a name="WebGL"></a>

## WebGL
A utility module with basic WebGL 2 capability testing.

**Kind**: global class  

* [WebGL](#WebGL)
    * [.isWebGL2Available()](#WebGL.isWebGL2Available) ⇒ <code>boolean</code>
    * [.isColorSpaceAvailable(colorSpace)](#WebGL.isColorSpaceAvailable) ⇒ <code>boolean</code>
    * [.getWebGL2ErrorMessage()](#WebGL.getWebGL2ErrorMessage) ⇒ <code>HTMLDivElement</code>

<a name="WebGL.isWebGL2Available"></a>

### WebGL.isWebGL2Available() ⇒ <code>boolean</code>
Returns `true` if WebGL 2 is available.

**Kind**: static method of [<code>WebGL</code>](#WebGL)  
**Returns**: <code>boolean</code> - Whether WebGL 2 is available or not.  
<a name="WebGL.isColorSpaceAvailable"></a>

### WebGL.isColorSpaceAvailable(colorSpace) ⇒ <code>boolean</code>
Returns `true` if the given color space is available. This method can only be used
if WebGL 2 is supported.

**Kind**: static method of [<code>WebGL</code>](#WebGL)  
**Returns**: <code>boolean</code> - Whether the given color space is available or not.  

| Param | Type | Description |
| --- | --- | --- |
| colorSpace | <code>string</code> | The color space to test. |

<a name="WebGL.getWebGL2ErrorMessage"></a>

### WebGL.getWebGL2ErrorMessage() ⇒ <code>HTMLDivElement</code>
Returns a `div` element representing a formatted error message that can be appended in
web sites if WebGL 2 isn't supported.

**Kind**: static method of [<code>WebGL</code>](#WebGL)  
**Returns**: <code>HTMLDivElement</code> - A `div` element representing a formatted error message that WebGL 2 isn't supported.  
<a name="WebGPU"></a>

## WebGPU
A utility module with basic WebGPU capability testing.

**Kind**: global class  

* [WebGPU](#WebGPU)
    * [.isAvailable()](#WebGPU.isAvailable) ⇒ <code>boolean</code>
    * [.getErrorMessage()](#WebGPU.getErrorMessage) ⇒ <code>HTMLDivElement</code>

<a name="WebGPU.isAvailable"></a>

### WebGPU.isAvailable() ⇒ <code>boolean</code>
Returns `true` if WebGPU is available.

**Kind**: static method of [<code>WebGPU</code>](#WebGPU)  
**Returns**: <code>boolean</code> - Whether WebGPU is available or not.  
<a name="WebGPU.getErrorMessage"></a>

### WebGPU.getErrorMessage() ⇒ <code>HTMLDivElement</code>
Returns a `div` element representing a formatted error message that can be appended in
web sites if WebGPU isn't supported.

**Kind**: static method of [<code>WebGPU</code>](#WebGPU)  
**Returns**: <code>HTMLDivElement</code> - A `div` element representing a formatted error message that WebGPU isn't supported.  
<a name="ArcballControls"></a>

## ArcballControls ⇐ <code>Controls</code>
Arcball controls allow the camera to be controlled by a virtual trackball with full touch support and advanced navigation functionality.
Cursor/finger positions and movements are mapped over a virtual trackball surface represented by a gizmo and mapped in intuitive and
consistent camera movements. Dragging cursor/fingers will cause camera to orbit around the center of the trackball in a conservative
way (returning to the starting point will make the camera to return to its starting orientation).

In addition to supporting pan, zoom and pinch gestures, Arcball controls provide focus< functionality with a double click/tap for intuitively
moving the object's point of interest in the center of the virtual trackball. Focus allows a much better inspection and navigation in complex
environment. Moreover Arcball controls allow FOV manipulation (in a vertigo-style method) and z-rotation. Saving and restoring of Camera State
is supported also through clipboard (use ctrl+c and ctrl+v shortcuts for copy and paste the state).

Unlike [OrbitControls](OrbitControls) and [TrackballControls](TrackballControls), `ArcballControls` doesn't require `update()` to be called externally in an
animation loop when animations are on.

**Kind**: global class  
**Extends**: <code>Controls</code>  

* [ArcballControls](#ArcballControls) ⇐ <code>Controls</code>
    * [new ArcballControls(camera, [domElement], [scene])](#new_ArcballControls_new)
    * [.scene](#ArcballControls+scene) : <code>Scene</code>
    * [.target](#ArcballControls+target) : <code>Vector3</code>
    * [.radiusFactor](#ArcballControls+radiusFactor) : <code>number</code>
    * [.mouseActions](#ArcballControls+mouseActions) : <code>Array.&lt;Object&gt;</code>
    * [.focusAnimationTime](#ArcballControls+focusAnimationTime) : <code>number</code>
    * [.adjustNearFar](#ArcballControls+adjustNearFar) : <code>boolean</code>
    * [.scaleFactor](#ArcballControls+scaleFactor) : <code>number</code>
    * [.dampingFactor](#ArcballControls+dampingFactor) : <code>number</code>
    * [.wMax](#ArcballControls+wMax) : <code>number</code>
    * [.enableAnimations](#ArcballControls+enableAnimations) : <code>boolean</code>
    * [.enableGrid](#ArcballControls+enableGrid) : <code>boolean</code>
    * [.cursorZoom](#ArcballControls+cursorZoom) : <code>boolean</code>
    * [.minFov](#ArcballControls+minFov) : <code>number</code>
    * [.maxFov](#ArcballControls+maxFov) : <code>number</code>
    * [.rotateSpeed](#ArcballControls+rotateSpeed) : <code>number</code>
    * [.enablePan](#ArcballControls+enablePan) : <code>boolean</code>
    * [.enableRotate](#ArcballControls+enableRotate) : <code>boolean</code>
    * [.enableZoom](#ArcballControls+enableZoom) : <code>boolean</code>
    * [.enableGizmos](#ArcballControls+enableGizmos) : <code>boolean</code>
    * [.enableFocus](#ArcballControls+enableFocus) : <code>boolean</code>
    * [.minDistance](#ArcballControls+minDistance) : <code>number</code>
    * [.maxDistance](#ArcballControls+maxDistance) : <code>number</code>
    * [.minZoom](#ArcballControls+minZoom) : <code>number</code>
    * [.maxZoom](#ArcballControls+maxZoom) : <code>number</code>
    * [.setMouseAction(operation, mouse, [key])](#ArcballControls+setMouseAction) ⇒ <code>boolean</code>
    * [.unsetMouseAction(mouse, key)](#ArcballControls+unsetMouseAction) ⇒ <code>boolean</code>
    * [.disposeGrid()](#ArcballControls+disposeGrid)
    * [.activateGizmos(isActive)](#ArcballControls+activateGizmos)
    * [.setCamera(camera)](#ArcballControls+setCamera)
    * [.setGizmosVisible(value)](#ArcballControls+setGizmosVisible)
    * [.setTbRadius(value)](#ArcballControls+setTbRadius)
    * [.reset()](#ArcballControls+reset)
    * [.copyState()](#ArcballControls+copyState)
    * [.pasteState()](#ArcballControls+pasteState)
    * [.saveState()](#ArcballControls+saveState)
    * [.getRaycaster()](#ArcballControls+getRaycaster) ⇒ <code>Raycaster</code>
    * ["change"](#ArcballControls+event_change)
    * ["start"](#ArcballControls+event_start)
    * ["end"](#ArcballControls+event_end)

<a name="new_ArcballControls_new"></a>

### new ArcballControls(camera, [domElement], [scene])
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>Camera</code> |  | The camera to be controlled. The camera must not be a child of another object, unless that object is the scene itself. |
| [domElement] | <code>HTMLDOMElement</code> | <code></code> | The HTML element used for event listeners. |
| [scene] | <code>Scene</code> | <code></code> | The scene rendered by the camera. If not given, gizmos cannot be shown. |

<a name="ArcballControls+scene"></a>

### arcballControls.scene : <code>Scene</code>
The scene rendered by the camera. If not given, gizmos cannot be shown.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>null</code>  
<a name="ArcballControls+target"></a>

### arcballControls.target : <code>Vector3</code>
The control's focus point.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+radiusFactor"></a>

### arcballControls.radiusFactor : <code>number</code>
The size of the gizmo relative to the screen width and height.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>0.67</code>  
<a name="ArcballControls+mouseActions"></a>

### arcballControls.mouseActions : <code>Array.&lt;Object&gt;</code>
Holds the mouse actions of this controls. This property is maintained by the methods
`setMouseAction()` and `unsetMouseAction()`.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+focusAnimationTime"></a>

### arcballControls.focusAnimationTime : <code>number</code>
Duration of focus animations in ms.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>500</code>  
<a name="ArcballControls+adjustNearFar"></a>

### arcballControls.adjustNearFar : <code>boolean</code>
If set to `true`, the camera's near and far values will be adjusted every time zoom is
performed trying to maintain the same visible portion given by initial near and far
values. Only works with perspective cameras.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>false</code>  
<a name="ArcballControls+scaleFactor"></a>

### arcballControls.scaleFactor : <code>number</code>
The scaling factor used when performing zoom operation.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>1.1</code>  
<a name="ArcballControls+dampingFactor"></a>

### arcballControls.dampingFactor : <code>number</code>
The damping inertia used if 'enableAnimations` is set to `true`.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>25</code>  
<a name="ArcballControls+wMax"></a>

### arcballControls.wMax : <code>number</code>
Maximum angular velocity allowed on rotation animation start.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>20</code>  
<a name="ArcballControls+enableAnimations"></a>

### arcballControls.enableAnimations : <code>boolean</code>
Set to `true` to enable animations for rotation (damping) and focus operation.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>true</code>  
<a name="ArcballControls+enableGrid"></a>

### arcballControls.enableGrid : <code>boolean</code>
If set to `true`, a grid will appear when panning operation is being performed
(desktop interaction only).

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>false</code>  
<a name="ArcballControls+cursorZoom"></a>

### arcballControls.cursorZoom : <code>boolean</code>
Set to `true` to make zoom become cursor centered.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>false</code>  
<a name="ArcballControls+minFov"></a>

### arcballControls.minFov : <code>number</code>
The minimum FOV in degrees.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>5</code>  
<a name="ArcballControls+maxFov"></a>

### arcballControls.maxFov : <code>number</code>
The maximum FOV in degrees.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>90</code>  
<a name="ArcballControls+rotateSpeed"></a>

### arcballControls.rotateSpeed : <code>number</code>
Speed of rotation.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>1</code>  
<a name="ArcballControls+enablePan"></a>

### arcballControls.enablePan : <code>boolean</code>
Enable or disable camera panning.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>true</code>  
<a name="ArcballControls+enableRotate"></a>

### arcballControls.enableRotate : <code>boolean</code>
Enable or disable camera rotation.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>true</code>  
<a name="ArcballControls+enableZoom"></a>

### arcballControls.enableZoom : <code>boolean</code>
Enable or disable camera zoom.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>true</code>  
<a name="ArcballControls+enableGizmos"></a>

### arcballControls.enableGizmos : <code>boolean</code>
Enable or disable gizmos.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>true</code>  
<a name="ArcballControls+enableFocus"></a>

### arcballControls.enableFocus : <code>boolean</code>
Enable or disable camera focusing on double-tap (or click) operations.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>true</code>  
<a name="ArcballControls+minDistance"></a>

### arcballControls.minDistance : <code>number</code>
How far you can dolly in. For perspective cameras only.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>0</code>  
<a name="ArcballControls+maxDistance"></a>

### arcballControls.maxDistance : <code>number</code>
How far you can dolly out. For perspective cameras only.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>Infinity</code>  
<a name="ArcballControls+minZoom"></a>

### arcballControls.minZoom : <code>number</code>
How far you can zoom in. For orthographic cameras only.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>0</code>  
<a name="ArcballControls+maxZoom"></a>

### arcballControls.maxZoom : <code>number</code>
How far you can zoom out. For orthographic cameras only.

**Kind**: instance property of [<code>ArcballControls</code>](#ArcballControls)  
**Default**: <code>Infinity</code>  
<a name="ArcballControls+setMouseAction"></a>

### arcballControls.setMouseAction(operation, mouse, [key]) ⇒ <code>boolean</code>
Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  
**Returns**: <code>boolean</code> - `true` if the mouse action has been successfully added, `false` otherwise.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| operation | <code>&#x27;PAN&#x27;</code> \| <code>&#x27;ROTATE&#x27;</code> \| <code>&#x27;ZOOM&#x27;</code> \| <code>&#x27;FOV&#x27;</code> |  | The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV'). |
| mouse | <code>0</code> \| <code>1</code> \| <code>2</code> \| <code>&#x27;WHEEL&#x27;</code> |  | A mouse button (0, 1, 2) or 'WHEEL' for wheel notches. |
| [key] | <code>&#x27;CTRL&#x27;</code> \| <code>&#x27;SHIFT&#x27;</code> \| <code>null</code> | <code></code> | The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed. |

<a name="ArcballControls+unsetMouseAction"></a>

### arcballControls.unsetMouseAction(mouse, key) ⇒ <code>boolean</code>
Remove a mouse action by specifying its mouse/key combination.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  
**Returns**: <code>boolean</code> - `true` if the operation has been successfully removed, `false` otherwise.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mouse | <code>0</code> \| <code>1</code> \| <code>2</code> \| <code>&#x27;WHEEL&#x27;</code> |  | A mouse button (0, 1, 2) or 'WHEEL' for wheel notches. |
| key | <code>&#x27;CTRL&#x27;</code> \| <code>&#x27;SHIFT&#x27;</code> \| <code>null</code> | <code></code> | The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed. |

<a name="ArcballControls+disposeGrid"></a>

### arcballControls.disposeGrid()
Removes the grid from the scene.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+activateGizmos"></a>

### arcballControls.activateGizmos(isActive)
Makes rotation gizmos more or less visible.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  

| Param | Type | Description |
| --- | --- | --- |
| isActive | <code>boolean</code> | If set to `true`, gizmos are more visible. |

<a name="ArcballControls+setCamera"></a>

### arcballControls.setCamera(camera)
Sets the camera to be controlled.  Must be called in order to set a new camera to be controlled.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera to be controlled. |

<a name="ArcballControls+setGizmosVisible"></a>

### arcballControls.setGizmosVisible(value)
Sets gizmos visibility.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | Value of gizmos visibility. |

<a name="ArcballControls+setTbRadius"></a>

### arcballControls.setTbRadius(value)
Sets gizmos radius factor and redraws gizmos.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | Value of radius factor. |

<a name="ArcballControls+reset"></a>

### arcballControls.reset()
Resets the controls.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+copyState"></a>

### arcballControls.copyState()
Copy the current state to clipboard (as a readable JSON text).

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+pasteState"></a>

### arcballControls.pasteState()
Set the controls state from the clipboard, assumes that the clipboard stores a JSON
text as saved from `copyState()`.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+saveState"></a>

### arcballControls.saveState()
Saves the current state of the control. This can later be recover with `reset()`.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+getRaycaster"></a>

### arcballControls.getRaycaster() ⇒ <code>Raycaster</code>
Returns the raycaster that is used for user interaction. This object is shared between all
instances of `ArcballControls`.

**Kind**: instance method of [<code>ArcballControls</code>](#ArcballControls)  
**Returns**: <code>Raycaster</code> - The internal raycaster.  
<a name="ArcballControls+event_change"></a>

### "change"
Fires when the camera has been transformed by the controls.

**Kind**: event emitted by [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+event_start"></a>

### "start"
Fires when an interaction was initiated.

**Kind**: event emitted by [<code>ArcballControls</code>](#ArcballControls)  
<a name="ArcballControls+event_end"></a>

### "end"
Fires when an interaction has finished.

**Kind**: event emitted by [<code>ArcballControls</code>](#ArcballControls)  
<a name="DragControls"></a>

## DragControls ⇐ <code>Controls</code>
This class can be used to provide a drag'n'drop interaction.

```js
const controls = new DragControls( objects, camera, renderer.domElement );

// add event listener to highlight dragged objects
controls.addEventListener( 'dragstart', function ( event ) {

	event.object.material.emissive.set( 0xaaaaaa );

} );

controls.addEventListener( 'dragend', function ( event ) {

	event.object.material.emissive.set( 0x000000 );

} );
```

**Kind**: global class  
**Extends**: <code>Controls</code>  

* [DragControls](#DragControls) ⇐ <code>Controls</code>
    * [new DragControls(objects, camera, [domElement])](#new_DragControls_new)
    * [.objects](#DragControls+objects) : <code>Array.&lt;Object3D&gt;</code>
    * [.recursive](#DragControls+recursive) : <code>boolean</code>
    * [.transformGroup](#DragControls+transformGroup) : <code>boolean</code>
    * [.rotateSpeed](#DragControls+rotateSpeed) : <code>number</code>
    * [.raycaster](#DragControls+raycaster) : <code>Raycaster</code>
    * ["drag"](#DragControls+event_drag)
    * ["dragend"](#DragControls+event_dragend)
    * ["hoveron"](#DragControls+event_hoveron)
    * ["hoveroff"](#DragControls+event_hoveroff)

<a name="new_DragControls_new"></a>

### new DragControls(objects, camera, [domElement])
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| objects | <code>Array.&lt;Object3D&gt;</code> |  | An array of draggable 3D objects. |
| camera | <code>Camera</code> |  | The camera of the rendered scene. |
| [domElement] | <code>HTMLDOMElement</code> | <code></code> | The HTML DOM element used for event listeners. |

<a name="DragControls+objects"></a>

### dragControls.objects : <code>Array.&lt;Object3D&gt;</code>
An array of draggable 3D objects.

**Kind**: instance property of [<code>DragControls</code>](#DragControls)  
<a name="DragControls+recursive"></a>

### dragControls.recursive : <code>boolean</code>
Whether children of draggable objects can be dragged independently from their parent.

**Kind**: instance property of [<code>DragControls</code>](#DragControls)  
**Default**: <code>true</code>  
<a name="DragControls+transformGroup"></a>

### dragControls.transformGroup : <code>boolean</code>
This option only works if the `objects` array contains a single draggable  group object.
If set to `true`, the controls does not transform individual objects but the entire group.

**Kind**: instance property of [<code>DragControls</code>](#DragControls)  
**Default**: <code>false</code>  
<a name="DragControls+rotateSpeed"></a>

### dragControls.rotateSpeed : <code>number</code>
The speed at which the object will rotate when dragged in `rotate` mode.
The higher the number the faster the rotation.

**Kind**: instance property of [<code>DragControls</code>](#DragControls)  
**Default**: <code>1</code>  
<a name="DragControls+raycaster"></a>

### dragControls.raycaster : <code>Raycaster</code>
The raycaster used for detecting 3D objects.

**Kind**: instance property of [<code>DragControls</code>](#DragControls)  
<a name="DragControls+event_drag"></a>

### "drag"
Fires when the user drags a 3D object.

**Kind**: event emitted by [<code>DragControls</code>](#DragControls)  
<a name="DragControls+event_dragend"></a>

### "dragend"
Fires when the user has finished dragging a 3D object.

**Kind**: event emitted by [<code>DragControls</code>](#DragControls)  
<a name="DragControls+event_hoveron"></a>

### "hoveron"
Fires when the pointer is moved onto a 3D object, or onto one of its children.

**Kind**: event emitted by [<code>DragControls</code>](#DragControls)  
<a name="DragControls+event_hoveroff"></a>

### "hoveroff"
Fires when the pointer is moved out of a 3D object.

**Kind**: event emitted by [<code>DragControls</code>](#DragControls)  
<a name="FirstPersonControls"></a>

## FirstPersonControls ⇐ <code>Controls</code>
This class is an alternative implementation of [FlyControls](FlyControls).

**Kind**: global class  
**Extends**: <code>Controls</code>  

* [FirstPersonControls](#FirstPersonControls) ⇐ <code>Controls</code>
    * [new FirstPersonControls(object, domElement)](#new_FirstPersonControls_new)
    * [.movementSpeed](#FirstPersonControls+movementSpeed) : <code>number</code>
    * [.lookSpeed](#FirstPersonControls+lookSpeed) : <code>number</code>
    * [.lookVertical](#FirstPersonControls+lookVertical) : <code>boolean</code>
    * [.autoForward](#FirstPersonControls+autoForward) : <code>boolean</code>
    * [.activeLook](#FirstPersonControls+activeLook) : <code>boolean</code>
    * [.heightSpeed](#FirstPersonControls+heightSpeed) : <code>boolean</code>
    * [.heightCoef](#FirstPersonControls+heightCoef) : <code>number</code>
    * [.heightMin](#FirstPersonControls+heightMin) : <code>number</code>
    * [.heightMax](#FirstPersonControls+heightMax) : <code>number</code>
    * [.constrainVertical](#FirstPersonControls+constrainVertical) : <code>boolean</code>
    * [.verticalMin](#FirstPersonControls+verticalMin) : <code>number</code>
    * [.verticalMax](#FirstPersonControls+verticalMax) : <code>number</code>
    * [.mouseDragOn](#FirstPersonControls+mouseDragOn) : <code>boolean</code>
    * [.handleResize()](#FirstPersonControls+handleResize)
    * [.lookAt(x, y, z)](#FirstPersonControls+lookAt) ⇒ [<code>FirstPersonControls</code>](#FirstPersonControls)

<a name="new_FirstPersonControls_new"></a>

### new FirstPersonControls(object, domElement)
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The object that is managed by the controls. |
| domElement | <code>HTMLDOMElement</code> | <code></code> | The HTML element used for event listeners. |

<a name="FirstPersonControls+movementSpeed"></a>

### firstPersonControls.movementSpeed : <code>number</code>
The movement speed.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>1</code>  
<a name="FirstPersonControls+lookSpeed"></a>

### firstPersonControls.lookSpeed : <code>number</code>
The look around speed.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>0.005</code>  
<a name="FirstPersonControls+lookVertical"></a>

### firstPersonControls.lookVertical : <code>boolean</code>
Whether it's possible to vertically look around or not.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>true</code>  
<a name="FirstPersonControls+autoForward"></a>

### firstPersonControls.autoForward : <code>boolean</code>
Whether the camera is automatically moved forward or not.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>false</code>  
<a name="FirstPersonControls+activeLook"></a>

### firstPersonControls.activeLook : <code>boolean</code>
Whether it's possible to look around or not.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>true</code>  
<a name="FirstPersonControls+heightSpeed"></a>

### firstPersonControls.heightSpeed : <code>boolean</code>
Whether or not the camera's height influences the forward movement speed.
Use the properties `heightCoef`, `heightMin` and `heightMax` for configuration.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>false</code>  
<a name="FirstPersonControls+heightCoef"></a>

### firstPersonControls.heightCoef : <code>number</code>
Determines how much faster the camera moves when it's y-component is near `heightMax`.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>1</code>  
<a name="FirstPersonControls+heightMin"></a>

### firstPersonControls.heightMin : <code>number</code>
Lower camera height limit used for movement speed adjustment.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>0</code>  
<a name="FirstPersonControls+heightMax"></a>

### firstPersonControls.heightMax : <code>number</code>
Upper camera height limit used for movement speed adjustment.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>1</code>  
<a name="FirstPersonControls+constrainVertical"></a>

### firstPersonControls.constrainVertical : <code>boolean</code>
Whether or not looking around is vertically constrained by `verticalMin` and `verticalMax`.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>false</code>  
<a name="FirstPersonControls+verticalMin"></a>

### firstPersonControls.verticalMin : <code>number</code>
How far you can vertically look around, lower limit. Range is `0` to `Math.PI` in radians.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>0</code>  
<a name="FirstPersonControls+verticalMax"></a>

### firstPersonControls.verticalMax : <code>number</code>
How far you can vertically look around, upper limit. Range is `0` to `Math.PI` in radians.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>0</code>  
<a name="FirstPersonControls+mouseDragOn"></a>

### firstPersonControls.mouseDragOn : <code>boolean</code>
Whether the mouse is pressed down or not.

**Kind**: instance property of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="FirstPersonControls+handleResize"></a>

### firstPersonControls.handleResize()
Must be called if the application window is resized.

**Kind**: instance method of [<code>FirstPersonControls</code>](#FirstPersonControls)  
<a name="FirstPersonControls+lookAt"></a>

### firstPersonControls.lookAt(x, y, z) ⇒ [<code>FirstPersonControls</code>](#FirstPersonControls)
Rotates the camera towards the defined target position.

**Kind**: instance method of [<code>FirstPersonControls</code>](#FirstPersonControls)  
**Returns**: [<code>FirstPersonControls</code>](#FirstPersonControls) - A reference to this controls.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector3</code> | The x coordinate of the target position or alternatively a vector representing the target position. |
| y | <code>number</code> | The y coordinate of the target position. |
| z | <code>number</code> | The z coordinate of the target position. |

<a name="FlyControls"></a>

## FlyControls ⇐ <code>Controls</code>
This class enables a navigation similar to fly modes in DCC tools like Blender.
You can arbitrarily transform the camera in 3D space without any limitations
(e.g. focus on a specific target).

**Kind**: global class  
**Extends**: <code>Controls</code>  

* [FlyControls](#FlyControls) ⇐ <code>Controls</code>
    * [new FlyControls(object, domElement)](#new_FlyControls_new)
    * [.movementSpeed](#FlyControls+movementSpeed) : <code>number</code>
    * [.rollSpeed](#FlyControls+rollSpeed) : <code>number</code>
    * [.dragToLook](#FlyControls+dragToLook) : <code>boolean</code>
    * [.autoForward](#FlyControls+autoForward) : <code>boolean</code>
    * ["change"](#FlyControls+event_change)

<a name="new_FlyControls_new"></a>

### new FlyControls(object, domElement)
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The object that is managed by the controls. |
| domElement | <code>HTMLDOMElement</code> | <code></code> | The HTML element used for event listeners. |

<a name="FlyControls+movementSpeed"></a>

### flyControls.movementSpeed : <code>number</code>
The movement speed.

**Kind**: instance property of [<code>FlyControls</code>](#FlyControls)  
**Default**: <code>1</code>  
<a name="FlyControls+rollSpeed"></a>

### flyControls.rollSpeed : <code>number</code>
The rotation speed.

**Kind**: instance property of [<code>FlyControls</code>](#FlyControls)  
**Default**: <code>0.005</code>  
<a name="FlyControls+dragToLook"></a>

### flyControls.dragToLook : <code>boolean</code>
If set to `true`, you can only look around by performing a drag interaction.

**Kind**: instance property of [<code>FlyControls</code>](#FlyControls)  
**Default**: <code>false</code>  
<a name="FlyControls+autoForward"></a>

### flyControls.autoForward : <code>boolean</code>
If set to `true`, the camera automatically moves forward (and does not stop) when initially translated.

**Kind**: instance property of [<code>FlyControls</code>](#FlyControls)  
**Default**: <code>false</code>  
<a name="FlyControls+event_change"></a>

### "change"
Fires when the camera has been transformed by the controls.

**Kind**: event emitted by [<code>FlyControls</code>](#FlyControls)  
<a name="MapControls"></a>

## MapControls ⇐ <code>OrbitControls</code>
This class is intended for transforming a camera over a map from bird's eye perspective.
The class shares its implementation with [OrbitControls](OrbitControls) but uses a specific preset
for mouse/touch interaction and disables screen space panning by default.

- Orbit: Right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate.
- Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.
- Pan: Left mouse, or arrow keys / touch: one-finger move.

**Kind**: global class  
**Extends**: <code>OrbitControls</code>  

* [MapControls](#MapControls) ⇐ <code>OrbitControls</code>
    * [.screenSpacePanning](#MapControls+screenSpacePanning) : <code>boolean</code>
    * [.mouseButtons](#MapControls+mouseButtons) : <code>Object</code>
    * [.touches](#MapControls+touches) : <code>Object</code>

<a name="MapControls+screenSpacePanning"></a>

### mapControls.screenSpacePanning : <code>boolean</code>
Overwritten and set to `false` to pan orthogonal to world-space direction `camera.up`.

**Kind**: instance property of [<code>MapControls</code>](#MapControls)  
**Default**: <code>false</code>  
<a name="MapControls+mouseButtons"></a>

### mapControls.mouseButtons : <code>Object</code>
This object contains references to the mouse actions used by the controls.

```js
controls.mouseButtons = {
	LEFT: THREE.MOUSE.PAN,
	MIDDLE: THREE.MOUSE.DOLLY,
	RIGHT: THREE.MOUSE.ROTATE
}
```

**Kind**: instance property of [<code>MapControls</code>](#MapControls)  
<a name="MapControls+touches"></a>

### mapControls.touches : <code>Object</code>
This object contains references to the touch actions used by the controls.

```js
controls.mouseButtons = {
	ONE: THREE.TOUCH.PAN,
	TWO: THREE.TOUCH.DOLLY_ROTATE
}
```

**Kind**: instance property of [<code>MapControls</code>](#MapControls)  
<a name="OrbitControls"></a>

## OrbitControls ⇐ <code>Controls</code>
Orbit controls allow the camera to orbit around a target.

OrbitControls performs orbiting, dollying (zooming), and panning. Unlike [TrackballControls](TrackballControls),
it maintains the "up" direction `object.up` (+Y by default).

- Orbit: Left mouse / touch: one-finger move.
- Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.
- Pan: Right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move.

```js
const controls = new OrbitControls( camera, renderer.domElement );

// controls.update() must be called after any manual changes to the camera's transform
camera.position.set( 0, 20, 100 );
controls.update();

function animate() {

	// required if controls.enableDamping or controls.autoRotate are set to true
	controls.update();

	renderer.render( scene, camera );

}
```

**Kind**: global class  
**Extends**: <code>Controls</code>  

* [OrbitControls](#OrbitControls) ⇐ <code>Controls</code>
    * [new OrbitControls(object, domElement)](#new_OrbitControls_new)
    * [.target](#OrbitControls+target) : <code>Vector3</code>
    * [.cursor](#OrbitControls+cursor) : <code>Vector3</code>
    * [.minDistance](#OrbitControls+minDistance) : <code>number</code>
    * [.maxDistance](#OrbitControls+maxDistance) : <code>number</code>
    * [.minZoom](#OrbitControls+minZoom) : <code>number</code>
    * [.maxZoom](#OrbitControls+maxZoom) : <code>number</code>
    * [.minTargetRadius](#OrbitControls+minTargetRadius) : <code>number</code>
    * [.maxTargetRadius](#OrbitControls+maxTargetRadius) : <code>number</code>
    * [.minPolarAngle](#OrbitControls+minPolarAngle) : <code>number</code>
    * [.maxPolarAngle](#OrbitControls+maxPolarAngle) : <code>number</code>
    * [.minAzimuthAngle](#OrbitControls+minAzimuthAngle) : <code>number</code>
    * [.maxAzimuthAngle](#OrbitControls+maxAzimuthAngle) : <code>number</code>
    * [.enableDamping](#OrbitControls+enableDamping) : <code>boolean</code>
    * [.dampingFactor](#OrbitControls+dampingFactor) : <code>number</code>
    * [.enableZoom](#OrbitControls+enableZoom) : <code>boolean</code>
    * [.zoomSpeed](#OrbitControls+zoomSpeed) : <code>number</code>
    * [.enableRotate](#OrbitControls+enableRotate) : <code>boolean</code>
    * [.rotateSpeed](#OrbitControls+rotateSpeed) : <code>number</code>
    * [.keyRotateSpeed](#OrbitControls+keyRotateSpeed) : <code>number</code>
    * [.enablePan](#OrbitControls+enablePan) : <code>boolean</code>
    * [.panSpeed](#OrbitControls+panSpeed) : <code>number</code>
    * [.screenSpacePanning](#OrbitControls+screenSpacePanning) : <code>boolean</code>
    * [.keyPanSpeed](#OrbitControls+keyPanSpeed) : <code>number</code>
    * [.zoomToCursor](#OrbitControls+zoomToCursor) : <code>boolean</code>
    * [.autoRotate](#OrbitControls+autoRotate) : <code>boolean</code>
    * [.autoRotateSpeed](#OrbitControls+autoRotateSpeed) : <code>number</code>
    * [.keys](#OrbitControls+keys) : <code>Object</code>
    * [.mouseButtons](#OrbitControls+mouseButtons) : <code>Object</code>
    * [.touches](#OrbitControls+touches) : <code>Object</code>
    * [.target0](#OrbitControls+target0) : <code>Vector3</code>
    * [.position0](#OrbitControls+position0) : <code>Vector3</code>
    * [.zoom0](#OrbitControls+zoom0) : <code>number</code>
    * [.getPolarAngle()](#OrbitControls+getPolarAngle) ⇒ <code>number</code>
    * [.getAzimuthalAngle()](#OrbitControls+getAzimuthalAngle) ⇒ <code>number</code>
    * [.getDistance()](#OrbitControls+getDistance) ⇒ <code>number</code>
    * [.listenToKeyEvents(domElement)](#OrbitControls+listenToKeyEvents)
    * [.stopListenToKeyEvents()](#OrbitControls+stopListenToKeyEvents)
    * [.saveState()](#OrbitControls+saveState)
    * [.reset()](#OrbitControls+reset)
    * ["change"](#OrbitControls+event_change)
    * ["start"](#OrbitControls+event_start)
    * ["end"](#OrbitControls+event_end)

<a name="new_OrbitControls_new"></a>

### new OrbitControls(object, domElement)
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The object that is managed by the controls. |
| domElement | <code>HTMLDOMElement</code> | <code></code> | The HTML element used for event listeners. |

<a name="OrbitControls+target"></a>

### orbitControls.target : <code>Vector3</code>
The focus point of the controls, the `object` orbits around this.
It can be updated manually at any point to change the focus of the controls.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+cursor"></a>

### orbitControls.cursor : <code>Vector3</code>
The focus point of the `minTargetRadius` and `maxTargetRadius` limits.
It can be updated manually at any point to change the center of interest
for the `target`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+minDistance"></a>

### orbitControls.minDistance : <code>number</code>
How far you can dolly in (perspective camera only).

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>0</code>  
<a name="OrbitControls+maxDistance"></a>

### orbitControls.maxDistance : <code>number</code>
How far you can dolly out (perspective camera only).

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>Infinity</code>  
<a name="OrbitControls+minZoom"></a>

### orbitControls.minZoom : <code>number</code>
How far you can zoom in (orthographic camera only).

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>0</code>  
<a name="OrbitControls+maxZoom"></a>

### orbitControls.maxZoom : <code>number</code>
How far you can zoom out (orthographic camera only).

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>Infinity</code>  
<a name="OrbitControls+minTargetRadius"></a>

### orbitControls.minTargetRadius : <code>number</code>
How close you can get the target to the 3D `cursor`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>0</code>  
<a name="OrbitControls+maxTargetRadius"></a>

### orbitControls.maxTargetRadius : <code>number</code>
How far you can move the target from the 3D `cursor`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>Infinity</code>  
<a name="OrbitControls+minPolarAngle"></a>

### orbitControls.minPolarAngle : <code>number</code>
How far you can orbit vertically, lower limit. Range is `[0, Math.PI]` radians.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>0</code>  
<a name="OrbitControls+maxPolarAngle"></a>

### orbitControls.maxPolarAngle : <code>number</code>
How far you can orbit vertically, upper limit. Range is `[0, Math.PI]` radians.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>Math.PI</code>  
<a name="OrbitControls+minAzimuthAngle"></a>

### orbitControls.minAzimuthAngle : <code>number</code>
How far you can orbit horizontally, lower limit. If set, the interval `[ min, max ]`
must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>-Infinity</code>  
<a name="OrbitControls+maxAzimuthAngle"></a>

### orbitControls.maxAzimuthAngle : <code>number</code>
How far you can orbit horizontally, upper limit. If set, the interval `[ min, max ]`
must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>-Infinity</code>  
<a name="OrbitControls+enableDamping"></a>

### orbitControls.enableDamping : <code>boolean</code>
Set to `true` to enable damping (inertia), which can be used to give a sense of weight
to the controls. Note that if this is enabled, you must call `update()` in your animation
loop.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>false</code>  
<a name="OrbitControls+dampingFactor"></a>

### orbitControls.dampingFactor : <code>number</code>
The damping inertia used if `enableDamping` is set to `true`.

Note that for this to work, you must call `update()` in your animation loop.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>0.05</code>  
<a name="OrbitControls+enableZoom"></a>

### orbitControls.enableZoom : <code>boolean</code>
Enable or disable zooming (dollying) of the camera.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>true</code>  
<a name="OrbitControls+zoomSpeed"></a>

### orbitControls.zoomSpeed : <code>number</code>
Speed of zooming / dollying.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>1</code>  
<a name="OrbitControls+enableRotate"></a>

### orbitControls.enableRotate : <code>boolean</code>
Enable or disable horizontal and vertical rotation of the camera.

Note that it is possible to disable a single axis by setting the min and max of the
`minPolarAngle` or `minAzimuthAngle` to the same value, which will cause the vertical
or horizontal rotation to be fixed at that value.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>true</code>  
<a name="OrbitControls+rotateSpeed"></a>

### orbitControls.rotateSpeed : <code>number</code>
Speed of rotation.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>1</code>  
<a name="OrbitControls+keyRotateSpeed"></a>

### orbitControls.keyRotateSpeed : <code>number</code>
How fast to rotate the camera when the keyboard is used.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>1</code>  
<a name="OrbitControls+enablePan"></a>

### orbitControls.enablePan : <code>boolean</code>
Enable or disable camera panning.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>true</code>  
<a name="OrbitControls+panSpeed"></a>

### orbitControls.panSpeed : <code>number</code>
Speed of panning.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>1</code>  
<a name="OrbitControls+screenSpacePanning"></a>

### orbitControls.screenSpacePanning : <code>boolean</code>
Defines how the camera's position is translated when panning. If `true`, the camera pans
in screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up
direction.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>true</code>  
<a name="OrbitControls+keyPanSpeed"></a>

### orbitControls.keyPanSpeed : <code>number</code>
How fast to pan the camera when the keyboard is used in
pixels per keypress.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>7</code>  
<a name="OrbitControls+zoomToCursor"></a>

### orbitControls.zoomToCursor : <code>boolean</code>
Setting this property to `true` allows to zoom to the cursor's position.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>false</code>  
<a name="OrbitControls+autoRotate"></a>

### orbitControls.autoRotate : <code>boolean</code>
Set to true to automatically rotate around the target

Note that if this is enabled, you must call `update()` in your animation loop.
If you want the auto-rotate speed to be independent of the frame rate (the refresh
rate of the display), you must pass the time `deltaTime`, in seconds, to `update()`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>false</code>  
<a name="OrbitControls+autoRotateSpeed"></a>

### orbitControls.autoRotateSpeed : <code>number</code>
How fast to rotate around the target if `autoRotate` is `true`. The default  equates to 30 seconds
per orbit at 60fps.

Note that if `autoRotate` is enabled, you must call `update()` in your animation loop.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
**Default**: <code>2</code>  
<a name="OrbitControls+keys"></a>

### orbitControls.keys : <code>Object</code>
This object contains references to the keycodes for controlling camera panning.

```js
controls.keys = {
	LEFT: 'ArrowLeft', //left arrow
	UP: 'ArrowUp', // up arrow
	RIGHT: 'ArrowRight', // right arrow
	BOTTOM: 'ArrowDown' // down arrow
}
```

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+mouseButtons"></a>

### orbitControls.mouseButtons : <code>Object</code>
This object contains references to the mouse actions used by the controls.

```js
controls.mouseButtons = {
	LEFT: THREE.MOUSE.ROTATE,
	MIDDLE: THREE.MOUSE.DOLLY,
	RIGHT: THREE.MOUSE.PAN
}
```

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+touches"></a>

### orbitControls.touches : <code>Object</code>
This object contains references to the touch actions used by the controls.

```js
controls.mouseButtons = {
	ONE: THREE.TOUCH.ROTATE,
	TWO: THREE.TOUCH.DOLLY_PAN
}
```

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+target0"></a>

### orbitControls.target0 : <code>Vector3</code>
Used internally by `saveState()` and `reset()`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+position0"></a>

### orbitControls.position0 : <code>Vector3</code>
Used internally by `saveState()` and `reset()`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+zoom0"></a>

### orbitControls.zoom0 : <code>number</code>
Used internally by `saveState()` and `reset()`.

**Kind**: instance property of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+getPolarAngle"></a>

### orbitControls.getPolarAngle() ⇒ <code>number</code>
Get the current vertical rotation, in radians.

**Kind**: instance method of [<code>OrbitControls</code>](#OrbitControls)  
**Returns**: <code>number</code> - The current vertical rotation, in radians.  
<a name="OrbitControls+getAzimuthalAngle"></a>

### orbitControls.getAzimuthalAngle() ⇒ <code>number</code>
Get the current horizontal rotation, in radians.

**Kind**: instance method of [<code>OrbitControls</code>](#OrbitControls)  
**Returns**: <code>number</code> - The current horizontal rotation, in radians.  
<a name="OrbitControls+getDistance"></a>

### orbitControls.getDistance() ⇒ <code>number</code>
Returns the distance from the camera to the target.

**Kind**: instance method of [<code>OrbitControls</code>](#OrbitControls)  
**Returns**: <code>number</code> - The distance from the camera to the target.  
<a name="OrbitControls+listenToKeyEvents"></a>

### orbitControls.listenToKeyEvents(domElement)
Adds key event listeners to the given DOM element.
`window` is a recommended argument for using this method.

**Kind**: instance method of [<code>OrbitControls</code>](#OrbitControls)  

| Param | Type | Description |
| --- | --- | --- |
| domElement | <code>HTMLDOMElement</code> | The DOM element |

<a name="OrbitControls+stopListenToKeyEvents"></a>

### orbitControls.stopListenToKeyEvents()
Removes the key event listener previously defined with `listenToKeyEvents()`.

**Kind**: instance method of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+saveState"></a>

### orbitControls.saveState()
Save the current state of the controls. This can later be recovered with `reset()`.

**Kind**: instance method of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+reset"></a>

### orbitControls.reset()
Reset the controls to their state from either the last time the `saveState()`
was called, or the initial state.

**Kind**: instance method of [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+event_change"></a>

### "change"
Fires when the camera has been transformed by the controls.

**Kind**: event emitted by [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+event_start"></a>

### "start"
Fires when an interaction was initiated.

**Kind**: event emitted by [<code>OrbitControls</code>](#OrbitControls)  
<a name="OrbitControls+event_end"></a>

### "end"
Fires when an interaction has finished.

**Kind**: event emitted by [<code>OrbitControls</code>](#OrbitControls)  
<a name="PointerLockControls"></a>

## PointerLockControls ⇐ <code>Controls</code>
The implementation of this class is based on the [Pointer Lock API](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API).
`PointerLockControls` is a perfect choice for first person 3D games.

```js
const controls = new PointerLockControls( camera, document.body );

// add event listener to show/hide a UI (e.g. the game's menu)
controls.addEventListener( 'lock', function () {

	menu.style.display = 'none';

} );

controls.addEventListener( 'unlock', function () {

	menu.style.display = 'block';

} );
```

**Kind**: global class  
**Extends**: <code>Controls</code>  

* [PointerLockControls](#PointerLockControls) ⇐ <code>Controls</code>
    * [new PointerLockControls(camera, domElement)](#new_PointerLockControls_new)
    * [.isLocked](#PointerLockControls+isLocked) : <code>boolean</code>
    * [.minPolarAngle](#PointerLockControls+minPolarAngle) : <code>number</code>
    * [.maxPolarAngle](#PointerLockControls+maxPolarAngle) : <code>number</code>
    * [.pointerSpeed](#PointerLockControls+pointerSpeed) : <code>number</code>
    * [.getDirection(v)](#PointerLockControls+getDirection) ⇒ <code>Vector3</code>
    * [.moveForward(distance)](#PointerLockControls+moveForward)
    * [.moveRight(distance)](#PointerLockControls+moveRight)
    * [.lock([unadjustedMovement])](#PointerLockControls+lock)
    * [.unlock()](#PointerLockControls+unlock)
    * ["change"](#PointerLockControls+event_change)
    * ["lock"](#PointerLockControls+event_lock)
    * ["unlock"](#PointerLockControls+event_unlock)

<a name="new_PointerLockControls_new"></a>

### new PointerLockControls(camera, domElement)
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>Camera</code> |  | The camera that is managed by the controls. |
| domElement | <code>HTMLDOMElement</code> | <code></code> | The HTML element used for event listeners. |

<a name="PointerLockControls+isLocked"></a>

### pointerLockControls.isLocked : <code>boolean</code>
Whether the controls are locked or not.

**Kind**: instance property of [<code>PointerLockControls</code>](#PointerLockControls)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="PointerLockControls+minPolarAngle"></a>

### pointerLockControls.minPolarAngle : <code>number</code>
Camera pitch, lower limit. Range is '[0, Math.PI]' in radians.

**Kind**: instance property of [<code>PointerLockControls</code>](#PointerLockControls)  
**Default**: <code>0</code>  
<a name="PointerLockControls+maxPolarAngle"></a>

### pointerLockControls.maxPolarAngle : <code>number</code>
Camera pitch, upper limit. Range is '[0, Math.PI]' in radians.

**Kind**: instance property of [<code>PointerLockControls</code>](#PointerLockControls)  
**Default**: <code>Math.PI</code>  
<a name="PointerLockControls+pointerSpeed"></a>

### pointerLockControls.pointerSpeed : <code>number</code>
Multiplier for how much the pointer movement influences the camera rotation.

**Kind**: instance property of [<code>PointerLockControls</code>](#PointerLockControls)  
**Default**: <code>1</code>  
<a name="PointerLockControls+getDirection"></a>

### pointerLockControls.getDirection(v) ⇒ <code>Vector3</code>
Returns the look direction of the camera.

**Kind**: instance method of [<code>PointerLockControls</code>](#PointerLockControls)  
**Returns**: <code>Vector3</code> - The normalized direction vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="PointerLockControls+moveForward"></a>

### pointerLockControls.moveForward(distance)
Moves the camera forward parallel to the xz-plane. Assumes camera.up is y-up.

**Kind**: instance method of [<code>PointerLockControls</code>](#PointerLockControls)  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The signed distance. |

<a name="PointerLockControls+moveRight"></a>

### pointerLockControls.moveRight(distance)
Moves the camera sidewards parallel to the xz-plane.

**Kind**: instance method of [<code>PointerLockControls</code>](#PointerLockControls)  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The signed distance. |

<a name="PointerLockControls+lock"></a>

### pointerLockControls.lock([unadjustedMovement])
Activates the pointer lock.

**Kind**: instance method of [<code>PointerLockControls</code>](#PointerLockControls)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [unadjustedMovement] | <code>boolean</code> | <code>false</code> | Disables OS-level adjustment for mouse acceleration, and accesses raw mouse input instead. Setting it to true will disable mouse acceleration. |

<a name="PointerLockControls+unlock"></a>

### pointerLockControls.unlock()
Exits the pointer lock.

**Kind**: instance method of [<code>PointerLockControls</code>](#PointerLockControls)  
<a name="PointerLockControls+event_change"></a>

### "change"
Fires when the user moves the mouse.

**Kind**: event emitted by [<code>PointerLockControls</code>](#PointerLockControls)  
<a name="PointerLockControls+event_lock"></a>

### "lock"
Fires when the pointer lock status is "locked" (in other words: the mouse is captured).

**Kind**: event emitted by [<code>PointerLockControls</code>](#PointerLockControls)  
<a name="PointerLockControls+event_unlock"></a>

### "unlock"
Fires when the pointer lock status is "unlocked" (in other words: the mouse is not captured anymore).

**Kind**: event emitted by [<code>PointerLockControls</code>](#PointerLockControls)  
<a name="TrackballControls"></a>

## TrackballControls ⇐ <code>Controls</code>
This class is similar to [OrbitControls](OrbitControls). However, it does not maintain a constant camera
`up` vector. That means if the camera orbits over the “north” and “south” poles, it does not flip
to stay "right side up".

**Kind**: global class  
**Extends**: <code>Controls</code>  

* [TrackballControls](#TrackballControls) ⇐ <code>Controls</code>
    * [new TrackballControls(object, domElement)](#new_TrackballControls_new)
    * [.screen](#TrackballControls+screen) : <code>Object</code>
    * [.rotateSpeed](#TrackballControls+rotateSpeed) : <code>number</code>
    * [.zoomSpeed](#TrackballControls+zoomSpeed) : <code>number</code>
    * [.panSpeed](#TrackballControls+panSpeed) : <code>number</code>
    * [.noRotate](#TrackballControls+noRotate) : <code>boolean</code>
    * [.noZoom](#TrackballControls+noZoom) : <code>boolean</code>
    * [.noPan](#TrackballControls+noPan) : <code>boolean</code>
    * [.staticMoving](#TrackballControls+staticMoving) : <code>boolean</code>
    * [.dynamicDampingFactor](#TrackballControls+dynamicDampingFactor) : <code>number</code>
    * [.minDistance](#TrackballControls+minDistance) : <code>number</code>
    * [.maxDistance](#TrackballControls+maxDistance) : <code>number</code>
    * [.minZoom](#TrackballControls+minZoom) : <code>number</code>
    * [.maxZoom](#TrackballControls+maxZoom) : <code>number</code>
    * [.keys](#TrackballControls+keys) : <code>Array.&lt;string&gt;</code>
    * [.mouseButtons](#TrackballControls+mouseButtons) : <code>Object</code>
    * [.target](#TrackballControls+target) : <code>Vector3</code>
    * [.handleResize()](#TrackballControls+handleResize)
    * [.reset()](#TrackballControls+reset)
    * ["change"](#TrackballControls+event_change)
    * ["start"](#TrackballControls+event_start)
    * ["end"](#TrackballControls+event_end)

<a name="new_TrackballControls_new"></a>

### new TrackballControls(object, domElement)
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The object that is managed by the controls. |
| domElement | <code>HTMLDOMElement</code> | <code></code> | The HTML element used for event listeners. |

<a name="TrackballControls+screen"></a>

### trackballControls.screen : <code>Object</code>
Represents the properties of the screen. Automatically set when `handleResize()` is called.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Read only**: true  
<a name="TrackballControls+rotateSpeed"></a>

### trackballControls.rotateSpeed : <code>number</code>
The rotation speed.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>1</code>  
<a name="TrackballControls+zoomSpeed"></a>

### trackballControls.zoomSpeed : <code>number</code>
The zoom speed.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>1.2</code>  
<a name="TrackballControls+panSpeed"></a>

### trackballControls.panSpeed : <code>number</code>
The pan speed.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>0.3</code>  
<a name="TrackballControls+noRotate"></a>

### trackballControls.noRotate : <code>boolean</code>
Whether rotation is disabled or not.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>false</code>  
<a name="TrackballControls+noZoom"></a>

### trackballControls.noZoom : <code>boolean</code>
Whether zooming is disabled or not.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>false</code>  
<a name="TrackballControls+noPan"></a>

### trackballControls.noPan : <code>boolean</code>
Whether panning is disabled or not.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>false</code>  
<a name="TrackballControls+staticMoving"></a>

### trackballControls.staticMoving : <code>boolean</code>
Whether damping is disabled or not.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>false</code>  
<a name="TrackballControls+dynamicDampingFactor"></a>

### trackballControls.dynamicDampingFactor : <code>number</code>
Defines the intensity of damping. Only considered if `staticMoving` is set to `false`.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>0.2</code>  
<a name="TrackballControls+minDistance"></a>

### trackballControls.minDistance : <code>number</code>
How far you can dolly in (perspective camera only).

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>0</code>  
<a name="TrackballControls+maxDistance"></a>

### trackballControls.maxDistance : <code>number</code>
How far you can dolly out (perspective camera only).

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>Infinity</code>  
<a name="TrackballControls+minZoom"></a>

### trackballControls.minZoom : <code>number</code>
How far you can zoom in (orthographic camera only).

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>0</code>  
<a name="TrackballControls+maxZoom"></a>

### trackballControls.maxZoom : <code>number</code>
How far you can zoom out (orthographic camera only).

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
**Default**: <code>Infinity</code>  
<a name="TrackballControls+keys"></a>

### trackballControls.keys : <code>Array.&lt;string&gt;</code>
This array holds keycodes for controlling interactions.

- When the first defined key is pressed, all mouse interactions (left, middle, right) performs orbiting.
- When the second defined key is pressed, all mouse interactions (left, middle, right) performs zooming.
- When the third defined key is pressed, all mouse interactions (left, middle, right) performs panning.

Default is *KeyA, KeyS, KeyD* which represents A, S, D.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
<a name="TrackballControls+mouseButtons"></a>

### trackballControls.mouseButtons : <code>Object</code>
This object contains references to the mouse actions used by the controls.

```js
controls.mouseButtons = {
	LEFT: THREE.MOUSE.ROTATE,
	MIDDLE: THREE.MOUSE.DOLLY,
	RIGHT: THREE.MOUSE.PAN
}
```

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
<a name="TrackballControls+target"></a>

### trackballControls.target : <code>Vector3</code>
The focus point of the controls.

**Kind**: instance property of [<code>TrackballControls</code>](#TrackballControls)  
<a name="TrackballControls+handleResize"></a>

### trackballControls.handleResize()
Must be called if the application window is resized.

**Kind**: instance method of [<code>TrackballControls</code>](#TrackballControls)  
<a name="TrackballControls+reset"></a>

### trackballControls.reset()
Resets the controls to its initial state.

**Kind**: instance method of [<code>TrackballControls</code>](#TrackballControls)  
<a name="TrackballControls+event_change"></a>

### "change"
Fires when the camera has been transformed by the controls.

**Kind**: event emitted by [<code>TrackballControls</code>](#TrackballControls)  
<a name="TrackballControls+event_start"></a>

### "start"
Fires when an interaction was initiated.

**Kind**: event emitted by [<code>TrackballControls</code>](#TrackballControls)  
<a name="TrackballControls+event_end"></a>

### "end"
Fires when an interaction has finished.

**Kind**: event emitted by [<code>TrackballControls</code>](#TrackballControls)  
<a name="TransformControls"></a>

## TransformControls ⇐ <code>Controls</code>
This class can be used to transform objects in 3D space by adapting a similar interaction model
of DCC tools like Blender. Unlike other controls, it is not intended to transform the scene's camera.

`TransformControls` expects that its attached 3D object is part of the scene graph.

**Kind**: global class  
**Extends**: <code>Controls</code>  

* [TransformControls](#TransformControls) ⇐ <code>Controls</code>
    * [new TransformControls(camera, domElement)](#new_TransformControls_new)
    * [.camera](#TransformControls+camera) : <code>Camera</code>
    * [.axis](#TransformControls+axis) : <code>string</code>
    * [.mode](#TransformControls+mode) : <code>&#x27;translate&#x27;</code> \| <code>&#x27;rotate&#x27;</code> \| <code>&#x27;scale&#x27;</code>
    * [.translationSnap](#TransformControls+translationSnap) : <code>number</code>
    * [.rotationSnap](#TransformControls+rotationSnap) : <code>number</code>
    * [.scaleSnap](#TransformControls+scaleSnap) : <code>number</code>
    * [.space](#TransformControls+space) : <code>&#x27;world&#x27;</code> \| <code>&#x27;local&#x27;</code>
    * [.size](#TransformControls+size) : <code>number</code>
    * [.dragging](#TransformControls+dragging) : <code>boolean</code>
    * [.showX](#TransformControls+showX) : <code>boolean</code>
    * [.showY](#TransformControls+showY) : <code>boolean</code>
    * [.showZ](#TransformControls+showZ) : <code>boolean</code>
    * [.minX](#TransformControls+minX) : <code>number</code>
    * [.maxX](#TransformControls+maxX) : <code>number</code>
    * [.minY](#TransformControls+minY) : <code>number</code>
    * [.maxY](#TransformControls+maxY) : <code>number</code>
    * [.minZ](#TransformControls+minZ) : <code>number</code>
    * [.maxZ](#TransformControls+maxZ) : <code>number</code>
    * [.getHelper()](#TransformControls+getHelper) ⇒ <code>TransformControlsRoot</code>
    * [.attach(object)](#TransformControls+attach) ⇒ [<code>TransformControls</code>](#TransformControls)
    * [.detach()](#TransformControls+detach) ⇒ [<code>TransformControls</code>](#TransformControls)
    * [.reset()](#TransformControls+reset)
    * [.getRaycaster()](#TransformControls+getRaycaster) ⇒ <code>Raycaster</code>
    * [.getMode()](#TransformControls+getMode) ⇒ <code>&#x27;translate&#x27;</code> \| <code>&#x27;rotate&#x27;</code> \| <code>&#x27;scale&#x27;</code>
    * [.setMode(mode)](#TransformControls+setMode)
    * [.setTranslationSnap(translationSnap)](#TransformControls+setTranslationSnap)
    * [.setRotationSnap(rotationSnap)](#TransformControls+setRotationSnap)
    * [.setScaleSnap(scaleSnap)](#TransformControls+setScaleSnap)
    * [.setSize(size)](#TransformControls+setSize)
    * [.setSpace(space)](#TransformControls+setSpace)
    * ["change"](#TransformControls+event_change)
    * ["mouseDown"](#TransformControls+event_mouseDown)
    * ["mouseUp"](#TransformControls+event_mouseUp)
    * ["objectChange"](#TransformControls+event_objectChange)

<a name="new_TransformControls_new"></a>

### new TransformControls(camera, domElement)
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>Camera</code> |  | The camera of the rendered scene. |
| domElement | <code>HTMLDOMElement</code> | <code></code> | The HTML element used for event listeners. |

<a name="TransformControls+camera"></a>

### transformControls.camera : <code>Camera</code>
The camera of the rendered scene.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
<a name="TransformControls+axis"></a>

### transformControls.axis : <code>string</code>
The current transformation axis.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
<a name="TransformControls+mode"></a>

### transformControls.mode : <code>&#x27;translate&#x27;</code> \| <code>&#x27;rotate&#x27;</code> \| <code>&#x27;scale&#x27;</code>
The current transformation axis.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>&#x27;translate&#x27;</code>  
<a name="TransformControls+translationSnap"></a>

### transformControls.translationSnap : <code>number</code>
By default, 3D objects are continuously translated. If you set this property to a numeric
value (world units), you can define in which steps the 3D object should be translated.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>null</code>  
<a name="TransformControls+rotationSnap"></a>

### transformControls.rotationSnap : <code>number</code>
By default, 3D objects are continuously rotated. If you set this property to a numeric
value (radians), you can define in which steps the 3D object should be rotated.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>null</code>  
<a name="TransformControls+scaleSnap"></a>

### transformControls.scaleSnap : <code>number</code>
By default, 3D objects are continuously scaled. If you set this property to a numeric
value, you can define in which steps the 3D object should be scaled.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>null</code>  
<a name="TransformControls+space"></a>

### transformControls.space : <code>&#x27;world&#x27;</code> \| <code>&#x27;local&#x27;</code>
Defines in which coordinate space transformations should be performed.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>&#x27;world&#x27;</code>  
<a name="TransformControls+size"></a>

### transformControls.size : <code>number</code>
The size of the helper UI (axes/planes).

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>1</code>  
<a name="TransformControls+dragging"></a>

### transformControls.dragging : <code>boolean</code>
Whether dragging is currently performed or not.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="TransformControls+showX"></a>

### transformControls.showX : <code>boolean</code>
Whether the x-axis helper should be visible or not.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>true</code>  
<a name="TransformControls+showY"></a>

### transformControls.showY : <code>boolean</code>
Whether the y-axis helper should be visible or not.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>true</code>  
<a name="TransformControls+showZ"></a>

### transformControls.showZ : <code>boolean</code>
Whether the z-axis helper should be visible or not.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>true</code>  
<a name="TransformControls+minX"></a>

### transformControls.minX : <code>number</code>
The minimum allowed X position during translation.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>-Infinity</code>  
<a name="TransformControls+maxX"></a>

### transformControls.maxX : <code>number</code>
The maximum allowed X position during translation.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>Infinity</code>  
<a name="TransformControls+minY"></a>

### transformControls.minY : <code>number</code>
The minimum allowed y position during translation.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>-Infinity</code>  
<a name="TransformControls+maxY"></a>

### transformControls.maxY : <code>number</code>
The maximum allowed Y position during translation.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>Infinity</code>  
<a name="TransformControls+minZ"></a>

### transformControls.minZ : <code>number</code>
The minimum allowed z position during translation.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>-Infinity</code>  
<a name="TransformControls+maxZ"></a>

### transformControls.maxZ : <code>number</code>
The maximum allowed Z position during translation.

**Kind**: instance property of [<code>TransformControls</code>](#TransformControls)  
**Default**: <code>Infinity</code>  
<a name="TransformControls+getHelper"></a>

### transformControls.getHelper() ⇒ <code>TransformControlsRoot</code>
Returns the visual representation of the controls. Add the helper to your scene to
visually transform the attached  3D object.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  
**Returns**: <code>TransformControlsRoot</code> - The helper.  
<a name="TransformControls+attach"></a>

### transformControls.attach(object) ⇒ [<code>TransformControls</code>](#TransformControls)
Sets the 3D object that should be transformed and ensures the controls UI is visible.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  
**Returns**: [<code>TransformControls</code>](#TransformControls) - A reference to this controls.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object that should be transformed. |

<a name="TransformControls+detach"></a>

### transformControls.detach() ⇒ [<code>TransformControls</code>](#TransformControls)
Removes the current 3D object from the controls and makes the helper UI invisible.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  
**Returns**: [<code>TransformControls</code>](#TransformControls) - A reference to this controls.  
<a name="TransformControls+reset"></a>

### transformControls.reset()
Resets the object's position, rotation and scale to when the current transform began.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  
<a name="TransformControls+getRaycaster"></a>

### transformControls.getRaycaster() ⇒ <code>Raycaster</code>
Returns the raycaster that is used for user interaction. This object is shared between all
instances of `TransformControls`.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  
**Returns**: <code>Raycaster</code> - The internal raycaster.  
<a name="TransformControls+getMode"></a>

### transformControls.getMode() ⇒ <code>&#x27;translate&#x27;</code> \| <code>&#x27;rotate&#x27;</code> \| <code>&#x27;scale&#x27;</code>
Returns the transformation mode.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  
**Returns**: <code>&#x27;translate&#x27;</code> \| <code>&#x27;rotate&#x27;</code> \| <code>&#x27;scale&#x27;</code> - The transformation mode.  
<a name="TransformControls+setMode"></a>

### transformControls.setMode(mode)
Sets the given transformation mode.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  

| Param | Type | Description |
| --- | --- | --- |
| mode | <code>&#x27;translate&#x27;</code> \| <code>&#x27;rotate&#x27;</code> \| <code>&#x27;scale&#x27;</code> | The transformation mode to set. |

<a name="TransformControls+setTranslationSnap"></a>

### transformControls.setTranslationSnap(translationSnap)
Sets the translation snap.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  

| Param | Type | Description |
| --- | --- | --- |
| translationSnap | <code>number</code> | The translation snap to set. |

<a name="TransformControls+setRotationSnap"></a>

### transformControls.setRotationSnap(rotationSnap)
Sets the rotation snap.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  

| Param | Type | Description |
| --- | --- | --- |
| rotationSnap | <code>number</code> | The rotation snap to set. |

<a name="TransformControls+setScaleSnap"></a>

### transformControls.setScaleSnap(scaleSnap)
Sets the scale snap.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  

| Param | Type | Description |
| --- | --- | --- |
| scaleSnap | <code>number</code> | The scale snap to set. |

<a name="TransformControls+setSize"></a>

### transformControls.setSize(size)
Sets the size of the helper UI.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  

| Param | Type | Description |
| --- | --- | --- |
| size | <code>number</code> | The size to set. |

<a name="TransformControls+setSpace"></a>

### transformControls.setSpace(space)
Sets the coordinate space in which transformations are applied.

**Kind**: instance method of [<code>TransformControls</code>](#TransformControls)  

| Param | Type | Description |
| --- | --- | --- |
| space | <code>&#x27;world&#x27;</code> \| <code>&#x27;local&#x27;</code> | The space to set. |

<a name="TransformControls+event_change"></a>

### "change"
Fires if any type of change (object or property change) is performed. Property changes
are separate events you can add event listeners to. The event type is "propertyname-changed".

**Kind**: event emitted by [<code>TransformControls</code>](#TransformControls)  
<a name="TransformControls+event_mouseDown"></a>

### "mouseDown"
Fires if a pointer (mouse/touch) becomes active.

**Kind**: event emitted by [<code>TransformControls</code>](#TransformControls)  
<a name="TransformControls+event_mouseUp"></a>

### "mouseUp"
Fires if a pointer (mouse/touch) is no longer active.

**Kind**: event emitted by [<code>TransformControls</code>](#TransformControls)  
<a name="TransformControls+event_objectChange"></a>

### "objectChange"
Fires if the controlled 3D object is changed.

**Kind**: event emitted by [<code>TransformControls</code>](#TransformControls)  
<a name="CSMFrustum"></a>

## CSMFrustum
Represents the frustum of a CSM instance.

**Kind**: global class  

* [CSMFrustum](#CSMFrustum)
    * [new CSMFrustum([data])](#new_CSMFrustum_new)
    * _instance_
        * [.zNear](#CSMFrustum+zNear) : <code>number</code>
        * [.vertices](#CSMFrustum+vertices) : <code>Object</code>
        * [.setFromProjectionMatrix(projectionMatrix, maxFar)](#CSMFrustum+setFromProjectionMatrix) ⇒ <code>Object</code>
        * [.split(breaks, target)](#CSMFrustum+split)
        * [.toSpace(cameraMatrix, target)](#CSMFrustum+toSpace)
    * _inner_
        * [~Data](#CSMFrustum..Data) : <code>Object</code>

<a name="new_CSMFrustum_new"></a>

### new CSMFrustum([data])
Constructs a new CSM frustum.


| Param | Type | Description |
| --- | --- | --- |
| [data] | [<code>Data</code>](#CSMFrustum..Data) | The CSM data. |

<a name="CSMFrustum+zNear"></a>

### csmFrustum.zNear : <code>number</code>
The zNear value. This value depends on whether the CSM
is used with WebGL or WebGPU. Both API use different
conventions for their projection matrices.

**Kind**: instance property of [<code>CSMFrustum</code>](#CSMFrustum)  
<a name="CSMFrustum+vertices"></a>

### csmFrustum.vertices : <code>Object</code>
An object representing the vertices of the near and
far plane in view space.

**Kind**: instance property of [<code>CSMFrustum</code>](#CSMFrustum)  
<a name="CSMFrustum+setFromProjectionMatrix"></a>

### csmFrustum.setFromProjectionMatrix(projectionMatrix, maxFar) ⇒ <code>Object</code>
Setups this CSM frustum from the given projection matrix and max far value.

**Kind**: instance method of [<code>CSMFrustum</code>](#CSMFrustum)  
**Returns**: <code>Object</code> - An object representing the vertices of the near and far plane in view space.  

| Param | Type | Description |
| --- | --- | --- |
| projectionMatrix | <code>Matrix4</code> | The projection matrix, usually of the scene's camera. |
| maxFar | <code>number</code> | The maximum far value. |

<a name="CSMFrustum+split"></a>

### csmFrustum.split(breaks, target)
Splits the CSM frustum by the given array. The new CSM frustum are pushed into the given
target array.

**Kind**: instance method of [<code>CSMFrustum</code>](#CSMFrustum)  

| Param | Type | Description |
| --- | --- | --- |
| breaks | <code>Array.&lt;number&gt;</code> | An array of numbers in the range `[0,1]` the defines how the CSM frustum should be split up. |
| target | [<code>Array.&lt;CSMFrustum&gt;</code>](#CSMFrustum) | The target array that holds the new CSM frustums. |

<a name="CSMFrustum+toSpace"></a>

### csmFrustum.toSpace(cameraMatrix, target)
Transforms the given target CSM frustum into the different coordinate system defined by the
given camera matrix.

**Kind**: instance method of [<code>CSMFrustum</code>](#CSMFrustum)  

| Param | Type | Description |
| --- | --- | --- |
| cameraMatrix | <code>Matrix4</code> | The matrix that defines the new coordinate system. |
| target | [<code>CSMFrustum</code>](#CSMFrustum) | The CSM to convert. |

<a name="CSMFrustum..Data"></a>

### CSMFrustum~Data : <code>Object</code>
Constructor data of `CSMFrustum`.

**Kind**: inner typedef of [<code>CSMFrustum</code>](#CSMFrustum)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [webGL] | <code>boolean</code> | Whether this CSM frustum is used with WebGL or WebGPU. |
| [projectionMatrix] | <code>Matrix4</code> | A projection matrix usually of the scene's camera. |
| [maxFar] | <code>number</code> | The maximum far value. |

<a name="CSMHelper"></a>

## CSMHelper ⇐ <code>Group</code>
A helper for visualizing the cascades of a CSM instance.

**Kind**: global class  
**Extends**: <code>Group</code>  

* [CSMHelper](#CSMHelper) ⇐ <code>Group</code>
    * [new CSMHelper(csm)](#new_CSMHelper_new)
    * [.csm](#CSMHelper+csm) : <code>CSM</code> \| <code>CSMShadowNode</code>
    * [.displayFrustum](#CSMHelper+displayFrustum) : <code>boolean</code>
    * [.displayPlanes](#CSMHelper+displayPlanes) : <code>boolean</code>
    * [.displayShadowBounds](#CSMHelper+displayShadowBounds) : <code>boolean</code>
    * [.updateVisibility()](#CSMHelper+updateVisibility)
    * [.update()](#CSMHelper+update)
    * [.dispose()](#CSMHelper+dispose)

<a name="new_CSMHelper_new"></a>

### new CSMHelper(csm)
Constructs a new CSM helper.


| Param | Type | Description |
| --- | --- | --- |
| csm | <code>CSM</code> \| <code>CSMShadowNode</code> | The CSM instance to visualize. |

<a name="CSMHelper+csm"></a>

### csmHelper.csm : <code>CSM</code> \| <code>CSMShadowNode</code>
The CSM instance to visualize.

**Kind**: instance property of [<code>CSMHelper</code>](#CSMHelper)  
<a name="CSMHelper+displayFrustum"></a>

### csmHelper.displayFrustum : <code>boolean</code>
Whether to display the CSM frustum or not.

**Kind**: instance property of [<code>CSMHelper</code>](#CSMHelper)  
**Default**: <code>true</code>  
<a name="CSMHelper+displayPlanes"></a>

### csmHelper.displayPlanes : <code>boolean</code>
Whether to display the cascade planes or not.

**Kind**: instance property of [<code>CSMHelper</code>](#CSMHelper)  
**Default**: <code>true</code>  
<a name="CSMHelper+displayShadowBounds"></a>

### csmHelper.displayShadowBounds : <code>boolean</code>
Whether to display the shadow bounds or not.

**Kind**: instance property of [<code>CSMHelper</code>](#CSMHelper)  
**Default**: <code>true</code>  
<a name="CSMHelper+updateVisibility"></a>

### csmHelper.updateVisibility()
This method must be called if one of the `display*` properties is changed at runtime.

**Kind**: instance method of [<code>CSMHelper</code>](#CSMHelper)  
<a name="CSMHelper+update"></a>

### csmHelper.update()
Updates the helper. This method should be called in the app's animation loop.

**Kind**: instance method of [<code>CSMHelper</code>](#CSMHelper)  
<a name="CSMHelper+dispose"></a>

### csmHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>CSMHelper</code>](#CSMHelper)  
<a name="module_CSMShader"></a>

## CSMShader
<a name="module_CSMShader..CSMShader"></a>

### CSMShader~CSMShader : <code>Object</code>
The object that holds the GLSL enhancements to enable CSM. This
code is injected into the built-in material shaders by [CSM](CSM).

**Kind**: inner constant of [<code>CSMShader</code>](#module_CSMShader)  
<a name="CSMShadowNode"></a>

## CSMShadowNode ⇐ <code>ShadowBaseNode</code>
An implementation of Cascade Shadow Maps (CSM).

This module can only be used with [WebGPURenderer](WebGPURenderer). When using [WebGLRenderer](WebGLRenderer),
use [CSM](CSM) instead.

**Kind**: global class  
**Extends**: <code>ShadowBaseNode</code>  

* [CSMShadowNode](#CSMShadowNode) ⇐ <code>ShadowBaseNode</code>
    * [new CSMShadowNode(light, [data])](#new_CSMShadowNode_new)
    * _instance_
        * [.camera](#CSMShadowNode+camera) : <code>Camera</code>
        * [.cascades](#CSMShadowNode+cascades) : <code>number</code>
        * [.maxFar](#CSMShadowNode+maxFar) : <code>number</code>
        * [.mode](#CSMShadowNode+mode) : <code>&#x27;practical&#x27;</code> \| <code>&#x27;uniform&#x27;</code> \| <code>&#x27;logarithmic&#x27;</code> \| <code>&#x27;custom&#x27;</code>
        * [.lightMargin](#CSMShadowNode+lightMargin) : <code>number</code>
        * [.customSplitsCallback](#CSMShadowNode+customSplitsCallback) : <code>function</code>
        * [.fade](#CSMShadowNode+fade) : <code>boolean</code>
        * [.breaks](#CSMShadowNode+breaks) : <code>Array.&lt;number&gt;</code>
        * [.mainFrustum](#CSMShadowNode+mainFrustum) : <code>CSMFrustum</code>
        * [.frustums](#CSMShadowNode+frustums) : <code>Array.&lt;CSMFrustum&gt;</code>
        * [.lights](#CSMShadowNode+lights) : <code>Array.&lt;DirectionalLight&gt;</code>
        * [.updateFrustums()](#CSMShadowNode+updateFrustums)
        * [.dispose()](#CSMShadowNode+dispose)
    * _inner_
        * [~Data](#CSMShadowNode..Data) : <code>Object</code>

<a name="new_CSMShadowNode_new"></a>

### new CSMShadowNode(light, [data])
Constructs a new CSM shadow node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>DirectionalLight</code> |  | The CSM light. |
| [data] | [<code>Data</code>](#CSMShadowNode..Data) | <code>{}</code> | The CSM data. |

<a name="CSMShadowNode+camera"></a>

### csmShadowNode.camera : <code>Camera</code>
The scene's camera.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
**Default**: <code>null</code>  
<a name="CSMShadowNode+cascades"></a>

### csmShadowNode.cascades : <code>number</code>
The number of cascades.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
**Default**: <code>3</code>  
<a name="CSMShadowNode+maxFar"></a>

### csmShadowNode.maxFar : <code>number</code>
The maximum far value.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
**Default**: <code>100000</code>  
<a name="CSMShadowNode+mode"></a>

### csmShadowNode.mode : <code>&#x27;practical&#x27;</code> \| <code>&#x27;uniform&#x27;</code> \| <code>&#x27;logarithmic&#x27;</code> \| <code>&#x27;custom&#x27;</code>
The frustum split mode.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
**Default**: <code>&#x27;practical&#x27;</code>  
<a name="CSMShadowNode+lightMargin"></a>

### csmShadowNode.lightMargin : <code>number</code>
The light margin.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
**Default**: <code>200</code>  
<a name="CSMShadowNode+customSplitsCallback"></a>

### csmShadowNode.customSplitsCallback : <code>function</code>
Custom split callback when using `mode='custom'`.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
<a name="CSMShadowNode+fade"></a>

### csmShadowNode.fade : <code>boolean</code>
Whether to fade between cascades or not.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
**Default**: <code>false</code>  
<a name="CSMShadowNode+breaks"></a>

### csmShadowNode.breaks : <code>Array.&lt;number&gt;</code>
An array of numbers in the range `[0,1]` the defines how the
mainCSM frustum should be split up.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
<a name="CSMShadowNode+mainFrustum"></a>

### csmShadowNode.mainFrustum : <code>CSMFrustum</code>
The main frustum.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
**Default**: <code>null</code>  
<a name="CSMShadowNode+frustums"></a>

### csmShadowNode.frustums : <code>Array.&lt;CSMFrustum&gt;</code>
An array of frustums representing the cascades.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
<a name="CSMShadowNode+lights"></a>

### csmShadowNode.lights : <code>Array.&lt;DirectionalLight&gt;</code>
An array of directional lights which cast the shadows for
the different cascades. There is one directional light for each
cascade.

**Kind**: instance property of [<code>CSMShadowNode</code>](#CSMShadowNode)  
<a name="CSMShadowNode+updateFrustums"></a>

### csmShadowNode.updateFrustums()
Applications must call this method every time they change camera or CSM settings.

**Kind**: instance method of [<code>CSMShadowNode</code>](#CSMShadowNode)  
<a name="CSMShadowNode+dispose"></a>

### csmShadowNode.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>CSMShadowNode</code>](#CSMShadowNode)  
<a name="CSMShadowNode..Data"></a>

### CSMShadowNode~Data : <code>Object</code>
Constructor data of `CSMShadowNode`.

**Kind**: inner typedef of [<code>CSMShadowNode</code>](#CSMShadowNode)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [cascades] | <code>number</code> | <code>3</code> | The number of cascades. |
| [maxFar] | <code>number</code> | <code>100000</code> | The maximum far value. |
| [mode] | <code>&#x27;practical&#x27;</code> \| <code>&#x27;uniform&#x27;</code> \| <code>&#x27;logarithmic&#x27;</code> \| <code>&#x27;custom&#x27;</code> | <code>&#x27;practical&#x27;</code> | The frustum split mode. |
| [customSplitsCallback] | <code>function</code> |  | Custom split callback when using `mode='custom'`. |
| [lightMargin] | <code>number</code> | <code>200</code> | The light margin. |

## Classes

<dl>
<dt><a href="#GrannyKnot">GrannyKnot</a> ⇐ <code>Curve</code></dt>
<dd><p>A Granny Knot curve.</p>
</dd>
<dt><a href="#HeartCurve">HeartCurve</a> ⇐ <code>Curve</code></dt>
<dd><p>A heart curve.</p>
</dd>
<dt><a href="#VivianiCurve">VivianiCurve</a> ⇐ <code>Curve</code></dt>
<dd><p>A Viviani curve.</p>
</dd>
<dt><a href="#KnotCurve">KnotCurve</a> ⇐ <code>Curve</code></dt>
<dd><p>A knot curve.</p>
</dd>
<dt><a href="#HelixCurve">HelixCurve</a> ⇐ <code>Curve</code></dt>
<dd><p>A helix curve.</p>
</dd>
<dt><a href="#TrefoilKnot">TrefoilKnot</a> ⇐ <code>Curve</code></dt>
<dd><p>A Trefoil Knot.</p>
</dd>
<dt><a href="#TorusKnot">TorusKnot</a> ⇐ <code>Curve</code></dt>
<dd><p>A torus knot.</p>
</dd>
<dt><a href="#CinquefoilKnot">CinquefoilKnot</a> ⇐ <code>Curve</code></dt>
<dd><p>A Cinquefoil Knot.</p>
</dd>
<dt><a href="#TrefoilPolynomialKnot">TrefoilPolynomialKnot</a> ⇐ <code>Curve</code></dt>
<dd><p>A Trefoil Polynomial Knot.</p>
</dd>
<dt><a href="#FigureEightPolynomialKnot">FigureEightPolynomialKnot</a> ⇐ <code>Curve</code></dt>
<dd><p>A Figure Eight Polynomial Knot.</p>
</dd>
<dt><a href="#DecoratedTorusKnot4a">DecoratedTorusKnot4a</a> ⇐ <code>Curve</code></dt>
<dd><p>A Decorated Torus Knot 4a.</p>
</dd>
<dt><a href="#DecoratedTorusKnot4b">DecoratedTorusKnot4b</a> ⇐ <code>Curve</code></dt>
<dd><p>A Decorated Torus Knot 4b.</p>
</dd>
<dt><a href="#DecoratedTorusKnot5a">DecoratedTorusKnot5a</a> ⇐ <code>Curve</code></dt>
<dd><p>A Decorated Torus Knot 5a.</p>
</dd>
<dt><a href="#DecoratedTorusKnot5c">DecoratedTorusKnot5c</a> ⇐ <code>Curve</code></dt>
<dd><p>A Decorated Torus Knot 5c.</p>
</dd>
</dl>

<a name="GrannyKnot"></a>

## GrannyKnot ⇐ <code>Curve</code>
A Granny Knot curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  
<a name="GrannyKnot+getPoint"></a>

### grannyKnot.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>GrannyKnot</code>](#GrannyKnot)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="HeartCurve"></a>

## HeartCurve ⇐ <code>Curve</code>
A heart curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [HeartCurve](#HeartCurve) ⇐ <code>Curve</code>
    * [new HeartCurve([scale])](#new_HeartCurve_new)
    * [.scale](#HeartCurve+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#HeartCurve+getPoint) ⇒ <code>Vector3</code>

<a name="new_HeartCurve_new"></a>

### new HeartCurve([scale])
Constructs a new heart curve.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>5</code> | The curve's scale. |

<a name="HeartCurve+scale"></a>

### heartCurve.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>HeartCurve</code>](#HeartCurve)  
**Default**: <code>5</code>  
<a name="HeartCurve+getPoint"></a>

### heartCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>HeartCurve</code>](#HeartCurve)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="VivianiCurve"></a>

## VivianiCurve ⇐ <code>Curve</code>
A Viviani curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [VivianiCurve](#VivianiCurve) ⇐ <code>Curve</code>
    * [new VivianiCurve([scale])](#new_VivianiCurve_new)
    * [.scale](#VivianiCurve+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#VivianiCurve+getPoint) ⇒ <code>Vector3</code>

<a name="new_VivianiCurve_new"></a>

### new VivianiCurve([scale])
Constructs a new Viviani curve.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>70</code> | The curve's scale. |

<a name="VivianiCurve+scale"></a>

### vivianiCurve.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>VivianiCurve</code>](#VivianiCurve)  
**Default**: <code>70</code>  
<a name="VivianiCurve+getPoint"></a>

### vivianiCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>VivianiCurve</code>](#VivianiCurve)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="KnotCurve"></a>

## KnotCurve ⇐ <code>Curve</code>
A knot curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  
<a name="KnotCurve+getPoint"></a>

### knotCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>KnotCurve</code>](#KnotCurve)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="HelixCurve"></a>

## HelixCurve ⇐ <code>Curve</code>
A helix curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  
<a name="HelixCurve+getPoint"></a>

### helixCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>HelixCurve</code>](#HelixCurve)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="TrefoilKnot"></a>

## TrefoilKnot ⇐ <code>Curve</code>
A Trefoil Knot.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [TrefoilKnot](#TrefoilKnot) ⇐ <code>Curve</code>
    * [new TrefoilKnot([scale])](#new_TrefoilKnot_new)
    * [.scale](#TrefoilKnot+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#TrefoilKnot+getPoint) ⇒ <code>Vector3</code>

<a name="new_TrefoilKnot_new"></a>

### new TrefoilKnot([scale])
Constructs a new Trefoil Knot.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>10</code> | The curve's scale. |

<a name="TrefoilKnot+scale"></a>

### trefoilKnot.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>TrefoilKnot</code>](#TrefoilKnot)  
**Default**: <code>10</code>  
<a name="TrefoilKnot+getPoint"></a>

### trefoilKnot.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>TrefoilKnot</code>](#TrefoilKnot)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="TorusKnot"></a>

## TorusKnot ⇐ <code>Curve</code>
A torus knot.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [TorusKnot](#TorusKnot) ⇐ <code>Curve</code>
    * [new TorusKnot([scale])](#new_TorusKnot_new)
    * [.scale](#TorusKnot+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#TorusKnot+getPoint) ⇒ <code>Vector3</code>

<a name="new_TorusKnot_new"></a>

### new TorusKnot([scale])
Constructs a new torus knot.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>10</code> | The curve's scale. |

<a name="TorusKnot+scale"></a>

### torusKnot.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>TorusKnot</code>](#TorusKnot)  
**Default**: <code>10</code>  
<a name="TorusKnot+getPoint"></a>

### torusKnot.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>TorusKnot</code>](#TorusKnot)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="CinquefoilKnot"></a>

## CinquefoilKnot ⇐ <code>Curve</code>
A Cinquefoil Knot.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [CinquefoilKnot](#CinquefoilKnot) ⇐ <code>Curve</code>
    * [new CinquefoilKnot([scale])](#new_CinquefoilKnot_new)
    * [.scale](#CinquefoilKnot+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#CinquefoilKnot+getPoint) ⇒ <code>Vector3</code>

<a name="new_CinquefoilKnot_new"></a>

### new CinquefoilKnot([scale])
Constructs a new Cinquefoil Knot.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>10</code> | The curve's scale. |

<a name="CinquefoilKnot+scale"></a>

### cinquefoilKnot.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>CinquefoilKnot</code>](#CinquefoilKnot)  
**Default**: <code>10</code>  
<a name="CinquefoilKnot+getPoint"></a>

### cinquefoilKnot.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>CinquefoilKnot</code>](#CinquefoilKnot)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="TrefoilPolynomialKnot"></a>

## TrefoilPolynomialKnot ⇐ <code>Curve</code>
A Trefoil Polynomial Knot.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [TrefoilPolynomialKnot](#TrefoilPolynomialKnot) ⇐ <code>Curve</code>
    * [new TrefoilPolynomialKnot([scale])](#new_TrefoilPolynomialKnot_new)
    * [.scale](#TrefoilPolynomialKnot+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#TrefoilPolynomialKnot+getPoint) ⇒ <code>Vector3</code>

<a name="new_TrefoilPolynomialKnot_new"></a>

### new TrefoilPolynomialKnot([scale])
Constructs a new Trefoil Polynomial Knot.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>10</code> | The curve's scale. |

<a name="TrefoilPolynomialKnot+scale"></a>

### trefoilPolynomialKnot.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>TrefoilPolynomialKnot</code>](#TrefoilPolynomialKnot)  
**Default**: <code>10</code>  
<a name="TrefoilPolynomialKnot+getPoint"></a>

### trefoilPolynomialKnot.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>TrefoilPolynomialKnot</code>](#TrefoilPolynomialKnot)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="FigureEightPolynomialKnot"></a>

## FigureEightPolynomialKnot ⇐ <code>Curve</code>
A Figure Eight Polynomial Knot.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [FigureEightPolynomialKnot](#FigureEightPolynomialKnot) ⇐ <code>Curve</code>
    * [new FigureEightPolynomialKnot([scale])](#new_FigureEightPolynomialKnot_new)
    * [.scale](#FigureEightPolynomialKnot+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#FigureEightPolynomialKnot+getPoint) ⇒ <code>Vector3</code>

<a name="new_FigureEightPolynomialKnot_new"></a>

### new FigureEightPolynomialKnot([scale])
Constructs a new Figure Eight Polynomial Knot.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>1</code> | The curve's scale. |

<a name="FigureEightPolynomialKnot+scale"></a>

### figureEightPolynomialKnot.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>FigureEightPolynomialKnot</code>](#FigureEightPolynomialKnot)  
**Default**: <code>1</code>  
<a name="FigureEightPolynomialKnot+getPoint"></a>

### figureEightPolynomialKnot.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>FigureEightPolynomialKnot</code>](#FigureEightPolynomialKnot)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="DecoratedTorusKnot4a"></a>

## DecoratedTorusKnot4a ⇐ <code>Curve</code>
A Decorated Torus Knot 4a.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [DecoratedTorusKnot4a](#DecoratedTorusKnot4a) ⇐ <code>Curve</code>
    * [new DecoratedTorusKnot4a([scale])](#new_DecoratedTorusKnot4a_new)
    * [.scale](#DecoratedTorusKnot4a+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#DecoratedTorusKnot4a+getPoint) ⇒ <code>Vector3</code>

<a name="new_DecoratedTorusKnot4a_new"></a>

### new DecoratedTorusKnot4a([scale])
Constructs a new Decorated Torus Knot 4a.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>1</code> | The curve's scale. |

<a name="DecoratedTorusKnot4a+scale"></a>

### decoratedTorusKnot4a.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>DecoratedTorusKnot4a</code>](#DecoratedTorusKnot4a)  
**Default**: <code>40</code>  
<a name="DecoratedTorusKnot4a+getPoint"></a>

### decoratedTorusKnot4a.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>DecoratedTorusKnot4a</code>](#DecoratedTorusKnot4a)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="DecoratedTorusKnot4b"></a>

## DecoratedTorusKnot4b ⇐ <code>Curve</code>
A Decorated Torus Knot 4b.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [DecoratedTorusKnot4b](#DecoratedTorusKnot4b) ⇐ <code>Curve</code>
    * [new DecoratedTorusKnot4b([scale])](#new_DecoratedTorusKnot4b_new)
    * [.scale](#DecoratedTorusKnot4b+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#DecoratedTorusKnot4b+getPoint) ⇒ <code>Vector3</code>

<a name="new_DecoratedTorusKnot4b_new"></a>

### new DecoratedTorusKnot4b([scale])
Constructs a new Decorated Torus Knot 4b.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>1</code> | The curve's scale. |

<a name="DecoratedTorusKnot4b+scale"></a>

### decoratedTorusKnot4b.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>DecoratedTorusKnot4b</code>](#DecoratedTorusKnot4b)  
**Default**: <code>40</code>  
<a name="DecoratedTorusKnot4b+getPoint"></a>

### decoratedTorusKnot4b.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>DecoratedTorusKnot4b</code>](#DecoratedTorusKnot4b)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="DecoratedTorusKnot5a"></a>

## DecoratedTorusKnot5a ⇐ <code>Curve</code>
A Decorated Torus Knot 5a.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [DecoratedTorusKnot5a](#DecoratedTorusKnot5a) ⇐ <code>Curve</code>
    * [new DecoratedTorusKnot5a([scale])](#new_DecoratedTorusKnot5a_new)
    * [.scale](#DecoratedTorusKnot5a+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#DecoratedTorusKnot5a+getPoint) ⇒ <code>Vector3</code>

<a name="new_DecoratedTorusKnot5a_new"></a>

### new DecoratedTorusKnot5a([scale])
Constructs a new Decorated Torus Knot 5a.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>1</code> | The curve's scale. |

<a name="DecoratedTorusKnot5a+scale"></a>

### decoratedTorusKnot5a.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>DecoratedTorusKnot5a</code>](#DecoratedTorusKnot5a)  
**Default**: <code>40</code>  
<a name="DecoratedTorusKnot5a+getPoint"></a>

### decoratedTorusKnot5a.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>DecoratedTorusKnot5a</code>](#DecoratedTorusKnot5a)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="DecoratedTorusKnot5c"></a>

## DecoratedTorusKnot5c ⇐ <code>Curve</code>
A Decorated Torus Knot 5c.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [DecoratedTorusKnot5c](#DecoratedTorusKnot5c) ⇐ <code>Curve</code>
    * [new DecoratedTorusKnot5c([scale])](#new_DecoratedTorusKnot5c_new)
    * [.scale](#DecoratedTorusKnot5c+scale) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#DecoratedTorusKnot5c+getPoint) ⇒ <code>Vector3</code>

<a name="new_DecoratedTorusKnot5c_new"></a>

### new DecoratedTorusKnot5c([scale])
Constructs a new Decorated Torus Knot 5c.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scale] | <code>number</code> | <code>1</code> | The curve's scale. |

<a name="DecoratedTorusKnot5c+scale"></a>

### decoratedTorusKnot5c.scale : <code>number</code>
The curve's scale.

**Kind**: instance property of [<code>DecoratedTorusKnot5c</code>](#DecoratedTorusKnot5c)  
**Default**: <code>40</code>  
<a name="DecoratedTorusKnot5c+getPoint"></a>

### decoratedTorusKnot5c.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>DecoratedTorusKnot5c</code>](#DecoratedTorusKnot5c)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="NURBSCurve"></a>

## NURBSCurve ⇐ <code>Curve</code>
This class represents a NURBS curve.

Implementation is based on `(x, y [, z=0 [, w=1]])` control points with `w=weight`.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [NURBSCurve](#NURBSCurve) ⇐ <code>Curve</code>
    * [new NURBSCurve(degree, knots, controlPoints, [startKnot], [endKnot])](#new_NURBSCurve_new)
    * [.degree](#NURBSCurve+degree) : <code>number</code>
    * [.knots](#NURBSCurve+knots) : <code>Array.&lt;number&gt;</code>
    * [.controlPoints](#NURBSCurve+controlPoints) : <code>Array.&lt;Vector4&gt;</code>
    * [.startKnot](#NURBSCurve+startKnot) : <code>number</code>
    * [.endKnot](#NURBSCurve+endKnot) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#NURBSCurve+getPoint) ⇒ <code>Vector3</code>
    * [.getTangent(t, [optionalTarget])](#NURBSCurve+getTangent) ⇒ <code>Vector3</code>

<a name="new_NURBSCurve_new"></a>

### new NURBSCurve(degree, knots, controlPoints, [startKnot], [endKnot])
Constructs a new NURBS curve.


| Param | Type | Description |
| --- | --- | --- |
| degree | <code>number</code> | The NURBS degree. |
| knots | <code>Array.&lt;number&gt;</code> | The knots as a flat array of numbers. |
| controlPoints | <code>Array.&lt;(Vector2\|Vector3\|Vector4)&gt;</code> | An array holding control points. |
| [startKnot] | <code>number</code> | Index of the start knot into the `knots` array. |
| [endKnot] | <code>number</code> | Index of the end knot into the `knots` array. |

<a name="NURBSCurve+degree"></a>

### nurbsCurve.degree : <code>number</code>
The NURBS degree.

**Kind**: instance property of [<code>NURBSCurve</code>](#NURBSCurve)  
<a name="NURBSCurve+knots"></a>

### nurbsCurve.knots : <code>Array.&lt;number&gt;</code>
The knots as a flat array of numbers.

**Kind**: instance property of [<code>NURBSCurve</code>](#NURBSCurve)  
<a name="NURBSCurve+controlPoints"></a>

### nurbsCurve.controlPoints : <code>Array.&lt;Vector4&gt;</code>
An array of control points.

**Kind**: instance property of [<code>NURBSCurve</code>](#NURBSCurve)  
<a name="NURBSCurve+startKnot"></a>

### nurbsCurve.startKnot : <code>number</code>
Index of the start knot into the `knots` array.

**Kind**: instance property of [<code>NURBSCurve</code>](#NURBSCurve)  
<a name="NURBSCurve+endKnot"></a>

### nurbsCurve.endKnot : <code>number</code>
Index of the end knot into the `knots` array.

**Kind**: instance property of [<code>NURBSCurve</code>](#NURBSCurve)  
<a name="NURBSCurve+getPoint"></a>

### nurbsCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
This method returns a vector in 3D space for the given interpolation factor.

**Kind**: instance method of [<code>NURBSCurve</code>](#NURBSCurve)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="NURBSCurve+getTangent"></a>

### nurbsCurve.getTangent(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a unit vector tangent for the given interpolation factor.

**Kind**: instance method of [<code>NURBSCurve</code>](#NURBSCurve)  
**Returns**: <code>Vector3</code> - The tangent vector.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="NURBSSurface"></a>

## NURBSSurface
This class represents a NURBS surface.

Implementation is based on `(x, y [, z=0 [, w=1]])` control points with `w=weight`.

**Kind**: global class  

* [NURBSSurface](#NURBSSurface)
    * [new NURBSSurface(degree1, degree2, knots1, knots2, controlPoints)](#new_NURBSSurface_new)
    * [.degree1](#NURBSSurface+degree1) : <code>number</code>
    * [.degree2](#NURBSSurface+degree2) : <code>number</code>
    * [.knots1](#NURBSSurface+knots1) : <code>Array.&lt;number&gt;</code>
    * [.knots2](#NURBSSurface+knots2) : <code>Array.&lt;number&gt;</code>
    * [.controlPoints](#NURBSSurface+controlPoints) : <code>Array.&lt;Array.&lt;(Vector2\|Vector3\|Vector4)&gt;&gt;</code>
    * [.getPoint(t1, t2, target)](#NURBSSurface+getPoint)

<a name="new_NURBSSurface_new"></a>

### new NURBSSurface(degree1, degree2, knots1, knots2, controlPoints)
Constructs a new NURBS surface.


| Param | Type | Description |
| --- | --- | --- |
| degree1 | <code>number</code> | The first NURBS degree. |
| degree2 | <code>number</code> | The second NURBS degree. |
| knots1 | <code>Array.&lt;number&gt;</code> | The first knots as a flat array of numbers. |
| knots2 | <code>Array.&lt;number&gt;</code> | The second knots as a flat array of numbers. |
| controlPoints | <code>Array.&lt;Array.&lt;(Vector2\|Vector3\|Vector4)&gt;&gt;</code> | An array^2 holding control points. |

<a name="NURBSSurface+degree1"></a>

### nurbsSurface.degree1 : <code>number</code>
The first NURBS degree.

**Kind**: instance property of [<code>NURBSSurface</code>](#NURBSSurface)  
<a name="NURBSSurface+degree2"></a>

### nurbsSurface.degree2 : <code>number</code>
The second NURBS degree.

**Kind**: instance property of [<code>NURBSSurface</code>](#NURBSSurface)  
<a name="NURBSSurface+knots1"></a>

### nurbsSurface.knots1 : <code>Array.&lt;number&gt;</code>
The first knots as a flat array of numbers.

**Kind**: instance property of [<code>NURBSSurface</code>](#NURBSSurface)  
<a name="NURBSSurface+knots2"></a>

### nurbsSurface.knots2 : <code>Array.&lt;number&gt;</code>
The second knots as a flat array of numbers.

**Kind**: instance property of [<code>NURBSSurface</code>](#NURBSSurface)  
<a name="NURBSSurface+controlPoints"></a>

### nurbsSurface.controlPoints : <code>Array.&lt;Array.&lt;(Vector2\|Vector3\|Vector4)&gt;&gt;</code>
An array holding arrays of control points.

**Kind**: instance property of [<code>NURBSSurface</code>](#NURBSSurface)  
<a name="NURBSSurface+getPoint"></a>

### nurbsSurface.getPoint(t1, t2, target)
This method returns a vector in 3D space for the given interpolation factor. This vector lies on the NURBS surface.

**Kind**: instance method of [<code>NURBSSurface</code>](#NURBSSurface)  

| Param | Type | Description |
| --- | --- | --- |
| t1 | <code>number</code> | The first interpolation factor representing the `u` position on the surface. Must be in the range `[0,1]`. |
| t2 | <code>number</code> | The second interpolation factor representing the `v` position on the surface. Must be in the range `[0,1]`. |
| target | <code>Vector3</code> | The target vector the result is written to. |

<a name="module_NURBSUtils"></a>

## NURBSUtils

* [NURBSUtils](#module_NURBSUtils)
    * [~findSpan(p, u, U)](#module_NURBSUtils..findSpan) ⇒ <code>number</code>
    * [~calcBasisFunctions(span, u, p, U)](#module_NURBSUtils..calcBasisFunctions) ⇒ <code>Array.&lt;number&gt;</code>
    * [~calcBSplinePoint(p, U, P, u)](#module_NURBSUtils..calcBSplinePoint) ⇒ <code>Vector4</code>
    * [~calcBasisFunctionDerivatives(span, u, p, n, U)](#module_NURBSUtils..calcBasisFunctionDerivatives) ⇒ <code>Array.&lt;Array.&lt;number&gt;&gt;</code>
    * [~calcBSplineDerivatives(p, U, P, u, nd)](#module_NURBSUtils..calcBSplineDerivatives) ⇒ <code>Array.&lt;Vector4&gt;</code>
    * [~calcKoverI(k, i)](#module_NURBSUtils..calcKoverI) ⇒ <code>number</code>
    * [~calcRationalCurveDerivatives(Pders)](#module_NURBSUtils..calcRationalCurveDerivatives) ⇒ <code>Array.&lt;Vector3&gt;</code>
    * [~calcNURBSDerivatives(p, U, P, u, nd)](#module_NURBSUtils..calcNURBSDerivatives) ⇒ <code>Array.&lt;Vector3&gt;</code>
    * [~calcSurfacePoint(p, q, U, V, P, u, v, target)](#module_NURBSUtils..calcSurfacePoint)
    * [~calcVolumePoint(p, q, r, U, V, W, P, u, v, w, target)](#module_NURBSUtils..calcVolumePoint)

<a name="module_NURBSUtils..findSpan"></a>

### NURBSUtils~findSpan(p, u, U) ⇒ <code>number</code>
Finds knot vector span.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  
**Returns**: <code>number</code> - The span.  

| Param | Type | Description |
| --- | --- | --- |
| p | <code>number</code> | The degree. |
| u | <code>number</code> | The parametric value. |
| U | <code>Array.&lt;number&gt;</code> | The knot vector. |

<a name="module_NURBSUtils..calcBasisFunctions"></a>

### NURBSUtils~calcBasisFunctions(span, u, p, U) ⇒ <code>Array.&lt;number&gt;</code>
Calculates basis functions. See The NURBS Book, page 70, algorithm A2.2.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  
**Returns**: <code>Array.&lt;number&gt;</code> - Array[p+1] with basis functions values.  

| Param | Type | Description |
| --- | --- | --- |
| span | <code>number</code> | The span in which `u` lies. |
| u | <code>number</code> | The parametric value. |
| p | <code>number</code> | The degree. |
| U | <code>Array.&lt;number&gt;</code> | The knot vector. |

<a name="module_NURBSUtils..calcBSplinePoint"></a>

### NURBSUtils~calcBSplinePoint(p, U, P, u) ⇒ <code>Vector4</code>
Calculates B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  
**Returns**: <code>Vector4</code> - The point for given `u`.  

| Param | Type | Description |
| --- | --- | --- |
| p | <code>number</code> | The degree of the B-Spline. |
| U | <code>Array.&lt;number&gt;</code> | The knot vector. |
| P | <code>Array.&lt;Vector4&gt;</code> | The control points |
| u | <code>number</code> | The parametric point. |

<a name="module_NURBSUtils..calcBasisFunctionDerivatives"></a>

### NURBSUtils~calcBasisFunctionDerivatives(span, u, p, n, U) ⇒ <code>Array.&lt;Array.&lt;number&gt;&gt;</code>
Calculates basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  
**Returns**: <code>Array.&lt;Array.&lt;number&gt;&gt;</code> - An array[n+1][p+1] with basis functions derivatives.  

| Param | Type | Description |
| --- | --- | --- |
| span | <code>number</code> | The span in which `u` lies. |
| u | <code>number</code> | The parametric point. |
| p | <code>number</code> | The degree. |
| n | <code>number</code> | number of derivatives to calculate |
| U | <code>Array.&lt;number&gt;</code> | The knot vector. |

<a name="module_NURBSUtils..calcBSplineDerivatives"></a>

### NURBSUtils~calcBSplineDerivatives(p, U, P, u, nd) ⇒ <code>Array.&lt;Vector4&gt;</code>
Calculates derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  
**Returns**: <code>Array.&lt;Vector4&gt;</code> - An array[d+1] with derivatives.  

| Param | Type | Description |
| --- | --- | --- |
| p | <code>number</code> | The degree. |
| U | <code>Array.&lt;number&gt;</code> | The knot vector. |
| P | <code>Array.&lt;Vector4&gt;</code> | The control points |
| u | <code>number</code> | The parametric point. |
| nd | <code>number</code> | The number of derivatives. |

<a name="module_NURBSUtils..calcKoverI"></a>

### NURBSUtils~calcKoverI(k, i) ⇒ <code>number</code>
Calculates "K over I".

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  
**Returns**: <code>number</code> - k!/(i!(k-i)!)  

| Param | Type | Description |
| --- | --- | --- |
| k | <code>number</code> | The K value. |
| i | <code>number</code> | The I value. |

<a name="module_NURBSUtils..calcRationalCurveDerivatives"></a>

### NURBSUtils~calcRationalCurveDerivatives(Pders) ⇒ <code>Array.&lt;Vector3&gt;</code>
Calculates derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  
**Returns**: <code>Array.&lt;Vector3&gt;</code> - An array with derivatives for rational curve.  

| Param | Type | Description |
| --- | --- | --- |
| Pders | <code>Array.&lt;Vector4&gt;</code> | Array with derivatives. |

<a name="module_NURBSUtils..calcNURBSDerivatives"></a>

### NURBSUtils~calcNURBSDerivatives(p, U, P, u, nd) ⇒ <code>Array.&lt;Vector3&gt;</code>
Calculates NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  
**Returns**: <code>Array.&lt;Vector3&gt;</code> - array with derivatives for rational curve.  

| Param | Type | Description |
| --- | --- | --- |
| p | <code>number</code> | The degree. |
| U | <code>Array.&lt;number&gt;</code> | The knot vector. |
| P | <code>Array.&lt;Vector4&gt;</code> | The control points in homogeneous space. |
| u | <code>number</code> | The parametric point. |
| nd | <code>number</code> | The number of derivatives. |

<a name="module_NURBSUtils..calcSurfacePoint"></a>

### NURBSUtils~calcSurfacePoint(p, q, U, V, P, u, v, target)
Calculates a rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  

| Param | Type | Description |
| --- | --- | --- |
| p | <code>number</code> | The first degree of B-Spline surface. |
| q | <code>number</code> | The second degree of B-Spline surface. |
| U | <code>Array.&lt;number&gt;</code> | The first knot vector. |
| V | <code>Array.&lt;number&gt;</code> | The second knot vector. |
| P | <code>Array.&lt;Array.&lt;Vector4&gt;&gt;</code> | The control points in homogeneous space. |
| u | <code>number</code> | The first parametric point. |
| v | <code>number</code> | The second parametric point. |
| target | <code>Vector3</code> | The target vector. |

<a name="module_NURBSUtils..calcVolumePoint"></a>

### NURBSUtils~calcVolumePoint(p, q, r, U, V, W, P, u, v, w, target)
Calculates a rational B-Spline volume point. See The NURBS Book, page 134, algorithm A4.3.

**Kind**: inner method of [<code>NURBSUtils</code>](#module_NURBSUtils)  

| Param | Type | Description |
| --- | --- | --- |
| p | <code>number</code> | The first degree of B-Spline surface. |
| q | <code>number</code> | The second degree of B-Spline surface. |
| r | <code>number</code> | The third degree of B-Spline surface. |
| U | <code>Array.&lt;number&gt;</code> | The first knot vector. |
| V | <code>Array.&lt;number&gt;</code> | The second knot vector. |
| W | <code>Array.&lt;number&gt;</code> | The third knot vector. |
| P | <code>Array.&lt;Array.&lt;Array.&lt;Vector4&gt;&gt;&gt;</code> | The control points in homogeneous space. |
| u | <code>number</code> | The first parametric point. |
| v | <code>number</code> | The second parametric point. |
| w | <code>number</code> | The third parametric point. |
| target | <code>Vector3</code> | The target vector. |

<a name="NURBSVolume"></a>

## NURBSVolume
This class represents a NURBS volume.

Implementation is based on `(x, y [, z=0 [, w=1]])` control points with `w=weight`.

**Kind**: global class  

* [NURBSVolume](#NURBSVolume)
    * [new NURBSVolume(degree1, degree2, degree3, knots1, knots2, knots3, controlPoints)](#new_NURBSVolume_new)
    * [.getPoint(t1, t2, t3, target)](#NURBSVolume+getPoint)

<a name="new_NURBSVolume_new"></a>

### new NURBSVolume(degree1, degree2, degree3, knots1, knots2, knots3, controlPoints)
Constructs a new NURBS surface.


| Param | Type | Description |
| --- | --- | --- |
| degree1 | <code>number</code> | The first NURBS degree. |
| degree2 | <code>number</code> | The second NURBS degree. |
| degree3 | <code>number</code> | The third NURBS degree. |
| knots1 | <code>Array.&lt;number&gt;</code> | The first knots as a flat array of numbers. |
| knots2 | <code>Array.&lt;number&gt;</code> | The second knots as a flat array of numbers. |
| knots3 | <code>Array.&lt;number&gt;</code> | The third knots as a flat array of numbers. |
| controlPoints | <code>Array.&lt;Array.&lt;Array.&lt;(Vector2\|Vector3\|Vector4)&gt;&gt;&gt;</code> | An array^3 holding control points. |

<a name="NURBSVolume+getPoint"></a>

### nurbsVolume.getPoint(t1, t2, t3, target)
This method returns a vector in 3D space for the given interpolation factor. This vector lies within the NURBS volume.

**Kind**: instance method of [<code>NURBSVolume</code>](#NURBSVolume)  

| Param | Type | Description |
| --- | --- | --- |
| t1 | <code>number</code> | The first interpolation factor representing the `u` position within the volume. Must be in the range `[0,1]`. |
| t2 | <code>number</code> | The second interpolation factor representing the `v` position within the volume. Must be in the range `[0,1]`. |
| t3 | <code>number</code> | The third interpolation factor representing the `w` position within the volume. Must be in the range `[0,1]`. |
| target | <code>Vector3</code> | The target vector the result is written to. |

<a name="AnaglyphEffect"></a>

## AnaglyphEffect
A class that creates an anaglyph effect.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [AnaglyphPassNode](AnaglyphPassNode).

**Kind**: global class  

* [AnaglyphEffect](#AnaglyphEffect)
    * [new AnaglyphEffect(renderer, width, height)](#new_AnaglyphEffect_new)
    * [.setSize(width, height)](#AnaglyphEffect+setSize)
    * [.render(scene, camera)](#AnaglyphEffect+render)
    * [.dispose()](#AnaglyphEffect+dispose)

<a name="new_AnaglyphEffect_new"></a>

### new AnaglyphEffect(renderer, width, height)
Constructs a new anaglyph effect.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>WebGLRenderer</code> |  | The renderer. |
| width | <code>number</code> | <code>512</code> | The width of the effect in physical pixels. |
| height | <code>number</code> | <code>512</code> | The height of the effect in physical pixels. |

<a name="AnaglyphEffect+setSize"></a>

### anaglyphEffect.setSize(width, height)
Resizes the effect.

**Kind**: instance method of [<code>AnaglyphEffect</code>](#AnaglyphEffect)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect in logical pixels. |
| height | <code>number</code> | The height of the effect in logical pixels. |

<a name="AnaglyphEffect+render"></a>

### anaglyphEffect.render(scene, camera)
When using this effect, this method should be called instead of the
default [WebGLRenderer#render](WebGLRenderer#render).

**Kind**: instance method of [<code>AnaglyphEffect</code>](#AnaglyphEffect)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="AnaglyphEffect+dispose"></a>

### anaglyphEffect.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>AnaglyphEffect</code>](#AnaglyphEffect)  
<a name="AsciiEffect"></a>

## AsciiEffect
A class that creates an ASCII effect.

The ASCII generation is based on [jsascii](https://github.com/hassadee/jsascii/blob/master/jsascii.js).

**Kind**: global class  

* [AsciiEffect](#AsciiEffect)
    * [new AsciiEffect(renderer, [charSet], [options])](#new_AsciiEffect_new)
    * _instance_
        * [.domElement](#AsciiEffect+domElement) : <code>HTMLDivElement</code>
        * [.setSize(w, h)](#AsciiEffect+setSize)
        * [.render(scene, camera)](#AsciiEffect+render)
    * _inner_
        * [~Options](#AsciiEffect..Options) : <code>Object</code>

<a name="new_AsciiEffect_new"></a>

### new AsciiEffect(renderer, [charSet], [options])
Constructs a new ASCII effect.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>WebGLRenderer</code> |  | The renderer. |
| [charSet] | <code>string</code> | <code>&quot;&#x27; .:-&#x3D;+*#%@&#x27;&quot;</code> | The char set. |
| [options] | [<code>Options</code>](#AsciiEffect..Options) |  | The configuration parameter. |

<a name="AsciiEffect+domElement"></a>

### asciiEffect.domElement : <code>HTMLDivElement</code>
The DOM element of the effect. This element must be used instead of the
default [WebGLRenderer#domElement](WebGLRenderer#domElement).

**Kind**: instance property of [<code>AsciiEffect</code>](#AsciiEffect)  
<a name="AsciiEffect+setSize"></a>

### asciiEffect.setSize(w, h)
Resizes the effect.

**Kind**: instance method of [<code>AsciiEffect</code>](#AsciiEffect)  

| Param | Type | Description |
| --- | --- | --- |
| w | <code>number</code> | The width of the effect in logical pixels. |
| h | <code>number</code> | The height of the effect in logical pixels. |

<a name="AsciiEffect+render"></a>

### asciiEffect.render(scene, camera)
When using this effect, this method should be called instead of the
default [WebGLRenderer#render](WebGLRenderer#render).

**Kind**: instance method of [<code>AsciiEffect</code>](#AsciiEffect)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="AsciiEffect..Options"></a>

### AsciiEffect~Options : <code>Object</code>
This type represents configuration settings of `AsciiEffect`.

**Kind**: inner typedef of [<code>AsciiEffect</code>](#AsciiEffect)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [resolution] | <code>number</code> | <code>0.15</code> | A higher value leads to more details. |
| [scale] | <code>number</code> | <code>1</code> | The scale of the effect. |
| [color] | <code>boolean</code> | <code>false</code> | Whether colors should be enabled or not. Better quality but slows down rendering. |
| [alpha] | <code>boolean</code> | <code>false</code> | Whether transparency should be enabled or not. |
| [block] | <code>boolean</code> | <code>false</code> | Whether blocked characters should be enabled or not. |
| [invert] | <code>boolean</code> | <code>false</code> | Whether colors should be inverted or not. |
| [strResolution] | <code>&#x27;low&#x27;</code> \| <code>&#x27;medium&#x27;</code> \| <code>&#x27;high&#x27;</code> | <code>&#x27;low&#x27;</code> | The string resolution. |

<a name="OutlineEffect"></a>

## OutlineEffect
An outline effect for toon shaders.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [ToonOutlinePassNode](ToonOutlinePassNode).

```js
const effect = new OutlineEffect( renderer );

function render() {

	effect.render( scene, camera );

}
```

**Kind**: global class  

* [OutlineEffect](#OutlineEffect)
    * [new OutlineEffect(renderer, [parameters])](#new_OutlineEffect_new)
    * _instance_
        * [.render(scene, camera)](#OutlineEffect+render)
        * [.renderOutline(scene, camera)](#OutlineEffect+renderOutline)
        * [.setSize(width, height)](#OutlineEffect+setSize)
    * _inner_
        * [~Options](#OutlineEffect..Options) : <code>Object</code>

<a name="new_OutlineEffect_new"></a>

### new OutlineEffect(renderer, [parameters])
Constructs a new outline effect.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| [parameters] | [<code>Options</code>](#OutlineEffect..Options) | The configuration parameter. |

<a name="OutlineEffect+render"></a>

### outlineEffect.render(scene, camera)
When using this effect, this method should be called instead of the
default [WebGLRenderer#render](WebGLRenderer#render).

**Kind**: instance method of [<code>OutlineEffect</code>](#OutlineEffect)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="OutlineEffect+renderOutline"></a>

### outlineEffect.renderOutline(scene, camera)
This method can be used to render outlines in VR.

```js
const effect = new OutlineEffect( renderer );
let renderingOutline = false;

scene.onAfterRender = function () {

	if ( renderingOutline ) return;

	renderingOutline = true;
	effect.renderOutline( scene, camera );
	renderingOutline = false;
};

function render() {
	renderer.render( scene, camera );
}
```

**Kind**: instance method of [<code>OutlineEffect</code>](#OutlineEffect)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="OutlineEffect+setSize"></a>

### outlineEffect.setSize(width, height)
Resizes the effect.

**Kind**: instance method of [<code>OutlineEffect</code>](#OutlineEffect)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect in logical pixels. |
| height | <code>number</code> | The height of the effect in logical pixels. |

<a name="OutlineEffect..Options"></a>

### OutlineEffect~Options : <code>Object</code>
This type represents configuration settings of `OutlineEffect`.

**Kind**: inner typedef of [<code>OutlineEffect</code>](#OutlineEffect)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [defaultThickness] | <code>number</code> | <code>0.003</code> | The outline thickness. |
| [defaultColor] | <code>Array.&lt;number&gt;</code> | <code>[0,0,0]</code> | The outline color. |
| [defaultAlpha] | <code>number</code> | <code>1</code> | The outline alpha value. |
| [defaultKeepAlive] | <code>boolean</code> | <code>false</code> | Whether to keep alive cached internal materials or not. |

<a name="ParallaxBarrierEffect"></a>

## ParallaxBarrierEffect
A class that creates an parallax barrier effect.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [ParallaxBarrierPassNode](ParallaxBarrierPassNode).

**Kind**: global class  

* [ParallaxBarrierEffect](#ParallaxBarrierEffect)
    * [new ParallaxBarrierEffect(renderer)](#new_ParallaxBarrierEffect_new)
    * [.setSize(width, height)](#ParallaxBarrierEffect+setSize)
    * [.render(scene, camera)](#ParallaxBarrierEffect+render)
    * [.dispose()](#ParallaxBarrierEffect+dispose)

<a name="new_ParallaxBarrierEffect_new"></a>

### new ParallaxBarrierEffect(renderer)
Constructs a new parallax barrier effect.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="ParallaxBarrierEffect+setSize"></a>

### parallaxBarrierEffect.setSize(width, height)
Resizes the effect.

**Kind**: instance method of [<code>ParallaxBarrierEffect</code>](#ParallaxBarrierEffect)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect in logical pixels. |
| height | <code>number</code> | The height of the effect in logical pixels. |

<a name="ParallaxBarrierEffect+render"></a>

### parallaxBarrierEffect.render(scene, camera)
When using this effect, this method should be called instead of the
default [WebGLRenderer#render](WebGLRenderer#render).

**Kind**: instance method of [<code>ParallaxBarrierEffect</code>](#ParallaxBarrierEffect)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="ParallaxBarrierEffect+dispose"></a>

### parallaxBarrierEffect.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>ParallaxBarrierEffect</code>](#ParallaxBarrierEffect)  
<a name="PeppersGhostEffect"></a>

## PeppersGhostEffect
A class that implements a peppers ghost effect.

Reference: [Reflective Prism](http://www.instructables.com/id/Reflective-Prism/?ALLSTEPS)

**Kind**: global class  

* [PeppersGhostEffect](#PeppersGhostEffect)
    * [new PeppersGhostEffect(renderer)](#new_PeppersGhostEffect_new)
    * [.setSize(width, height)](#PeppersGhostEffect+setSize)
    * [.render(scene, camera)](#PeppersGhostEffect+render)

<a name="new_PeppersGhostEffect_new"></a>

### new PeppersGhostEffect(renderer)
Constructs a new peppers ghost effect.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The renderer. |

<a name="PeppersGhostEffect+setSize"></a>

### peppersGhostEffect.setSize(width, height)
Resizes the effect.

**Kind**: instance method of [<code>PeppersGhostEffect</code>](#PeppersGhostEffect)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect in logical pixels. |
| height | <code>number</code> | The height of the effect in logical pixels. |

<a name="PeppersGhostEffect+render"></a>

### peppersGhostEffect.render(scene, camera)
When using this effect, this method should be called instead of the
default [WebGLRenderer#render](WebGLRenderer#render).

**Kind**: instance method of [<code>PeppersGhostEffect</code>](#PeppersGhostEffect)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="StereoEffect"></a>

## StereoEffect
A class that creates an stereo effect.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [StereoPassNode](StereoPassNode).

**Kind**: global class  

* [StereoEffect](#StereoEffect)
    * [new StereoEffect(renderer)](#new_StereoEffect_new)
    * [.setEyeSeparation(eyeSep)](#StereoEffect+setEyeSeparation)
    * [.setSize(width, height)](#StereoEffect+setSize)
    * [.render(scene, camera)](#StereoEffect+render)

<a name="new_StereoEffect_new"></a>

### new StereoEffect(renderer)
Constructs a new stereo effect.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="StereoEffect+setEyeSeparation"></a>

### stereoEffect.setEyeSeparation(eyeSep)
Sets the given eye separation.

**Kind**: instance method of [<code>StereoEffect</code>](#StereoEffect)  

| Param | Type | Description |
| --- | --- | --- |
| eyeSep | <code>number</code> | The eye separation to set. |

<a name="StereoEffect+setSize"></a>

### stereoEffect.setSize(width, height)
Resizes the effect.

**Kind**: instance method of [<code>StereoEffect</code>](#StereoEffect)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect in logical pixels. |
| height | <code>number</code> | The height of the effect in logical pixels. |

<a name="StereoEffect+render"></a>

### stereoEffect.render(scene, camera)
When using this effect, this method should be called instead of the
default [WebGLRenderer#render](WebGLRenderer#render).

**Kind**: instance method of [<code>StereoEffect</code>](#StereoEffect)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="DebugEnvironment"></a>

## DebugEnvironment ⇐ <code>Scene</code>
This class represents a scene with a very basic room setup that can be used as
input for [PMREMGenerator#fromScene](PMREMGenerator#fromScene). The resulting PMREM represents the room's
lighting and can be used for Image Based Lighting by assigning it to [Scene#environment](Scene#environment)
or directly as an environment map to PBR materials.

This class uses a simple room setup and should only be used for development purposes.
A more appropriate setup for production is [RoomEnvironment](RoomEnvironment).

```js
const environment = new DebugEnvironment();
const pmremGenerator = new THREE.PMREMGenerator( renderer );

const envMap = pmremGenerator.fromScene( environment ).texture;
scene.environment = envMap;
```

**Kind**: global class  
**Extends**: <code>Scene</code>  

* [DebugEnvironment](#DebugEnvironment) ⇐ <code>Scene</code>
    * [new DebugEnvironment()](#new_DebugEnvironment_new)
    * [.dispose()](#DebugEnvironment+dispose)

<a name="new_DebugEnvironment_new"></a>

### new DebugEnvironment()
Constructs a new debug environment.

<a name="DebugEnvironment+dispose"></a>

### debugEnvironment.dispose()
Frees internal resources. This method should be called
when the environment is no longer required.

**Kind**: instance method of [<code>DebugEnvironment</code>](#DebugEnvironment)  
<a name="RoomEnvironment"></a>

## RoomEnvironment ⇐ <code>Scene</code>
This class represents a scene with a basic room setup that can be used as
input for [PMREMGenerator#fromScene](PMREMGenerator#fromScene). The resulting PMREM represents the room's
lighting and can be used for Image Based Lighting by assigning it to [Scene#environment](Scene#environment)
or directly as an environment map to PBR materials.

The implementation is based on the [EnvironmentScene](https://github.com/google/model-viewer/blob/master/packages/model-viewer/src/three-components/EnvironmentScene.ts)
component from the `model-viewer` project.

```js
const environment = new RoomEnvironment();
const pmremGenerator = new THREE.PMREMGenerator( renderer );

const envMap = pmremGenerator.fromScene( environment ).texture;
scene.environment = envMap;
```

**Kind**: global class  
**Extends**: <code>Scene</code>  
<a name="RoomEnvironment+dispose"></a>

### roomEnvironment.dispose()
Frees internal resources. This method should be called
when the environment is no longer required.

**Kind**: instance method of [<code>RoomEnvironment</code>](#RoomEnvironment)  
<a name="DRACOExporter"></a>

## DRACOExporter
An exporter to compress geometry with the Draco library.

[Draco](https://google.github.io/draco/) is an open source library for compressing and
decompressing 3D meshes and point clouds. Compressed geometry can be significantly smaller,
at the cost of additional decoding time on the client device.

Standalone Draco files have a `.drc` extension, and contain vertex positions,
normals, colors, and other attributes. Draco files *do not* contain materials,
textures, animation, or node hierarchies – to use these features, embed Draco geometry
inside of a glTF file. A normal glTF file can be converted to a Draco-compressed glTF file
using [glTF-Pipeline](https://github.com/AnalyticalGraphicsInc/gltf-pipeline).

```js
const exporter = new DRACOExporter();
const data = exporter.parse( mesh, options );
```

**Kind**: global class  

* [DRACOExporter](#DRACOExporter)
    * _instance_
        * [.parse(object, options)](#DRACOExporter+parse) ⇒ <code>ArrayBuffer</code>
    * _static_
        * [.MESH_EDGEBREAKER_ENCODING](#DRACOExporter.MESH_EDGEBREAKER_ENCODING) : <code>number</code>
        * [.MESH_SEQUENTIAL_ENCODING](#DRACOExporter.MESH_SEQUENTIAL_ENCODING) : <code>number</code>
    * _inner_
        * [~Options](#DRACOExporter..Options) : <code>Object</code>

<a name="DRACOExporter+parse"></a>

### dracoExporter.parse(object, options) ⇒ <code>ArrayBuffer</code>
Parses the given mesh or point cloud and generates the Draco output.

**Kind**: instance method of [<code>DRACOExporter</code>](#DRACOExporter)  
**Returns**: <code>ArrayBuffer</code> - The exported Draco.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Mesh</code> \| <code>Points</code> | The mesh or point cloud to export. |
| options | [<code>Options</code>](#DRACOExporter..Options) | The export options. |

<a name="DRACOExporter.MESH_EDGEBREAKER_ENCODING"></a>

### DRACOExporter.MESH\_EDGEBREAKER\_ENCODING : <code>number</code>
Edgebreaker encoding.

**Kind**: static constant of [<code>DRACOExporter</code>](#DRACOExporter)  
**Default**: <code>1</code>  
<a name="DRACOExporter.MESH_SEQUENTIAL_ENCODING"></a>

### DRACOExporter.MESH\_SEQUENTIAL\_ENCODING : <code>number</code>
Sequential encoding.

**Kind**: static constant of [<code>DRACOExporter</code>](#DRACOExporter)  
**Default**: <code>0</code>  
<a name="DRACOExporter..Options"></a>

### DRACOExporter~Options : <code>Object</code>
Export options of `DRACOExporter`.

**Kind**: inner typedef of [<code>DRACOExporter</code>](#DRACOExporter)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [decodeSpeed] | <code>number</code> | <code>5</code> | Indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality). |
| [encodeSpeed] | <code>number</code> | <code>5</code> | Indicates how to tune the encoder parameters (0 gives better speed but worst quality). |
| [encoderMethod] | <code>number</code> | <code>1</code> | Either sequential (very little compression) or Edgebreaker. Edgebreaker traverses the triangles of the mesh in a deterministic, spiral-like way which provides most of the benefits of this data format. |
| [quantization] | <code>Array.&lt;number&gt;</code> | <code>[ 16, 8, 8, 8, 8 ]</code> | Indicates the precision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC). |
| [exportUvs] | <code>boolean</code> | <code>true</code> | Whether to export UVs or not. |
| [exportNormals] | <code>boolean</code> | <code>true</code> | Whether to export normals or not. |
| [exportColor] | <code>boolean</code> | <code>false</code> | Whether to export colors or not. |

<a name="EXRExporter"></a>

## EXRExporter
An exporter for EXR.

EXR ( Extended Dynamic Range) is an [open format specification](https://github.com/AcademySoftwareFoundation/openexr)
for professional-grade image storage format of the motion picture industry. The purpose of
format is to accurately and efficiently represent high-dynamic-range scene-linear image data
and associated metadata. The library is widely used in host application software where accuracy
is critical, such as photorealistic rendering, texture access, image compositing, deep compositing,
and DI.

```js
const exporter = new EXRExporter();
const result = await exporter.parse( renderer, options );
```

**Kind**: global class  

* [EXRExporter](#EXRExporter)
    * _instance_
        * [.parse(arg1, arg2, [arg3])](#EXRExporter+parse) ⇒ <code>Promise.&lt;Uint8Array&gt;</code>
    * _inner_
        * [~Options](#EXRExporter..Options) : <code>Object</code>

<a name="EXRExporter+parse"></a>

### exrExporter.parse(arg1, arg2, [arg3]) ⇒ <code>Promise.&lt;Uint8Array&gt;</code>
This method has two variants.

- When exporting a data texture, it receives two parameters. The texture and the exporter options.
- When exporting a render target (e.g. a PMREM), it receives three parameters. The renderer, the
render target and the exporter options.

**Kind**: instance method of [<code>EXRExporter</code>](#EXRExporter)  
**Returns**: <code>Promise.&lt;Uint8Array&gt;</code> - A Promise that resolves with the exported EXR.  

| Param | Type | Description |
| --- | --- | --- |
| arg1 | <code>DataTexture</code> \| <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The data texture to export or a renderer. |
| arg2 | [<code>Options</code>](#EXRExporter..Options) \| <code>RenderTarget</code> | The exporter options or a render target. |
| [arg3] | [<code>Options</code>](#EXRExporter..Options) | The exporter options. |

<a name="EXRExporter..Options"></a>

### EXRExporter~Options : <code>Object</code>
Export options of `EXRExporter`.

**Kind**: inner typedef of [<code>EXRExporter</code>](#EXRExporter)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [type] | <code>HalfFloatType</code> \| <code>FloatType</code> | <code>HalfFloatType</code> | Output data type. |
| [type] | <code>NO\_COMPRESSION</code> \| <code>ZIP\_COMPRESSION</code> \| <code>ZIPS\_COMPRESSION</code> | <code>ZIP_COMPRESSION</code> | The compression algorithm. |

## Classes

<dl>
<dt><a href="#GLTFExporter">GLTFExporter</a></dt>
<dd><p>An exporter for <code>glTF</code> 2.0.</p>
<p>glTF (GL Transmission Format) is an <a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0">open format specification</a>
for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf)
or binary (.glb) format. External files store textures (.jpg, .png) and additional binary
data (.bin). A glTF asset may deliver one or more scenes, including meshes, materials,
textures, skins, skeletons, morph targets, animations, lights, and/or cameras.</p>
<p>GLTFExporter supports the <a href="https://github.com/KhronosGroup/glTF/tree/master/extensions/">glTF 2.0 extensions</a>:</p>
<ul>
<li>KHR_lights_punctual</li>
<li>KHR_materials_clearcoat</li>
<li>KHR_materials_dispersion</li>
<li>KHR_materials_emissive_strength</li>
<li>KHR_materials_ior</li>
<li>KHR_materials_iridescence</li>
<li>KHR_materials_specular</li>
<li>KHR_materials_sheen</li>
<li>KHR_materials_transmission</li>
<li>KHR_materials_unlit</li>
<li>KHR_materials_volume</li>
<li>KHR_mesh_quantization</li>
<li>KHR_texture_transform</li>
<li>EXT_materials_bump</li>
<li>EXT_mesh_gpu_instancing</li>
</ul>
<p>The following glTF 2.0 extension is supported by an external user plugin:</p>
<ul>
<li><a href="https://github.com/takahirox/three-gltf-extensions">KHR_materials_variants</a></li>
</ul>
<pre><code class="language-js">const exporter = new GLTFExporter();
const data = await exporter.parseAsync( scene, options );
</code></pre>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#KHR_mesh_quantization_ExtraAttrTypes">KHR_mesh_quantization_ExtraAttrTypes</a></dt>
<dd><p>The KHR_mesh_quantization extension allows these extra attribute component types</p>
</dd>
</dl>

<a name="GLTFExporter"></a>

## GLTFExporter
An exporter for `glTF` 2.0.

glTF (GL Transmission Format) is an [open format specification](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0)
for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf)
or binary (.glb) format. External files store textures (.jpg, .png) and additional binary
data (.bin). A glTF asset may deliver one or more scenes, including meshes, materials,
textures, skins, skeletons, morph targets, animations, lights, and/or cameras.

GLTFExporter supports the [glTF 2.0 extensions](https://github.com/KhronosGroup/glTF/tree/master/extensions/):

- KHR_lights_punctual
- KHR_materials_clearcoat
- KHR_materials_dispersion
- KHR_materials_emissive_strength
- KHR_materials_ior
- KHR_materials_iridescence
- KHR_materials_specular
- KHR_materials_sheen
- KHR_materials_transmission
- KHR_materials_unlit
- KHR_materials_volume
- KHR_mesh_quantization
- KHR_texture_transform
- EXT_materials_bump
- EXT_mesh_gpu_instancing

The following glTF 2.0 extension is supported by an external user plugin:

- [KHR_materials_variants](https://github.com/takahirox/three-gltf-extensions)

```js
const exporter = new GLTFExporter();
const data = await exporter.parseAsync( scene, options );
```

**Kind**: global class  

* [GLTFExporter](#GLTFExporter)
    * [new GLTFExporter()](#new_GLTFExporter_new)
    * _instance_
        * [.textureUtils](#GLTFExporter+textureUtils) : <code>WebGLTextureUtils</code> \| <code>WebGPUTextureUtils</code>
        * [.register(callback)](#GLTFExporter+register) ⇒ [<code>GLTFExporter</code>](#GLTFExporter)
        * [.unregister(callback)](#GLTFExporter+unregister) ⇒ [<code>GLTFExporter</code>](#GLTFExporter)
        * [.setTextureUtils(utils)](#GLTFExporter+setTextureUtils) ⇒ [<code>GLTFExporter</code>](#GLTFExporter)
        * [.parse(input, onDone, onError, options)](#GLTFExporter+parse)
        * [.parseAsync(input, options)](#GLTFExporter+parseAsync) ⇒ <code>Promise.&lt;(ArrayBuffer\|string)&gt;</code>
    * _inner_
        * [~Options](#GLTFExporter..Options) : <code>Object</code>
        * [~OnDone](#GLTFExporter..OnDone) : <code>function</code>
        * [~OnError](#GLTFExporter..OnError) : <code>function</code>

<a name="new_GLTFExporter_new"></a>

### new GLTFExporter()
Constructs a new glTF exporter.

<a name="GLTFExporter+textureUtils"></a>

### gltfExporter.textureUtils : <code>WebGLTextureUtils</code> \| <code>WebGPUTextureUtils</code>
A reference to a texture utils module.

**Kind**: instance property of [<code>GLTFExporter</code>](#GLTFExporter)  
**Default**: <code>null</code>  
<a name="GLTFExporter+register"></a>

### gltfExporter.register(callback) ⇒ [<code>GLTFExporter</code>](#GLTFExporter)
Registers a plugin callback. This API is internally used to implement the various
glTF extensions but can also used by third-party code to add additional logic
to the exporter.

**Kind**: instance method of [<code>GLTFExporter</code>](#GLTFExporter)  
**Returns**: [<code>GLTFExporter</code>](#GLTFExporter) - A reference to this exporter.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The callback function to register. |

<a name="GLTFExporter+unregister"></a>

### gltfExporter.unregister(callback) ⇒ [<code>GLTFExporter</code>](#GLTFExporter)
Unregisters a plugin callback.

**Kind**: instance method of [<code>GLTFExporter</code>](#GLTFExporter)  
**Returns**: [<code>GLTFExporter</code>](#GLTFExporter) - A reference to this exporter.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The callback function to unregister. |

<a name="GLTFExporter+setTextureUtils"></a>

### gltfExporter.setTextureUtils(utils) ⇒ [<code>GLTFExporter</code>](#GLTFExporter)
Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.

Depending on whether you use [WebGLRenderer](WebGLRenderer) or [WebGPURenderer](WebGPURenderer), you must inject the
corresponding texture utils [WebGLTextureUtils](WebGLTextureUtils) or [WebGPUTextureUtils](WebGPUTextureUtils).

**Kind**: instance method of [<code>GLTFExporter</code>](#GLTFExporter)  
**Returns**: [<code>GLTFExporter</code>](#GLTFExporter) - A reference to this exporter.  

| Param | Type | Description |
| --- | --- | --- |
| utils | <code>WebGLTextureUtils</code> \| <code>WebGPUTextureUtils</code> | The texture utils. |

<a name="GLTFExporter+parse"></a>

### gltfExporter.parse(input, onDone, onError, options)
Parses the given scenes and generates the glTF output.

**Kind**: instance method of [<code>GLTFExporter</code>](#GLTFExporter)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Scene</code> \| <code>Array.&lt;Scene&gt;</code> | A scene or an array of scenes. |
| onDone | [<code>OnDone</code>](#GLTFExporter..OnDone) | A callback function that is executed when the export has finished. |
| onError | [<code>OnError</code>](#GLTFExporter..OnError) | A callback function that is executed when an error happens. |
| options | [<code>Options</code>](#GLTFExporter..Options) | options |

<a name="GLTFExporter+parseAsync"></a>

### gltfExporter.parseAsync(input, options) ⇒ <code>Promise.&lt;(ArrayBuffer\|string)&gt;</code>
Async version of [parse](#GLTFExporter+parse).

**Kind**: instance method of [<code>GLTFExporter</code>](#GLTFExporter)  
**Returns**: <code>Promise.&lt;(ArrayBuffer\|string)&gt;</code> - A Promise that resolved with the exported glTF data.  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Scene</code> \| <code>Array.&lt;Scene&gt;</code> | A scene or an array of scenes. |
| options | [<code>Options</code>](#GLTFExporter..Options) | options. |

<a name="GLTFExporter..Options"></a>

### GLTFExporter~Options : <code>Object</code>
Export options of `GLTFExporter`.

**Kind**: inner typedef of [<code>GLTFExporter</code>](#GLTFExporter)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [trs] | <code>boolean</code> | <code>false</code> | Export position, rotation and scale instead of matrix per node. |
| [onlyVisible] | <code>boolean</code> | <code>true</code> | Export only visible 3D objects. |
| [binary] | <code>boolean</code> | <code>false</code> | Export in binary (.glb) format, returning an ArrayBuffer. |
| [maxTextureSize] | <code>number</code> | <code>Infinity</code> | Restricts the image maximum size (both width and height) to the given value. |
| [animations] | <code>Array.&lt;AnimationClip&gt;</code> | <code>[]</code> | List of animations to be included in the export. |
| [includeCustomExtensions] | <code>boolean</code> | <code>false</code> | Export custom glTF extensions defined on an object's `userData.gltfExtensions` property. |

<a name="GLTFExporter..OnDone"></a>

### GLTFExporter~OnDone : <code>function</code>
onDone callback of `GLTFExporter`.

**Kind**: inner typedef of [<code>GLTFExporter</code>](#GLTFExporter)  

| Param | Type | Description |
| --- | --- | --- |
| result | <code>ArrayBuffer</code> \| <code>string</code> | The generated .gltf (JSON) or .glb (binary). |

<a name="GLTFExporter..OnError"></a>

### GLTFExporter~OnError : <code>function</code>
onError callback of `GLTFExporter`.

**Kind**: inner typedef of [<code>GLTFExporter</code>](#GLTFExporter)  

| Param | Type | Description |
| --- | --- | --- |
| error | <code>Error</code> | The error object. |

<a name="KHR_mesh_quantization_ExtraAttrTypes"></a>

## KHR\_mesh\_quantization\_ExtraAttrTypes
The KHR_mesh_quantization extension allows these extra attribute component types

**Kind**: global constant  
**See**: https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes  
## Classes

<dl>
<dt><a href="#KTX2Exporter">KTX2Exporter</a></dt>
<dd><p>An exporter for KTX2.</p>
<pre><code class="language-js">const exporter = new KTX2Exporter();
const result = await exporter.parse( dataTexture );
</code></pre>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#VK_FORMAT_MAP">VK_FORMAT_MAP</a></dt>
<dd><p>References:</p>
<ul>
<li><a href="https://github.khronos.org/KTX-Specification/ktxspec.v2.html">https://github.khronos.org/KTX-Specification/ktxspec.v2.html</a></li>
<li><a href="https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.html">https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.html</a></li>
<li><a href="https://github.com/donmccurdy/KTX-Parse">https://github.com/donmccurdy/KTX-Parse</a></li>
</ul>
</dd>
</dl>

<a name="KTX2Exporter"></a>

## KTX2Exporter
An exporter for KTX2.

```js
const exporter = new KTX2Exporter();
const result = await exporter.parse( dataTexture );
```

**Kind**: global class  
<a name="KTX2Exporter+parse"></a>

### ktX2Exporter.parse(arg1, [arg2]) ⇒ <code>Promise.&lt;Uint8Array&gt;</code>
This method has two variants.

- When exporting a data texture, it receives one parameter. The data or 3D data texture.
- When exporting a render target (e.g. a PMREM), it receives two parameters. The renderer and the
render target.

**Kind**: instance method of [<code>KTX2Exporter</code>](#KTX2Exporter)  
**Returns**: <code>Promise.&lt;Uint8Array&gt;</code> - A Promise that resolves with the exported KTX2.  

| Param | Type | Description |
| --- | --- | --- |
| arg1 | <code>DataTexture</code> \| <code>Data3DTexture</code> \| <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The data texture to export or a renderer. |
| [arg2] | <code>RenderTarget</code> | The render target that should be exported |

<a name="VK_FORMAT_MAP"></a>

## VK\_FORMAT\_MAP
References:
- https://github.khronos.org/KTX-Specification/ktxspec.v2.html
- https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.html
- https://github.com/donmccurdy/KTX-Parse

**Kind**: global constant  
<a name="OBJExporter"></a>

## OBJExporter
An exporter for OBJ.

`OBJExporter` is not able to export material data into MTL files so only geometry data are supported.

```js
const exporter = new OBJExporter();
const data = exporter.parse( scene );
```

**Kind**: global class  
<a name="OBJExporter+parse"></a>

### objExporter.parse(object) ⇒ <code>string</code>
Parses the given 3D object and generates the OBJ output.

If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.

**Kind**: instance method of [<code>OBJExporter</code>](#OBJExporter)  
**Returns**: <code>string</code> - The exported OBJ.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to export. |

<a name="PLYExporter"></a>

## PLYExporter
An exporter for PLY.

PLY (Polygon or Stanford Triangle Format) is a file format for efficient delivery and
loading of simple, static 3D content in a dense format. Both binary and ascii formats are
supported. PLY can store vertex positions, colors, normals and uv coordinates. No textures
or texture references are saved.

```js
const exporter = new PLYExporter();
const data = exporter.parse( scene, options );
```

**Kind**: global class  

* [PLYExporter](#PLYExporter)
    * _instance_
        * [.parse(object, onDone, options)](#PLYExporter+parse) ⇒ <code>string</code> \| <code>ArrayBuffer</code>
    * _inner_
        * [~Options](#PLYExporter..Options) : <code>Object</code>
        * [~OnDone](#PLYExporter..OnDone) : <code>function</code>

<a name="PLYExporter+parse"></a>

### plyExporter.parse(object, onDone, options) ⇒ <code>string</code> \| <code>ArrayBuffer</code>
Parses the given 3D object and generates the PLY output.

If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.

**Kind**: instance method of [<code>PLYExporter</code>](#PLYExporter)  
**Returns**: <code>string</code> \| <code>ArrayBuffer</code> - The exported PLY.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to export. |
| onDone | [<code>OnDone</code>](#PLYExporter..OnDone) | A callback function that is executed when the export has finished. |
| options | [<code>Options</code>](#PLYExporter..Options) | The export options. |

<a name="PLYExporter..Options"></a>

### PLYExporter~Options : <code>Object</code>
Export options of `PLYExporter`.

**Kind**: inner typedef of [<code>PLYExporter</code>](#PLYExporter)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [binary] | <code>boolean</code> | <code>false</code> | Whether to export in binary format or ASCII. |
| [excludeAttributes] | <code>Array.&lt;string&gt;</code> |  | Which properties to explicitly exclude from the exported PLY file. Valid values are `'color'`, `'normal'`, `'uv'`, and `'index'`. If triangle indices are excluded, then a point cloud is exported. |
| [littleEndian] | <code>boolean</code> | <code>false</code> | Whether the binary export uses little or big endian. |

<a name="PLYExporter..OnDone"></a>

### PLYExporter~OnDone : <code>function</code>
onDone callback of `PLYExporter`.

**Kind**: inner typedef of [<code>PLYExporter</code>](#PLYExporter)  

| Param | Type | Description |
| --- | --- | --- |
| result | <code>string</code> \| <code>ArrayBuffer</code> | The generated PLY ascii or binary. |

<a name="STLExporter"></a>

## STLExporter
An exporter for STL.

STL files describe only the surface geometry of a three-dimensional object without
any representation of color, texture or other common model attributes. The STL format
specifies both ASCII and binary representations, with binary being more compact.
STL files contain no scale information or indexes, and the units are arbitrary.

```js
const exporter = new STLExporter();
const data = exporter.parse( mesh, { binary: true } );
```

**Kind**: global class  

* [STLExporter](#STLExporter)
    * _instance_
        * [.parse(scene, options)](#STLExporter+parse) ⇒ <code>string</code> \| <code>ArrayBuffer</code>
    * _inner_
        * [~Options](#STLExporter..Options) : <code>Object</code>

<a name="STLExporter+parse"></a>

### stlExporter.parse(scene, options) ⇒ <code>string</code> \| <code>ArrayBuffer</code>
Parses the given 3D object and generates the STL output.

If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.

**Kind**: instance method of [<code>STLExporter</code>](#STLExporter)  
**Returns**: <code>string</code> \| <code>ArrayBuffer</code> - The exported STL.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene, mesh or any other 3D object containing meshes to encode. |
| options | [<code>Options</code>](#STLExporter..Options) | The export options. |

<a name="STLExporter..Options"></a>

### STLExporter~Options : <code>Object</code>
Export options of `STLExporter`.

**Kind**: inner typedef of [<code>STLExporter</code>](#STLExporter)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [binary] | <code>boolean</code> | <code>false</code> | Whether to export in binary format or ASCII. |

<a name="USDZExporter"></a>

## USDZExporter
An exporter for USDZ.

```js
const exporter = new USDZExporter();
const arraybuffer = await exporter.parseAsync( scene );
```

**Kind**: global class  

* [USDZExporter](#USDZExporter)
    * [new USDZExporter()](#new_USDZExporter_new)
    * _instance_
        * [.textureUtils](#USDZExporter+textureUtils) : <code>WebGLTextureUtils</code> \| <code>WebGPUTextureUtils</code>
        * [.setTextureUtils(utils)](#USDZExporter+setTextureUtils)
        * [.parse(scene, onDone, onError, options)](#USDZExporter+parse)
        * [.parseAsync(scene, options)](#USDZExporter+parseAsync) ⇒ <code>Promise.&lt;ArrayBuffer&gt;</code>
    * _inner_
        * [~Options](#USDZExporter..Options) : <code>Object</code>
        * [~OnDone](#USDZExporter..OnDone) : <code>function</code>
        * [~OnError](#USDZExporter..OnError) : <code>function</code>

<a name="new_USDZExporter_new"></a>

### new USDZExporter()
Constructs a new USDZ exporter.

<a name="USDZExporter+textureUtils"></a>

### usdzExporter.textureUtils : <code>WebGLTextureUtils</code> \| <code>WebGPUTextureUtils</code>
A reference to a texture utils module.

**Kind**: instance property of [<code>USDZExporter</code>](#USDZExporter)  
**Default**: <code>null</code>  
<a name="USDZExporter+setTextureUtils"></a>

### usdzExporter.setTextureUtils(utils)
Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.

Depending on whether you use [WebGLRenderer](WebGLRenderer) or [WebGPURenderer](WebGPURenderer), you must inject the
corresponding texture utils [WebGLTextureUtils](WebGLTextureUtils) or [WebGPUTextureUtils](WebGPUTextureUtils).

**Kind**: instance method of [<code>USDZExporter</code>](#USDZExporter)  

| Param | Type | Description |
| --- | --- | --- |
| utils | <code>WebGLTextureUtils</code> \| <code>WebGPUTextureUtils</code> | The texture utils. |

<a name="USDZExporter+parse"></a>

### usdzExporter.parse(scene, onDone, onError, options)
Parse the given 3D object and generates the USDZ output.

**Kind**: instance method of [<code>USDZExporter</code>](#USDZExporter)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The 3D object to export. |
| onDone | [<code>OnDone</code>](#USDZExporter..OnDone) | A callback function that is executed when the export has finished. |
| onError | [<code>OnError</code>](#USDZExporter..OnError) | A callback function that is executed when an error happens. |
| options | [<code>Options</code>](#USDZExporter..Options) | The export options. |

<a name="USDZExporter+parseAsync"></a>

### usdzExporter.parseAsync(scene, options) ⇒ <code>Promise.&lt;ArrayBuffer&gt;</code>
Async version of [parse](#USDZExporter+parse).

**Kind**: instance method of [<code>USDZExporter</code>](#USDZExporter)  
**Returns**: <code>Promise.&lt;ArrayBuffer&gt;</code> - A Promise that resolved with the exported USDZ data.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The 3D object to export. |
| options | [<code>Options</code>](#USDZExporter..Options) | The export options. |

<a name="USDZExporter..Options"></a>

### USDZExporter~Options : <code>Object</code>
Export options of `USDZExporter`.

**Kind**: inner typedef of [<code>USDZExporter</code>](#USDZExporter)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [maxTextureSize] | <code>number</code> | <code>1024</code> | The maximum texture size that is going to be exported. |
| [includeAnchoringProperties] | <code>boolean</code> | <code>false</code> | Whether to include anchoring properties or not. |
| [ar] | <code>Object</code> |  | If `includeAnchoringProperties` is set to `true`, the anchoring type and alignment can be configured via `ar.anchoring.type` and `ar.planeAnchoring.alignment`. |
| [quickLookCompatible] | <code>boolean</code> | <code>false</code> | Whether to make the exported USDZ compatible to QuickLook which means the asset is modified to accommodate the bugs FB10036297 and FB11442287 (Apple Feedback). |

<a name="USDZExporter..OnDone"></a>

### USDZExporter~OnDone : <code>function</code>
onDone callback of `USDZExporter`.

**Kind**: inner typedef of [<code>USDZExporter</code>](#USDZExporter)  

| Param | Type | Description |
| --- | --- | --- |
| result | <code>ArrayBuffer</code> | The generated USDZ. |

<a name="USDZExporter..OnError"></a>

### USDZExporter~OnError : <code>function</code>
onError callback of `USDZExporter`.

**Kind**: inner typedef of [<code>USDZExporter</code>](#USDZExporter)  

| Param | Type | Description |
| --- | --- | --- |
| error | <code>Error</code> | The error object. |

<a name="BoxLineGeometry"></a>

## BoxLineGeometry ⇐ <code>BufferGeometry</code>
A special type of box geometry intended for [LineSegments](LineSegments).

```js
const geometry = new THREE.BoxLineGeometry();
const material = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
const lines = new THREE.LineSegments( geometry, material );
scene.add( lines );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_BoxLineGeometry_new"></a>

### new BoxLineGeometry([width], [height], [depth], [widthSegments], [heightSegments], [depthSegments])
Constructs a new box line geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width. That is, the length of the edges parallel to the X axis. |
| [height] | <code>number</code> | <code>1</code> | The height. That is, the length of the edges parallel to the Y axis. |
| [depth] | <code>number</code> | <code>1</code> | The depth. That is, the length of the edges parallel to the Z axis. |
| [widthSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular sections along the width of the sides. |
| [heightSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular sections along the height of the sides. |
| [depthSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular sections along the depth of the sides. |

<a name="ConvexGeometry"></a>

## ConvexGeometry ⇐ <code>BufferGeometry</code>
This class can be used to generate a convex hull for a given array of 3D points.
The average time complexity for this task is considered to be O(nlog(n)).

```js
const geometry = new ConvexGeometry( points );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_ConvexGeometry_new"></a>

### new ConvexGeometry(points)
Constructs a new convex geometry.


| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | An array of points in 3D space which should be enclosed by the convex hull. |

<a name="DecalGeometry"></a>

## DecalGeometry ⇐ <code>BufferGeometry</code>
This class can be used to create a decal mesh that serves different kinds of purposes e.g.
adding unique details to models, performing dynamic visual environmental changes or covering seams.

Please not that decal projections can be distorted when used around corners. More information at
this GitHub issue: [Decal projections without distortions](https://github.com/mrdoob/three.js/issues/21187).

Reference: [How to project decals](http://blog.wolfire.com/2009/06/how-to-project-decals/)

```js
const geometry = new DecalGeometry( mesh, position, orientation, size );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_DecalGeometry_new"></a>

### new DecalGeometry([mesh], [position], [orientation], [size])
Constructs a new decal geometry.


| Param | Type | Description |
| --- | --- | --- |
| [mesh] | <code>Mesh</code> | The base mesh the decal should be projected on. |
| [position] | <code>Vector3</code> | The position of the decal projector. |
| [orientation] | <code>Euler</code> | The orientation of the decal projector. |
| [size] | <code>Vector3</code> | Tje scale of the decal projector. |

<a name="module_ParametricFunctions"></a>

## ParametricFunctions

* [ParametricFunctions](#module_ParametricFunctions)
    * [~klein(v, u, target)](#module_ParametricFunctions..klein)
    * [~plane(u, v, target)](#module_ParametricFunctions..plane)
    * [~mobius(u, t, target)](#module_ParametricFunctions..mobius)
    * [~mobius3d(u, t, target)](#module_ParametricFunctions..mobius3d)

<a name="module_ParametricFunctions..klein"></a>

### ParametricFunctions~klein(v, u, target)
A parametric function representing the Klein bottle.

**Kind**: inner method of [<code>ParametricFunctions</code>](#module_ParametricFunctions)  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>number</code> | The `v` coordinate on the surface in the range `[0,1]`. |
| u | <code>number</code> | The `u` coordinate on the surface in the range `[0,1]`. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="module_ParametricFunctions..plane"></a>

### ParametricFunctions~plane(u, v, target)
A parametric function representing a flat plane.

**Kind**: inner method of [<code>ParametricFunctions</code>](#module_ParametricFunctions)  

| Param | Type | Description |
| --- | --- | --- |
| u | <code>number</code> | The `u` coordinate on the surface in the range `[0,1]`. |
| v | <code>number</code> | The `v` coordinate on the surface in the range `[0,1]`. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="module_ParametricFunctions..mobius"></a>

### ParametricFunctions~mobius(u, t, target)
A parametric function representing a flat mobius strip.

**Kind**: inner method of [<code>ParametricFunctions</code>](#module_ParametricFunctions)  

| Param | Type | Description |
| --- | --- | --- |
| u | <code>number</code> | The `u` coordinate on the surface in the range `[0,1]`. |
| t | <code>number</code> | The `v` coordinate on the surface in the range `[0,1]`. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="module_ParametricFunctions..mobius3d"></a>

### ParametricFunctions~mobius3d(u, t, target)
A parametric function representing a volumetric mobius strip.

**Kind**: inner method of [<code>ParametricFunctions</code>](#module_ParametricFunctions)  

| Param | Type | Description |
| --- | --- | --- |
| u | <code>number</code> | The `u` coordinate on the surface in the range `[0,1]`. |
| t | <code>number</code> | The `v` coordinate on the surface in the range `[0,1]`. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="ParametricGeometry"></a>

## ParametricGeometry ⇐ <code>BufferGeometry</code>
This class can be used to generate a geometry based on a parametric surface.

Reference: [Mesh Generation with Python](https://prideout.net/blog/old/blog/index.html@p=44.html)

```js
const geometry = new THREE.ParametricGeometry( klein, 25, 25 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const klein = new THREE.Mesh( geometry, material );
scene.add( klein );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [ParametricGeometry](#ParametricGeometry) ⇐ <code>BufferGeometry</code>
    * [new ParametricGeometry(func, [slices], [stacks])](#new_ParametricGeometry_new)
    * _instance_
        * [.parameters](#ParametricGeometry+parameters) : <code>Object</code>
    * _inner_
        * [~Func](#ParametricGeometry..Func) : <code>function</code>

<a name="new_ParametricGeometry_new"></a>

### new ParametricGeometry(func, [slices], [stacks])
Constructs a new parametric geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| func | [<code>Func</code>](#ParametricGeometry..Func) |  | The parametric function. Default is a function that generates a curved plane surface. |
| [slices] | <code>number</code> | <code>8</code> | The number of slices to use for the parametric function. |
| [stacks] | <code>number</code> | <code>8</code> | The stacks of slices to use for the parametric function. |

<a name="ParametricGeometry+parameters"></a>

### parametricGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>ParametricGeometry</code>](#ParametricGeometry)  
<a name="ParametricGeometry..Func"></a>

### ParametricGeometry~Func : <code>function</code>
Parametric function definition of `ParametricGeometry`.

**Kind**: inner typedef of [<code>ParametricGeometry</code>](#ParametricGeometry)  

| Param | Type | Description |
| --- | --- | --- |
| u | <code>number</code> | The `u` coordinate on the surface in the range `[0,1]`. |
| v | <code>number</code> | The `v` coordinate on the surface in the range `[0,1]`. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="RoundedBoxGeometry"></a>

## RoundedBoxGeometry ⇐ <code>BoxGeometry</code>
A special type of box geometry with rounded corners and edges.

```js
const geometry = new THREE.RoundedBoxGeometry();
const material = new THREE.MeshStandardMaterial( { color: 0x00ff00 } );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
```

**Kind**: global class  
**Extends**: <code>BoxGeometry</code>  
<a name="new_RoundedBoxGeometry_new"></a>

### new RoundedBoxGeometry([width], [height], [depth], [segments], [radius])
Constructs a new rounded box geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width. That is, the length of the edges parallel to the X axis. |
| [height] | <code>number</code> | <code>1</code> | The height. That is, the length of the edges parallel to the Y axis. |
| [depth] | <code>number</code> | <code>1</code> | The depth. That is, the length of the edges parallel to the Z axis. |
| [segments] | <code>number</code> | <code>2</code> | Number of segmented that form the rounded corners. |
| [radius] | <code>number</code> | <code>0.1</code> | The radius of the rounded corners. |

<a name="TeapotGeometry"></a>

## TeapotGeometry ⇐ <code>BufferGeometry</code>
Tessellates the famous Utah teapot database by Martin Newell into triangles.

The teapot should normally be rendered as a double sided object, since for some
patches both sides can be seen, e.g., the gap around the lid and inside the spout.

Segments 'n' determines the number of triangles output. Total triangles = 32*2*n*n - 8*n
(degenerates at the top and bottom cusps are deleted).

Code based on [SPD software](http://tog.acm.org/resources/SPD/)
Created for the Udacity course [Interactive Rendering](http://bit.ly/ericity)

```js
const geometry = new TeapotGeometry( 50, 18 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const teapot = new THREE.Mesh( geometry, material );
scene.add( teapot );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_TeapotGeometry_new"></a>

### new TeapotGeometry([size], [segments], [bottom], [lid], [body], [fitLid], [blinn])
Constructs a new teapot geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>50</code> | Relative scale of the teapot. |
| [segments] | <code>number</code> | <code>10</code> | Number of line segments to subdivide each patch edge. |
| [bottom] | <code>boolean</code> | <code>true</code> | Whether the bottom of the teapot is generated or not. |
| [lid] | <code>boolean</code> | <code>true</code> | Whether the lid is generated or not. |
| [body] | <code>boolean</code> | <code>true</code> | Whether the body is generated or not. |
| [fitLid] | <code>boolean</code> | <code>true</code> | Whether the lid is slightly stretched to prevent gaps between the body and lid or not. |
| [blinn] | <code>boolean</code> | <code>true</code> | Whether the teapot is scaled vertically for better aesthetics or not. |

<a name="TextGeometry"></a>

## TextGeometry ⇐ <code>ExtrudeGeometry</code>
A class for generating text as a single geometry. It is constructed by providing a string of text, and a set of
parameters consisting of a loaded font and extrude settings.

See the [FontLoader](FontLoader) page for additional details.

`TextGeometry` uses [typeface.json](http://gero3.github.io/facetype.js/) generated fonts.
Some existing fonts can be found located in `/examples/fonts`.

```js
const loader = new FontLoader();
const font = await loader.loadAsync( 'fonts/helvetiker_regular.typeface.json' );
const geometry = new TextGeometry( 'Hello three.js!', {
	font: font,
	size: 80,
	depth: 5,
	curveSegments: 12
} );
```

**Kind**: global class  
**Extends**: <code>ExtrudeGeometry</code>  

* [TextGeometry](#TextGeometry) ⇐ <code>ExtrudeGeometry</code>
    * [new TextGeometry(text, [parameters])](#new_TextGeometry_new)
    * [~Options](#TextGeometry..Options) : <code>Object</code>

<a name="new_TextGeometry_new"></a>

### new TextGeometry(text, [parameters])
Constructs a new text geometry.


| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The text that should be transformed into a geometry. |
| [parameters] | [<code>Options</code>](#TextGeometry..Options) | The text settings. |

<a name="TextGeometry..Options"></a>

### TextGeometry~Options : <code>Object</code>
Represents the `options` type of the geometry's constructor.

**Kind**: inner typedef of [<code>TextGeometry</code>](#TextGeometry)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [font] | <code>Font</code> |  | The font. |
| [size] | <code>number</code> | <code>100</code> | The text size. |
| [depth] | <code>number</code> | <code>50</code> | Depth to extrude the shape. |
| [curveSegments] | <code>number</code> | <code>12</code> | Number of points on the curves. |
| [steps] | <code>number</code> | <code>1</code> | Number of points used for subdividing segments along the depth of the extruded spline. |
| [bevelEnabled] | <code>boolean</code> | <code>false</code> | Whether to beveling to the shape or not. |
| [bevelThickness] | <code>number</code> | <code>10</code> | How deep into the original shape the bevel goes. |
| [bevelSize] | <code>number</code> | <code>8</code> | Distance from the shape outline that the bevel extends. |
| [bevelOffset] | <code>number</code> | <code>0</code> | Distance from the shape outline that the bevel starts. |
| [bevelSegments] | <code>number</code> | <code>3</code> | Number of bevel layers. |
| [extrudePath] | <code>Curve</code> | <code></code> | A 3D spline path along which the shape should be extruded. Bevels not supported for path extrusion. |
| [UVGenerator] | <code>Object</code> |  | An object that provides UV generator functions for custom UV generation. |

<a name="LightProbeHelper"></a>

## LightProbeHelper ⇐ <code>Mesh</code>
Renders a sphere to visualize a light probe in the scene.

This helper can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), import from `LightProbeHelperGPU.js`.

```js
const helper = new LightProbeHelper( lightProbe );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [LightProbeHelper](#LightProbeHelper) ⇐ <code>Mesh</code>
    * [new LightProbeHelper(lightProbe, [size])](#new_LightProbeHelper_new)
    * [.lightProbe](#LightProbeHelper+lightProbe) : <code>LightProbe</code>
    * [.size](#LightProbeHelper+size) : <code>number</code>
    * [.dispose()](#LightProbeHelper+dispose)

<a name="new_LightProbeHelper_new"></a>

### new LightProbeHelper(lightProbe, [size])
Constructs a new light probe helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| lightProbe | <code>LightProbe</code> |  | The light probe to visualize. |
| [size] | <code>number</code> | <code>1</code> | The size of the helper. |

<a name="LightProbeHelper+lightProbe"></a>

### lightProbeHelper.lightProbe : <code>LightProbe</code>
The light probe to visualize.

**Kind**: instance property of [<code>LightProbeHelper</code>](#LightProbeHelper)  
<a name="LightProbeHelper+size"></a>

### lightProbeHelper.size : <code>number</code>
The size of the helper.

**Kind**: instance property of [<code>LightProbeHelper</code>](#LightProbeHelper)  
**Default**: <code>1</code>  
<a name="LightProbeHelper+dispose"></a>

### lightProbeHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>LightProbeHelper</code>](#LightProbeHelper)  
<a name="OctreeHelper"></a>

## OctreeHelper ⇐ <code>LineSegments</code>
A helper for visualizing an Octree.

```js
const helper = new OctreeHelper( octree );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [OctreeHelper](#OctreeHelper) ⇐ <code>LineSegments</code>
    * [new OctreeHelper(octree, [color])](#new_OctreeHelper_new)
    * [.octree](#OctreeHelper+octree) : <code>Octree</code>
    * [.color](#OctreeHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.update()](#OctreeHelper+update)
    * [.dispose()](#OctreeHelper+dispose)

<a name="new_OctreeHelper_new"></a>

### new OctreeHelper(octree, [color])
Constructs a new Octree helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| octree | <code>Octree</code> |  | The octree to visualize. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | The helper's color. |

<a name="OctreeHelper+octree"></a>

### octreeHelper.octree : <code>Octree</code>
The octree to visualize.

**Kind**: instance property of [<code>OctreeHelper</code>](#OctreeHelper)  
<a name="OctreeHelper+color"></a>

### octreeHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The helper's color.

**Kind**: instance property of [<code>OctreeHelper</code>](#OctreeHelper)  
<a name="OctreeHelper+update"></a>

### octreeHelper.update()
Updates the helper. This method must be called whenever the Octree's
structure is changed.

**Kind**: instance method of [<code>OctreeHelper</code>](#OctreeHelper)  
<a name="OctreeHelper+dispose"></a>

### octreeHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>OctreeHelper</code>](#OctreeHelper)  
<a name="PositionalAudioHelper"></a>

## PositionalAudioHelper ⇐ <code>Line</code>
This helper displays the directional cone of a positional audio.

`PositionalAudioHelper` must be added as a child of the positional audio.

```js
const positionalAudio = new THREE.PositionalAudio( listener );
positionalAudio.setDirectionalCone( 180, 230, 0.1 );
scene.add( positionalAudio );

const helper = new PositionalAudioHelper( positionalAudio );
positionalAudio.add( helper );
```

**Kind**: global class  
**Extends**: <code>Line</code>  

* [PositionalAudioHelper](#PositionalAudioHelper) ⇐ <code>Line</code>
    * [new PositionalAudioHelper(audio, [range], [divisionsInnerAngle], [divisionsOuterAngle])](#new_PositionalAudioHelper_new)
    * [.audio](#PositionalAudioHelper+audio) : <code>PositionalAudio</code>
    * [.range](#PositionalAudioHelper+range) : <code>number</code>
    * [.divisionsInnerAngle](#PositionalAudioHelper+divisionsInnerAngle) : <code>number</code>
    * [.divisionsOuterAngle](#PositionalAudioHelper+divisionsOuterAngle) : <code>number</code>
    * [.update()](#PositionalAudioHelper+update)
    * [.dispose()](#PositionalAudioHelper+dispose)

<a name="new_PositionalAudioHelper_new"></a>

### new PositionalAudioHelper(audio, [range], [divisionsInnerAngle], [divisionsOuterAngle])
Constructs a new positional audio helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| audio | <code>PositionalAudio</code> |  | The audio to visualize. |
| [range] | <code>number</code> | <code>1</code> | The range of the directional cone. |
| [divisionsInnerAngle] | <code>number</code> | <code>16</code> | The number of divisions of the inner part of the directional cone. |
| [divisionsOuterAngle] | <code>number</code> | <code>2</code> | The number of divisions of the outer part of the directional cone. |

<a name="PositionalAudioHelper+audio"></a>

### positionalAudioHelper.audio : <code>PositionalAudio</code>
The audio to visualize.

**Kind**: instance property of [<code>PositionalAudioHelper</code>](#PositionalAudioHelper)  
<a name="PositionalAudioHelper+range"></a>

### positionalAudioHelper.range : <code>number</code>
The range of the directional cone.

**Kind**: instance property of [<code>PositionalAudioHelper</code>](#PositionalAudioHelper)  
**Default**: <code>1</code>  
<a name="PositionalAudioHelper+divisionsInnerAngle"></a>

### positionalAudioHelper.divisionsInnerAngle : <code>number</code>
The number of divisions of the inner part of the directional cone.

**Kind**: instance property of [<code>PositionalAudioHelper</code>](#PositionalAudioHelper)  
**Default**: <code>16</code>  
<a name="PositionalAudioHelper+divisionsOuterAngle"></a>

### positionalAudioHelper.divisionsOuterAngle : <code>number</code>
The number of divisions of the outer part of the directional cone.

**Kind**: instance property of [<code>PositionalAudioHelper</code>](#PositionalAudioHelper)  
**Default**: <code>2</code>  
<a name="PositionalAudioHelper+update"></a>

### positionalAudioHelper.update()
Updates the helper. This method must be called whenever the directional cone
of the positional audio is changed.

**Kind**: instance method of [<code>PositionalAudioHelper</code>](#PositionalAudioHelper)  
<a name="PositionalAudioHelper+dispose"></a>

### positionalAudioHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>PositionalAudioHelper</code>](#PositionalAudioHelper)  
<a name="RectAreaLightHelper"></a>

## RectAreaLightHelper ⇐ <code>Line</code>
Creates a visual aid for rect area lights.

`RectAreaLightHelper` must be added as a child of the light.

```js
const light = new THREE.RectAreaLight( 0xffffbb, 1.0, 5, 5 );
const helper = new RectAreaLightHelper( light );
light.add( helper );
```

**Kind**: global class  
**Extends**: <code>Line</code>  

* [RectAreaLightHelper](#RectAreaLightHelper) ⇐ <code>Line</code>
    * [new RectAreaLightHelper(light, [color])](#new_RectAreaLightHelper_new)
    * [.light](#RectAreaLightHelper+light) : <code>RectAreaLight</code>
    * [.color](#RectAreaLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code> \| <code>undefined</code>
    * [.dispose()](#RectAreaLightHelper+dispose)

<a name="new_RectAreaLightHelper_new"></a>

### new RectAreaLightHelper(light, [color])
Constructs a new rect area light helper.


| Param | Type | Description |
| --- | --- | --- |
| light | <code>RectAreaLight</code> | The light to visualize. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | The helper's color. If this is not the set, the helper will take the color of the light. |

<a name="RectAreaLightHelper+light"></a>

### rectAreaLightHelper.light : <code>RectAreaLight</code>
The light to visualize.

**Kind**: instance property of [<code>RectAreaLightHelper</code>](#RectAreaLightHelper)  
<a name="RectAreaLightHelper+color"></a>

### rectAreaLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code> \| <code>undefined</code>
The helper's color. If `undefined`, the helper will take the color of the light.

**Kind**: instance property of [<code>RectAreaLightHelper</code>](#RectAreaLightHelper)  
<a name="RectAreaLightHelper+dispose"></a>

### rectAreaLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>RectAreaLightHelper</code>](#RectAreaLightHelper)  
<a name="TextureHelper"></a>

## TextureHelper ⇐ <code>Mesh</code>
A helper that can be used to display any type of texture for
debugging purposes. Depending on the type of texture (2D, 3D, Array),
the helper becomes a plane or box mesh.

This helper can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), import from `TextureHelperGPU.js`.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [TextureHelper](#TextureHelper) ⇐ <code>Mesh</code>
    * [new TextureHelper(texture, [width], [height], [depth])](#new_TextureHelper_new)
    * [.texture](#TextureHelper+texture) : <code>Texture</code>
    * [.dispose()](#TextureHelper+dispose)

<a name="new_TextureHelper_new"></a>

### new TextureHelper(texture, [width], [height], [depth])
Constructs a new texture helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture to visualize. |
| [width] | <code>number</code> | <code>1</code> | The helper's width. |
| [height] | <code>number</code> | <code>1</code> | The helper's height. |
| [depth] | <code>number</code> | <code>1</code> | The helper's depth. |

<a name="TextureHelper+texture"></a>

### textureHelper.texture : <code>Texture</code>
The texture to visualize.

**Kind**: instance property of [<code>TextureHelper</code>](#TextureHelper)  
<a name="TextureHelper+dispose"></a>

### textureHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>TextureHelper</code>](#TextureHelper)  
<a name="VertexNormalsHelper"></a>

## VertexNormalsHelper ⇐ <code>LineSegments</code>
Visualizes an object's vertex normals.

Requires that normals have been specified in the geometry as a buffer attribute or
have been calculated using [BufferGeometry#computeVertexNormals](BufferGeometry#computeVertexNormals).
```js
const geometry = new THREE.BoxGeometry( 10, 10, 10, 2, 2, 2 );
const material = new THREE.MeshStandardMaterial();
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );

const helper = new VertexNormalsHelper( mesh, 1, 0xff0000 );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [VertexNormalsHelper](#VertexNormalsHelper) ⇐ <code>LineSegments</code>
    * [new VertexNormalsHelper(object, [size], [color])](#new_VertexNormalsHelper_new)
    * [.object](#VertexNormalsHelper+object) : <code>Object3D</code>
    * [.size](#VertexNormalsHelper+size) : <code>number</code>
    * [.matrixAutoUpdate](#VertexNormalsHelper+matrixAutoUpdate) : <code>boolean</code>
    * [.isVertexNormalsHelper](#VertexNormalsHelper+isVertexNormalsHelper) : <code>boolean</code>
    * [.update()](#VertexNormalsHelper+update)
    * [.dispose()](#VertexNormalsHelper+dispose)

<a name="new_VertexNormalsHelper_new"></a>

### new VertexNormalsHelper(object, [size], [color])
Constructs a new vertex normals helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The object for which to visualize vertex normals. |
| [size] | <code>number</code> | <code>1</code> | The helper's size. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xff0000</code> | The helper's color. |

<a name="VertexNormalsHelper+object"></a>

### vertexNormalsHelper.object : <code>Object3D</code>
The object for which to visualize vertex normals.

**Kind**: instance property of [<code>VertexNormalsHelper</code>](#VertexNormalsHelper)  
<a name="VertexNormalsHelper+size"></a>

### vertexNormalsHelper.size : <code>number</code>
The helper's size.

**Kind**: instance property of [<code>VertexNormalsHelper</code>](#VertexNormalsHelper)  
**Default**: <code>1</code>  
<a name="VertexNormalsHelper+matrixAutoUpdate"></a>

### vertexNormalsHelper.matrixAutoUpdate : <code>boolean</code>
Overwritten and set to `false` since the object's world transformation
is encoded in the helper's geometry data.

**Kind**: instance property of [<code>VertexNormalsHelper</code>](#VertexNormalsHelper)  
**Default**: <code>false</code>  
<a name="VertexNormalsHelper+isVertexNormalsHelper"></a>

### vertexNormalsHelper.isVertexNormalsHelper : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VertexNormalsHelper</code>](#VertexNormalsHelper)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VertexNormalsHelper+update"></a>

### vertexNormalsHelper.update()
Updates the vertex normals preview based on the object's world transform.

**Kind**: instance method of [<code>VertexNormalsHelper</code>](#VertexNormalsHelper)  
<a name="VertexNormalsHelper+dispose"></a>

### vertexNormalsHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>VertexNormalsHelper</code>](#VertexNormalsHelper)  
<a name="VertexTangentsHelper"></a>

## VertexTangentsHelper ⇐ <code>LineSegments</code>
Visualizes an object's vertex tangents.

Requires that tangents have been specified in the geometry as a buffer attribute or
have been calculated using [BufferGeometry#computeTangents](BufferGeometry#computeTangents).
```js
const helper = new VertexTangentsHelper( mesh, 1, 0xff0000 );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [VertexTangentsHelper](#VertexTangentsHelper) ⇐ <code>LineSegments</code>
    * [new VertexTangentsHelper(object, [size], [color])](#new_VertexTangentsHelper_new)
    * [.object](#VertexTangentsHelper+object) : <code>Object3D</code>
    * [.size](#VertexTangentsHelper+size) : <code>number</code>
    * [.matrixAutoUpdate](#VertexTangentsHelper+matrixAutoUpdate) : <code>boolean</code>
    * [.update()](#VertexTangentsHelper+update)
    * [.dispose()](#VertexTangentsHelper+dispose)

<a name="new_VertexTangentsHelper_new"></a>

### new VertexTangentsHelper(object, [size], [color])
Constructs a new vertex tangents helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The object for which to visualize vertex tangents. |
| [size] | <code>number</code> | <code>1</code> | The helper's size. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xff0000</code> | The helper's color. |

<a name="VertexTangentsHelper+object"></a>

### vertexTangentsHelper.object : <code>Object3D</code>
The object for which to visualize vertex tangents.

**Kind**: instance property of [<code>VertexTangentsHelper</code>](#VertexTangentsHelper)  
<a name="VertexTangentsHelper+size"></a>

### vertexTangentsHelper.size : <code>number</code>
The helper's size.

**Kind**: instance property of [<code>VertexTangentsHelper</code>](#VertexTangentsHelper)  
**Default**: <code>1</code>  
<a name="VertexTangentsHelper+matrixAutoUpdate"></a>

### vertexTangentsHelper.matrixAutoUpdate : <code>boolean</code>
Overwritten and set to `false` since the object's world transformation
is encoded in the helper's geometry data.

**Kind**: instance property of [<code>VertexTangentsHelper</code>](#VertexTangentsHelper)  
**Default**: <code>false</code>  
<a name="VertexTangentsHelper+update"></a>

### vertexTangentsHelper.update()
Updates the vertex normals preview based on the object's world transform.

**Kind**: instance method of [<code>VertexTangentsHelper</code>](#VertexTangentsHelper)  
<a name="VertexTangentsHelper+dispose"></a>

### vertexTangentsHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>VertexTangentsHelper</code>](#VertexTangentsHelper)  
<a name="ViewHelper"></a>

## ViewHelper ⇐ <code>Object3D</code>
A special type of helper that visualizes the camera's transformation
in a small viewport area as an axes helper. Such a helper is often wanted
in 3D modeling tools or scene editors like the [three.js editor](https://threejs.org/editor).

The helper allows to click on the X, Y and Z axes which animates the camera
so it looks along the selected axis.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [ViewHelper](#ViewHelper) ⇐ <code>Object3D</code>
    * [new ViewHelper(camera, [domElement])](#new_ViewHelper_new)
    * [.isViewHelper](#ViewHelper+isViewHelper) : <code>boolean</code>
    * [.animating](#ViewHelper+animating) : <code>boolean</code>
    * [.center](#ViewHelper+center) : <code>Vector3</code>
    * [.render(renderer)](#ViewHelper+render)
    * [.handleClick(event)](#ViewHelper+handleClick) ⇒ <code>boolean</code>
    * [.setLabels(labelX, labelY, labelZ)](#ViewHelper+setLabels)
    * [.setLabelStyle([font], [color], [radius])](#ViewHelper+setLabelStyle)
    * [.update(delta)](#ViewHelper+update)
    * [.dispose()](#ViewHelper+dispose)

<a name="new_ViewHelper_new"></a>

### new ViewHelper(camera, [domElement])
Constructs a new view helper.


| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera whose transformation should be visualized. |
| [domElement] | <code>HTMLDOMElement</code> | The DOM element that is used to render the view. |

<a name="ViewHelper+isViewHelper"></a>

### viewHelper.isViewHelper : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ViewHelper</code>](#ViewHelper)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ViewHelper+animating"></a>

### viewHelper.animating : <code>boolean</code>
Whether the helper is currently animating or not.

**Kind**: instance property of [<code>ViewHelper</code>](#ViewHelper)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="ViewHelper+center"></a>

### viewHelper.center : <code>Vector3</code>
The helper's center point.

**Kind**: instance property of [<code>ViewHelper</code>](#ViewHelper)  
<a name="ViewHelper+render"></a>

### viewHelper.render(renderer)
Renders the helper in a separate view in the bottom-right corner
of the viewport.

**Kind**: instance method of [<code>ViewHelper</code>](#ViewHelper)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> \| <code>WebGPURenderer</code> | The renderer. |

<a name="ViewHelper+handleClick"></a>

### viewHelper.handleClick(event) ⇒ <code>boolean</code>
This method should be called when a click or pointer event
has happened in the app.

**Kind**: instance method of [<code>ViewHelper</code>](#ViewHelper)  
**Returns**: <code>boolean</code> - Whether an intersection with the helper has been detected or not.  

| Param | Type | Description |
| --- | --- | --- |
| event | <code>PointerEvent</code> | The event to process. |

<a name="ViewHelper+setLabels"></a>

### viewHelper.setLabels(labelX, labelY, labelZ)
Sets labels for each axis. By default, they are unlabeled.

**Kind**: instance method of [<code>ViewHelper</code>](#ViewHelper)  

| Param | Type | Description |
| --- | --- | --- |
| labelX | <code>string</code> \| <code>undefined</code> | The label for the x-axis. |
| labelY | <code>string</code> \| <code>undefined</code> | The label for the y-axis. |
| labelZ | <code>string</code> \| <code>undefined</code> | The label for the z-axis. |

<a name="ViewHelper+setLabelStyle"></a>

### viewHelper.setLabelStyle([font], [color], [radius])
Sets the label style. Has no effect when the axes are unlabeled.

**Kind**: instance method of [<code>ViewHelper</code>](#ViewHelper)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [font] | <code>string</code> | <code>&quot;&#x27;24px Arial&#x27;&quot;</code> | The label font. |
| [color] | <code>string</code> | <code>&quot;&#x27;#000000&#x27;&quot;</code> | The label color. |
| [radius] | <code>number</code> | <code>14</code> | The label radius. |

<a name="ViewHelper+update"></a>

### viewHelper.update(delta)
Updates the helper. This method should be called in the app's animation
loop.

**Kind**: instance method of [<code>ViewHelper</code>](#ViewHelper)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="ViewHelper+dispose"></a>

### viewHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>ViewHelper</code>](#ViewHelper)  
<a name="HTMLMesh"></a>

## HTMLMesh ⇐ <code>Mesh</code>
This class can be used to render a DOM element onto a canvas and use it as a texture
for a plane mesh.

A typical use case for this class is to render the GUI of `lil-gui` as a texture so it
is compatible for VR.

```js
const gui = new GUI( { width: 300 } ); // create lil-gui instance

const mesh = new HTMLMesh( gui.domElement );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [HTMLMesh](#HTMLMesh) ⇐ <code>Mesh</code>
    * [new HTMLMesh(dom)](#new_HTMLMesh_new)
    * [.dispose()](#HTMLMesh+dispose)

<a name="new_HTMLMesh_new"></a>

### new HTMLMesh(dom)
Constructs a new HTML mesh.


| Param | Type | Description |
| --- | --- | --- |
| dom | <code>HTMLElement</code> | The DOM element to display as a plane mesh. |

<a name="HTMLMesh+dispose"></a>

### htmlMesh.dispose()
Frees the GPU-related resources allocated by this instance and removes all event listeners.
Call this method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>HTMLMesh</code>](#HTMLMesh)  
<a name="InteractiveGroup"></a>

## InteractiveGroup ⇐ <code>Group</code>
This class can be used to group 3D objects in an interactive group.
The group itself can listen to Pointer, Mouse or XR controller events to
detect selections of descendant 3D objects. If a 3D object is selected,
the respective event is going to dispatched to it.

```js
const group = new InteractiveGroup();
group.listenToPointerEvents( renderer, camera );
group.listenToXRControllerEvents( controller1 );
group.listenToXRControllerEvents( controller2 );
scene.add( group );

// now add objects that should be interactive
group.add( mesh1, mesh2, mesh3 );
```

**Kind**: global class  
**Extends**: <code>Group</code>  

* [InteractiveGroup](#InteractiveGroup) ⇐ <code>Group</code>
    * [.raycaster](#InteractiveGroup+raycaster) : <code>Raycaster</code>
    * [.element](#InteractiveGroup+element) : <code>HTMLDOMElement</code>
    * [.camera](#InteractiveGroup+camera) : <code>Camera</code>
    * [.controllers](#InteractiveGroup+controllers) : <code>Array.&lt;Group&gt;</code>
    * [.listenToPointerEvents(renderer, camera)](#InteractiveGroup+listenToPointerEvents)
    * [.disconnectionPointerEvents()](#InteractiveGroup+disconnectionPointerEvents)
    * [.listenToXRControllerEvents(controller)](#InteractiveGroup+listenToXRControllerEvents)
    * [.disconnectXrControllerEvents()](#InteractiveGroup+disconnectXrControllerEvents)
    * [.disconnect()](#InteractiveGroup+disconnect)

<a name="InteractiveGroup+raycaster"></a>

### interactiveGroup.raycaster : <code>Raycaster</code>
The internal raycaster.

**Kind**: instance property of [<code>InteractiveGroup</code>](#InteractiveGroup)  
<a name="InteractiveGroup+element"></a>

### interactiveGroup.element : <code>HTMLDOMElement</code>
The internal raycaster.

**Kind**: instance property of [<code>InteractiveGroup</code>](#InteractiveGroup)  
**Default**: <code>null</code>  
<a name="InteractiveGroup+camera"></a>

### interactiveGroup.camera : <code>Camera</code>
The camera used for raycasting.

**Kind**: instance property of [<code>InteractiveGroup</code>](#InteractiveGroup)  
**Default**: <code>null</code>  
<a name="InteractiveGroup+controllers"></a>

### interactiveGroup.controllers : <code>Array.&lt;Group&gt;</code>
An array of XR controllers.

**Kind**: instance property of [<code>InteractiveGroup</code>](#InteractiveGroup)  
<a name="InteractiveGroup+listenToPointerEvents"></a>

### interactiveGroup.listenToPointerEvents(renderer, camera)
Calling this method makes sure the interactive group listens to Pointer and Mouse events.
The target is the `domElement` of the given renderer. The camera is required for the internal
raycasting so 3D objects can be detected based on the events.

**Kind**: instance method of [<code>InteractiveGroup</code>](#InteractiveGroup)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The renderer. |
| camera | <code>Camera</code> | The camera. |

<a name="InteractiveGroup+disconnectionPointerEvents"></a>

### interactiveGroup.disconnectionPointerEvents()
Disconnects this interactive group from all Pointer and Mouse Events.

**Kind**: instance method of [<code>InteractiveGroup</code>](#InteractiveGroup)  
<a name="InteractiveGroup+listenToXRControllerEvents"></a>

### interactiveGroup.listenToXRControllerEvents(controller)
Calling this method makes sure the interactive group listens to events of
the given XR controller.

**Kind**: instance method of [<code>InteractiveGroup</code>](#InteractiveGroup)  

| Param | Type | Description |
| --- | --- | --- |
| controller | <code>Group</code> | The XR controller. |

<a name="InteractiveGroup+disconnectXrControllerEvents"></a>

### interactiveGroup.disconnectXrControllerEvents()
Disconnects this interactive group from all XR controllers.

**Kind**: instance method of [<code>InteractiveGroup</code>](#InteractiveGroup)  
<a name="InteractiveGroup+disconnect"></a>

### interactiveGroup.disconnect()
Disconnects this interactive group from the DOM and all XR controllers.

**Kind**: instance method of [<code>InteractiveGroup</code>](#InteractiveGroup)  
<a name="SelectionBox"></a>

## SelectionBox
This class can be used to select 3D objects in a scene with a selection box.
It is recommended to visualize the selected area with the help of [SelectionHelper](SelectionHelper).

```js
const selectionBox = new SelectionBox( camera, scene );
const selectedObjects = selectionBox.select( startPoint, endPoint );
```

**Kind**: global class  

* [SelectionBox](#SelectionBox)
    * [new SelectionBox(camera, scene, [deep])](#new_SelectionBox_new)
    * [.camera](#SelectionBox+camera) : <code>Camera</code>
    * [.scene](#SelectionBox+scene) : <code>Scene</code>
    * [.startPoint](#SelectionBox+startPoint) : <code>Vector3</code>
    * [.endPoint](#SelectionBox+endPoint) : <code>Vector3</code>
    * [.collection](#SelectionBox+collection) : <code>Array.&lt;Object3D&gt;</code>
    * [.instances](#SelectionBox+instances) : <code>Object</code>
    * [.deep](#SelectionBox+deep) : <code>number</code>
    * [.select([startPoint], [endPoint])](#SelectionBox+select) ⇒ <code>Array.&lt;Object3D&gt;</code>

<a name="new_SelectionBox_new"></a>

### new SelectionBox(camera, scene, [deep])
Constructs a new selection box.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>Camera</code> |  | The camera the scene is rendered with. |
| scene | <code>Scene</code> |  | The scene. |
| [deep] | <code>number</code> | <code>Number.MAX_VALUE</code> | How deep the selection frustum of perspective cameras should extend. |

<a name="SelectionBox+camera"></a>

### selectionBox.camera : <code>Camera</code>
The camera the scene is rendered with.

**Kind**: instance property of [<code>SelectionBox</code>](#SelectionBox)  
<a name="SelectionBox+scene"></a>

### selectionBox.scene : <code>Scene</code>
The camera the scene is rendered with.

**Kind**: instance property of [<code>SelectionBox</code>](#SelectionBox)  
<a name="SelectionBox+startPoint"></a>

### selectionBox.startPoint : <code>Vector3</code>
The start point of the selection.

**Kind**: instance property of [<code>SelectionBox</code>](#SelectionBox)  
<a name="SelectionBox+endPoint"></a>

### selectionBox.endPoint : <code>Vector3</code>
The end point of the selection.

**Kind**: instance property of [<code>SelectionBox</code>](#SelectionBox)  
<a name="SelectionBox+collection"></a>

### selectionBox.collection : <code>Array.&lt;Object3D&gt;</code>
The selected 3D objects.

**Kind**: instance property of [<code>SelectionBox</code>](#SelectionBox)  
<a name="SelectionBox+instances"></a>

### selectionBox.instances : <code>Object</code>
The selected instance IDs of instanced meshes.

**Kind**: instance property of [<code>SelectionBox</code>](#SelectionBox)  
<a name="SelectionBox+deep"></a>

### selectionBox.deep : <code>number</code>
How deep the selection frustum of perspective cameras should extend.

**Kind**: instance property of [<code>SelectionBox</code>](#SelectionBox)  
**Default**: <code>Number.MAX_VALUE</code>  
<a name="SelectionBox+select"></a>

### selectionBox.select([startPoint], [endPoint]) ⇒ <code>Array.&lt;Object3D&gt;</code>
This method selects 3D objects in the scene based on the given start
and end point. If no parameters are provided, the method uses the start
and end values of the respective members.

**Kind**: instance method of [<code>SelectionBox</code>](#SelectionBox)  
**Returns**: <code>Array.&lt;Object3D&gt;</code> - The selected 3D objects.  

| Param | Type | Description |
| --- | --- | --- |
| [startPoint] | <code>Vector3</code> | The start point. |
| [endPoint] | <code>Vector3</code> | The end point. |

<a name="SelectionHelper"></a>

## SelectionHelper
A helper for [SelectionBox](SelectionBox).

It visualizes the current selection box with a `div` container element.

**Kind**: global class  

* [SelectionHelper](#SelectionHelper)
    * [new SelectionHelper(renderer, cssClassName)](#new_SelectionHelper_new)
    * [.element](#SelectionHelper+element) : <code>HTMLDivElement</code>
    * [.renderer](#SelectionHelper+renderer) : <code>WebGPURenderer</code> \| <code>WebGLRenderer</code>
    * [.isDown](#SelectionHelper+isDown) : <code>boolean</code>
    * [.enabled](#SelectionHelper+enabled) : <code>boolean</code>
    * [.dispose()](#SelectionHelper+dispose)

<a name="new_SelectionHelper_new"></a>

### new SelectionHelper(renderer, cssClassName)
Constructs a new selection helper.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The renderer. |
| cssClassName | <code>string</code> | The CSS class name of the `div`. |

<a name="SelectionHelper+element"></a>

### selectionHelper.element : <code>HTMLDivElement</code>
The visualization of the selection box.

**Kind**: instance property of [<code>SelectionHelper</code>](#SelectionHelper)  
<a name="SelectionHelper+renderer"></a>

### selectionHelper.renderer : <code>WebGPURenderer</code> \| <code>WebGLRenderer</code>
A reference to the renderer.

**Kind**: instance property of [<code>SelectionHelper</code>](#SelectionHelper)  
<a name="SelectionHelper+isDown"></a>

### selectionHelper.isDown : <code>boolean</code>
Whether the mouse or pointer is pressed down.

**Kind**: instance property of [<code>SelectionHelper</code>](#SelectionHelper)  
**Default**: <code>false</code>  
<a name="SelectionHelper+enabled"></a>

### selectionHelper.enabled : <code>boolean</code>
Whether helper is enabled or not.

**Kind**: instance property of [<code>SelectionHelper</code>](#SelectionHelper)  
**Default**: <code>true</code>  
<a name="SelectionHelper+dispose"></a>

### selectionHelper.dispose()
Call this method if you no longer want use to the controls. It frees all internal
resources and removes all event listeners.

**Kind**: instance method of [<code>SelectionHelper</code>](#SelectionHelper)  
<a name="LightProbeGenerator"></a>

## LightProbeGenerator
Utility class for creating instances of [LightProbe](LightProbe).

**Kind**: global class  

* [LightProbeGenerator](#LightProbeGenerator)
    * [.fromCubeTexture(cubeTexture)](#LightProbeGenerator.fromCubeTexture) ⇒ <code>LightProbe</code>
    * [.fromCubeRenderTarget(renderer, cubeRenderTarget)](#LightProbeGenerator.fromCubeRenderTarget) ⇒ <code>Promise.&lt;LightProbe&gt;</code>

<a name="LightProbeGenerator.fromCubeTexture"></a>

### LightProbeGenerator.fromCubeTexture(cubeTexture) ⇒ <code>LightProbe</code>
Creates a light probe from the given (radiance) environment map.
The method expects that the environment map is represented as a cube texture.

**Kind**: static method of [<code>LightProbeGenerator</code>](#LightProbeGenerator)  
**Returns**: <code>LightProbe</code> - The created light probe.  

| Param | Type | Description |
| --- | --- | --- |
| cubeTexture | <code>CubeTexture</code> | The environment map. |

<a name="LightProbeGenerator.fromCubeRenderTarget"></a>

### LightProbeGenerator.fromCubeRenderTarget(renderer, cubeRenderTarget) ⇒ <code>Promise.&lt;LightProbe&gt;</code>
Creates a light probe from the given (radiance) environment map.
The method expects that the environment map is represented as a cube render target.

The cube render target must be in RGBA so `cubeRenderTarget.texture.format` must be
set to [RGBAFormat](RGBAFormat).

**Kind**: static method of [<code>LightProbeGenerator</code>](#LightProbeGenerator)  
**Returns**: <code>Promise.&lt;LightProbe&gt;</code> - A Promise that resolves with the created light probe.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The renderer. |
| cubeRenderTarget | <code>CubeRenderTarget</code> \| <code>WebGLCubeRenderTarget</code> | The environment map. |

<a name="RectAreaLightTexturesLib"></a>

## RectAreaLightTexturesLib
Texture library for [RectAreaLight](RectAreaLight). This class holds the LTC BRDF data
in data textures for further use in the renderer.

Reference: Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt. [Code](https://github.com/selfshadow/ltc_code/).

NOTE: This is a temporary location for the BRDF approximation texture data
based off of Eric Heitz's work (see citation). BRDF data for
`RectAreaLight` is currently approximated using a precomputed texture
of roughly 80kb in size. The hope is to find a better way to include
the large texture data before including the full RectAreaLight implementation
in the main build files.

**Kind**: global class  

* [RectAreaLightTexturesLib](#RectAreaLightTexturesLib)
    * [.LTC_HALF_1](#RectAreaLightTexturesLib.LTC_HALF_1) : <code>DataTexture</code>
    * [.LTC_HALF_2](#RectAreaLightTexturesLib.LTC_HALF_2) : <code>DataTexture</code>
    * [.LTC_FLOAT_1](#RectAreaLightTexturesLib.LTC_FLOAT_1) : <code>DataTexture</code>
    * [.LTC_FLOAT_2](#RectAreaLightTexturesLib.LTC_FLOAT_2) : <code>DataTexture</code>
    * [.init()](#RectAreaLightTexturesLib.init) ⇒ [<code>RectAreaLightTexturesLib</code>](#RectAreaLightTexturesLib)

<a name="RectAreaLightTexturesLib.LTC_HALF_1"></a>

### RectAreaLightTexturesLib.LTC\_HALF\_1 : <code>DataTexture</code>
The first LTC FP16 data texture.

**Kind**: static property of [<code>RectAreaLightTexturesLib</code>](#RectAreaLightTexturesLib)  
**Default**: <code>null</code>  
<a name="RectAreaLightTexturesLib.LTC_HALF_2"></a>

### RectAreaLightTexturesLib.LTC\_HALF\_2 : <code>DataTexture</code>
The second LTC FP16 data texture.

**Kind**: static property of [<code>RectAreaLightTexturesLib</code>](#RectAreaLightTexturesLib)  
**Default**: <code>null</code>  
<a name="RectAreaLightTexturesLib.LTC_FLOAT_1"></a>

### RectAreaLightTexturesLib.LTC\_FLOAT\_1 : <code>DataTexture</code>
The first LTC FP32 data texture.

**Kind**: static property of [<code>RectAreaLightTexturesLib</code>](#RectAreaLightTexturesLib)  
**Default**: <code>null</code>  
<a name="RectAreaLightTexturesLib.LTC_FLOAT_2"></a>

### RectAreaLightTexturesLib.LTC\_FLOAT\_2 : <code>DataTexture</code>
The second LTC FP32 data texture.

**Kind**: static property of [<code>RectAreaLightTexturesLib</code>](#RectAreaLightTexturesLib)  
**Default**: <code>null</code>  
<a name="RectAreaLightTexturesLib.init"></a>

### RectAreaLightTexturesLib.init() ⇒ [<code>RectAreaLightTexturesLib</code>](#RectAreaLightTexturesLib)
Inits the texture library.

**Kind**: static method of [<code>RectAreaLightTexturesLib</code>](#RectAreaLightTexturesLib)  
<a name="RectAreaLightUniformsLib"></a>

## RectAreaLightUniformsLib
This class is only relevant when using [RectAreaLight](RectAreaLight) with [WebGLRenderer](WebGLRenderer).

Before rect area lights can be used, the internal uniform library of the renderer must be
enhanced with the following code.

```js
RectAreaLightUniformsLib.init();
```

**Kind**: global class  
<a name="RectAreaLightUniformsLib.init"></a>

### RectAreaLightUniformsLib.init()
Inits the uniform library required when using rect area lights.

**Kind**: static method of [<code>RectAreaLightUniformsLib</code>](#RectAreaLightUniformsLib)  
<a name="Line2"></a>

## Line2 ⇐ <code>LineSegments2</code>
A polyline drawn between vertices.

This adds functionality beyond [Line](Line), like arbitrary line width and changing width to
be in world units.It extends [LineSegments2](LineSegments2), simplifying constructing segments from a
chain of points.

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the class from `lines/webgpu/Line2.js`.

```js
const geometry = new LineGeometry();
geometry.setPositions( positions );
geometry.setColors( colors );

const material = new LineMaterial( { linewidth: 5, vertexColors: true } };

const line = new Line2( geometry, material );
scene.add( line );
```

**Kind**: global class  
**Extends**: <code>LineSegments2</code>  

* [Line2](#Line2) ⇐ <code>LineSegments2</code>
    * [new Line2([geometry], [material])](#new_Line2_new)
    * [.isLine2](#Line2+isLine2) : <code>boolean</code>

<a name="new_Line2_new"></a>

### new Line2([geometry], [material])
Constructs a new wide line.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>LineGeometry</code> | The line geometry. |
| [material] | <code>LineMaterial</code> | The line material. |

<a name="Line2+isLine2"></a>

### line2.isLine2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Line2</code>](#Line2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineGeometry"></a>

## LineGeometry ⇐ <code>LineSegmentsGeometry</code>
A chain of vertices, forming a polyline.

This is used in [Line2](Line2) to describe the shape.

```js
const points = [
	new THREE.Vector3( - 10, 0, 0 ),
	new THREE.Vector3( 0, 5, 0 ),
	new THREE.Vector3( 10, 0, 0 ),
];

const geometry = new LineGeometry();
geometry.setFromPoints( points );
```

**Kind**: global class  
**Extends**: <code>LineSegmentsGeometry</code>  

* [LineGeometry](#LineGeometry) ⇐ <code>LineSegmentsGeometry</code>
    * [new LineGeometry()](#new_LineGeometry_new)
    * [.isLineGeometry](#LineGeometry+isLineGeometry) : <code>boolean</code>
    * [.setPositions(array)](#LineGeometry+setPositions) ⇒ [<code>LineGeometry</code>](#LineGeometry)
    * [.setColors(array)](#LineGeometry+setColors) ⇒ [<code>LineGeometry</code>](#LineGeometry)
    * [.setFromPoints(points)](#LineGeometry+setFromPoints) ⇒ [<code>LineGeometry</code>](#LineGeometry)
    * [.fromLine(line)](#LineGeometry+fromLine) ⇒ [<code>LineGeometry</code>](#LineGeometry)

<a name="new_LineGeometry_new"></a>

### new LineGeometry()
Constructs a new line geometry.

<a name="LineGeometry+isLineGeometry"></a>

### lineGeometry.isLineGeometry : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineGeometry</code>](#LineGeometry)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineGeometry+setPositions"></a>

### lineGeometry.setPositions(array) ⇒ [<code>LineGeometry</code>](#LineGeometry)
Sets the given line positions for this geometry.

**Kind**: instance method of [<code>LineGeometry</code>](#LineGeometry)  
**Returns**: [<code>LineGeometry</code>](#LineGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Float32Array</code> \| <code>Array.&lt;number&gt;</code> | The position data to set. |

<a name="LineGeometry+setColors"></a>

### lineGeometry.setColors(array) ⇒ [<code>LineGeometry</code>](#LineGeometry)
Sets the given line colors for this geometry.

**Kind**: instance method of [<code>LineGeometry</code>](#LineGeometry)  
**Returns**: [<code>LineGeometry</code>](#LineGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Float32Array</code> \| <code>Array.&lt;number&gt;</code> | The position data to set. |

<a name="LineGeometry+setFromPoints"></a>

### lineGeometry.setFromPoints(points) ⇒ [<code>LineGeometry</code>](#LineGeometry)
Setups this line segments geometry from the given sequence of points.

**Kind**: instance method of [<code>LineGeometry</code>](#LineGeometry)  
**Returns**: [<code>LineGeometry</code>](#LineGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;(Vector3\|Vector2)&gt;</code> | An array of points in 2D or 3D space. |

<a name="LineGeometry+fromLine"></a>

### lineGeometry.fromLine(line) ⇒ [<code>LineGeometry</code>](#LineGeometry)
Setups this line segments geometry from the given line.

**Kind**: instance method of [<code>LineGeometry</code>](#LineGeometry)  
**Returns**: [<code>LineGeometry</code>](#LineGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| line | <code>Line</code> | The line that should be used as a data source for this geometry. |

<a name="LineMaterial"></a>

## LineMaterial ⇐ <code>ShaderMaterial</code>
A material for drawing wireframe-style geometries.

Unlike [LineBasicMaterial](LineBasicMaterial), it supports arbitrary line widths and allows using world units
instead of screen space units. This material is used with [LineSegments2](LineSegments2) and [Line2](Line2).

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
use [Line2NodeMaterial](Line2NodeMaterial).

**Kind**: global class  
**Extends**: <code>ShaderMaterial</code>  

* [LineMaterial](#LineMaterial) ⇐ <code>ShaderMaterial</code>
    * [new LineMaterial([parameters])](#new_LineMaterial_new)
    * [.isLineMaterial](#LineMaterial+isLineMaterial) : <code>boolean</code>
    * [.color](#LineMaterial+color) : <code>Color</code>
    * [.worldUnits](#LineMaterial+worldUnits) : <code>boolean</code>
    * [.linewidth](#LineMaterial+linewidth) : <code>number</code>
    * [.dashed](#LineMaterial+dashed) : <code>boolean</code>
    * [.dashScale](#LineMaterial+dashScale) : <code>number</code>
    * [.dashSize](#LineMaterial+dashSize) : <code>number</code>
    * [.dashOffset](#LineMaterial+dashOffset) : <code>number</code>
    * [.gapSize](#LineMaterial+gapSize) : <code>number</code>
    * [.opacity](#LineMaterial+opacity) : <code>number</code>
    * [.resolution](#LineMaterial+resolution) : <code>Vector2</code>
    * [.alphaToCoverage](#LineMaterial+alphaToCoverage) : <code>boolean</code>

<a name="new_LineMaterial_new"></a>

### new LineMaterial([parameters])
Constructs a new line segments geometry.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="LineMaterial+isLineMaterial"></a>

### lineMaterial.isLineMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineMaterial+color"></a>

### lineMaterial.color : <code>Color</code>
The material's color.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="LineMaterial+worldUnits"></a>

### lineMaterial.worldUnits : <code>boolean</code>
Whether the material's sizes (width, dash gaps) are in world units.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>false</code>  
<a name="LineMaterial+linewidth"></a>

### lineMaterial.linewidth : <code>number</code>
Controls line thickness in CSS pixel units when `worldUnits` is `false` (default),
or in world units when `worldUnits` is `true`.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>1</code>  
<a name="LineMaterial+dashed"></a>

### lineMaterial.dashed : <code>boolean</code>
Whether the line is dashed, or solid.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>false</code>  
<a name="LineMaterial+dashScale"></a>

### lineMaterial.dashScale : <code>number</code>
The scale of the dashes and gaps.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>1</code>  
<a name="LineMaterial+dashSize"></a>

### lineMaterial.dashSize : <code>number</code>
The size of the dash.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>1</code>  
<a name="LineMaterial+dashOffset"></a>

### lineMaterial.dashOffset : <code>number</code>
Where in the dash cycle the dash starts.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>0</code>  
<a name="LineMaterial+gapSize"></a>

### lineMaterial.gapSize : <code>number</code>
The size of the gap.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>0</code>  
<a name="LineMaterial+opacity"></a>

### lineMaterial.opacity : <code>number</code>
The opacity.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
**Default**: <code>1</code>  
<a name="LineMaterial+resolution"></a>

### lineMaterial.resolution : <code>Vector2</code>
The size of the viewport, in screen pixels. This must be kept updated to make
screen-space rendering accurate.The `LineSegments2.onBeforeRender` callback
performs the update for visible objects.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
<a name="LineMaterial+alphaToCoverage"></a>

### lineMaterial.alphaToCoverage : <code>boolean</code>
Whether to use alphaToCoverage or not. When enabled, this can improve the
anti-aliasing of line edges when using MSAA.

**Kind**: instance property of [<code>LineMaterial</code>](#LineMaterial)  
<a name="LineSegments2"></a>

## LineSegments2 ⇐ <code>Mesh</code>
A series of lines drawn between pairs of vertices.

This adds functionality beyond [LineSegments](LineSegments), like arbitrary line width and changing width
to be in world units. [Line2](Line2) extends this object, forming a polyline instead of individual
segments.

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the class from `lines/webgpu/LineSegments2.js`.

 ```js
const geometry = new LineSegmentsGeometry();
geometry.setPositions( positions );
geometry.setColors( colors );

const material = new LineMaterial( { linewidth: 5, vertexColors: true } };

const lineSegments = new LineSegments2( geometry, material );
scene.add( lineSegments );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [LineSegments2](#LineSegments2) ⇐ <code>Mesh</code>
    * [new LineSegments2([geometry], [material])](#new_LineSegments2_new)
    * [.isLineSegments2](#LineSegments2+isLineSegments2) : <code>boolean</code>
    * [.computeLineDistances()](#LineSegments2+computeLineDistances) ⇒ [<code>LineSegments2</code>](#LineSegments2)
    * [.raycast(raycaster, intersects)](#LineSegments2+raycast)

<a name="new_LineSegments2_new"></a>

### new LineSegments2([geometry], [material])
Constructs a new wide line.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>LineSegmentsGeometry</code> | The line geometry. |
| [material] | <code>LineMaterial</code> | The line material. |

<a name="LineSegments2+isLineSegments2"></a>

### lineSegments2.isLineSegments2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineSegments2</code>](#LineSegments2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineSegments2+computeLineDistances"></a>

### lineSegments2.computeLineDistances() ⇒ [<code>LineSegments2</code>](#LineSegments2)
Computes an array of distance values which are necessary for rendering dashed lines.
For each vertex in the geometry, the method calculates the cumulative length from the
current point to the very beginning of the line.

**Kind**: instance method of [<code>LineSegments2</code>](#LineSegments2)  
**Returns**: [<code>LineSegments2</code>](#LineSegments2) - A reference to this instance.  
<a name="LineSegments2+raycast"></a>

### lineSegments2.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this instance.

**Kind**: instance method of [<code>LineSegments2</code>](#LineSegments2)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="LineSegmentsGeometry"></a>

## LineSegmentsGeometry ⇐ <code>InstancedBufferGeometry</code>
A series of vertex pairs, forming line segments.

This is used in [LineSegments2](LineSegments2) to describe the shape.

**Kind**: global class  
**Extends**: <code>InstancedBufferGeometry</code>  

* [LineSegmentsGeometry](#LineSegmentsGeometry) ⇐ <code>InstancedBufferGeometry</code>
    * [new LineSegmentsGeometry()](#new_LineSegmentsGeometry_new)
    * [.isLineSegmentsGeometry](#LineSegmentsGeometry+isLineSegmentsGeometry) : <code>boolean</code>
    * [.applyMatrix4(matrix)](#LineSegmentsGeometry+applyMatrix4) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
    * [.setPositions(array)](#LineSegmentsGeometry+setPositions) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
    * [.setColors(array)](#LineSegmentsGeometry+setColors) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
    * [.fromWireframeGeometry(geometry)](#LineSegmentsGeometry+fromWireframeGeometry) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
    * [.fromEdgesGeometry(geometry)](#LineSegmentsGeometry+fromEdgesGeometry) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
    * [.fromMesh(mesh)](#LineSegmentsGeometry+fromMesh) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
    * [.fromLineSegments(lineSegments)](#LineSegmentsGeometry+fromLineSegments) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)

<a name="new_LineSegmentsGeometry_new"></a>

### new LineSegmentsGeometry()
Constructs a new line segments geometry.

<a name="LineSegmentsGeometry+isLineSegmentsGeometry"></a>

### lineSegmentsGeometry.isLineSegmentsGeometry : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineSegmentsGeometry+applyMatrix4"></a>

### lineSegmentsGeometry.applyMatrix4(matrix) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
Applies the given 4x4 transformation matrix to the geometry.

**Kind**: instance method of [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)  
**Returns**: [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The matrix to apply. |

<a name="LineSegmentsGeometry+setPositions"></a>

### lineSegmentsGeometry.setPositions(array) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
Sets the given line positions for this geometry. The length must be a multiple of six since
each line segment is defined by a start end vertex in the pattern `(xyz xyz)`.

**Kind**: instance method of [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)  
**Returns**: [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Float32Array</code> \| <code>Array.&lt;number&gt;</code> | The position data to set. |

<a name="LineSegmentsGeometry+setColors"></a>

### lineSegmentsGeometry.setColors(array) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
Sets the given line colors for this geometry. The length must be a multiple of six since
each line segment is defined by a start end color in the pattern `(rgb rgb)`.

**Kind**: instance method of [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)  
**Returns**: [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Float32Array</code> \| <code>Array.&lt;number&gt;</code> | The position data to set. |

<a name="LineSegmentsGeometry+fromWireframeGeometry"></a>

### lineSegmentsGeometry.fromWireframeGeometry(geometry) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
Setups this line segments geometry from the given wireframe geometry.

**Kind**: instance method of [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)  
**Returns**: [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>WireframeGeometry</code> | The geometry that should be used as a data source for this geometry. |

<a name="LineSegmentsGeometry+fromEdgesGeometry"></a>

### lineSegmentsGeometry.fromEdgesGeometry(geometry) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
Setups this line segments geometry from the given edges geometry.

**Kind**: instance method of [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)  
**Returns**: [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>EdgesGeometry</code> | The geometry that should be used as a data source for this geometry. |

<a name="LineSegmentsGeometry+fromMesh"></a>

### lineSegmentsGeometry.fromMesh(mesh) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
Setups this line segments geometry from the given mesh.

**Kind**: instance method of [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)  
**Returns**: [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The mesh geometry that should be used as a data source for this geometry. |

<a name="LineSegmentsGeometry+fromLineSegments"></a>

### lineSegmentsGeometry.fromLineSegments(lineSegments) ⇒ [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)
Setups this line segments geometry from the given line segments.

**Kind**: instance method of [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry)  
**Returns**: [<code>LineSegmentsGeometry</code>](#LineSegmentsGeometry) - A reference to this geometry.  

| Param | Type | Description |
| --- | --- | --- |
| lineSegments | <code>LineSegments</code> | The line segments that should be used as a data source for this geometry. Assumes the source geometry is not using indices. |

<a name="Wireframe"></a>

## Wireframe ⇐ <code>Mesh</code>
A class for creating wireframes based on wide lines.

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the class from `lines/webgpu/Wireframe.js`.

```js
const geometry = new THREE.IcosahedronGeometry();
const wireframeGeometry = new WireframeGeometry2( geo );

const wireframe = new Wireframe( wireframeGeometry, material );
scene.add( wireframe );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Wireframe](#Wireframe) ⇐ <code>Mesh</code>
    * [new Wireframe([geometry], [material])](#new_Wireframe_new)
    * [.isWireframe](#Wireframe+isWireframe) : <code>boolean</code>
    * [.computeLineDistances()](#Wireframe+computeLineDistances) ⇒ [<code>Wireframe</code>](#Wireframe)

<a name="new_Wireframe_new"></a>

### new Wireframe([geometry], [material])
Constructs a new wireframe.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>LineSegmentsGeometry</code> | The line geometry. |
| [material] | <code>LineMaterial</code> | The line material. |

<a name="Wireframe+isWireframe"></a>

### wireframe.isWireframe : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Wireframe</code>](#Wireframe)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Wireframe+computeLineDistances"></a>

### wireframe.computeLineDistances() ⇒ [<code>Wireframe</code>](#Wireframe)
Computes an array of distance values which are necessary for rendering dashed lines.
For each vertex in the geometry, the method calculates the cumulative length from the
current point to the very beginning of the line.

**Kind**: instance method of [<code>Wireframe</code>](#Wireframe)  
**Returns**: [<code>Wireframe</code>](#Wireframe) - A reference to this instance.  
<a name="WireframeGeometry2"></a>

## WireframeGeometry2 ⇐ <code>LineSegmentsGeometry</code>
A special type of line segments geometry intended for wireframe rendering.

This is used in [Wireframe](Wireframe) to describe the shape.

```js
const geometry = new THREE.IcosahedronGeometry();
const wireframeGeometry = new WireframeGeometry2( geo );
```

**Kind**: global class  
**Extends**: <code>LineSegmentsGeometry</code>  

* [WireframeGeometry2](#WireframeGeometry2) ⇐ <code>LineSegmentsGeometry</code>
    * [new WireframeGeometry2([geometry])](#new_WireframeGeometry2_new)
    * [.isWireframeGeometry2](#WireframeGeometry2+isWireframeGeometry2) : <code>boolean</code>

<a name="new_WireframeGeometry2_new"></a>

### new WireframeGeometry2([geometry])
Constructs a new wireframe geometry.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The geometry to render the wireframe for. |

<a name="WireframeGeometry2+isWireframeGeometry2"></a>

### wireframeGeometry2.isWireframeGeometry2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WireframeGeometry2</code>](#WireframeGeometry2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Rhino3dmLoader"></a>

## Rhino3dmLoader ⇐ <code>Loader</code>
A loader for Rhinoceros 3D files and objects.

Rhinoceros is a 3D modeler used to create, edit, analyze, document, render,
animate, and translate NURBS curves, surfaces, breps, extrusions, point clouds,
as well as polygon meshes and SubD objects. `rhino3dm.js` is compiled to WebAssembly
from the open source geometry library `openNURBS`. The loader currently uses
`rhino3dm.js 8.4.0`.

```js
const loader = new Rhino3dmLoader();
loader.setLibraryPath( 'https://cdn.jsdelivr.net/npm/rhino3dm@8.0.1' );

const object = await loader.loadAsync( 'models/3dm/Rhino_Logo.3dm' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [Rhino3dmLoader](#Rhino3dmLoader) ⇐ <code>Loader</code>
    * [new Rhino3dmLoader([manager])](#new_Rhino3dmLoader_new)
    * [.setLibraryPath(path)](#Rhino3dmLoader+setLibraryPath) ⇒ [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)
    * [.setWorkerLimit(workerLimit)](#Rhino3dmLoader+setWorkerLimit) ⇒ [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)
    * [.load(url, onLoad, onProgress, onError)](#Rhino3dmLoader+load)
    * [.debug()](#Rhino3dmLoader+debug)
    * [.decodeObjects(buffer, url)](#Rhino3dmLoader+decodeObjects) ⇒ <code>Promise.&lt;Object3D&gt;</code>
    * [.parse(data, onLoad, onError)](#Rhino3dmLoader+parse)
    * [.dispose()](#Rhino3dmLoader+dispose)

<a name="new_Rhino3dmLoader_new"></a>

### new Rhino3dmLoader([manager])
Constructs a new Rhino 3DM loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="Rhino3dmLoader+setLibraryPath"></a>

### rhino3dmLoader.setLibraryPath(path) ⇒ [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)
Path to a folder containing the JS and WASM libraries.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
**Returns**: [<code>Rhino3dmLoader</code>](#Rhino3dmLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The library path to set. |

<a name="Rhino3dmLoader+setWorkerLimit"></a>

### rhino3dmLoader.setWorkerLimit(workerLimit) ⇒ [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)
Sets the maximum number of Web Workers to be used during decoding.
A lower limit may be preferable if workers are also for other
tasks in the application.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
**Returns**: [<code>Rhino3dmLoader</code>](#Rhino3dmLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| workerLimit | <code>number</code> | The worker limit. |

<a name="Rhino3dmLoader+load"></a>

### rhino3dmLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded 3DM asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="Rhino3dmLoader+debug"></a>

### rhino3dmLoader.debug()
Prints debug messages to the browser console.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
<a name="Rhino3dmLoader+decodeObjects"></a>

### rhino3dmLoader.decodeObjects(buffer, url) ⇒ <code>Promise.&lt;Object3D&gt;</code>
Decodes the 3DM asset data with a Web Worker.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
**Returns**: <code>Promise.&lt;Object3D&gt;</code> - A Promise that resolved with the decoded 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw 3DM asset data as an array buffer. |
| url | <code>string</code> | The asset URL. |

<a name="Rhino3dmLoader+parse"></a>

### rhino3dmLoader.parse(data, onLoad, onError)
Parses the given 3DM data and passes the loaded 3DM asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw 3DM asset data as an array buffer. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="Rhino3dmLoader+dispose"></a>

### rhino3dmLoader.dispose()
Frees internal resources. This method should be called
when the loader is no longer required.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
<a name="ThreeMFLoader"></a>

## ThreeMFLoader ⇐ <code>Loader</code>
A loader for the [3D Manufacturing Format (3MF)](https://3mf.io/specification/) format.

The following features from the core specification are supported:

- 3D Models
- Object Resources (Meshes and Components)
- Material Resources (Base Materials)

3MF Materials and Properties Extension are only partially supported.

- Texture 2D
- Texture 2D Groups
- Color Groups (Vertex Colors)
- Metallic Display Properties (PBR)

```js
const loader = new ThreeMFLoader();

const object = await loader.loadAsync( './models/3mf/truck.3mf' );
object.rotation.set( - Math.PI / 2, 0, 0 ); // z-up conversion
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ThreeMFLoader](#ThreeMFLoader) ⇐ <code>Loader</code>
    * [new ThreeMFLoader([manager])](#new_ThreeMFLoader_new)
    * [.availableExtensions](#ThreeMFLoader+availableExtensions) : <code>Array.&lt;Object&gt;</code>
    * [.load(url, onLoad, onProgress, onError)](#ThreeMFLoader+load)
    * [.parse(data)](#ThreeMFLoader+parse) ⇒ <code>Group</code>
    * [.addExtension(extension)](#ThreeMFLoader+addExtension)

<a name="new_ThreeMFLoader_new"></a>

### new ThreeMFLoader([manager])
Constructs a new 3MF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="ThreeMFLoader+availableExtensions"></a>

### threeMFLoader.availableExtensions : <code>Array.&lt;Object&gt;</code>
An array of available extensions.

**Kind**: instance property of [<code>ThreeMFLoader</code>](#ThreeMFLoader)  
<a name="ThreeMFLoader+load"></a>

### threeMFLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded 3MF asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>ThreeMFLoader</code>](#ThreeMFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="ThreeMFLoader+parse"></a>

### threeMFLoader.parse(data) ⇒ <code>Group</code>
Parses the given 3MF data and returns the resulting group.

**Kind**: instance method of [<code>ThreeMFLoader</code>](#ThreeMFLoader)  
**Returns**: <code>Group</code> - A group representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw 3MF asset data as an array buffer. |

<a name="ThreeMFLoader+addExtension"></a>

### threeMFLoader.addExtension(extension)
Adds a 3MF extension.

**Kind**: instance method of [<code>ThreeMFLoader</code>](#ThreeMFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| extension | <code>Object</code> | The extension to add. |

<a name="AMFLoader"></a>

## AMFLoader ⇐ <code>Loader</code>
A loader for the AMF format.

The loader supports materials, color and ZIP compressed files.
No constellation support (yet).

```js
const loader = new AMFLoader();

const object = await loader.loadAsync( './models/amf/rook.amf' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [AMFLoader](#AMFLoader) ⇐ <code>Loader</code>
    * [new AMFLoader([manager])](#new_AMFLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#AMFLoader+load)
    * [.parse(data)](#AMFLoader+parse) ⇒ <code>Group</code>

<a name="new_AMFLoader_new"></a>

### new AMFLoader([manager])
Constructs a new AMF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="AMFLoader+load"></a>

### amfLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded AMF asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>AMFLoader</code>](#AMFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="AMFLoader+parse"></a>

### amfLoader.parse(data) ⇒ <code>Group</code>
Parses the given AMF data and returns the resulting group.

**Kind**: instance method of [<code>AMFLoader</code>](#AMFLoader)  
**Returns**: <code>Group</code> - A group representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw AMF asset data as an array buffer. |

<a name="BVHLoader"></a>

## BVHLoader ⇐ <code>Loader</code>
A loader for the BVH format.

Imports BVH files and outputs a single [Skeleton](Skeleton) and [AnimationClip](AnimationClip).
The loader only supports BVH files containing a single root right now.

```js
const loader = new BVHLoader();
const result = await loader.loadAsync( 'models/bvh/pirouette.bvh' );

// visualize skeleton
const skeletonHelper = new THREE.SkeletonHelper( result.skeleton.bones[ 0 ] );
scene.add( result.skeleton.bones[ 0 ] );
scene.add( skeletonHelper );

// play animation clip
mixer = new THREE.AnimationMixer( result.skeleton.bones[ 0 ] );
mixer.clipAction( result.clip ).play();
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [BVHLoader](#BVHLoader) ⇐ <code>Loader</code>
    * [new BVHLoader([manager])](#new_BVHLoader_new)
    * [.animateBonePositions](#BVHLoader+animateBonePositions) : <code>boolean</code>
    * [.animateBoneRotations](#BVHLoader+animateBoneRotations) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#BVHLoader+load)
    * [.parse(text)](#BVHLoader+parse) ⇒ <code>Object</code>

<a name="new_BVHLoader_new"></a>

### new BVHLoader([manager])
Constructs a new BVH loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="BVHLoader+animateBonePositions"></a>

### bvhLoader.animateBonePositions : <code>boolean</code>
Whether to animate bone positions or not.

**Kind**: instance property of [<code>BVHLoader</code>](#BVHLoader)  
**Default**: <code>true</code>  
<a name="BVHLoader+animateBoneRotations"></a>

### bvhLoader.animateBoneRotations : <code>boolean</code>
Whether to animate bone rotations or not.

**Kind**: instance property of [<code>BVHLoader</code>](#BVHLoader)  
**Default**: <code>true</code>  
<a name="BVHLoader+load"></a>

### bvhLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded BVH asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>BVHLoader</code>](#BVHLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="BVHLoader+parse"></a>

### bvhLoader.parse(text) ⇒ <code>Object</code>
Parses the given BVH data and returns the resulting data.

**Kind**: instance method of [<code>BVHLoader</code>](#BVHLoader)  
**Returns**: <code>Object</code> - An object representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw BVH data as a string. |

<a name="ColladaLoader"></a>

## ColladaLoader ⇐ <code>Loader</code>
A loader for the Collada format.

The Collada format is very complex so this loader only supports a subset of what
is defined in the [official specification](https://www.khronos.org/files/collada_spec_1_5.pdf).

Assets with a Z-UP coordinate system are transformed it into Y-UP by a simple rotation.
The vertex data are not converted.

```js
const loader = new ColladaLoader();

const result = await loader.loadAsync( './models/collada/elf/elf.dae' );
scene.add( result.scene );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ColladaLoader](#ColladaLoader) ⇐ <code>Loader</code>
    * [.load(url, onLoad, onProgress, onError)](#ColladaLoader+load)
    * [.parse(text, path)](#ColladaLoader+parse) ⇒ <code>Object</code>

<a name="ColladaLoader+load"></a>

### colladaLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded Collada asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>ColladaLoader</code>](#ColladaLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="ColladaLoader+parse"></a>

### colladaLoader.parse(text, path) ⇒ <code>Object</code>
Parses the given Collada data and returns a result oject holding the parsed scene,
an array of animation clips and kinematics.

**Kind**: instance method of [<code>ColladaLoader</code>](#ColladaLoader)  
**Returns**: <code>Object</code> - An object representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw Collada data as a string. |
| path | <code>string</code> | The asset path. |

<a name="DDSLoader"></a>

## DDSLoader ⇐ <code>CompressedTextureLoader</code>
A loader for the S3TC texture compression format.

```js
const loader = new DDSLoader();

const map = loader.load( 'textures/compressed/disturb_dxt1_nomip.dds' );
map.colorSpace = THREE.SRGBColorSpace; // only for color textures
```

**Kind**: global class  
**Extends**: <code>CompressedTextureLoader</code>  

* [DDSLoader](#DDSLoader) ⇐ <code>CompressedTextureLoader</code>
    * [new DDSLoader([manager])](#new_DDSLoader_new)
    * [.parse(buffer, loadMipmaps)](#DDSLoader+parse) ⇒ <code>CompressedTextureLoader~TexData</code>

<a name="new_DDSLoader_new"></a>

### new DDSLoader([manager])
Constructs a new DDS loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="DDSLoader+parse"></a>

### ddsLoader.parse(buffer, loadMipmaps) ⇒ <code>CompressedTextureLoader~TexData</code>
Parses the given S3TC texture data.

**Kind**: instance method of [<code>DDSLoader</code>](#DDSLoader)  
**Returns**: <code>CompressedTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |
| loadMipmaps | <code>boolean</code> | Whether to load mipmaps or not. |

<a name="DRACOLoader"></a>

## DRACOLoader ⇐ <code>Loader</code>
A loader for the Draco format.

[Draco](https://google.github.io/draco/) is an open source library for compressing
and decompressing 3D meshes and point clouds. Compressed geometry can be significantly smaller,
at the cost of additional decoding time on the client device.

Standalone Draco files have a `.drc` extension, and contain vertex positions, normals, colors,
and other attributes. Draco files do not contain materials, textures, animation, or node hierarchies –
to use these features, embed Draco geometry inside of a glTF file. A normal glTF file can be converted
to a Draco-compressed glTF file using [glTF-Pipeline](https://github.com/CesiumGS/gltf-pipeline).
When using Draco with glTF, an instance of `DRACOLoader` will be used internally by [GLTFLoader](GLTFLoader).

It is recommended to create one DRACOLoader instance and reuse it to avoid loading and creating
multiple decoder instances.

`DRACOLoader` will automatically use either the JS or the WASM decoding library, based on
browser capabilities.

```js
const loader = new DRACOLoader();
loader.setDecoderPath( '/examples/jsm/libs/draco/' );

const geometry = await dracoLoader.loadAsync( 'models/draco/bunny.drc' );
geometry.computeVertexNormals(); // optional

dracoLoader.dispose();
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [DRACOLoader](#DRACOLoader) ⇐ <code>Loader</code>
    * [new DRACOLoader([manager])](#new_DRACOLoader_new)
    * [.setDecoderPath(path)](#DRACOLoader+setDecoderPath) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
    * [.setDecoderConfig(config)](#DRACOLoader+setDecoderConfig) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
    * [.setWorkerLimit(workerLimit)](#DRACOLoader+setWorkerLimit) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
    * [.load(url, onLoad, onProgress, onError)](#DRACOLoader+load)
    * [.parse(buffer, onLoad, onError)](#DRACOLoader+parse)

<a name="new_DRACOLoader_new"></a>

### new DRACOLoader([manager])
Constructs a new Draco loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="DRACOLoader+setDecoderPath"></a>

### dracoLoader.setDecoderPath(path) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
Provides configuration for the decoder libraries. Configuration cannot be changed after decoding begins.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  
**Returns**: [<code>DRACOLoader</code>](#DRACOLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The decoder path. |

<a name="DRACOLoader+setDecoderConfig"></a>

### dracoLoader.setDecoderConfig(config) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
Provides configuration for the decoder libraries. Configuration cannot be changed after decoding begins.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  
**Returns**: [<code>DRACOLoader</code>](#DRACOLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| config | <code>Object</code> | The decoder config. |

<a name="DRACOLoader+setWorkerLimit"></a>

### dracoLoader.setWorkerLimit(workerLimit) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
Sets the maximum number of Web Workers to be used during decoding.
A lower limit may be preferable if workers are also for other tasks in the application.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  
**Returns**: [<code>DRACOLoader</code>](#DRACOLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| workerLimit | <code>number</code> | The worker limit. |

<a name="DRACOLoader+load"></a>

### dracoLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded Draco asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="DRACOLoader+parse"></a>

### dracoLoader.parse(buffer, onLoad, onError)
Parses the given Draco data.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw Draco data as an array buffer. |
| onLoad | <code>function</code> | Executed when the loading/parsing process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="EXRLoader"></a>

## EXRLoader ⇐ <code>DataTextureLoader</code>
A loader for the OpenEXR texture format.

`EXRLoader` currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.
Supports reading as UnsignedByte, HalfFloat and Float type data texture.

```js
const loader = new EXRLoader();
const texture = await loader.loadAsync( 'textures/memorial.exr' );
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [EXRLoader](#EXRLoader) ⇐ <code>DataTextureLoader</code>
    * [new EXRLoader([manager])](#new_EXRLoader_new)
    * [.type](#EXRLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.parse(buffer)](#EXRLoader+parse) ⇒ <code>DataTextureLoader~TexData</code>
    * [.setDataType(value)](#EXRLoader+setDataType) ⇒ <code>RGBMLoader</code>

<a name="new_EXRLoader_new"></a>

### new EXRLoader([manager])
Constructs a new EXR loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="EXRLoader+type"></a>

### exrLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>EXRLoader</code>](#EXRLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="EXRLoader+parse"></a>

### exrLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given EXR texture data.

**Kind**: instance method of [<code>EXRLoader</code>](#EXRLoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="EXRLoader+setDataType"></a>

### exrLoader.setDataType(value) ⇒ <code>RGBMLoader</code>
Sets the texture type.

**Kind**: instance method of [<code>EXRLoader</code>](#EXRLoader)  
**Returns**: <code>RGBMLoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="FBXLoader"></a>

## FBXLoader ⇐ <code>Loader</code>
A loader for the FBX format.

Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format.
Versions lower than this may load but will probably have errors.

Needs Support:
- Morph normals / blend shape normals

FBX format references:
- [C++ SDK reference](https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html)

Binary format specification:
- [FBX binary file format specification](https://code.blender.org/2013/08/fbx-binary-file-format-specification/)

```js
const loader = new FBXLoader();
const object = await loader.loadAsync( 'models/fbx/stanford-bunny.fbx' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [FBXLoader](#FBXLoader) ⇐ <code>Loader</code>
    * [new FBXLoader([manager])](#new_FBXLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#FBXLoader+load)
    * [.parse(FBXBuffer, path)](#FBXLoader+parse) ⇒ <code>Group</code>

<a name="new_FBXLoader_new"></a>

### new FBXLoader([manager])
Constructs a new FBX loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="FBXLoader+load"></a>

### fbxLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded FBX asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>FBXLoader</code>](#FBXLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="FBXLoader+parse"></a>

### fbxLoader.parse(FBXBuffer, path) ⇒ <code>Group</code>
Parses the given FBX data and returns the resulting group.

**Kind**: instance method of [<code>FBXLoader</code>](#FBXLoader)  
**Returns**: <code>Group</code> - An object representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| FBXBuffer | <code>Array</code> | The raw FBX data as an array buffer. |
| path | <code>string</code> | The URL base path. |

## Classes

<dl>
<dt><a href="#FontLoader">FontLoader</a> ⇐ <code>Loader</code></dt>
<dd><p>A loader for loading fonts.</p>
<p>You can convert fonts online using <a href="https://gero3.github.io/facetype.js/">facetype.js</a>.</p>
<pre><code class="language-js">const loader = new FontLoader();
const font = await loader.loadAsync( &#39;fonts/helvetiker_regular.typeface.json&#39; );
</code></pre>
</dd>
<dt><a href="#Font">Font</a></dt>
<dd><p>Class representing a font.</p>
</dd>
</dl>

<a name="FontLoader"></a>

## FontLoader ⇐ <code>Loader</code>
A loader for loading fonts.

You can convert fonts online using [facetype.js](https://gero3.github.io/facetype.js/).

```js
const loader = new FontLoader();
const font = await loader.loadAsync( 'fonts/helvetiker_regular.typeface.json' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [FontLoader](#FontLoader) ⇐ <code>Loader</code>
    * [new FontLoader([manager])](#new_FontLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#FontLoader+load)
    * [.parse(json)](#FontLoader+parse) ⇒ [<code>Font</code>](#Font)

<a name="new_FontLoader_new"></a>

### new FontLoader([manager])
Constructs a new font loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="FontLoader+load"></a>

### fontLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded font
to the `onLoad()` callback.

**Kind**: instance method of [<code>FontLoader</code>](#FontLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="FontLoader+parse"></a>

### fontLoader.parse(json) ⇒ [<code>Font</code>](#Font)
Parses the given font data and returns the resulting font.

**Kind**: instance method of [<code>FontLoader</code>](#FontLoader)  
**Returns**: [<code>Font</code>](#Font) - The font.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The raw font data as a JSON object. |

<a name="Font"></a>

## Font
Class representing a font.

**Kind**: global class  

* [Font](#Font)
    * [new Font(data)](#new_Font_new)
    * [.isFont](#Font+isFont) : <code>boolean</code>
    * [.data](#Font+data) : <code>Object</code>
    * [.generateShapes(text, [size])](#Font+generateShapes) ⇒ <code>Array.&lt;Shape&gt;</code>

<a name="new_Font_new"></a>

### new Font(data)
Constructs a new font.


| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | The font data as JSON. |

<a name="Font+isFont"></a>

### font.isFont : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Font</code>](#Font)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Font+data"></a>

### font.data : <code>Object</code>
The font data as JSON.

**Kind**: instance property of [<code>Font</code>](#Font)  
<a name="Font+generateShapes"></a>

### font.generateShapes(text, [size]) ⇒ <code>Array.&lt;Shape&gt;</code>
Generates geometry shapes from the given text and size. The result of this method
should be used with [ShapeGeometry](ShapeGeometry) to generate the actual geometry data.

**Kind**: instance method of [<code>Font</code>](#Font)  
**Returns**: <code>Array.&lt;Shape&gt;</code> - An array of shapes representing the text.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| text | <code>string</code> |  | The text. |
| [size] | <code>number</code> | <code>100</code> | The text size. |

<a name="GCodeLoader"></a>

## GCodeLoader ⇐ <code>Loader</code>
A loader for the GCode format.

GCode files are usually used for 3D printing or CNC applications.

```js
const loader = new GCodeLoader();
const object = await loader.loadAsync( 'models/gcode/benchy.gcode' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [GCodeLoader](#GCodeLoader) ⇐ <code>Loader</code>
    * [new GCodeLoader([manager])](#new_GCodeLoader_new)
    * [.splitLayer](#GCodeLoader+splitLayer) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#GCodeLoader+load)
    * [.parse(data)](#GCodeLoader+parse) ⇒ <code>Group</code>

<a name="new_GCodeLoader_new"></a>

### new GCodeLoader([manager])
Constructs a new GCode loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="GCodeLoader+splitLayer"></a>

### gCodeLoader.splitLayer : <code>boolean</code>
Whether to split layers or not.

**Kind**: instance property of [<code>GCodeLoader</code>](#GCodeLoader)  
**Default**: <code>false</code>  
<a name="GCodeLoader+load"></a>

### gCodeLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded GCode asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>GCodeLoader</code>](#GCodeLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="GCodeLoader+parse"></a>

### gCodeLoader.parse(data) ⇒ <code>Group</code>
Parses the given GCode data and returns a group with lines.

**Kind**: instance method of [<code>GCodeLoader</code>](#GCodeLoader)  
**Returns**: <code>Group</code> - The parsed GCode asset.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>string</code> | The raw Gcode data as a string. |

<a name="GLTFLoader"></a>

## GLTFLoader ⇐ <code>Loader</code>
A loader for the glTF 2.0 format.

[glTF](https://www.khronos.org/gltf/) (GL Transmission Format) is an [open format specification](https://github.com/KhronosGroup/glTF/tree/main/specification/2.0)
for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf) or binary (.glb)
format. External files store textures (.jpg, .png) and additional binary data (.bin). A glTF asset may deliver
one or more scenes, including meshes, materials, textures, skins, skeletons, morph targets, animations, lights,
and/or cameras.

`GLTFLoader` uses [ImageBitmapLoader](ImageBitmapLoader) whenever possible. Be advised that image bitmaps are not
automatically GC-collected when they are no longer referenced, and they require special handling during
the disposal process.

`GLTFLoader` supports the following glTF 2.0 extensions:
- KHR_draco_mesh_compression
- KHR_materials_clearcoat
- KHR_materials_dispersion
- KHR_materials_ior
- KHR_materials_specular
- KHR_materials_transmission
- KHR_materials_iridescence
- KHR_materials_unlit
- KHR_materials_volume
- KHR_mesh_quantization
- KHR_lights_punctual
- KHR_texture_basisu
- KHR_texture_transform
- EXT_texture_webp
- EXT_meshopt_compression
- EXT_mesh_gpu_instancing

The following glTF 2.0 extension is supported by an external user plugin:
- [KHR_materials_variants](https://github.com/takahirox/three-gltf-extensions)
- [MSFT_texture_dds](https://github.com/takahirox/three-gltf-extensions)

```js
const loader = new GLTFLoader();

// Optional: Provide a DRACOLoader instance to decode compressed mesh data
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath( '/examples/jsm/libs/draco/' );
loader.setDRACOLoader( dracoLoader );

const gltf = await loader.loadAsync( 'models/gltf/duck/duck.gltf' );
scene.add( gltf.scene );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [GLTFLoader](#GLTFLoader) ⇐ <code>Loader</code>
    * [new GLTFLoader([manager])](#new_GLTFLoader_new)
    * _instance_
        * [.load(url, onLoad, onProgress, onError)](#GLTFLoader+load)
        * [.setDRACOLoader(dracoLoader)](#GLTFLoader+setDRACOLoader) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.setKTX2Loader(ktx2Loader)](#GLTFLoader+setKTX2Loader) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.setMeshoptDecoder(meshoptDecoder)](#GLTFLoader+setMeshoptDecoder) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.register(callback)](#GLTFLoader+register) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.unregister(callback)](#GLTFLoader+unregister) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.parse(data, path, onLoad, onError)](#GLTFLoader+parse)
        * [.parseAsync(data, path)](#GLTFLoader+parseAsync) ⇒ [<code>Promise.&lt;LoadObject&gt;</code>](#GLTFLoader..LoadObject)
    * _inner_
        * [~LoadObject](#GLTFLoader..LoadObject) : <code>Object</code>

<a name="new_GLTFLoader_new"></a>

### new GLTFLoader([manager])
Constructs a new glTF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="GLTFLoader+load"></a>

### gltfLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded glTF asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="GLTFLoader+setDRACOLoader"></a>

### gltfLoader.setDRACOLoader(dracoLoader) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Sets the given Draco loader to this loader. Required for decoding assets
compressed with the `KHR_draco_mesh_compression` extension.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| dracoLoader | <code>DRACOLoader</code> | The Draco loader to set. |

<a name="GLTFLoader+setKTX2Loader"></a>

### gltfLoader.setKTX2Loader(ktx2Loader) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Sets the given KTX2 loader to this loader. Required for loading KTX2
compressed textures.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| ktx2Loader | <code>KTX2Loader</code> | The KTX2 loader to set. |

<a name="GLTFLoader+setMeshoptDecoder"></a>

### gltfLoader.setMeshoptDecoder(meshoptDecoder) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Sets the given meshopt decoder. Required for decoding assets
compressed with the `EXT_meshopt_compression` extension.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| meshoptDecoder | <code>Object</code> | The meshopt decoder to set. |

<a name="GLTFLoader+register"></a>

### gltfLoader.register(callback) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Registers a plugin callback. This API is internally used to implement the various
glTF extensions but can also used by third-party code to add additional logic
to the loader.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The callback function to register. |

<a name="GLTFLoader+unregister"></a>

### gltfLoader.unregister(callback) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Unregisters a plugin callback.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The callback function to unregister. |

<a name="GLTFLoader+parse"></a>

### gltfLoader.parse(data, path, onLoad, onError)
Parses the given FBX data and returns the resulting group.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>string</code> \| <code>ArrayBuffer</code> | The raw glTF data. |
| path | <code>string</code> | The URL base path. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="GLTFLoader+parseAsync"></a>

### gltfLoader.parseAsync(data, path) ⇒ [<code>Promise.&lt;LoadObject&gt;</code>](#GLTFLoader..LoadObject)
Async version of [parse](#GLTFLoader+parse).

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>Promise.&lt;LoadObject&gt;</code>](#GLTFLoader..LoadObject) - A Promise that resolves with the loaded glTF when the parsing has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>string</code> \| <code>ArrayBuffer</code> | The raw glTF data. |
| path | <code>string</code> | The URL base path. |

<a name="GLTFLoader..LoadObject"></a>

### GLTFLoader~LoadObject : <code>Object</code>
Loader result of `GLTFLoader`.

**Kind**: inner typedef of [<code>GLTFLoader</code>](#GLTFLoader)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| animations | <code>Array.&lt;AnimationClip&gt;</code> | An array of animation clips. |
| asset | <code>Object</code> | Meta data about the loaded asset. |
| cameras | <code>Array.&lt;Camera&gt;</code> | An array of cameras. |
| parser | <code>GLTFParser</code> | A reference to the internal parser. |
| scene | <code>Group</code> | The default scene. |
| scenes | <code>Array.&lt;Group&gt;</code> | glTF assets might define multiple scenes. |
| userData | <code>Object</code> | Additional data. |

<a name="HDRCubeTextureLoader"></a>

## HDRCubeTextureLoader ⇐ <code>Loader</code>
A loader for loading HDR cube textures.

```js
const loader = new HDRCubeTextureLoader();
loader.setPath( 'textures/cube/pisaHDR/' );
const cubeTexture = await loader.loadAsync( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ] );

scene.background = cubeTexture;
scene.environment = cubeTexture;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [HDRCubeTextureLoader](#HDRCubeTextureLoader) ⇐ <code>Loader</code>
    * [new HDRCubeTextureLoader([manager])](#new_HDRCubeTextureLoader_new)
    * [.hdrLoader](#HDRCubeTextureLoader+hdrLoader) : <code>RGBELoader</code>
    * [.type](#HDRCubeTextureLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.load(urls, onLoad, onProgress, onError)](#HDRCubeTextureLoader+load) ⇒ <code>CubeTexture</code>
    * [.setDataType(value)](#HDRCubeTextureLoader+setDataType) ⇒ <code>RGBELoader</code>

<a name="new_HDRCubeTextureLoader_new"></a>

### new HDRCubeTextureLoader([manager])
Constructs a new HDR cube texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="HDRCubeTextureLoader+hdrLoader"></a>

### hdrCubeTextureLoader.hdrLoader : <code>RGBELoader</code>
The internal HDR loader that loads the
individual textures for each cube face.

**Kind**: instance property of [<code>HDRCubeTextureLoader</code>](#HDRCubeTextureLoader)  
<a name="HDRCubeTextureLoader+type"></a>

### hdrCubeTextureLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>HDRCubeTextureLoader</code>](#HDRCubeTextureLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="HDRCubeTextureLoader+load"></a>

### hdrCubeTextureLoader.load(urls, onLoad, onProgress, onError) ⇒ <code>CubeTexture</code>
Starts loading from the given URLs and passes the loaded HDR cube texture
to the `onLoad()` callback.

**Kind**: instance method of [<code>HDRCubeTextureLoader</code>](#HDRCubeTextureLoader)  
**Returns**: <code>CubeTexture</code> - The HDR cube texture.  

| Param | Type | Description |
| --- | --- | --- |
| urls | <code>Array.&lt;string&gt;</code> | The paths/URLs of the files to be loaded. This can also be a data URIs. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="HDRCubeTextureLoader+setDataType"></a>

### hdrCubeTextureLoader.setDataType(value) ⇒ <code>RGBELoader</code>
Sets the texture type.

**Kind**: instance method of [<code>HDRCubeTextureLoader</code>](#HDRCubeTextureLoader)  
**Returns**: <code>RGBELoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="IESLoader"></a>

## IESLoader ⇐ <code>Loader</code>
A loader for the IES format.

The loaded texture should be assigned to [IESSpotLight#map](IESSpotLight#map).

```js
const loader = new IESLoader();
const texture = await loader.loadAsync( 'ies/007cfb11e343e2f42e3b476be4ab684e.ies' );

const spotLight = new THREE.IESSpotLight( 0xff0000, 500 );
spotLight.iesMap = texture;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [IESLoader](#IESLoader) ⇐ <code>Loader</code>
    * [new IESLoader([manager])](#new_IESLoader_new)
    * [.type](#IESLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.load(url, onLoad, onProgress, onError)](#IESLoader+load)
    * [.parse(text)](#IESLoader+parse) ⇒ <code>DataTexture</code>

<a name="new_IESLoader_new"></a>

### new IESLoader([manager])
Constructs a new IES loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="IESLoader+type"></a>

### iesLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>IESLoader</code>](#IESLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="IESLoader+load"></a>

### iesLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded IES texture
to the `onLoad()` callback.

**Kind**: instance method of [<code>IESLoader</code>](#IESLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="IESLoader+parse"></a>

### iesLoader.parse(text) ⇒ <code>DataTexture</code>
Parses the given IES data.

**Kind**: instance method of [<code>IESLoader</code>](#IESLoader)  
**Returns**: <code>DataTexture</code> - THE IES data as a texture.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw IES data. |

<a name="KMZLoader"></a>

## KMZLoader ⇐ <code>Loader</code>
A loader for the KMZ format.

```js
const loader = new KMZLoader();
const kmz = await loader.loadAsync( './models/kmz/Box.kmz' );

scene.add( kmz.scene );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [KMZLoader](#KMZLoader) ⇐ <code>Loader</code>
    * [new KMZLoader([manager])](#new_KMZLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#KMZLoader+load)
    * [.parse(data)](#KMZLoader+parse) ⇒ <code>Object</code>

<a name="new_KMZLoader_new"></a>

### new KMZLoader([manager])
Constructs a new KMZ loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="KMZLoader+load"></a>

### kmzLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded KMZ asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>KMZLoader</code>](#KMZLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="KMZLoader+parse"></a>

### kmzLoader.parse(data) ⇒ <code>Object</code>
Parses the given KMZ data and returns an object holding the scene.

**Kind**: instance method of [<code>KMZLoader</code>](#KMZLoader)  
**Returns**: <code>Object</code> - The parsed KMZ asset.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw KMZ data as an array buffer. |

<a name="KTX2Loader"></a>

## KTX2Loader ⇐ <code>Loader</code>
A loader for KTX 2.0 GPU Texture containers.

KTX 2.0 is a container format for various GPU texture formats. The loader supports Basis Universal GPU textures,
which can be quickly transcoded to a wide variety of GPU texture compression formats. While KTX 2.0 also allows
other hardware-specific formats, this loader does not yet parse them.

This loader parses the KTX 2.0 container and transcodes to a supported GPU compressed texture format.
The required WASM transcoder and JS wrapper are available from the `examples/jsm/libs/basis` directory.

This loader relies on Web Assembly which is not supported in older browsers.

References:
- [KTX specification](http://github.khronos.org/KTX-Specification/)
- [DFD](https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor)
- [BasisU HDR](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Texture-Specification-v1.0)

```js
const loader = new KTX2Loader();
loader.setTranscoderPath( 'examples/jsm/libs/basis/' );
loader.detectSupport( renderer );
const texture = loader.loadAsync( 'diffuse.ktx2' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [KTX2Loader](#KTX2Loader) ⇐ <code>Loader</code>
    * [new KTX2Loader([manager])](#new_KTX2Loader_new)
    * [.setTranscoderPath(path)](#KTX2Loader+setTranscoderPath) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
    * [.setWorkerLimit(workerLimit)](#KTX2Loader+setWorkerLimit) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
    * [.detectSupportAsync(renderer)](#KTX2Loader+detectSupportAsync) ⇒ <code>Promise</code>
    * [.detectSupport(renderer)](#KTX2Loader+detectSupport) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
    * [.load(url, onLoad, onProgress, onError)](#KTX2Loader+load)
    * [.parse(buffer, onLoad, onError)](#KTX2Loader+parse) ⇒ <code>Promise</code>
    * [.dispose()](#KTX2Loader+dispose)

<a name="new_KTX2Loader_new"></a>

### new KTX2Loader([manager])
Constructs a new KTX2 loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="KTX2Loader+setTranscoderPath"></a>

### ktX2Loader.setTranscoderPath(path) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
Sets the transcoder path.

The WASM transcoder and JS wrapper are available from the `examples/jsm/libs/basis` directory.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: [<code>KTX2Loader</code>](#KTX2Loader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The transcoder path to set. |

<a name="KTX2Loader+setWorkerLimit"></a>

### ktX2Loader.setWorkerLimit(workerLimit) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
Sets the maximum number of Web Workers to be allocated by this instance.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: [<code>KTX2Loader</code>](#KTX2Loader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| workerLimit | <code>number</code> | The worker limit. |

<a name="KTX2Loader+detectSupportAsync"></a>

### ktX2Loader.detectSupportAsync(renderer) ⇒ <code>Promise</code>
Async version of [detectSupport](#KTX2Loader+detectSupport).

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: <code>Promise</code> - A Promise that resolves when the support has been detected.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The renderer. |

<a name="KTX2Loader+detectSupport"></a>

### ktX2Loader.detectSupport(renderer) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
Detects hardware support for available compressed texture formats, to determine
the output format for the transcoder. Must be called before loading a texture.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: [<code>KTX2Loader</code>](#KTX2Loader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The renderer. |

<a name="KTX2Loader+load"></a>

### ktX2Loader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded KTX2 texture
to the `onLoad()` callback.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="KTX2Loader+parse"></a>

### ktX2Loader.parse(buffer, onLoad, onError) ⇒ <code>Promise</code>
Parses the given KTX2 data.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: <code>Promise</code> - A Promise that resolves when the parsing has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw KTX2 data as an array buffer. |
| onLoad | <code>function</code> | Executed when the loading/parsing process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="KTX2Loader+dispose"></a>

### ktX2Loader.dispose()
Frees internal resources. This method should be called
when the loader is no longer required.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
<a name="KTXLoader"></a>

## KTXLoader ⇐ <code>CompressedTextureLoader</code>
A loader for the KTX texture compression format.

References:
- [The KTX File Format and Tools](https://www.khronos.org/opengles/sdk/tools/KTX/)
- [Babylon.JS khronosTextureContainer.ts](https://github.com/BabylonJS/Babylon.js/blob/master/src/Misc/khronosTextureContainer.ts)

```js
const loader = new KTXLoader();

const map = loader.load( 'textures/compressed/lensflare_ASTC8x8.ktx' )
map.colorSpace = THREE.SRGBColorSpace; // only for color textures
```

**Kind**: global class  
**Extends**: <code>CompressedTextureLoader</code>  

* [KTXLoader](#KTXLoader) ⇐ <code>CompressedTextureLoader</code>
    * [new KTXLoader([manager])](#new_KTXLoader_new)
    * [.parse(buffer, loadMipmaps)](#KTXLoader+parse) ⇒ <code>CompressedTextureLoader~TexData</code>

<a name="new_KTXLoader_new"></a>

### new KTXLoader([manager])
Constructs a new KTX loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="KTXLoader+parse"></a>

### ktxLoader.parse(buffer, loadMipmaps) ⇒ <code>CompressedTextureLoader~TexData</code>
Parses the given KTX texture data.

**Kind**: instance method of [<code>KTXLoader</code>](#KTXLoader)  
**Returns**: <code>CompressedTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |
| loadMipmaps | <code>boolean</code> | Whether to load mipmaps or not. |

<a name="LDrawLoader"></a>

## LDrawLoader ⇐ <code>Loader</code>
A loader for the LDraw format.

[LDraw](https://ldraw.org/) (LEGO Draw) is an [open format specification](https://ldraw.org/article/218.html)
for describing LEGO and other construction set 3D models.

An LDraw asset (a text file usually with extension .ldr, .dat or .txt) can describe just a single construction
piece, or an entire model. In the case of a model the LDraw file can reference other LDraw files, which are
loaded from a library path set with `setPartsLibraryPath`. You usually download the LDraw official parts library,
extract to a folder and point setPartsLibraryPath to it.

Library parts will be loaded by trial and error in subfolders 'parts', 'p' and 'models'. These file accesses
are not optimal for web environment, so a script tool has been made to pack an LDraw file with all its dependencies
into a single file, which loads much faster. See section 'Packing LDraw models'. The LDrawLoader example loads
several packed files. The official parts library is not included due to its large size.

`LDrawLoader` supports the following extensions:
- !COLOUR: Color and surface finish declarations.
- BFC: Back Face Culling specification.
- !CATEGORY: Model/part category declarations.
- !KEYWORDS: Model/part keywords declarations.

```js
const loader = new LDrawLoader();
loader.setConditionalLineMaterial( LDrawConditionalLineMaterial ); // the type of line material depends on the used renderer
const object = await loader.loadAsync( 'models/ldraw/officialLibrary/models/car.ldr_Packed.mpd' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [LDrawLoader](#LDrawLoader) ⇐ <code>Loader</code>
    * [new LDrawLoader([manager])](#new_LDrawLoader_new)
    * [.setPartsLibraryPath(path)](#LDrawLoader+setPartsLibraryPath) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
    * [.setConditionalLineMaterial(type)](#LDrawLoader+setConditionalLineMaterial) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
    * [.preloadMaterials(url)](#LDrawLoader+preloadMaterials) ⇒ <code>Promise</code>
    * [.load(url, onLoad, onProgress, onError)](#LDrawLoader+load)
    * [.parse(text, onLoad, onError)](#LDrawLoader+parse)
    * [.setFileMap(fileMap)](#LDrawLoader+setFileMap) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
    * [.getMaterial(colorCode)](#LDrawLoader+getMaterial) ⇒ <code>Material</code>
    * [.getMainMaterial()](#LDrawLoader+getMainMaterial) ⇒ <code>Material</code>
    * [.getMainEdgeMaterial()](#LDrawLoader+getMainEdgeMaterial) ⇒ <code>Material</code>

<a name="new_LDrawLoader_new"></a>

### new LDrawLoader([manager])
Constructs a new LDraw loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="LDrawLoader+setPartsLibraryPath"></a>

### lDrawLoader.setPartsLibraryPath(path) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
This method must be called prior to `load()` unless the model to load does not reference
library parts (usually it will be a model with all its parts packed in a single file).

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: [<code>LDrawLoader</code>](#LDrawLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | Path to library parts files to load referenced parts from. This is different from Loader.setPath, which indicates the path to load the main asset from. |

<a name="LDrawLoader+setConditionalLineMaterial"></a>

### lDrawLoader.setConditionalLineMaterial(type) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
Sets the conditional line material type which depends on the used renderer.
Use [LDrawConditionalLineMaterial](LDrawConditionalLineMaterial) when using `WebGLRenderer` and
[LDrawConditionalLineNodeMaterial](LDrawConditionalLineNodeMaterial) when using `WebGPURenderer`.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: [<code>LDrawLoader</code>](#LDrawLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>LDrawConditionalLineMaterial.constructor</code> \| <code>LDrawConditionalLineNodeMaterial.constructor</code> | The conditional line material type. |

<a name="LDrawLoader+preloadMaterials"></a>

### lDrawLoader.preloadMaterials(url) ⇒ <code>Promise</code>
This async method preloads materials from a single LDraw file. In the official
parts library there is a special file which is loaded always the first (LDConfig.ldr)
and contains all the standard color codes. This method is intended to be used with
not packed files, for example in an editor where materials are preloaded and parts
are loaded on demand.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: <code>Promise</code> - A Promise that resolves when the preload has finished.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | Path of the LDraw materials asset. |

<a name="LDrawLoader+load"></a>

### lDrawLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded LDraw asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="LDrawLoader+parse"></a>

### lDrawLoader.parse(text, onLoad, onError)
Parses the given LDraw data and returns the resulting group.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw VRML data as a string. |
| onLoad | <code>function</code> | Executed when the loading/parsing process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="LDrawLoader+setFileMap"></a>

### lDrawLoader.setFileMap(fileMap) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
Sets a map which maps referenced library filenames to new filenames.
If a fileMap is not specified (the default), library parts will be accessed by trial and
error in subfolders 'parts', 'p' and 'models'.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: [<code>LDrawLoader</code>](#LDrawLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| fileMap | <code>Object.&lt;string, string&gt;</code> | The file map to set. |

<a name="LDrawLoader+getMaterial"></a>

### lDrawLoader.getMaterial(colorCode) ⇒ <code>Material</code>
Returns a material for the given color code.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: <code>Material</code> - The material. Returns `null` if no material has been found.  

| Param | Type | Description |
| --- | --- | --- |
| colorCode | <code>string</code> | The color code. |

<a name="LDrawLoader+getMainMaterial"></a>

### lDrawLoader.getMainMaterial() ⇒ <code>Material</code>
Returns the Material for the main LDraw color.

For an already loaded LDraw asset, returns the Material associated with the main color code.
This method can be useful to modify the main material of a model or part that exposes it.

The main color code is the standard way to color an LDraw part. It is '16' for triangles and
'24' for edges. Usually a complete model will not expose the main color (that is, no part
uses the code '16' at the top level, because they are assigned other specific colors) An LDraw
 part file on the other hand will expose the code '16' to be colored, and can have additional
fixed colors.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: <code>Material</code> - The material. Returns `null` if no material has been found.  
<a name="LDrawLoader+getMainEdgeMaterial"></a>

### lDrawLoader.getMainEdgeMaterial() ⇒ <code>Material</code>
Returns the material for the edges main LDraw color.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: <code>Material</code> - The material. Returns `null` if no material has been found.  
<a name="LWOLoader"></a>

## LWOLoader ⇐ <code>Loader</code>
A loader for the LWO format.

LWO3 and LWO2 formats are supported.

References:
- [LWO3 format specification](https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html)
- [LWO2 format specification](https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html)

```js
const loader = new LWOLoader();
const lwoData = await loader.loadAsync( 'models/lwo/Objects/LWO3/Demo.lwo' );

const mesh = object.meshes[ 0 ];
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [LWOLoader](#LWOLoader) ⇐ <code>Loader</code>
    * [new LWOLoader([manager])](#new_LWOLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#LWOLoader+load)
    * [.parse(iffBuffer, path, modelName)](#LWOLoader+parse) ⇒ <code>Object</code>

<a name="new_LWOLoader_new"></a>

### new LWOLoader([manager])
Constructs a new LWO loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="LWOLoader+load"></a>

### lwoLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded LWO asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>LWOLoader</code>](#LWOLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="LWOLoader+parse"></a>

### lwoLoader.parse(iffBuffer, path, modelName) ⇒ <code>Object</code>
Parses the given LWO data and returns the resulting meshes and materials.

**Kind**: instance method of [<code>LWOLoader</code>](#LWOLoader)  
**Returns**: <code>Object</code> - An object holding the parse meshes and materials.  

| Param | Type | Description |
| --- | --- | --- |
| iffBuffer | <code>ArrayBuffer</code> | The raw LWO data as an array buffer. |
| path | <code>string</code> | The URL base path. |
| modelName | <code>string</code> | The model name. |

<a name="LottieLoader"></a>

## LottieLoader ⇐ <code>Loader</code>
A loader for the Lottie texture animation format.

The loader returns an instance of [CanvasTexture](CanvasTexture) to represent
the animated texture. Two additional properties are added to each texture:
- `animation`: The return value of `lottie.loadAnimation()` which is an object
with an API for controlling the animation's playback.
- `image`: The image container.

```js
const loader = new LottieLoader();
loader.setQuality( 2 );
const texture = await loader.loadAsync( 'textures/lottie/24017-lottie-logo-animation.json' );

const geometry = new THREE.BoxGeometry();
const material = new THREE.MeshBasicMaterial( { map: texture } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [LottieLoader](#LottieLoader) ⇐ <code>Loader</code>
    * [.setQuality(value)](#LottieLoader+setQuality)
    * [.load(url, onLoad, onProgress, onError)](#LottieLoader+load) ⇒ <code>CanvasTexture</code>

<a name="LottieLoader+setQuality"></a>

### lottieLoader.setQuality(value)
Sets the texture quality.

**Kind**: instance method of [<code>LottieLoader</code>](#LottieLoader)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The texture quality. |

<a name="LottieLoader+load"></a>

### lottieLoader.load(url, onLoad, onProgress, onError) ⇒ <code>CanvasTexture</code>
Starts loading from the given URL and passes the loaded Lottie asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>LottieLoader</code>](#LottieLoader)  
**Returns**: <code>CanvasTexture</code> - The Lottie texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MD2Loader"></a>

## MD2Loader ⇐ <code>Loader</code>
A loader for the MD2 format.

The loader represents the animations of the MD2 asset as an array of animation
clips and stores them in the `animations` property of the geometry.

```js
const loader = new MD2Loader();
const geometry = await loader.loadAsync( './models/md2/ogro/ogro.md2' );

const animations = geometry.animations;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MD2Loader](#MD2Loader) ⇐ <code>Loader</code>
    * [new MD2Loader([manager])](#new_MD2Loader_new)
    * [.load(url, onLoad, [onProgress], [onError])](#MD2Loader+load)
    * [.parse(buffer)](#MD2Loader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_MD2Loader_new"></a>

### new MD2Loader([manager])
Constructs a new MD2 loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="MD2Loader+load"></a>

### mD2Loader.load(url, onLoad, [onProgress], [onError])
Starts loading from the given URL and passes the loaded MD2 asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>MD2Loader</code>](#MD2Loader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| [onProgress] | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| [onError] | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MD2Loader+parse"></a>

### mD2Loader.parse(buffer) ⇒ <code>BufferGeometry</code>
Parses the given MD2 data and returns a geometry.

**Kind**: instance method of [<code>MD2Loader</code>](#MD2Loader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw MD2 data as an array buffer. |

<a name="MDDLoader"></a>

## MDDLoader ⇐ <code>Loader</code>
A loader for the MDD format.

MDD stores a position for every vertex in a model for every frame in an animation.
Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.

MDD stores its data in binary format (big endian) in the following way:

- number of frames (a single uint32)
- number of vertices (a single uint32)
- time values for each frame (sequence of float32)
- vertex data for each frame (sequence of float32)

```js
const loader = new MDDLoader();
const result = await loader.loadAsync( 'models/mdd/cube.mdd' );

const morphTargets = result.morphTargets;
const clip = result.clip;
// clip.optimize(); // optional

const geometry = new THREE.BoxGeometry();
geometry.morphAttributes.position = morphTargets; // apply morph targets (vertex data must match)

const material = new THREE.MeshBasicMaterial();

const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );

const mixer = new THREE.AnimationMixer( mesh );
mixer.clipAction( clip ).play();
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MDDLoader](#MDDLoader) ⇐ <code>Loader</code>
    * [new MDDLoader([manager])](#new_MDDLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#MDDLoader+load)
    * [.parse(data)](#MDDLoader+parse) ⇒ <code>Object</code>

<a name="new_MDDLoader_new"></a>

### new MDDLoader([manager])
Constructs a new MDD loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="MDDLoader+load"></a>

### mddLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded MDD asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>MDDLoader</code>](#MDDLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MDDLoader+parse"></a>

### mddLoader.parse(data) ⇒ <code>Object</code>
Parses the given MDD data and returns an object holding the animation clip and the respective
morph targets.

**Kind**: instance method of [<code>MDDLoader</code>](#MDDLoader)  
**Returns**: <code>Object</code> - The result object.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw XYZ data as an array buffer. |

<a name="MTLLoader"></a>

## MTLLoader ⇐ <code>Loader</code>
A loader for the MTL format.

The Material Template Library format (MTL) or .MTL File Format is a companion file format
to OBJ that describes surface shading (material) properties of objects within one or more
OBJ files.

```js
const loader = new MTLLoader();
const materials = await loader.loadAsync( 'models/obj/male02/male02.mtl' );

const objLoader = new OBJLoader();
objLoader.setMaterials( materials );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MTLLoader](#MTLLoader) ⇐ <code>Loader</code>
    * _instance_
        * [.load(url, onLoad, onProgress, onError)](#MTLLoader+load)
        * [.setMaterialOptions(value)](#MTLLoader+setMaterialOptions) ⇒ [<code>MTLLoader</code>](#MTLLoader)
        * [.parse(text, path)](#MTLLoader+parse) ⇒ <code>MaterialCreator</code>
    * _inner_
        * [~MaterialOptions](#MTLLoader..MaterialOptions) : <code>Object</code>

<a name="MTLLoader+load"></a>

### mtlLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded MTL asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>MTLLoader</code>](#MTLLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MTLLoader+setMaterialOptions"></a>

### mtlLoader.setMaterialOptions(value) ⇒ [<code>MTLLoader</code>](#MTLLoader)
Sets the material options.

**Kind**: instance method of [<code>MTLLoader</code>](#MTLLoader)  
**Returns**: [<code>MTLLoader</code>](#MTLLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>MaterialOptions</code>](#MTLLoader..MaterialOptions) | The material options. |

<a name="MTLLoader+parse"></a>

### mtlLoader.parse(text, path) ⇒ <code>MaterialCreator</code>
Parses the given MTL data and returns the resulting material creator.

**Kind**: instance method of [<code>MTLLoader</code>](#MTLLoader)  
**Returns**: <code>MaterialCreator</code> - The material creator.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw MTL data as a string. |
| path | <code>string</code> | The URL base path. |

<a name="MTLLoader..MaterialOptions"></a>

### MTLLoader~MaterialOptions : <code>Object</code>
Material options of `MTLLoader`.

**Kind**: inner typedef of [<code>MTLLoader</code>](#MTLLoader)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [side] | <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code> | <code>FrontSide</code> | Which side to apply the material. |
| [wrap] | <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code> | <code>RepeatWrapping</code> | What type of wrapping to apply for textures. |
| [normalizeRGB] | <code>boolean</code> | <code>false</code> | Whether RGB colors should be normalized to `0-1` from `0-255`. |
| [ignoreZeroRGBs] | <code>boolean</code> | <code>false</code> | Ignore values of RGBs (Ka,Kd,Ks) that are all 0's. |

<a name="MaterialXLoader"></a>

## MaterialXLoader ⇐ <code>Loader</code>
A loader for the MaterialX format.

The node materials loaded with this loader can only be used with [WebGPURenderer](WebGPURenderer).

```js
const loader = new MaterialXLoader().setPath( SAMPLE_PATH );
const materials = await loader.loadAsync( 'standard_surface_brass_tiled.mtlx' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MaterialXLoader](#MaterialXLoader) ⇐ <code>Loader</code>
    * [new MaterialXLoader([manager])](#new_MaterialXLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#MaterialXLoader+load) ⇒ [<code>MaterialXLoader</code>](#MaterialXLoader)
    * [.parse(text)](#MaterialXLoader+parse) ⇒ <code>Object.&lt;string, NodeMaterial&gt;</code>

<a name="new_MaterialXLoader_new"></a>

### new MaterialXLoader([manager])
Constructs a new MaterialX loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="MaterialXLoader+load"></a>

### materialXLoader.load(url, onLoad, onProgress, onError) ⇒ [<code>MaterialXLoader</code>](#MaterialXLoader)
Starts loading from the given URL and passes the loaded MaterialX asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>MaterialXLoader</code>](#MaterialXLoader)  
**Returns**: [<code>MaterialXLoader</code>](#MaterialXLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MaterialXLoader+parse"></a>

### materialXLoader.parse(text) ⇒ <code>Object.&lt;string, NodeMaterial&gt;</code>
Parses the given MaterialX data and returns the resulting materials.

**Kind**: instance method of [<code>MaterialXLoader</code>](#MaterialXLoader)  
**Returns**: <code>Object.&lt;string, NodeMaterial&gt;</code> - A dictionary holding the parse node materials.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw MaterialX data as a string. |

<a name="NRRDLoader"></a>

## NRRDLoader ⇐ <code>Loader</code>
A loader for the NRRD format.

```js
const loader = new NRRDLoader();
const volume = await loader.loadAsync( 'models/nrrd/I.nrrd' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [NRRDLoader](#NRRDLoader) ⇐ <code>Loader</code>
    * [new NRRDLoader([manager])](#new_NRRDLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#NRRDLoader+load)
    * [.setSegmentation(segmentation)](#NRRDLoader+setSegmentation)
    * [.parse(data)](#NRRDLoader+parse) ⇒ <code>Volume</code>

<a name="new_NRRDLoader_new"></a>

### new NRRDLoader([manager])
Constructs a new NRRD loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="NRRDLoader+load"></a>

### nrrdLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded NRRD asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>NRRDLoader</code>](#NRRDLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="NRRDLoader+setSegmentation"></a>

### nrrdLoader.setSegmentation(segmentation)
Toggles the segmentation mode.

**Kind**: instance method of [<code>NRRDLoader</code>](#NRRDLoader)  

| Param | Type | Description |
| --- | --- | --- |
| segmentation | <code>boolean</code> | Whether to use segmentation mode or not. |

<a name="NRRDLoader+parse"></a>

### nrrdLoader.parse(data) ⇒ <code>Volume</code>
Parses the given NRRD data and returns the resulting volume data.

**Kind**: instance method of [<code>NRRDLoader</code>](#NRRDLoader)  
**Returns**: <code>Volume</code> - The parsed volume.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw NRRD data as an array buffer. |

<a name="OBJLoader"></a>

## OBJLoader ⇐ <code>Loader</code>
A loader for the OBJ format.

The [OBJ format](https://en.wikipedia.org/wiki/Wavefront_.obj_file) is a simple data-format that
represents 3D geometry in a human readable format as the position of each vertex, the UV position of
each texture coordinate vertex, vertex normals, and the faces that make each polygon defined as a list
of vertices, and texture vertices.

```js
const loader = new OBJLoader();
const object = await loader.loadAsync( 'models/monster.obj' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [OBJLoader](#OBJLoader) ⇐ <code>Loader</code>
    * [new OBJLoader([manager])](#new_OBJLoader_new)
    * [.materials](#OBJLoader+materials) : <code>MaterialCreator</code>
    * [.load(url, onLoad, onProgress, onError)](#OBJLoader+load)
    * [.setMaterials(materials)](#OBJLoader+setMaterials) ⇒ [<code>OBJLoader</code>](#OBJLoader)
    * [.parse(text)](#OBJLoader+parse) ⇒ <code>Group</code>

<a name="new_OBJLoader_new"></a>

### new OBJLoader([manager])
Constructs a new OBJ loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="OBJLoader+materials"></a>

### objLoader.materials : <code>MaterialCreator</code>
A reference to a material creator.

**Kind**: instance property of [<code>OBJLoader</code>](#OBJLoader)  
**Default**: <code>null</code>  
<a name="OBJLoader+load"></a>

### objLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded OBJ asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>OBJLoader</code>](#OBJLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="OBJLoader+setMaterials"></a>

### objLoader.setMaterials(materials) ⇒ [<code>OBJLoader</code>](#OBJLoader)
Sets the material creator for this OBJ. This object is loaded via [MTLLoader](MTLLoader).

**Kind**: instance method of [<code>OBJLoader</code>](#OBJLoader)  
**Returns**: [<code>OBJLoader</code>](#OBJLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| materials | <code>MaterialCreator</code> | An object that creates the materials for this OBJ. |

<a name="OBJLoader+parse"></a>

### objLoader.parse(text) ⇒ <code>Group</code>
Parses the given OBJ data and returns the resulting group.

**Kind**: instance method of [<code>OBJLoader</code>](#OBJLoader)  
**Returns**: <code>Group</code> - The parsed OBJ.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw OBJ data as a string. |

<a name="PCDLoader"></a>

## PCDLoader ⇐ <code>Loader</code>
A loader for the Point Cloud Data (PCD) format.

PCDLoader supports ASCII and (compressed) binary files as well as the following PCD fields:
- x y z
- rgb
- normal_x normal_y normal_z
- intensity
- label

```js
const loader = new PCDLoader();

const points = await loader.loadAsync( './models/pcd/binary/Zaghetto.pcd' );
points.geometry.center(); // optional
points.geometry.rotateX( Math.PI ); // optional
scene.add( points );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [PCDLoader](#PCDLoader) ⇐ <code>Loader</code>
    * [new PCDLoader([manager])](#new_PCDLoader_new)
    * [.littleEndian](#PCDLoader+littleEndian) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#PCDLoader+load)
    * [.parse(data)](#PCDLoader+parse) ⇒ <code>Points</code>

<a name="new_PCDLoader_new"></a>

### new PCDLoader([manager])
Constructs a new PCD loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="PCDLoader+littleEndian"></a>

### pcdLoader.littleEndian : <code>boolean</code>
Whether to use little Endian or not.

**Kind**: instance property of [<code>PCDLoader</code>](#PCDLoader)  
**Default**: <code>true</code>  
<a name="PCDLoader+load"></a>

### pcdLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded PCD asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>PCDLoader</code>](#PCDLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="PCDLoader+parse"></a>

### pcdLoader.parse(data) ⇒ <code>Points</code>
Parses the given PCD data and returns a point cloud.

**Kind**: instance method of [<code>PCDLoader</code>](#PCDLoader)  
**Returns**: <code>Points</code> - The parsed point cloud.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw PCD data as an array buffer. |

<a name="PDBLoader"></a>

## PDBLoader ⇐ <code>Loader</code>
A loader for the PDB format.

The [Protein Data Bank](https://en.wikipedia.org/wiki/Protein_Data_Bank_(file_format))
file format is a textual file describing the three-dimensional structures of molecules.

```js
const loader = new PDBLoader();
const pdb = await loader.loadAsync( 'models/pdb/ethanol.pdb' );

const geometryAtoms = pdb.geometryAtoms;
const geometryBonds = pdb.geometryBonds;
const json = pdb.json;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [PDBLoader](#PDBLoader) ⇐ <code>Loader</code>
    * [new PDBLoader([manager])](#new_PDBLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#PDBLoader+load)
    * [.parse(text)](#PDBLoader+parse) ⇒ <code>Object</code>

<a name="new_PDBLoader_new"></a>

### new PDBLoader([manager])
Constructs a new PDB loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="PDBLoader+load"></a>

### pdbLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded PDB asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>PDBLoader</code>](#PDBLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="PDBLoader+parse"></a>

### pdbLoader.parse(text) ⇒ <code>Object</code>
Parses the given PDB data and returns an object holding the atoms and
bond geometries as well as the raw atom data as JSON.

**Kind**: instance method of [<code>PDBLoader</code>](#PDBLoader)  
**Returns**: <code>Object</code> - The result object.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw PDB data as a string. |

<a name="PLYLoader"></a>

## PLYLoader ⇐ <code>Loader</code>
A loader for PLY the PLY format (known as the Polygon
File Format or the Stanford Triangle Format).

Limitations:
 - ASCII decoding assumes file is UTF-8.

```js
const loader = new PLYLoader();
const geometry = await loader.loadAsync( './models/ply/ascii/dolphins.ply' );
scene.add( new THREE.Mesh( geometry ) );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [PLYLoader](#PLYLoader) ⇐ <code>Loader</code>
    * [new PLYLoader([manager])](#new_PLYLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#PLYLoader+load)
    * [.setPropertyNameMapping(mapping)](#PLYLoader+setPropertyNameMapping)
    * [.setCustomPropertyNameMapping(mapping)](#PLYLoader+setCustomPropertyNameMapping)
    * [.parse(data)](#PLYLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_PLYLoader_new"></a>

### new PLYLoader([manager])
Constructs a new PLY loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="PLYLoader+load"></a>

### plyLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded PLY asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>PLYLoader</code>](#PLYLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="PLYLoader+setPropertyNameMapping"></a>

### plyLoader.setPropertyNameMapping(mapping)
Sets a property name mapping that maps default property names
to custom ones. For example, the following maps the properties
“diffuse_(red|green|blue)” in the file to standard color names.

```js
loader.setPropertyNameMapping( {
	diffuse_red: 'red',
	diffuse_green: 'green',
	diffuse_blue: 'blue'
} );
```

**Kind**: instance method of [<code>PLYLoader</code>](#PLYLoader)  

| Param | Type | Description |
| --- | --- | --- |
| mapping | <code>Object</code> | The mapping dictionary. |

<a name="PLYLoader+setCustomPropertyNameMapping"></a>

### plyLoader.setCustomPropertyNameMapping(mapping)
Custom properties outside of the defaults for position, uv, normal
and color attributes can be added using the setCustomPropertyNameMapping method.
For example, the following maps the element properties “custom_property_a”
and “custom_property_b” to an attribute “customAttribute” with an item size of 2.
Attribute item sizes are set from the number of element properties in the property array.

```js
loader.setCustomPropertyNameMapping( {
	customAttribute: ['custom_property_a', 'custom_property_b'],
} );
```

**Kind**: instance method of [<code>PLYLoader</code>](#PLYLoader)  

| Param | Type | Description |
| --- | --- | --- |
| mapping | <code>Object</code> | The mapping dictionary. |

<a name="PLYLoader+parse"></a>

### plyLoader.parse(data) ⇒ <code>BufferGeometry</code>
Parses the given PLY data and returns the resulting geometry.

**Kind**: instance method of [<code>PLYLoader</code>](#PLYLoader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw PLY data as an array buffer. |

<a name="PVRLoader"></a>

## PVRLoader ⇐ <code>CompressedTextureLoader</code>
A loader for the PVRTC texture compression format.

```js
const loader = new PVRLoader();

const map = loader.load( 'textures/compressed/disturb_4bpp_rgb.pvr' );
map.colorSpace = THREE.SRGBColorSpace; // only for color textures
```

**Kind**: global class  
**Extends**: <code>CompressedTextureLoader</code>  

* [PVRLoader](#PVRLoader) ⇐ <code>CompressedTextureLoader</code>
    * [new PVRLoader([manager])](#new_PVRLoader_new)
    * [.parse(buffer, loadMipmaps)](#PVRLoader+parse) ⇒ <code>CompressedTextureLoader~TexData</code>

<a name="new_PVRLoader_new"></a>

### new PVRLoader([manager])
Constructs a new PVR loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="PVRLoader+parse"></a>

### pvrLoader.parse(buffer, loadMipmaps) ⇒ <code>CompressedTextureLoader~TexData</code>
Parses the given PVRTC texture data.

**Kind**: instance method of [<code>PVRLoader</code>](#PVRLoader)  
**Returns**: <code>CompressedTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |
| loadMipmaps | <code>boolean</code> | Whether to load mipmaps or not. This option is not yet supported by the loader. |

<a name="RGBELoader"></a>

## RGBELoader ⇐ <code>DataTextureLoader</code>
A loader for the RGBE HDR texture format.

```js
const loader = new RGBELoader();
const envMap = await loader.loadAsync( 'textures/equirectangular/blouberg_sunrise_2_1k.hdr' );
envMap.mapping = THREE.EquirectangularReflectionMapping;

scene.environment = envMap;
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [RGBELoader](#RGBELoader) ⇐ <code>DataTextureLoader</code>
    * [new RGBELoader([manager])](#new_RGBELoader_new)
    * [.type](#RGBELoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.parse(buffer)](#RGBELoader+parse) ⇒ <code>DataTextureLoader~TexData</code>
    * [.setDataType(value)](#RGBELoader+setDataType) ⇒ [<code>RGBELoader</code>](#RGBELoader)

<a name="new_RGBELoader_new"></a>

### new RGBELoader([manager])
Constructs a new RGBE loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="RGBELoader+type"></a>

### rgbeLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>RGBELoader</code>](#RGBELoader)  
**Default**: <code>HalfFloatType</code>  
<a name="RGBELoader+parse"></a>

### rgbeLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given RGBE texture data.

**Kind**: instance method of [<code>RGBELoader</code>](#RGBELoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="RGBELoader+setDataType"></a>

### rgbeLoader.setDataType(value) ⇒ [<code>RGBELoader</code>](#RGBELoader)
Sets the texture type.

**Kind**: instance method of [<code>RGBELoader</code>](#RGBELoader)  
**Returns**: [<code>RGBELoader</code>](#RGBELoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="RGBMLoader"></a>

## RGBMLoader ⇐ <code>DataTextureLoader</code>
A loader for the RGBM HDR texture format.

```js
const loader = new RGBMLoader();
loader.setMaxRange( 16 );

const texture = await loader.loadAsync( 'textures/memorial.png' );
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [RGBMLoader](#RGBMLoader) ⇐ <code>DataTextureLoader</code>
    * [new RGBMLoader([manager])](#new_RGBMLoader_new)
    * [.type](#RGBMLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.maxRange](#RGBMLoader+maxRange) : <code>7</code> \| <code>16</code>
    * [.setDataType(value)](#RGBMLoader+setDataType) ⇒ [<code>RGBMLoader</code>](#RGBMLoader)
    * [.setMaxRange(value)](#RGBMLoader+setMaxRange) ⇒ [<code>RGBMLoader</code>](#RGBMLoader)
    * [.loadCubemap(urls, onLoad, onProgress, onError)](#RGBMLoader+loadCubemap) ⇒ <code>CubeTexture</code>
    * [.loadCubemapAsync(urls, onProgress)](#RGBMLoader+loadCubemapAsync) ⇒ <code>Promise.&lt;CubeTexture&gt;</code>
    * [.parse(buffer)](#RGBMLoader+parse) ⇒ <code>DataTextureLoader~TexData</code>

<a name="new_RGBMLoader_new"></a>

### new RGBMLoader([manager])
Constructs a new RGBM loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="RGBMLoader+type"></a>

### rgbmLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>RGBMLoader</code>](#RGBMLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="RGBMLoader+maxRange"></a>

### rgbmLoader.maxRange : <code>7</code> \| <code>16</code>
More information about this property at [The difference between RGBM and RGBD](https://iwasbeingirony.blogspot.com/2010/06/difference-between-rgbm-and-rgbd.html)

**Kind**: instance property of [<code>RGBMLoader</code>](#RGBMLoader)  
**Default**: <code>7</code>  
<a name="RGBMLoader+setDataType"></a>

### rgbmLoader.setDataType(value) ⇒ [<code>RGBMLoader</code>](#RGBMLoader)
Sets the texture type.

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: [<code>RGBMLoader</code>](#RGBMLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="RGBMLoader+setMaxRange"></a>

### rgbmLoader.setMaxRange(value) ⇒ [<code>RGBMLoader</code>](#RGBMLoader)
Sets the maximum range.

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: [<code>RGBMLoader</code>](#RGBMLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>7</code> \| <code>16</code> | The maximum range to set. |

<a name="RGBMLoader+loadCubemap"></a>

### rgbmLoader.loadCubemap(urls, onLoad, onProgress, onError) ⇒ <code>CubeTexture</code>
Starts loading from the given URLs and passes the loaded RGBM cube map
to the `onLoad()` callback.

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: <code>CubeTexture</code> - The cube texture.  

| Param | Type | Description |
| --- | --- | --- |
| urls | <code>Array.&lt;string&gt;</code> | The paths/URLs of the files to be loaded. This can also be a data URIs. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="RGBMLoader+loadCubemapAsync"></a>

### rgbmLoader.loadCubemapAsync(urls, onProgress) ⇒ <code>Promise.&lt;CubeTexture&gt;</code>
Async version of [loadCubemap](#RGBMLoader+loadCubemap).

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: <code>Promise.&lt;CubeTexture&gt;</code> - A Promise that resolves with the loaded cube map.  

| Param | Type | Description |
| --- | --- | --- |
| urls | <code>Array.&lt;string&gt;</code> | The paths/URLs of the files to be loaded. This can also be a data URIs. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |

<a name="RGBMLoader+parse"></a>

### rgbmLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given RGBM texture data.

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="STLLoader"></a>

## STLLoader ⇐ <code>Loader</code>
A loader for the STL format, as created by Solidworks and other CAD programs.

Supports both binary and ASCII encoded files. The loader returns a non-indexed buffer geometry.

Limitations:
- Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
- There is perhaps some question as to how valid it is to always assume little-endian-ness.
- ASCII decoding assumes file is UTF-8.

```js
const loader = new STLLoader();
const geometry = await loader.loadAsync( './models/stl/slotted_disk.stl' )
scene.add( new THREE.Mesh( geometry ) );
```
For binary STLs geometry might contain colors for vertices. To use it:
```js
// use the same code to load STL as above
if ( geometry.hasColors ) {
	material = new THREE.MeshPhongMaterial( { opacity: geometry.alpha, vertexColors: true } );
}
const mesh = new THREE.Mesh( geometry, material );
```
For ASCII STLs containing multiple solids, each solid is assigned to a different group.
Groups can be used to assign a different color by defining an array of materials with the same length of
geometry.groups and passing it to the Mesh constructor:

```js
const materials = [];
const nGeometryGroups = geometry.groups.length;

for ( let i = 0; i < nGeometryGroups; i ++ ) {
	const material = new THREE.MeshPhongMaterial( { color: colorMap[ i ], wireframe: false } );
	materials.push( material );
}

const mesh = new THREE.Mesh(geometry, materials);
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [STLLoader](#STLLoader) ⇐ <code>Loader</code>
    * [new STLLoader([manager])](#new_STLLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#STLLoader+load)
    * [.parse(data)](#STLLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_STLLoader_new"></a>

### new STLLoader([manager])
Constructs a new STL loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="STLLoader+load"></a>

### stlLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded STL asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>STLLoader</code>](#STLLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="STLLoader+parse"></a>

### stlLoader.parse(data) ⇒ <code>BufferGeometry</code>
Parses the given STL data and returns the resulting geometry.

**Kind**: instance method of [<code>STLLoader</code>](#STLLoader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw STL data as an array buffer. |

<a name="SVGLoader"></a>

## SVGLoader ⇐ <code>Loader</code>
A loader for the SVG format.

Scalable Vector Graphics is an XML-based vector image format for two-dimensional graphics
with support for interactivity and animation.

```js
const loader = new SVGLoader();
const data = await loader.loadAsync( 'data/svgSample.svg' );

const paths = data.paths;
const group = new THREE.Group();

for ( let i = 0; i < paths.length; i ++ ) {

	const path = paths[ i ];
	const material = new THREE.MeshBasicMaterial( {
		color: path.color,
		side: THREE.DoubleSide,
		depthWrite: false
	} );

	const shapes = SVGLoader.createShapes( path );

	for ( let j = 0; j < shapes.length; j ++ ) {

		const shape = shapes[ j ];
		const geometry = new THREE.ShapeGeometry( shape );
		const mesh = new THREE.Mesh( geometry, material );
		group.add( mesh );

	}

}

scene.add( group );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [SVGLoader](#SVGLoader) ⇐ <code>Loader</code>
    * [new SVGLoader([manager])](#new_SVGLoader_new)
    * _instance_
        * [.defaultDPI](#SVGLoader+defaultDPI) : <code>number</code>
        * [.defaultUnit](#SVGLoader+defaultUnit) : <code>&#x27;mm&#x27;</code> \| <code>&#x27;cm&#x27;</code> \| <code>&#x27;in&#x27;</code> \| <code>&#x27;pt&#x27;</code> \| <code>&#x27;pc&#x27;</code> \| <code>&#x27;px&#x27;</code>
        * [.load(url, onLoad, onProgress, onError)](#SVGLoader+load)
        * [.parse(text)](#SVGLoader+parse) ⇒ <code>Object</code>
    * _static_
        * [.createShapes(shapePath)](#SVGLoader.createShapes) ⇒ <code>Array.&lt;Shape&gt;</code>
        * [.getStrokeStyle([width], [color], [lineJoin], [lineCap], [miterLimit])](#SVGLoader.getStrokeStyle) ⇒ <code>Object</code>
        * [.pointsToStroke(points, style, [arcDivisions], [minDistance])](#SVGLoader.pointsToStroke) ⇒ <code>BufferGeometry</code>
        * [.pointsToStrokeWithBuffers(points, style, [arcDivisions], [minDistance], vertices, normals, uvs, [vertexOffset])](#SVGLoader.pointsToStrokeWithBuffers) ⇒ <code>number</code>

<a name="new_SVGLoader_new"></a>

### new SVGLoader([manager])
Constructs a new SVG loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="SVGLoader+defaultDPI"></a>

### svgLoader.defaultDPI : <code>number</code>
Default dots per inch.

**Kind**: instance property of [<code>SVGLoader</code>](#SVGLoader)  
**Default**: <code>90</code>  
<a name="SVGLoader+defaultUnit"></a>

### svgLoader.defaultUnit : <code>&#x27;mm&#x27;</code> \| <code>&#x27;cm&#x27;</code> \| <code>&#x27;in&#x27;</code> \| <code>&#x27;pt&#x27;</code> \| <code>&#x27;pc&#x27;</code> \| <code>&#x27;px&#x27;</code>
Default unit.

**Kind**: instance property of [<code>SVGLoader</code>](#SVGLoader)  
**Default**: <code>&#x27;px&#x27;</code>  
<a name="SVGLoader+load"></a>

### svgLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded SVG asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>SVGLoader</code>](#SVGLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="SVGLoader+parse"></a>

### svgLoader.parse(text) ⇒ <code>Object</code>
Parses the given SVG data and returns the resulting data.

**Kind**: instance method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>Object</code> - An object holding an array of shape paths and the
SVG XML document.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw SVG data as a string. |

<a name="SVGLoader.createShapes"></a>

### SVGLoader.createShapes(shapePath) ⇒ <code>Array.&lt;Shape&gt;</code>
Creates from the given shape path and array of shapes.

**Kind**: static method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>Array.&lt;Shape&gt;</code> - An array of shapes.  

| Param | Type | Description |
| --- | --- | --- |
| shapePath | <code>ShapePath</code> | The shape path. |

<a name="SVGLoader.getStrokeStyle"></a>

### SVGLoader.getStrokeStyle([width], [color], [lineJoin], [lineCap], [miterLimit]) ⇒ <code>Object</code>
Returns a stroke style object from the given parameters.

**Kind**: static method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>Object</code> - The style object.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The stroke width. |
| [color] | <code>string</code> | <code>&quot;&#x27;#000&#x27;&quot;</code> | The stroke color, as  returned by [Color#getStyle](Color#getStyle). |
| [lineJoin] | <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code> \| <code>&#x27;miter-limit&#x27;</code> | <code>&#x27;miter&#x27;</code> | The line join style. |
| [lineCap] | <code>&#x27;round&#x27;</code> \| <code>&#x27;square&#x27;</code> \| <code>&#x27;butt&#x27;</code> | <code>&#x27;butt&#x27;</code> | The line cap style. |
| [miterLimit] | <code>number</code> | <code>4</code> | Maximum join length, in multiples of the `width` parameter (join is truncated if it exceeds that distance). |

<a name="SVGLoader.pointsToStroke"></a>

### SVGLoader.pointsToStroke(points, style, [arcDivisions], [minDistance]) ⇒ <code>BufferGeometry</code>
Creates a stroke from an array of points.

**Kind**: static method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>BufferGeometry</code> - The stroke geometry. UV coordinates are generated ('u' along path. 'v' across it, from left to right).
Returns `null` if not geometry was generated.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> |  | The points in 2D space. Minimum 2 points. The path can be open or closed (last point equals to first point). |
| style | <code>Object</code> |  | Object with SVG properties as returned by `SVGLoader.getStrokeStyle()`, or `SVGLoader.parse()` in the `path.userData.style` object. |
| [arcDivisions] | <code>number</code> | <code>12</code> | Arc divisions for round joins and endcaps. |
| [minDistance] | <code>number</code> | <code>0.001</code> | Points closer to this distance will be merged. |

<a name="SVGLoader.pointsToStrokeWithBuffers"></a>

### SVGLoader.pointsToStrokeWithBuffers(points, style, [arcDivisions], [minDistance], vertices, normals, uvs, [vertexOffset]) ⇒ <code>number</code>
Creates a stroke from an array of points.

**Kind**: static method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>number</code> - The number of vertices.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> |  | The points in 2D space. Minimum 2 points. |
| style | <code>Object</code> |  | Object with SVG properties as returned by `SVGLoader.getStrokeStyle()`, or `SVGLoader.parse()` in the `path.userData.style` object. |
| [arcDivisions] | <code>number</code> | <code>12</code> | Arc divisions for round joins and endcaps. |
| [minDistance] | <code>number</code> | <code>0.001</code> | Points closer to this distance will be merged. |
| vertices | <code>Array.&lt;number&gt;</code> |  | An array holding vertices. |
| normals | <code>Array.&lt;number&gt;</code> |  | An array holding normals. |
| uvs | <code>Array.&lt;number&gt;</code> |  | An array holding uvs. |
| [vertexOffset] | <code>number</code> | <code>0</code> | The vertex offset. |

<a name="TDSLoader"></a>

## TDSLoader ⇐ <code>Loader</code>
A loader for the 3DS format, based on lib3ds.

Loads geometry with uv and materials basic properties with texture support.

```js
const loader = new TDSLoader();
loader.setResourcePath( 'models/3ds/portalgun/textures/' );
const object = await loader.loadAsync( 'models/3ds/portalgun/portalgun.3ds' );
scene.add( object );

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [TDSLoader](#TDSLoader) ⇐ <code>Loader</code>
    * [new TDSLoader([manager])](#new_TDSLoader_new)
    * [.debug](#TDSLoader+debug) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#TDSLoader+load)
    * [.parse(arraybuffer, path)](#TDSLoader+parse) ⇒ <code>Group</code>

<a name="new_TDSLoader_new"></a>

### new TDSLoader([manager])
Constructs a new 3DS loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TDSLoader+debug"></a>

### tdsLoader.debug : <code>boolean</code>
Whether debug mode should be enabled or not.

**Kind**: instance property of [<code>TDSLoader</code>](#TDSLoader)  
**Default**: <code>false</code>  
<a name="TDSLoader+load"></a>

### tdsLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded 3DS asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>TDSLoader</code>](#TDSLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="TDSLoader+parse"></a>

### tdsLoader.parse(arraybuffer, path) ⇒ <code>Group</code>
Parses the given 3DS data and returns the resulting data.

**Kind**: instance method of [<code>TDSLoader</code>](#TDSLoader)  
**Returns**: <code>Group</code> - The parsed asset represented as a group.  

| Param | Type | Description |
| --- | --- | --- |
| arraybuffer | <code>ArrayBuffer</code> | The raw 3DS data as an array buffer. |
| path | <code>string</code> | The asset path. |

<a name="TGALoader"></a>

## TGALoader ⇐ <code>DataTextureLoader</code>
A loader for the TGA texture format.

```js
const loader = new TGALoader();
const texture = await loader.loadAsync( 'textures/crate_color8.tga' );
texture.colorSpace = THREE.SRGBColorSpace; // only for color textures
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [TGALoader](#TGALoader) ⇐ <code>DataTextureLoader</code>
    * [new TGALoader([manager])](#new_TGALoader_new)
    * [.parse(buffer)](#TGALoader+parse) ⇒ <code>DataTextureLoader~TexData</code>

<a name="new_TGALoader_new"></a>

### new TGALoader([manager])
Constructs a new TGA loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TGALoader+parse"></a>

### tgaLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given TGA texture data.

**Kind**: instance method of [<code>TGALoader</code>](#TGALoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="TIFFLoader"></a>

## TIFFLoader ⇐ <code>DataTextureLoader</code>
A loader for the TIFF texture format.

```js
const loader = new TIFFLoader();
const texture = await loader.loadAsync( 'textures/tiff/crate_lzw.tif' );
texture.colorSpace = THREE.SRGBColorSpace;
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [TIFFLoader](#TIFFLoader) ⇐ <code>DataTextureLoader</code>
    * [new TIFFLoader([manager])](#new_TIFFLoader_new)
    * [.parse(buffer)](#TIFFLoader+parse) ⇒ <code>DataTextureLoader~TexData</code>

<a name="new_TIFFLoader_new"></a>

### new TIFFLoader([manager])
Constructs a new TIFF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TIFFLoader+parse"></a>

### tiffLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given TIFF texture data.

**Kind**: instance method of [<code>TIFFLoader</code>](#TIFFLoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="TTFLoader"></a>

## TTFLoader ⇐ <code>Loader</code>
A loader for the TTF format.

Loads TTF files and converts them into typeface JSON that can be used directly
to create THREE.Font objects.

```js
const loader = new TTFLoader();
const json = await loader.loadAsync( 'fonts/ttf/kenpixel.ttf' );
const font = new Font( json );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [TTFLoader](#TTFLoader) ⇐ <code>Loader</code>
    * [new TTFLoader([manager])](#new_TTFLoader_new)
    * [.reversed](#TTFLoader+reversed) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#TTFLoader+load)
    * [.parse(arraybuffer)](#TTFLoader+parse) ⇒ <code>Object</code>

<a name="new_TTFLoader_new"></a>

### new TTFLoader([manager])
Constructs a new TTF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TTFLoader+reversed"></a>

### ttfLoader.reversed : <code>boolean</code>
Whether the TTF commands should be reversed or not.

**Kind**: instance property of [<code>TTFLoader</code>](#TTFLoader)  
**Default**: <code>false</code>  
<a name="TTFLoader+load"></a>

### ttfLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded TTF asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>TTFLoader</code>](#TTFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="TTFLoader+parse"></a>

### ttfLoader.parse(arraybuffer) ⇒ <code>Object</code>
Parses the given TTF data and returns a JSON for creating a font.

**Kind**: instance method of [<code>TTFLoader</code>](#TTFLoader)  
**Returns**: <code>Object</code> - The result JSON.  

| Param | Type | Description |
| --- | --- | --- |
| arraybuffer | <code>ArrayBuffer</code> | The raw TTF data as an array buffer. |

<a name="USDZLoader"></a>

## USDZLoader ⇐ <code>Loader</code>
A loader for the USDZ format.

USDZ files that use USDC internally are not yet supported, only USDA.

```js
const loader = new USDZLoader();
const model = await loader.loadAsync( 'saeukkang.usdz' );
scene.add( model );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [USDZLoader](#USDZLoader) ⇐ <code>Loader</code>
    * [new USDZLoader([manager])](#new_USDZLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#USDZLoader+load)
    * [.parse(buffer)](#USDZLoader+parse) ⇒ <code>Group</code>

<a name="new_USDZLoader_new"></a>

### new USDZLoader([manager])
Constructs a new USDZ loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="USDZLoader+load"></a>

### usdzLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded USDZ asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>USDZLoader</code>](#USDZLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="USDZLoader+parse"></a>

### usdzLoader.parse(buffer) ⇒ <code>Group</code>
Parses the given USDZ data and returns the resulting group.

**Kind**: instance method of [<code>USDZLoader</code>](#USDZLoader)  
**Returns**: <code>Group</code> - The parsed asset as a group.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw USDZ data as an array buffer. |

## Classes

<dl>
<dt><a href="#UltraHDRLoader">UltraHDRLoader</a> ⇐ <code>Loader</code></dt>
<dd><p>A loader for the Ultra HDR Image Format.</p>
<p>Existing HDR or EXR textures can be converted to Ultra HDR with this <a href="https://gainmap-creator.monogrid.com/">tool</a>.</p>
<p>Current feature set:</p>
<ul>
<li>JPEG headers (required)</li>
<li>XMP metadata (required)</li>
<li>XMP validation (not implemented)</li>
<li>EXIF profile (not implemented)</li>
<li>ICC profile (not implemented)</li>
<li>Binary storage for SDR &amp; HDR images (required)</li>
<li>Gainmap metadata (required)</li>
<li>Non-JPEG image formats (not implemented)</li>
<li>Primary image as an HDR image (not implemented)</li>
</ul>
<pre><code class="language-js">const loader = new UltraHDRLoader();
const texture = await loader.loadAsync( &#39;textures/equirectangular/ice_planet_close.jpg&#39; );
texture.mapping = THREE.EquirectangularReflectionMapping;

scene.background = texture;
scene.environment = texture;
</code></pre>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#SRGB_TO_LINEAR">SRGB_TO_LINEAR</a></dt>
<dd><p>UltraHDR Image Format - <a href="https://developer.android.com/media/platform/hdr-image-format">https://developer.android.com/media/platform/hdr-image-format</a></p>
<p>Short format brief:</p>
<p> [JPEG headers]
 [XMP metadata describing the MPF container and <em>both</em> SDR and gainmap images]
 [Optional metadata] [EXIF] [ICC Profile]
 [SDR image]
 [XMP metadata describing only the gainmap image]
 [Gainmap image]</p>
<p>Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)
Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.</p>
</dd>
</dl>

<a name="UltraHDRLoader"></a>

## UltraHDRLoader ⇐ <code>Loader</code>
A loader for the Ultra HDR Image Format.

Existing HDR or EXR textures can be converted to Ultra HDR with this [tool](https://gainmap-creator.monogrid.com/).

Current feature set:
- JPEG headers (required)
- XMP metadata (required)
- XMP validation (not implemented)
- EXIF profile (not implemented)
- ICC profile (not implemented)
- Binary storage for SDR & HDR images (required)
- Gainmap metadata (required)
- Non-JPEG image formats (not implemented)
- Primary image as an HDR image (not implemented)

```js
const loader = new UltraHDRLoader();
const texture = await loader.loadAsync( 'textures/equirectangular/ice_planet_close.jpg' );
texture.mapping = THREE.EquirectangularReflectionMapping;

scene.background = texture;
scene.environment = texture;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [UltraHDRLoader](#UltraHDRLoader) ⇐ <code>Loader</code>
    * [new UltraHDRLoader([manager])](#new_UltraHDRLoader_new)
    * [.type](#UltraHDRLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.setDataType(value)](#UltraHDRLoader+setDataType) ⇒ <code>RGBELoader</code>
    * [.parse(buffer, onLoad)](#UltraHDRLoader+parse)
    * [.load(url, onLoad, onProgress, onError)](#UltraHDRLoader+load) ⇒ <code>DataTexture</code>

<a name="new_UltraHDRLoader_new"></a>

### new UltraHDRLoader([manager])
Constructs a new Ultra HDR loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="UltraHDRLoader+type"></a>

### ultraHDRLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>UltraHDRLoader</code>](#UltraHDRLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="UltraHDRLoader+setDataType"></a>

### ultraHDRLoader.setDataType(value) ⇒ <code>RGBELoader</code>
Sets the texture type.

**Kind**: instance method of [<code>UltraHDRLoader</code>](#UltraHDRLoader)  
**Returns**: <code>RGBELoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="UltraHDRLoader+parse"></a>

### ultraHDRLoader.parse(buffer, onLoad)
Parses the given Ultra HDR texture data.

**Kind**: instance method of [<code>UltraHDRLoader</code>](#UltraHDRLoader)  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |
| onLoad | <code>function</code> | The `onLoad` callback. |

<a name="UltraHDRLoader+load"></a>

### ultraHDRLoader.load(url, onLoad, onProgress, onError) ⇒ <code>DataTexture</code>
Starts loading from the given URL and passes the loaded Ultra HDR texture
to the `onLoad()` callback.

**Kind**: instance method of [<code>UltraHDRLoader</code>](#UltraHDRLoader)  
**Returns**: <code>DataTexture</code> - The Ultra HDR texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the files to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="SRGB_TO_LINEAR"></a>

## SRGB\_TO\_LINEAR
UltraHDR Image Format - https://developer.android.com/media/platform/hdr-image-format

Short format brief:

 [JPEG headers]
 [XMP metadata describing the MPF container and *both* SDR and gainmap images]
 [Optional metadata] [EXIF] [ICC Profile]
 [SDR image]
 [XMP metadata describing only the gainmap image]
 [Gainmap image]

Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)
Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.

**Kind**: global constant  
## Classes

<dl>
<dt><a href="#VOXLoader">VOXLoader</a> ⇐ <code>Loader</code></dt>
<dd><p>A loader for the VOX format.</p>
<pre><code class="language-js">const loader = new VOXLoader();
const chunks = await loader.loadAsync( &#39;models/vox/monu10.vox&#39; );

for ( let i = 0; i &lt; chunks.length; i ++ ) {

    const chunk = chunks[ i ];
    const mesh = new VOXMesh( chunk );
    mesh.scale.setScalar( 0.0015 );
    scene.add( mesh );

}
</code></pre>
</dd>
<dt><a href="#VOXMesh">VOXMesh</a> ⇐ <code>Mesh</code></dt>
<dd><p>A VOX mesh.</p>
<p>Instances of this class are created from the loaded chunks of <a href="#VOXLoader">VOXLoader</a>.</p>
</dd>
<dt><a href="#VOXData3DTexture">VOXData3DTexture</a> ⇐ <code>Data3DTexture</code></dt>
<dd><p>A VOX 3D texture.</p>
<p>Instances of this class are created from the loaded chunks of <a href="#VOXLoader">VOXLoader</a>.</p>
</dd>
</dl>

<a name="VOXLoader"></a>

## VOXLoader ⇐ <code>Loader</code>
A loader for the VOX format.

```js
const loader = new VOXLoader();
const chunks = await loader.loadAsync( 'models/vox/monu10.vox' );

for ( let i = 0; i < chunks.length; i ++ ) {

	const chunk = chunks[ i ];
	const mesh = new VOXMesh( chunk );
	mesh.scale.setScalar( 0.0015 );
	scene.add( mesh );

}
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [VOXLoader](#VOXLoader) ⇐ <code>Loader</code>
    * [.load(url, onLoad, onProgress, onError)](#VOXLoader+load)
    * [.parse(buffer)](#VOXLoader+parse) ⇒ <code>Array.&lt;Object&gt;</code>

<a name="VOXLoader+load"></a>

### voxLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded VOX asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>VOXLoader</code>](#VOXLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="VOXLoader+parse"></a>

### voxLoader.parse(buffer) ⇒ <code>Array.&lt;Object&gt;</code>
Parses the given VOX data and returns the resulting chunks.

**Kind**: instance method of [<code>VOXLoader</code>](#VOXLoader)  
**Returns**: <code>Array.&lt;Object&gt;</code> - The parsed chunks.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw VOX data as an array buffer. |

<a name="VOXMesh"></a>

## VOXMesh ⇐ <code>Mesh</code>
A VOX mesh.

Instances of this class are created from the loaded chunks of [VOXLoader](#VOXLoader).

**Kind**: global class  
**Extends**: <code>Mesh</code>  
<a name="new_VOXMesh_new"></a>

### new VOXMesh(chunk)
Constructs a new VOX mesh.


| Param | Type | Description |
| --- | --- | --- |
| chunk | <code>Object</code> | A VOX chunk loaded via [VOXLoader](#VOXLoader). |

<a name="VOXData3DTexture"></a>

## VOXData3DTexture ⇐ <code>Data3DTexture</code>
A VOX 3D texture.

Instances of this class are created from the loaded chunks of [VOXLoader](#VOXLoader).

**Kind**: global class  
**Extends**: <code>Data3DTexture</code>  
<a name="new_VOXData3DTexture_new"></a>

### new VOXData3DTexture(chunk)
Constructs a new VOX 3D texture.


| Param | Type | Description |
| --- | --- | --- |
| chunk | <code>Object</code> | A VOX chunk loaded via [VOXLoader](#VOXLoader). |

<a name="VRMLLoader"></a>

## VRMLLoader ⇐ <code>Loader</code>
A loader for the VRML format.

```js
const loader = new VRMLLoader();
const object = await loader.loadAsync( 'models/vrml/house.wrl' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [VRMLLoader](#VRMLLoader) ⇐ <code>Loader</code>
    * [new VRMLLoader([manager])](#new_VRMLLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#VRMLLoader+load)
    * [.parse(data, path)](#VRMLLoader+parse) ⇒ <code>Scene</code>

<a name="new_VRMLLoader_new"></a>

### new VRMLLoader([manager])
Constructs a new VRML loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="VRMLLoader+load"></a>

### vrmlLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded VRML asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>VRMLLoader</code>](#VRMLLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="VRMLLoader+parse"></a>

### vrmlLoader.parse(data, path) ⇒ <code>Scene</code>
Parses the given VRML data and returns the resulting scene.

**Kind**: instance method of [<code>VRMLLoader</code>](#VRMLLoader)  
**Returns**: <code>Scene</code> - The parsed scene.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>string</code> | The raw VRML data as a string. |
| path | <code>string</code> | The URL base path. |

<a name="VTKLoader"></a>

## VTKLoader ⇐ <code>Loader</code>
A loader for the VTK format.

This loader only supports the `POLYDATA` dataset format so far. Other formats
(structured points, structured grid, rectilinear grid, unstructured grid, appended)
are not supported.

```js
const loader = new VTKLoader();
const geometry = await loader.loadAsync( 'models/vtk/liver.vtk' );
geometry.computeVertexNormals();

const mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial() );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [VTKLoader](#VTKLoader) ⇐ <code>Loader</code>
    * [new VTKLoader([manager])](#new_VTKLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#VTKLoader+load)
    * [.parse(data)](#VTKLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_VTKLoader_new"></a>

### new VTKLoader([manager])
Constructs a new VTK loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="VTKLoader+load"></a>

### vtkLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded VRML asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>VTKLoader</code>](#VTKLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="VTKLoader+parse"></a>

### vtkLoader.parse(data) ⇒ <code>BufferGeometry</code>
Parses the given VTK data and returns the resulting geometry.

**Kind**: instance method of [<code>VTKLoader</code>](#VTKLoader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw VTK data as an array buffer |

<a name="XYZLoader"></a>

## XYZLoader ⇐ <code>Loader</code>
A loader for the XYZ format.

XYZ is a very simple format for storing point clouds. The layouts
`XYZ` (points) and `XYZRGB` (points + colors) are supported.

```js
const loader = new XYZLoader();
const geometry = await loader.loadAsync( 'models/xyz/helix_201.xyz' );
geometry.center();

const vertexColors = ( geometry.hasAttribute( 'color' ) === true );
const material = new THREE.PointsMaterial( { size: 0.1, vertexColors: vertexColors } );

const points = new THREE.Points( geometry, material );
scene.add( points );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [XYZLoader](#XYZLoader) ⇐ <code>Loader</code>
    * [.load(url, onLoad, onProgress, onError)](#XYZLoader+load)
    * [.parse(text)](#XYZLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="XYZLoader+load"></a>

### xyzLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded XYZ asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>XYZLoader</code>](#XYZLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="XYZLoader+parse"></a>

### xyzLoader.parse(text) ⇒ <code>BufferGeometry</code>
Parses the given XYZ data and returns the resulting geometry.

**Kind**: instance method of [<code>XYZLoader</code>](#XYZLoader)  
**Returns**: <code>BufferGeometry</code> - The geometry representing the point cloud.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw XYZ data as a string. |

<a name="LDrawConditionalLineMaterial"></a>

## LDrawConditionalLineMaterial ⇐ <code>ShaderMaterial</code>
A special line material for meshes loaded via [LDrawLoader](LDrawLoader).

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the class from `LDrawConditionalLineNodeMaterial.js`.

**Kind**: global class  
**Extends**: <code>ShaderMaterial</code>  

* [LDrawConditionalLineMaterial](#LDrawConditionalLineMaterial) ⇐ <code>ShaderMaterial</code>
    * [new LDrawConditionalLineMaterial([parameters])](#new_LDrawConditionalLineMaterial_new)
    * [.opacity](#LDrawConditionalLineMaterial+opacity) : <code>number</code>
    * [.color](#LDrawConditionalLineMaterial+color) : <code>Color</code>
    * [.isLDrawConditionalLineMaterial](#LDrawConditionalLineMaterial+isLDrawConditionalLineMaterial) : <code>boolean</code>

<a name="new_LDrawConditionalLineMaterial_new"></a>

### new LDrawConditionalLineMaterial([parameters])
Constructs a new conditional line material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="LDrawConditionalLineMaterial+opacity"></a>

### lDrawConditionalLineMaterial.opacity : <code>number</code>
The material's opacity.

**Kind**: instance property of [<code>LDrawConditionalLineMaterial</code>](#LDrawConditionalLineMaterial)  
**Default**: <code>1</code>  
<a name="LDrawConditionalLineMaterial+color"></a>

### lDrawConditionalLineMaterial.color : <code>Color</code>
The material's color.

**Kind**: instance property of [<code>LDrawConditionalLineMaterial</code>](#LDrawConditionalLineMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="LDrawConditionalLineMaterial+isLDrawConditionalLineMaterial"></a>

### lDrawConditionalLineMaterial.isLDrawConditionalLineMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LDrawConditionalLineMaterial</code>](#LDrawConditionalLineMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPostProcessingMaterial"></a>

## MeshPostProcessingMaterial ⇐ <code>MeshPhysicalMaterial</code>
The aim of this mesh material is to use information from a post processing pass in the diffuse color pass.
This material is based on the MeshPhysicalMaterial.

In the current state, only the information of a screen space AO pass can be used in the material.
Actually, the output of any screen space AO (SSAO, GTAO) can be used,
as it is only necessary to provide the AO in one color channel of a texture,
however the AO pass must be rendered prior to the color pass,
which makes the post-processing pass somewhat of a pre-processing pass.
Fot this purpose a new map (`aoPassMap`) is added to the material.
The value of the map is used the same way as the `aoMap` value.

Motivation to use the outputs AO pass directly in the material:
The incident light of a fragment is composed of ambient light, direct light and indirect light
Ambient Occlusion only occludes ambient light and environment light, but not direct light.
Direct light is only occluded by geometry that casts shadows.
And of course the emitted light should not be darkened by ambient occlusion either.
This cannot be achieved if the AO post processing pass is simply blended with the diffuse render pass.

Further extension work might be to use the output of an SSR pass or an HBIL pass from a previous frame.
This would then create the possibility of SSR and IR depending on material properties such as `roughness`, `metalness` and `reflectivity`.

**Kind**: global class  
**Extends**: <code>MeshPhysicalMaterial</code>  

* [MeshPostProcessingMaterial](#MeshPostProcessingMaterial) ⇐ <code>MeshPhysicalMaterial</code>
    * [new MeshPostProcessingMaterial([parameters])](#new_MeshPostProcessingMaterial_new)
    * [.aoPassMapScale](#MeshPostProcessingMaterial+aoPassMapScale) : <code>number</code>
    * [.aoPassMap](#MeshPostProcessingMaterial+aoPassMap) : <code>Texture</code>

<a name="new_MeshPostProcessingMaterial_new"></a>

### new MeshPostProcessingMaterial([parameters])
Constructs a new conditional line material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshPostProcessingMaterial+aoPassMapScale"></a>

### meshPostProcessingMaterial.aoPassMapScale : <code>number</code>
The scale of the AO pass.

**Kind**: instance property of [<code>MeshPostProcessingMaterial</code>](#MeshPostProcessingMaterial)  
**Default**: <code>1</code>  
<a name="MeshPostProcessingMaterial+aoPassMap"></a>

### meshPostProcessingMaterial.aoPassMap : <code>Texture</code>
A texture representing the AO pass.

**Kind**: instance property of [<code>MeshPostProcessingMaterial</code>](#MeshPostProcessingMaterial)  
<a name="Capsule"></a>

## Capsule
A capsule is essentially a cylinder with hemispherical caps at both ends.
It can be thought of as a swept sphere, where a sphere is moved along a line segment.

Capsules are often used as bounding volumes (next to AABBs and bounding spheres).

**Kind**: global class  

* [Capsule](#Capsule)
    * [new Capsule([start], [end], [radius])](#new_Capsule_new)
    * [.start](#Capsule+start) : <code>Vector3</code>
    * [.end](#Capsule+end) : <code>Vector3</code>
    * [.radius](#Capsule+radius) : <code>number</code>
    * [.clone()](#Capsule+clone) ⇒ [<code>Capsule</code>](#Capsule)
    * [.set(start, end, radius)](#Capsule+set) ⇒ [<code>Capsule</code>](#Capsule)
    * [.copy(capsule)](#Capsule+copy) ⇒ [<code>Capsule</code>](#Capsule)
    * [.getCenter(target)](#Capsule+getCenter) ⇒ <code>Vector3</code>
    * [.translate(v)](#Capsule+translate) ⇒ [<code>Capsule</code>](#Capsule)
    * [.intersectsBox(box)](#Capsule+intersectsBox) ⇒ <code>boolean</code>

<a name="new_Capsule_new"></a>

### new Capsule([start], [end], [radius])
Constructs a new capsule.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [start] | <code>Vector3</code> |  | The start vector. |
| [end] | <code>Vector3</code> |  | The end vector. |
| [radius] | <code>number</code> | <code>1</code> | The capsule's radius. |

<a name="Capsule+start"></a>

### capsule.start : <code>Vector3</code>
The start vector.

**Kind**: instance property of [<code>Capsule</code>](#Capsule)  
<a name="Capsule+end"></a>

### capsule.end : <code>Vector3</code>
The end vector.

**Kind**: instance property of [<code>Capsule</code>](#Capsule)  
<a name="Capsule+radius"></a>

### capsule.radius : <code>number</code>
The capsule's radius.

**Kind**: instance property of [<code>Capsule</code>](#Capsule)  
**Default**: <code>1</code>  
<a name="Capsule+clone"></a>

### capsule.clone() ⇒ [<code>Capsule</code>](#Capsule)
Returns a new capsule with copied values from this instance.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: [<code>Capsule</code>](#Capsule) - A clone of this instance.  
<a name="Capsule+set"></a>

### capsule.set(start, end, radius) ⇒ [<code>Capsule</code>](#Capsule)
Sets the capsule components to the given values.
Please note that this method only copies the values from the given objects.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: [<code>Capsule</code>](#Capsule) - A reference to this capsule.  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>Vector3</code> | The start vector. |
| end | <code>Vector3</code> | The end vector |
| radius | <code>number</code> | The capsule's radius. |

<a name="Capsule+copy"></a>

### capsule.copy(capsule) ⇒ [<code>Capsule</code>](#Capsule)
Copies the values of the given capsule to this instance.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: [<code>Capsule</code>](#Capsule) - A reference to this capsule.  

| Param | Type | Description |
| --- | --- | --- |
| capsule | [<code>Capsule</code>](#Capsule) | The capsule to copy. |

<a name="Capsule+getCenter"></a>

### capsule.getCenter(target) ⇒ <code>Vector3</code>
Returns the center point of this capsule.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: <code>Vector3</code> - The center point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Capsule+translate"></a>

### capsule.translate(v) ⇒ [<code>Capsule</code>](#Capsule)
Adds the given offset to this capsule, effectively moving it in 3D space.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: [<code>Capsule</code>](#Capsule) - A reference to this capsule.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The offset that should be used to translate the capsule. |

<a name="Capsule+intersectsBox"></a>

### capsule.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box intersects with this capsule.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: <code>boolean</code> - Whether the given bounding box intersects with this capsule.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The bounding box to test. |

<a name="ColorConverter"></a>

## ColorConverter
A utility class with helper functions for color conversion.

**Kind**: global class  

* [ColorConverter](#ColorConverter)
    * [.setHSV(color, h, s, v)](#ColorConverter.setHSV) ⇒ <code>Color</code>
    * [.getHSV(color, target)](#ColorConverter.getHSV) ⇒ <code>Object</code>

<a name="ColorConverter.setHSV"></a>

### ColorConverter.setHSV(color, h, s, v) ⇒ <code>Color</code>
Sets the given HSV color definition to the given color object.

**Kind**: static method of [<code>ColorConverter</code>](#ColorConverter)  
**Returns**: <code>Color</code> - The update color.  

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Color</code> | The color to set. |
| h | <code>number</code> | The hue. |
| s | <code>number</code> | The saturation. |
| v | <code>number</code> | The value. |

<a name="ColorConverter.getHSV"></a>

### ColorConverter.getHSV(color, target) ⇒ <code>Object</code>
Returns a HSV color representation of the given color object.

**Kind**: static method of [<code>ColorConverter</code>](#ColorConverter)  
**Returns**: <code>Object</code> - The HSV color.  

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Color</code> | The color to get HSV values from. |
| target | <code>Object</code> | The target object that is used to store the method's result. |

<a name="module_ColorSpaces"></a>

## ColorSpaces

* [ColorSpaces](#module_ColorSpaces)
    * _static_
        * [.DisplayP3ColorSpace](#module_ColorSpaces.DisplayP3ColorSpace) : <code>string</code>
        * [.LinearDisplayP3ColorSpace](#module_ColorSpaces.LinearDisplayP3ColorSpace) : <code>string</code>
        * [.DisplayP3ColorSpaceImpl](#module_ColorSpaces.DisplayP3ColorSpaceImpl) : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
        * [.LinearDisplayP3ColorSpaceImpl](#module_ColorSpaces.LinearDisplayP3ColorSpaceImpl) : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
        * [.LinearRec2020ColorSpace](#module_ColorSpaces.LinearRec2020ColorSpace) : <code>string</code>
        * [.LinearRec2020ColorSpaceImpl](#module_ColorSpaces.LinearRec2020ColorSpaceImpl) : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
    * _inner_
        * [~ColorSpaceImpl](#module_ColorSpaces..ColorSpaceImpl) : <code>Object</code>

<a name="module_ColorSpaces.DisplayP3ColorSpace"></a>

### ColorSpaces.DisplayP3ColorSpace : <code>string</code>
Display-P3 color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.LinearDisplayP3ColorSpace"></a>

### ColorSpaces.LinearDisplayP3ColorSpace : <code>string</code>
Display-P3-Linear color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.DisplayP3ColorSpaceImpl"></a>

### ColorSpaces.DisplayP3ColorSpaceImpl : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
Implementation object for the Display-P3 color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.LinearDisplayP3ColorSpaceImpl"></a>

### ColorSpaces.LinearDisplayP3ColorSpaceImpl : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
Implementation object for the Display-P3-Linear color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.LinearRec2020ColorSpace"></a>

### ColorSpaces.LinearRec2020ColorSpace : <code>string</code>
Rec2020-Linear color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.LinearRec2020ColorSpaceImpl"></a>

### ColorSpaces.LinearRec2020ColorSpaceImpl : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
Implementation object for the Rec2020-Linear color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces..ColorSpaceImpl"></a>

### ColorSpaces~ColorSpaceImpl : <code>Object</code>
An object holding the color space implementation.

**Kind**: inner typedef of [<code>ColorSpaces</code>](#module_ColorSpaces)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| primaries | <code>Array.&lt;number&gt;</code> | The primaries. |
| whitePoint | <code>Array.&lt;number&gt;</code> | The white point. |
| toXYZ | <code>Matrix3</code> | A color space conversion matrix, converting to CIE XYZ. |
| fromXYZ | <code>Matrix3</code> | A color space conversion matrix, converting from CIE XYZ. |
| luminanceCoefficients | <code>Array.&lt;number&gt;</code> | The luminance coefficients. |
| [workingColorSpaceConfig] | <code>Object</code> | The working color space config. |
| [outputColorSpaceConfig] | <code>Object</code> | The drawing buffer color space config. |

<a name="ConvexHull"></a>

## ConvexHull
Can be used to compute the convex hull in 3D space for a given set of points. It
is primarily intended for [ConvexGeometry](ConvexGeometry).

This Quickhull 3D implementation is a port of [quickhull3d](https://github.com/maurizzzio/quickhull3d/)
by Mauricio Poppe.

**Kind**: global class  

* [ConvexHull](#ConvexHull)
    * [new ConvexHull()](#new_ConvexHull_new)
    * [.setFromPoints(points)](#ConvexHull+setFromPoints) ⇒ [<code>ConvexHull</code>](#ConvexHull)
    * [.setFromObject(object)](#ConvexHull+setFromObject) ⇒ [<code>ConvexHull</code>](#ConvexHull)
    * [.containsPoint(point)](#ConvexHull+containsPoint) ⇒ <code>boolean</code>
    * [.intersectRay(ray, target)](#ConvexHull+intersectRay) ⇒ <code>Vector3</code> \| <code>null</code>
    * [.intersectsRay(ray)](#ConvexHull+intersectsRay) ⇒ <code>boolean</code>
    * [.makeEmpty()](#ConvexHull+makeEmpty) ⇒ [<code>ConvexHull</code>](#ConvexHull)

<a name="new_ConvexHull_new"></a>

### new ConvexHull()
Constructs a new convex hull.

<a name="ConvexHull+setFromPoints"></a>

### convexHull.setFromPoints(points) ⇒ [<code>ConvexHull</code>](#ConvexHull)
Computes to convex hull for the given array of points.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: [<code>ConvexHull</code>](#ConvexHull) - A reference to this convex hull.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | The array of points in 3D space. |

<a name="ConvexHull+setFromObject"></a>

### convexHull.setFromObject(object) ⇒ [<code>ConvexHull</code>](#ConvexHull)
Computes the convex hull of the given 3D object (including its descendants),
accounting for the world transforms of both the 3D object and its descendants.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: [<code>ConvexHull</code>](#ConvexHull) - A reference to this convex hull.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to compute the convex hull for. |

<a name="ConvexHull+containsPoint"></a>

### convexHull.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies in the convex hull.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: <code>boolean</code> - Whether the given point lies in the convex hull or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to test. |

<a name="ConvexHull+intersectRay"></a>

### convexHull.intersectRay(ray, target) ⇒ <code>Vector3</code> \| <code>null</code>
Computes the intersections point of the given ray and this convex hull.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: <code>Vector3</code> \| <code>null</code> - The intersection point. Returns `null` if not intersection was detected.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="ConvexHull+intersectsRay"></a>

### convexHull.intersectsRay(ray) ⇒ <code>boolean</code>
Returns `true` if the given ray intersects with this convex hull.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: <code>boolean</code> - Whether the given ray intersects with this convex hull or not.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |

<a name="ConvexHull+makeEmpty"></a>

### convexHull.makeEmpty() ⇒ [<code>ConvexHull</code>](#ConvexHull)
Makes the convex hull empty.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: [<code>ConvexHull</code>](#ConvexHull) - A reference to this convex hull.  
<a name="ImprovedNoise"></a>

## ImprovedNoise
A utility class providing a 3D noise function.

The code is based on [IMPROVED NOISE](https://cs.nyu.edu/~perlin/noise/)
by Ken Perlin, 2002.

**Kind**: global class  
<a name="ImprovedNoise+noise"></a>

### improvedNoise.noise(x, y, z) ⇒ <code>number</code>
Returns a noise value for the given parameters.

**Kind**: instance method of [<code>ImprovedNoise</code>](#ImprovedNoise)  
**Returns**: <code>number</code> - The noise value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate. |
| y | <code>number</code> | The y coordinate. |
| z | <code>number</code> | The z coordinate. |

<a name="Lut"></a>

## Lut
Represents a lookup table for colormaps. It is used to determine the color
values from a range of data values.

```js
const lut = new Lut( 'rainbow', 512 );
const color = lut.getColor( 0.5 );
```

**Kind**: global class  

* [Lut](#Lut)
    * [new Lut([colormap], [count])](#new_Lut_new)
    * [.isLut](#Lut+isLut) : <code>boolean</code>
    * [.lut](#Lut+lut) : <code>Array.&lt;Color&gt;</code>
    * [.map](#Lut+map) : <code>Array</code>
    * [.n](#Lut+n) : <code>number</code>
    * [.minV](#Lut+minV) : <code>number</code>
    * [.maxV](#Lut+maxV) : <code>number</code>
    * [.set(value)](#Lut+set) ⇒ [<code>Lut</code>](#Lut)
    * [.setMin(min)](#Lut+setMin) ⇒ [<code>Lut</code>](#Lut)
    * [.setMax(max)](#Lut+setMax) ⇒ [<code>Lut</code>](#Lut)
    * [.setColorMap(colormap, [count])](#Lut+setColorMap) ⇒ [<code>Lut</code>](#Lut)
    * [.copy(lut)](#Lut+copy) ⇒ [<code>Lut</code>](#Lut)
    * [.getColor(alpha)](#Lut+getColor) ⇒ <code>Color</code>
    * [.addColorMap(name, arrayOfColors)](#Lut+addColorMap) ⇒ [<code>Lut</code>](#Lut)
    * [.createCanvas()](#Lut+createCanvas) ⇒ <code>HTMLCanvasElement</code>
    * [.updateCanvas(canvas)](#Lut+updateCanvas) ⇒ <code>HTMLCanvasElement</code>

<a name="new_Lut_new"></a>

### new Lut([colormap], [count])
Constructs a new Lut.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [colormap] | <code>&#x27;rainbow&#x27;</code> \| <code>&#x27;cooltowarm&#x27;</code> \| <code>&#x27;blackbody&#x27;</code> \| <code>&#x27;grayscale&#x27;</code> | <code>&#x27;rainbow&#x27;</code> | Sets a colormap from predefined list of colormaps. |
| [count] | <code>number</code> | <code>32</code> | Sets the number of colors used to represent the data array. |

<a name="Lut+isLut"></a>

### lut.isLut : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Lut+lut"></a>

### lut.lut : <code>Array.&lt;Color&gt;</code>
The lookup table for the selected color map

**Kind**: instance property of [<code>Lut</code>](#Lut)  
<a name="Lut+map"></a>

### lut.map : <code>Array</code>
The currently selected color map.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
<a name="Lut+n"></a>

### lut.n : <code>number</code>
The number of colors of the current selected color map.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
**Default**: <code>32</code>  
<a name="Lut+minV"></a>

### lut.minV : <code>number</code>
The minimum value to be represented with the lookup table.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
**Default**: <code>0</code>  
<a name="Lut+maxV"></a>

### lut.maxV : <code>number</code>
The maximum value to be represented with the lookup table.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
**Default**: <code>1</code>  
<a name="Lut+set"></a>

### lut.set(value) ⇒ [<code>Lut</code>](#Lut)
Sets the given LUT.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>Lut</code>](#Lut) | The LUT to set. |

<a name="Lut+setMin"></a>

### lut.setMin(min) ⇒ [<code>Lut</code>](#Lut)
Sets the minimum value to be represented with this LUT.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>number</code> | The minimum value to be represented with the lookup table. |

<a name="Lut+setMax"></a>

### lut.setMax(max) ⇒ [<code>Lut</code>](#Lut)
Sets the maximum value to be represented with this LUT.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| max | <code>number</code> | The maximum value to be represented with the lookup table. |

<a name="Lut+setColorMap"></a>

### lut.setColorMap(colormap, [count]) ⇒ [<code>Lut</code>](#Lut)
Configure the lookup table for the given color map and number of colors.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| colormap | <code>string</code> |  | The name of the color map. |
| [count] | <code>number</code> | <code>32</code> | The number of colors. |

<a name="Lut+copy"></a>

### lut.copy(lut) ⇒ [<code>Lut</code>](#Lut)
Copies the given lut.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| lut | [<code>Lut</code>](#Lut) | The LUT to copy. |

<a name="Lut+getColor"></a>

### lut.getColor(alpha) ⇒ <code>Color</code>
Returns an instance of Color for the given data value.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: <code>Color</code> - The color from the LUT.  

| Param | Type | Description |
| --- | --- | --- |
| alpha | <code>number</code> | The value to lookup. |

<a name="Lut+addColorMap"></a>

### lut.addColorMap(name, arrayOfColors) ⇒ [<code>Lut</code>](#Lut)
Adds a color map to this Lut instance.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the color map. |
| arrayOfColors | <code>Array</code> | An array of color values. Each value is an array holding a threshold and the actual color value as a hexadecimal number. |

<a name="Lut+createCanvas"></a>

### lut.createCanvas() ⇒ <code>HTMLCanvasElement</code>
Creates a canvas in order to visualize the lookup table as a texture.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: <code>HTMLCanvasElement</code> - The created canvas.  
<a name="Lut+updateCanvas"></a>

### lut.updateCanvas(canvas) ⇒ <code>HTMLCanvasElement</code>
Updates the given canvas with the Lut's data.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: <code>HTMLCanvasElement</code> - The updated canvas.  

| Param | Type | Description |
| --- | --- | --- |
| canvas | <code>HTMLCanvasElement</code> | The canvas to update. |

<a name="MeshSurfaceSampler"></a>

## MeshSurfaceSampler
Utility class for sampling weighted random points on the surface of a mesh.

Building the sampler is a one-time O(n) operation. Once built, any number of
random samples may be selected in O(logn) time. Memory usage is O(n).

References:
- [http://www.joesfer.com/?p=84](http://www.joesfer.com/?p=84)
- [https://stackoverflow.com/a/4322940/1314762](https://stackoverflow.com/a/4322940/1314762)

```js
const sampler = new MeshSurfaceSampler( surfaceMesh )
	.setWeightAttribute( 'color' )
	.build();

const mesh = new THREE.InstancedMesh( sampleGeometry, sampleMaterial, 100 );

const position = new THREE.Vector3();
const matrix = new THREE.Matrix4();

// Sample randomly from the surface, creating an instance of the sample geometry at each sample point.

for ( let i = 0; i < 100; i ++ ) {

	sampler.sample( position );
	matrix.makeTranslation( position.x, position.y, position.z );
	mesh.setMatrixAt( i, matrix );

}

scene.add( mesh );
```

**Kind**: global class  

* [MeshSurfaceSampler](#MeshSurfaceSampler)
    * [new MeshSurfaceSampler(mesh)](#new_MeshSurfaceSampler_new)
    * [.setWeightAttribute(name)](#MeshSurfaceSampler+setWeightAttribute) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
    * [.build()](#MeshSurfaceSampler+build) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
    * [.setRandomGenerator(randomFunction)](#MeshSurfaceSampler+setRandomGenerator) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
    * [.sample(targetPosition, targetNormal, targetColor, targetUV)](#MeshSurfaceSampler+sample) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)

<a name="new_MeshSurfaceSampler_new"></a>

### new MeshSurfaceSampler(mesh)
Constructs a mesh surface sampler.


| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | Surface mesh from which to sample. |

<a name="MeshSurfaceSampler+setWeightAttribute"></a>

### meshSurfaceSampler.setWeightAttribute(name) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
Specifies a vertex attribute to be used as a weight when sampling from the surface.
Faces with higher weights are more likely to be sampled, and those with weights of
zero will not be sampled at all. For vector attributes, only .x is used in sampling.

If no weight attribute is selected, sampling is randomly distributed by area.

**Kind**: instance method of [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)  
**Returns**: [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler) - A reference to this sampler.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute name. |

<a name="MeshSurfaceSampler+build"></a>

### meshSurfaceSampler.build() ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
Processes the input geometry and prepares to return samples. Any configuration of the
geometry or sampler must occur before this method is called. Time complexity is O(n)
for a surface with n faces.

**Kind**: instance method of [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)  
**Returns**: [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler) - A reference to this sampler.  
<a name="MeshSurfaceSampler+setRandomGenerator"></a>

### meshSurfaceSampler.setRandomGenerator(randomFunction) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
Allows to set a custom random number generator. Default is `Math.random()`.

**Kind**: instance method of [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)  
**Returns**: [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler) - A reference to this sampler.  

| Param | Type | Description |
| --- | --- | --- |
| randomFunction | <code>function</code> | A random number generator. |

<a name="MeshSurfaceSampler+sample"></a>

### meshSurfaceSampler.sample(targetPosition, targetNormal, targetColor, targetUV) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
Selects a random point on the surface of the input geometry, returning the
position and optionally the normal vector, color and UV Coordinate at that point.
Time complexity is O(log n) for a surface with n faces.

**Kind**: instance method of [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)  
**Returns**: [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler) - A reference to this sampler.  

| Param | Type | Description |
| --- | --- | --- |
| targetPosition | <code>Vector3</code> | The target object holding the sampled position. |
| targetNormal | <code>Vector3</code> | The target object holding the sampled normal. |
| targetColor | <code>Color</code> | The target object holding the sampled color. |
| targetUV | <code>Vector2</code> | The target object holding the sampled uv coordinates. |

<a name="OBB"></a>

## OBB
Represents an oriented bounding box (OBB) in 3D space.

**Kind**: global class  

* [OBB](#OBB)
    * [new OBB([center], [halfSize], [rotation])](#new_OBB_new)
    * [.center](#OBB+center) : <code>Vector3</code>
    * [.halfSize](#OBB+halfSize) : <code>Vector3</code>
    * [.rotation](#OBB+rotation) : <code>Matrix3</code>
    * [.set([center], [halfSize], [rotation])](#OBB+set) ⇒ [<code>OBB</code>](#OBB)
    * [.copy(obb)](#OBB+copy) ⇒ [<code>OBB</code>](#OBB)
    * [.clone()](#OBB+clone) ⇒ [<code>OBB</code>](#OBB)
    * [.getSize(target)](#OBB+getSize) ⇒ <code>Vector3</code>
    * [.clampPoint(point, target)](#OBB+clampPoint) ⇒ <code>Vector3</code>
    * [.containsPoint(point)](#OBB+containsPoint) ⇒ <code>boolean</code>
    * [.intersectsBox3(box3)](#OBB+intersectsBox3) ⇒ <code>boolean</code>
    * [.intersectsSphere(sphere)](#OBB+intersectsSphere) ⇒ <code>boolean</code>
    * [.intersectsOBB(obb, [epsilon])](#OBB+intersectsOBB) ⇒ <code>boolean</code>
    * [.intersectsPlane(plane)](#OBB+intersectsPlane) ⇒ <code>boolean</code>
    * [.intersectRay(ray, target)](#OBB+intersectRay) ⇒ <code>Vector3</code>
    * [.intersectsRay(ray)](#OBB+intersectsRay) ⇒ <code>boolean</code>
    * [.fromBox3(box3)](#OBB+fromBox3) ⇒ [<code>OBB</code>](#OBB)
    * [.equals(obb)](#OBB+equals) ⇒ <code>boolean</code>
    * [.applyMatrix4(matrix)](#OBB+applyMatrix4) ⇒ [<code>OBB</code>](#OBB)

<a name="new_OBB_new"></a>

### new OBB([center], [halfSize], [rotation])
Constructs a new OBB.


| Param | Type | Description |
| --- | --- | --- |
| [center] | <code>Vector3</code> | The center of the OBB. |
| [halfSize] | <code>Vector3</code> | Positive halfwidth extents of the OBB along each axis. |
| [rotation] | <code>Matrix3</code> | The rotation of the OBB. |

<a name="OBB+center"></a>

### obB.center : <code>Vector3</code>
The center of the OBB.

**Kind**: instance property of [<code>OBB</code>](#OBB)  
<a name="OBB+halfSize"></a>

### obB.halfSize : <code>Vector3</code>
Positive halfwidth extents of the OBB along each axis.

**Kind**: instance property of [<code>OBB</code>](#OBB)  
<a name="OBB+rotation"></a>

### obB.rotation : <code>Matrix3</code>
The rotation of the OBB.

**Kind**: instance property of [<code>OBB</code>](#OBB)  
<a name="OBB+set"></a>

### obB.set([center], [halfSize], [rotation]) ⇒ [<code>OBB</code>](#OBB)
Sets the OBBs components to the given values.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A reference to this OBB.  

| Param | Type | Description |
| --- | --- | --- |
| [center] | <code>Vector3</code> | The center of the OBB. |
| [halfSize] | <code>Vector3</code> | Positive halfwidth extents of the OBB along each axis. |
| [rotation] | <code>Matrix3</code> | The rotation of the OBB. |

<a name="OBB+copy"></a>

### obB.copy(obb) ⇒ [<code>OBB</code>](#OBB)
Copies the values of the given OBB to this instance.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A reference to this OBB.  

| Param | Type | Description |
| --- | --- | --- |
| obb | [<code>OBB</code>](#OBB) | The OBB to copy. |

<a name="OBB+clone"></a>

### obB.clone() ⇒ [<code>OBB</code>](#OBB)
Returns a new OBB with copied values from this instance.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A clone of this instance.  
<a name="OBB+getSize"></a>

### obB.getSize(target) ⇒ <code>Vector3</code>
Returns the size of this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>Vector3</code> - The size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="OBB+clampPoint"></a>

### obB.clampPoint(point, target) ⇒ <code>Vector3</code>
Clamps the given point within the bounds of this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>Vector3</code> - - The clamped point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point that should be clamped within the bounds of this OBB. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="OBB+containsPoint"></a>

### obB.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies within this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - - Whether the given point lies within this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to test. |

<a name="OBB+intersectsBox3"></a>

### obB.intersectsBox3(box3) ⇒ <code>boolean</code>
Returns `true` if the given AABB intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - - Whether the given AABB intersects this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| box3 | <code>Box3</code> | The AABB to test. |

<a name="OBB+intersectsSphere"></a>

### obB.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if the given bounding sphere intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - - Whether the given bounding sphere intersects this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="OBB+intersectsOBB"></a>

### obB.intersectsOBB(obb, [epsilon]) ⇒ <code>boolean</code>
Returns `true` if the given OBB intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - - Whether the given OBB intersects this OBB or not.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| obb | [<code>OBB</code>](#OBB) |  | The OBB to test. |
| [epsilon] | <code>number</code> | <code>Number.EPSILON</code> | A small value to prevent arithmetic errors. |

<a name="OBB+intersectsPlane"></a>

### obB.intersectsPlane(plane) ⇒ <code>boolean</code>
Returns `true` if the given plane intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - Whether the given plane intersects this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to test. |

<a name="OBB+intersectRay"></a>

### obB.intersectRay(ray, target) ⇒ <code>Vector3</code>
Performs a ray/OBB intersection test and stores the intersection point
in the given 3D vector.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>Vector3</code> - The intersection point. If no intersection is detected, `null` is returned.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="OBB+intersectsRay"></a>

### obB.intersectsRay(ray) ⇒ <code>boolean</code>
Returns `true` if the given ray intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - Whether the given ray intersects this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |

<a name="OBB+fromBox3"></a>

### obB.fromBox3(box3) ⇒ [<code>OBB</code>](#OBB)
Defines an OBB based on the given AABB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A reference of this OBB.  

| Param | Type | Description |
| --- | --- | --- |
| box3 | <code>Box3</code> | The AABB to setup the OBB from. |

<a name="OBB+equals"></a>

### obB.equals(obb) ⇒ <code>boolean</code>
Returns `true` if the given OBB is equal to this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - Whether the given OBB is equal to this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| obb | [<code>OBB</code>](#OBB) | The OBB to test. |

<a name="OBB+applyMatrix4"></a>

### obB.applyMatrix4(matrix) ⇒ [<code>OBB</code>](#OBB)
Applies the given transformation matrix to this OBB. This method can be
used to transform the bounding volume with the world matrix of a 3D object
in order to keep both entities in sync.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A reference of this OBB.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The matrix to apply. |

<a name="Octree"></a>

## Octree
An octree is a hierarchical tree data structure used to partition a three-dimensional
space by recursively subdividing it into eight octants.

This particular implementation can have up to sixteen levels and stores up to eight triangles
in leaf nodes.

`Octree` can be used in games to compute collision between the game world and colliders from
the player or other dynamic 3D objects.


```js
const octree = new Octree().fromGraphNode( scene );
const result = octree.capsuleIntersect( playerCollider ); // collision detection
```

**Kind**: global class  

* [Octree](#Octree)
    * [new Octree([box])](#new_Octree_new)
    * [.box](#Octree+box) : <code>Box3</code>
    * [.bounds](#Octree+bounds) : <code>Box3</code>
    * [.layers](#Octree+layers) : <code>Layers</code>
    * [.addTriangle(triangle)](#Octree+addTriangle) ⇒ [<code>Octree</code>](#Octree)
    * [.calcBox()](#Octree+calcBox) ⇒ [<code>Octree</code>](#Octree)
    * [.split(level)](#Octree+split) ⇒ [<code>Octree</code>](#Octree)
    * [.build()](#Octree+build) ⇒ [<code>Octree</code>](#Octree)
    * [.getRayTriangles(ray, triangles)](#Octree+getRayTriangles)
    * [.triangleCapsuleIntersect(capsule, triangle)](#Octree+triangleCapsuleIntersect) ⇒ <code>Object</code> \| <code>false</code>
    * [.triangleSphereIntersect(sphere, triangle)](#Octree+triangleSphereIntersect) ⇒ <code>Object</code> \| <code>false</code>
    * [.getSphereTriangles(sphere, triangles)](#Octree+getSphereTriangles)
    * [.getCapsuleTriangles(capsule, triangles)](#Octree+getCapsuleTriangles)
    * [.sphereIntersect(sphere)](#Octree+sphereIntersect) ⇒ <code>Object</code> \| <code>boolean</code>
    * [.capsuleIntersect(capsule)](#Octree+capsuleIntersect) ⇒ <code>Object</code> \| <code>boolean</code>
    * [.rayIntersect(ray)](#Octree+rayIntersect) ⇒ <code>Object</code> \| <code>boolean</code>
    * [.fromGraphNode(group)](#Octree+fromGraphNode) ⇒ [<code>Octree</code>](#Octree)
    * [.clear()](#Octree+clear) ⇒ [<code>Octree</code>](#Octree)

<a name="new_Octree_new"></a>

### new Octree([box])
Constructs a new Octree.


| Param | Type | Description |
| --- | --- | --- |
| [box] | <code>Box3</code> | The base box with enclose the entire Octree. |

<a name="Octree+box"></a>

### octree.box : <code>Box3</code>
The base box with enclose the entire Octree.

**Kind**: instance property of [<code>Octree</code>](#Octree)  
<a name="Octree+bounds"></a>

### octree.bounds : <code>Box3</code>
The bounds of the Octree. Compared to [box](#Octree+box), no
margin is applied.

**Kind**: instance property of [<code>Octree</code>](#Octree)  
<a name="Octree+layers"></a>

### octree.layers : <code>Layers</code>
Can by used for layers configuration for refine testing.

**Kind**: instance property of [<code>Octree</code>](#Octree)  
<a name="Octree+addTriangle"></a>

### octree.addTriangle(triangle) ⇒ [<code>Octree</code>](#Octree)
Adds the given triangle to the Octree. The triangle vertices are clamped if they exceed
the bounds of the Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  

| Param | Type | Description |
| --- | --- | --- |
| triangle | <code>Triangle</code> | The triangle to add. |

<a name="Octree+calcBox"></a>

### octree.calcBox() ⇒ [<code>Octree</code>](#Octree)
Prepares [box](#Octree+box) for the build.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  
<a name="Octree+split"></a>

### octree.split(level) ⇒ [<code>Octree</code>](#Octree)
Splits the Octree. This method is used recursively when
building the Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  

| Param | Type | Description |
| --- | --- | --- |
| level | <code>number</code> | The current level. |

<a name="Octree+build"></a>

### octree.build() ⇒ [<code>Octree</code>](#Octree)
Builds the Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  
<a name="Octree+getRayTriangles"></a>

### octree.getRayTriangles(ray, triangles)
Computes the triangles that potentially intersect with the given ray.

**Kind**: instance method of [<code>Octree</code>](#Octree)  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |
| triangles | <code>Array.&lt;Triangle&gt;</code> | The target array that holds the triangles. |

<a name="Octree+triangleCapsuleIntersect"></a>

### octree.triangleCapsuleIntersect(capsule, triangle) ⇒ <code>Object</code> \| <code>false</code>
Computes the intersection between the given capsule and triangle.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>false</code> - The intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| capsule | <code>Capsule</code> | The capsule to test. |
| triangle | <code>Triangle</code> | The triangle to test. |

<a name="Octree+triangleSphereIntersect"></a>

### octree.triangleSphereIntersect(sphere, triangle) ⇒ <code>Object</code> \| <code>false</code>
Computes the intersection between the given sphere and triangle.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>false</code> - The intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to test. |
| triangle | <code>Triangle</code> | The triangle to test. |

<a name="Octree+getSphereTriangles"></a>

### octree.getSphereTriangles(sphere, triangles)
Computes the triangles that potentially intersect with the given bounding sphere.

**Kind**: instance method of [<code>Octree</code>](#Octree)  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to test. |
| triangles | <code>Array.&lt;Triangle&gt;</code> | The target array that holds the triangles. |

<a name="Octree+getCapsuleTriangles"></a>

### octree.getCapsuleTriangles(capsule, triangles)
Computes the triangles that potentially intersect with the given capsule.

**Kind**: instance method of [<code>Octree</code>](#Octree)  

| Param | Type | Description |
| --- | --- | --- |
| capsule | <code>Capsule</code> | The capsule to test. |
| triangles | <code>Array.&lt;Triangle&gt;</code> | The target array that holds the triangles. |

<a name="Octree+sphereIntersect"></a>

### octree.sphereIntersect(sphere) ⇒ <code>Object</code> \| <code>boolean</code>
Performs a bounding sphere intersection test with this Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>boolean</code> - The intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="Octree+capsuleIntersect"></a>

### octree.capsuleIntersect(capsule) ⇒ <code>Object</code> \| <code>boolean</code>
Performs a capsule intersection test with this Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>boolean</code> - The intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| capsule | <code>Capsule</code> | The capsule to test. |

<a name="Octree+rayIntersect"></a>

### octree.rayIntersect(ray) ⇒ <code>Object</code> \| <code>boolean</code>
Performs a ray intersection test with this Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>boolean</code> - The nearest intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |

<a name="Octree+fromGraphNode"></a>

### octree.fromGraphNode(group) ⇒ [<code>Octree</code>](#Octree)
Constructs the Octree from the given 3D object.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  

| Param | Type | Description |
| --- | --- | --- |
| group | <code>Object3D</code> | The scene graph node. |

<a name="Octree+clear"></a>

### octree.clear() ⇒ [<code>Octree</code>](#Octree)
Clears the Octree by making it empty.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  
<a name="SimplexNoise"></a>

## SimplexNoise
A utility class providing noise functions.

The code is based on [Simplex noise demystified](https://web.archive.org/web/20210210162332/http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf)
by Stefan Gustavson, 2005.

**Kind**: global class  

* [SimplexNoise](#SimplexNoise)
    * [new SimplexNoise([r])](#new_SimplexNoise_new)
    * [.noise(xin, yin)](#SimplexNoise+noise) ⇒ <code>number</code>
    * [.noise3d(xin, yin, zin)](#SimplexNoise+noise3d) ⇒ <code>number</code>
    * [.noise4d(x, y, z, w)](#SimplexNoise+noise4d) ⇒ <code>number</code>

<a name="new_SimplexNoise_new"></a>

### new SimplexNoise([r])
Constructs a new simplex noise object.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [r] | <code>Object</code> | <code>Math</code> | A math utility class that holds a `random()` method. This makes it possible to pass in custom random number generator. |

<a name="SimplexNoise+noise"></a>

### simplexNoise.noise(xin, yin) ⇒ <code>number</code>
A 2D simplex noise method.

**Kind**: instance method of [<code>SimplexNoise</code>](#SimplexNoise)  
**Returns**: <code>number</code> - The noise value.  

| Param | Type | Description |
| --- | --- | --- |
| xin | <code>number</code> | The x coordinate. |
| yin | <code>number</code> | The y coordinate. |

<a name="SimplexNoise+noise3d"></a>

### simplexNoise.noise3d(xin, yin, zin) ⇒ <code>number</code>
A 3D simplex noise method.

**Kind**: instance method of [<code>SimplexNoise</code>](#SimplexNoise)  
**Returns**: <code>number</code> - The noise value.  

| Param | Type | Description |
| --- | --- | --- |
| xin | <code>number</code> | The x coordinate. |
| yin | <code>number</code> | The y coordinate. |
| zin | <code>number</code> | The z coordinate. |

<a name="SimplexNoise+noise4d"></a>

### simplexNoise.noise4d(x, y, z, w) ⇒ <code>number</code>
A 4D simplex noise method.

**Kind**: instance method of [<code>SimplexNoise</code>](#SimplexNoise)  
**Returns**: <code>number</code> - The noise value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate. |
| y | <code>number</code> | The y coordinate. |
| z | <code>number</code> | The z coordinate. |
| w | <code>number</code> | The w coordinate. |

<a name="ConvexObjectBreaker"></a>

## ConvexObjectBreaker
This class can be used to subdivide a convex Geometry object into pieces.

Use the function prepareBreakableObject to prepare a Mesh object to be broken.
Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane).
Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.

Requisites for the object:
- Mesh object must have a buffer geometry and a material.
- Vertex normals must be planar (not smoothed).
- The geometry must be convex (this is not checked in the library). You can create convex
geometries with [ConvexGeometry](ConvexGeometry). The [BoxGeometry](BoxGeometry), [SphereGeometry](SphereGeometry) and other
convex primitives can also be used.

Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)
Use with caution and read the code when using with other libs.

**Kind**: global class  

* [ConvexObjectBreaker](#ConvexObjectBreaker)
    * [new ConvexObjectBreaker([minSizeForBreak], [smallDelta])](#new_ConvexObjectBreaker_new)
    * [.prepareBreakableObject(object, mass, velocity, angularVelocity, breakable)](#ConvexObjectBreaker+prepareBreakableObject)
    * [.subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations)](#ConvexObjectBreaker+subdivideByImpact) ⇒ <code>Array.&lt;Object3D&gt;</code>
    * [.cutByPlane(object, plane, output)](#ConvexObjectBreaker+cutByPlane) ⇒ <code>number</code>

<a name="new_ConvexObjectBreaker_new"></a>

### new ConvexObjectBreaker([minSizeForBreak], [smallDelta])
Constructs a new convex object breaker.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [minSizeForBreak] | <code>number</code> | <code>1.4</code> | Min size a debris can have to break. |
| [smallDelta] | <code>number</code> | <code>0.0001</code> | Max distance to consider that a point belongs to a plane. |

<a name="ConvexObjectBreaker+prepareBreakableObject"></a>

### convexObjectBreaker.prepareBreakableObject(object, mass, velocity, angularVelocity, breakable)
Must be called for all 3D objects that should be breakable.

**Kind**: instance method of [<code>ConvexObjectBreaker</code>](#ConvexObjectBreaker)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object. It must have a convex geometry. |
| mass | <code>number</code> | The 3D object's mass in kg. Must be greater than `0`. |
| velocity | <code>Vector3</code> | The 3D object's velocity. |
| angularVelocity | <code>Vector3</code> | The 3D object's angular velocity. |
| breakable | <code>boolean</code> | Whether the 3D object is breakable or not. |

<a name="ConvexObjectBreaker+subdivideByImpact"></a>

### convexObjectBreaker.subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) ⇒ <code>Array.&lt;Object3D&gt;</code>
Subdivides the given 3D object into pieces by an impact (meaning another object hits
the given 3D object at a certain surface point).

**Kind**: instance method of [<code>ConvexObjectBreaker</code>](#ConvexObjectBreaker)  
**Returns**: <code>Array.&lt;Object3D&gt;</code> - The array of pieces.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to subdivide. |
| pointOfImpact | <code>Vector3</code> | The point of impact. |
| normal | <code>Vector3</code> | The impact normal. |
| maxRadialIterations | <code>number</code> | Iterations for radial cuts. |
| maxRandomIterations | <code>number</code> | Max random iterations for not-radial cuts. |

<a name="ConvexObjectBreaker+cutByPlane"></a>

### convexObjectBreaker.cutByPlane(object, plane, output) ⇒ <code>number</code>
Subdivides the given 3D object into pieces by a plane.

**Kind**: instance method of [<code>ConvexObjectBreaker</code>](#ConvexObjectBreaker)  
**Returns**: <code>number</code> - The number of pieces.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to subdivide. |
| plane | <code>Plane</code> | The plane to cut the 3D object. |
| output | <code>Object</code> | An object that stores the pieces. |

<a name="GPUComputationRenderer"></a>

## GPUComputationRenderer
GPUComputationRenderer, based on SimulationRenderer by @zz85.

The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats
for each compute element (texel).

Each variable has a fragment shader that defines the computation made to obtain the variable in question.
You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader
(the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.

The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used
as inputs to render the textures of the next frame.

The render targets of the variables can be used as input textures for your visualization shaders.

Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.
a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...

The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:
```
#DEFINE resolution vec2( 1024.0, 1024.0 )
```
Basic use:
```js
// Initialization...

// Create computation renderer
const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );

// Create initial state float textures
const pos0 = gpuCompute.createTexture();
const vel0 = gpuCompute.createTexture();
// and fill in here the texture data...

// Add texture variables
const velVar = gpuCompute.addVariable( "textureVelocity", fragmentShaderVel, vel0 );
const posVar = gpuCompute.addVariable( "texturePosition", fragmentShaderPos, pos0 );

// Add variable dependencies
gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );
gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );

// Add custom uniforms
velVar.material.uniforms.time = { value: 0.0 };

// Check for completeness
const error = gpuCompute.init();
if ( error !== null ) {
		console.error( error );
}

// In each frame...

// Compute!
gpuCompute.compute();

// Update texture uniforms in your visualization materials with the gpu renderer output
myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;

// Do your rendering
renderer.render( myScene, myCamera );
```

Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)
Note that the shaders can have multiple input textures.

```js
const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );
const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );

const inputTexture = gpuCompute.createTexture();

// Fill in here inputTexture...

myFilter1.uniforms.theTexture.value = inputTexture;

const myRenderTarget = gpuCompute.createRenderTarget();
myFilter2.uniforms.theTexture.value = myRenderTarget.texture;

const outputRenderTarget = gpuCompute.createRenderTarget();

// Now use the output texture where you want:
myMaterial.uniforms.map.value = outputRenderTarget.texture;

// And compute each frame, before rendering to screen:
gpuCompute.doRenderTarget( myFilter1, myRenderTarget );
gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );
```

**Kind**: global class  

* [GPUComputationRenderer](#GPUComputationRenderer)
    * [new GPUComputationRenderer(sizeX, sizeY, renderer)](#new_GPUComputationRenderer_new)
    * [.addResolutionDefine](#GPUComputationRenderer+addResolutionDefine)
    * [.setDataType(type)](#GPUComputationRenderer+setDataType) ⇒ [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)
    * [.addVariable(variableName, computeFragmentShader, initialValueTexture)](#GPUComputationRenderer+addVariable) ⇒ <code>Object</code>
    * [.setVariableDependencies(variable, dependencies)](#GPUComputationRenderer+setVariableDependencies)
    * [.init()](#GPUComputationRenderer+init) ⇒ <code>string</code>
    * [.compute()](#GPUComputationRenderer+compute)
    * [.getCurrentRenderTarget(variable)](#GPUComputationRenderer+getCurrentRenderTarget) ⇒ <code>WebGLRenderTarget</code>
    * [.getAlternateRenderTarget(variable)](#GPUComputationRenderer+getAlternateRenderTarget) ⇒ <code>WebGLRenderTarget</code>
    * [.dispose()](#GPUComputationRenderer+dispose)
    * [.createRenderTarget(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter)](#GPUComputationRenderer+createRenderTarget) ⇒ <code>WebGLRenderTarget</code>
    * [.createTexture()](#GPUComputationRenderer+createTexture) ⇒ <code>DataTexture</code>
    * [.renderTexture(input, output)](#GPUComputationRenderer+renderTexture)
    * [.doRenderTarget(material, output)](#GPUComputationRenderer+doRenderTarget)

<a name="new_GPUComputationRenderer_new"></a>

### new GPUComputationRenderer(sizeX, sizeY, renderer)
Constructs a new GPU computation renderer.


| Param | Type | Description |
| --- | --- | --- |
| sizeX | <code>number</code> | Computation problem size is always 2d: sizeX * sizeY elements. |
| sizeY | <code>number</code> | Computation problem size is always 2d: sizeX * sizeY elements. |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="GPUComputationRenderer+addResolutionDefine"></a>

### gpuComputationRenderer.addResolutionDefine
Adds a resolution defined for the given material shader.

**Kind**: instance property of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| materialShader | <code>Object</code> | The material shader. |

<a name="GPUComputationRenderer+setDataType"></a>

### gpuComputationRenderer.setDataType(type) ⇒ [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)
Sets the data type of the internal textures.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: [<code>GPUComputationRenderer</code>](#GPUComputationRenderer) - A reference to this renderer.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>FloatType</code> \| <code>HalfFloatType</code> | The type to set. |

<a name="GPUComputationRenderer+addVariable"></a>

### gpuComputationRenderer.addVariable(variableName, computeFragmentShader, initialValueTexture) ⇒ <code>Object</code>
Adds a compute variable to the renderer.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>Object</code> - The compute variable.  

| Param | Type | Description |
| --- | --- | --- |
| variableName | <code>string</code> | The variable name. |
| computeFragmentShader | <code>string</code> | The compute (fragment) shader source. |
| initialValueTexture | <code>Texture</code> | The initial value texture. |

<a name="GPUComputationRenderer+setVariableDependencies"></a>

### gpuComputationRenderer.setVariableDependencies(variable, dependencies)
Sets variable dependencies.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| variable | <code>Object</code> | The compute variable. |
| dependencies | <code>Array.&lt;Object&gt;</code> | Other compute variables that represents the dependencies. |

<a name="GPUComputationRenderer+init"></a>

### gpuComputationRenderer.init() ⇒ <code>string</code>
Initializes the renderer.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>string</code> - Returns `null` if no errors are detected. Otherwise returns the error message.  
<a name="GPUComputationRenderer+compute"></a>

### gpuComputationRenderer.compute()
Executes the compute. This method is usually called in the animation loop.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
<a name="GPUComputationRenderer+getCurrentRenderTarget"></a>

### gpuComputationRenderer.getCurrentRenderTarget(variable) ⇒ <code>WebGLRenderTarget</code>
Returns the current render target for the given compute variable.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>WebGLRenderTarget</code> - The current render target.  

| Param | Type | Description |
| --- | --- | --- |
| variable | <code>Object</code> | The compute variable. |

<a name="GPUComputationRenderer+getAlternateRenderTarget"></a>

### gpuComputationRenderer.getAlternateRenderTarget(variable) ⇒ <code>WebGLRenderTarget</code>
Returns the alternate render target for the given compute variable.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>WebGLRenderTarget</code> - The alternate render target.  

| Param | Type | Description |
| --- | --- | --- |
| variable | <code>Object</code> | The compute variable. |

<a name="GPUComputationRenderer+dispose"></a>

### gpuComputationRenderer.dispose()
Frees all internal resources. Call this method if you don't need the
renderer anymore.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
<a name="GPUComputationRenderer+createRenderTarget"></a>

### gpuComputationRenderer.createRenderTarget(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) ⇒ <code>WebGLRenderTarget</code>
Creates a new render target from the given parameters.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>WebGLRenderTarget</code> - The new render target.  

| Param | Type | Description |
| --- | --- | --- |
| sizeXTexture | <code>number</code> | The width of the render target. |
| sizeYTexture | <code>number</code> | The height of the render target. |
| wrapS | <code>number</code> | The wrapS value. |
| wrapT | <code>number</code> | The wrapS value. |
| minFilter | <code>number</code> | The minFilter value. |
| magFilter | <code>number</code> | The magFilter value. |

<a name="GPUComputationRenderer+createTexture"></a>

### gpuComputationRenderer.createTexture() ⇒ <code>DataTexture</code>
Creates a new data texture.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>DataTexture</code> - The new data texture.  
<a name="GPUComputationRenderer+renderTexture"></a>

### gpuComputationRenderer.renderTexture(input, output)
Renders the given texture into the given render target.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Texture</code> | The input. |
| output | <code>WebGLRenderTarget</code> | The output. |

<a name="GPUComputationRenderer+doRenderTarget"></a>

### gpuComputationRenderer.doRenderTarget(material, output)
Renders the given material into the given render target
with a full-screen pass.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| material | <code>Material</code> | The material. |
| output | <code>WebGLRenderTarget</code> | The output. |

<a name="Gyroscope"></a>

## Gyroscope ⇐ <code>Object3D</code>
A special type of 3D object that takes a position from the scene graph hierarchy
but uses its local rotation as world rotation. It works like real-world gyroscope -
you can move it around using hierarchy while its orientation stays fixed with
respect to the world.

**Kind**: global class  
**Extends**: <code>Object3D</code>  
<a name="new_Gyroscope_new"></a>

### new Gyroscope()
Constructs a new gyroscope.

<a name="MD2Character"></a>

## MD2Character
This class represents a management component for animated MD2
character assets.

**Kind**: global class  

* [MD2Character](#MD2Character)
    * [new MD2Character()](#new_MD2Character_new)
    * [.scale](#MD2Character+scale) : <code>number</code>
    * [.animationFPS](#MD2Character+animationFPS) : <code>number</code>
    * [.root](#MD2Character+root) : <code>Object3D</code>
    * [.meshBody](#MD2Character+meshBody) : <code>Mesh</code>
    * [.meshWeapon](#MD2Character+meshWeapon) : <code>Mesh</code>
    * [.skinsBody](#MD2Character+skinsBody) : <code>Array.&lt;Texture&gt;</code>
    * [.skinsWeapon](#MD2Character+skinsWeapon) : <code>Array.&lt;Texture&gt;</code>
    * [.weapons](#MD2Character+weapons) : <code>Array.&lt;Mesh&gt;</code>
    * [.activeAnimationClipName](#MD2Character+activeAnimationClipName) : <code>string</code>
    * [.mixer](#MD2Character+mixer) : <code>AnimationMixer</code>
    * [.onLoadComplete()](#MD2Character+onLoadComplete) : <code>function</code>
    * [.loadParts(config)](#MD2Character+loadParts)
    * [.setPlaybackRate(rate)](#MD2Character+setPlaybackRate)
    * [.setWireframe(wireframeEnabled)](#MD2Character+setWireframe)
    * [.setSkin(index)](#MD2Character+setSkin)
    * [.setWeapon(index)](#MD2Character+setWeapon)
    * [.setAnimation(clipName)](#MD2Character+setAnimation)
    * [.syncWeaponAnimation()](#MD2Character+syncWeaponAnimation)
    * [.update(delta)](#MD2Character+update)

<a name="new_MD2Character_new"></a>

### new MD2Character()
Constructs a new MD2 character.

<a name="MD2Character+scale"></a>

### mD2Character.scale : <code>number</code>
The mesh scale.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>1</code>  
<a name="MD2Character+animationFPS"></a>

### mD2Character.animationFPS : <code>number</code>
The FPS

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>6</code>  
<a name="MD2Character+root"></a>

### mD2Character.root : <code>Object3D</code>
The root 3D object

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+meshBody"></a>

### mD2Character.meshBody : <code>Mesh</code>
The body mesh.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>null</code>  
<a name="MD2Character+meshWeapon"></a>

### mD2Character.meshWeapon : <code>Mesh</code>
The weapon mesh.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>null</code>  
<a name="MD2Character+skinsBody"></a>

### mD2Character.skinsBody : <code>Array.&lt;Texture&gt;</code>
The body skins.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+skinsWeapon"></a>

### mD2Character.skinsWeapon : <code>Array.&lt;Texture&gt;</code>
The weapon skins.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+weapons"></a>

### mD2Character.weapons : <code>Array.&lt;Mesh&gt;</code>
The weapon meshes.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+activeAnimationClipName"></a>

### mD2Character.activeAnimationClipName : <code>string</code>
The name of the active animation clip.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>&quot;null&quot;</code>  
<a name="MD2Character+mixer"></a>

### mD2Character.mixer : <code>AnimationMixer</code>
The animation mixer.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>null</code>  
<a name="MD2Character+onLoadComplete"></a>

### mD2Character.onLoadComplete() : <code>function</code>
The `onLoad` callback function.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+loadParts"></a>

### mD2Character.loadParts(config)
Loads the character model for the given config.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| config | <code>Object</code> | The config which defines the model and textures paths. |

<a name="MD2Character+setPlaybackRate"></a>

### mD2Character.setPlaybackRate(rate)
Sets the animation playback rate.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| rate | <code>number</code> | The playback rate to set. |

<a name="MD2Character+setWireframe"></a>

### mD2Character.setWireframe(wireframeEnabled)
Sets the wireframe material flag.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| wireframeEnabled | <code>boolean</code> | Whether to enable wireframe rendering or not. |

<a name="MD2Character+setSkin"></a>

### mD2Character.setSkin(index)
Sets the skin defined by the given skin index. This will result in a different texture
for the body mesh.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The skin index. |

<a name="MD2Character+setWeapon"></a>

### mD2Character.setWeapon(index)
Sets the weapon defined by the given weapon index. This will result in a different weapon
hold by the character.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The weapon index. |

<a name="MD2Character+setAnimation"></a>

### mD2Character.setAnimation(clipName)
Sets the defined animation clip as the active animation.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| clipName | <code>string</code> | The name of the animation clip. |

<a name="MD2Character+syncWeaponAnimation"></a>

### mD2Character.syncWeaponAnimation()
Synchronizes the weapon with the body animation.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+update"></a>

### mD2Character.update(delta)
Updates the animations of the mesh. Must be called inside the animation loop.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="MD2CharacterComplex"></a>

## MD2CharacterComplex
This class represents a management component for animated MD2
character assets. It provides a larger API compared to [MD2Character](MD2Character).

**Kind**: global class  

* [MD2CharacterComplex](#MD2CharacterComplex)
    * [new MD2CharacterComplex()](#new_MD2CharacterComplex_new)
    * [.scale](#MD2CharacterComplex+scale) : <code>number</code>
    * [.animationFPS](#MD2CharacterComplex+animationFPS) : <code>number</code>
    * [.transitionFrames](#MD2CharacterComplex+transitionFrames) : <code>number</code>
    * [.maxSpeed](#MD2CharacterComplex+maxSpeed) : <code>number</code>
    * [.maxReverseSpeed](#MD2CharacterComplex+maxReverseSpeed) : <code>number</code>
    * [.frontAcceleration](#MD2CharacterComplex+frontAcceleration) : <code>number</code>
    * [.backAcceleration](#MD2CharacterComplex+backAcceleration) : <code>number</code>
    * [.frontDecceleration](#MD2CharacterComplex+frontDecceleration) : <code>number</code>
    * [.angularSpeed](#MD2CharacterComplex+angularSpeed) : <code>number</code>
    * [.root](#MD2CharacterComplex+root) : <code>Object3D</code>
    * [.meshBody](#MD2CharacterComplex+meshBody) : <code>Mesh</code>
    * [.meshWeapon](#MD2CharacterComplex+meshWeapon) : <code>Mesh</code>
    * [.controls](#MD2CharacterComplex+controls) : <code>Object</code>
    * [.skinsBody](#MD2CharacterComplex+skinsBody) : <code>Array.&lt;Texture&gt;</code>
    * [.skinsWeapon](#MD2CharacterComplex+skinsWeapon) : <code>Array.&lt;Texture&gt;</code>
    * [.weapons](#MD2CharacterComplex+weapons) : <code>Array.&lt;Mesh&gt;</code>
    * [.currentSkin](#MD2CharacterComplex+currentSkin) : <code>Texture</code>
    * [.enableShadows(enable)](#MD2CharacterComplex+enableShadows)
    * [.setVisible(enable)](#MD2CharacterComplex+setVisible)
    * [.shareParts(original)](#MD2CharacterComplex+shareParts)
    * [.loadParts(config)](#MD2CharacterComplex+loadParts)
    * [.setPlaybackRate(rate)](#MD2CharacterComplex+setPlaybackRate)
    * [.setWireframe(wireframeEnabled)](#MD2CharacterComplex+setWireframe)
    * [.setSkin(index)](#MD2CharacterComplex+setSkin)
    * [.setWeapon(index)](#MD2CharacterComplex+setWeapon)
    * [.setAnimation(animationName)](#MD2CharacterComplex+setAnimation)
    * [.updateAnimations(delta)](#MD2CharacterComplex+updateAnimations)
    * [.updateBehaviors()](#MD2CharacterComplex+updateBehaviors)
    * [.updateMovementModel(delta)](#MD2CharacterComplex+updateMovementModel)

<a name="new_MD2CharacterComplex_new"></a>

### new MD2CharacterComplex()
Constructs a new MD2 character.

<a name="MD2CharacterComplex+scale"></a>

### mD2CharacterComplex.scale : <code>number</code>
The mesh scale.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>1</code>  
<a name="MD2CharacterComplex+animationFPS"></a>

### mD2CharacterComplex.animationFPS : <code>number</code>
The FPS

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>6</code>  
<a name="MD2CharacterComplex+transitionFrames"></a>

### mD2CharacterComplex.transitionFrames : <code>number</code>
The transition frames.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>15</code>  
<a name="MD2CharacterComplex+maxSpeed"></a>

### mD2CharacterComplex.maxSpeed : <code>number</code>
The character's maximum speed.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>275</code>  
<a name="MD2CharacterComplex+maxReverseSpeed"></a>

### mD2CharacterComplex.maxReverseSpeed : <code>number</code>
The character's maximum reverse speed.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>- 275</code>  
<a name="MD2CharacterComplex+frontAcceleration"></a>

### mD2CharacterComplex.frontAcceleration : <code>number</code>
The character's front acceleration.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>600</code>  
<a name="MD2CharacterComplex+backAcceleration"></a>

### mD2CharacterComplex.backAcceleration : <code>number</code>
The character's back acceleration.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>600</code>  
<a name="MD2CharacterComplex+frontDecceleration"></a>

### mD2CharacterComplex.frontDecceleration : <code>number</code>
The character's front decceleration.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>600</code>  
<a name="MD2CharacterComplex+angularSpeed"></a>

### mD2CharacterComplex.angularSpeed : <code>number</code>
The character's angular speed.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>2.5</code>  
<a name="MD2CharacterComplex+root"></a>

### mD2CharacterComplex.root : <code>Object3D</code>
The root 3D object

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+meshBody"></a>

### mD2CharacterComplex.meshBody : <code>Mesh</code>
The body mesh.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>null</code>  
<a name="MD2CharacterComplex+meshWeapon"></a>

### mD2CharacterComplex.meshWeapon : <code>Mesh</code>
The weapon mesh.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>null</code>  
<a name="MD2CharacterComplex+controls"></a>

### mD2CharacterComplex.controls : <code>Object</code>
The movement controls.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>null</code>  
<a name="MD2CharacterComplex+skinsBody"></a>

### mD2CharacterComplex.skinsBody : <code>Array.&lt;Texture&gt;</code>
The body skins.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+skinsWeapon"></a>

### mD2CharacterComplex.skinsWeapon : <code>Array.&lt;Texture&gt;</code>
The weapon skins.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+weapons"></a>

### mD2CharacterComplex.weapons : <code>Array.&lt;Mesh&gt;</code>
The weapon meshes.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+currentSkin"></a>

### mD2CharacterComplex.currentSkin : <code>Texture</code>
The current skin.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>undefined</code>  
<a name="MD2CharacterComplex+enableShadows"></a>

### mD2CharacterComplex.enableShadows(enable)
Toggles shadow casting and receiving on the character's meshes.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| enable | <code>boolean</code> | Whether to enable shadows or not. |

<a name="MD2CharacterComplex+setVisible"></a>

### mD2CharacterComplex.setVisible(enable)
Toggles visibility on the character's meshes.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| enable | <code>boolean</code> | Whether the character is visible or not. |

<a name="MD2CharacterComplex+shareParts"></a>

### mD2CharacterComplex.shareParts(original)
Shares certain resources from a different character model.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| original | [<code>MD2CharacterComplex</code>](#MD2CharacterComplex) | The original MD2 character. |

<a name="MD2CharacterComplex+loadParts"></a>

### mD2CharacterComplex.loadParts(config)
Loads the character model for the given config.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| config | <code>Object</code> | The config which defines the model and textures paths. |

<a name="MD2CharacterComplex+setPlaybackRate"></a>

### mD2CharacterComplex.setPlaybackRate(rate)
Sets the animation playback rate.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| rate | <code>number</code> | The playback rate to set. |

<a name="MD2CharacterComplex+setWireframe"></a>

### mD2CharacterComplex.setWireframe(wireframeEnabled)
Sets the wireframe material flag.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| wireframeEnabled | <code>boolean</code> | Whether to enable wireframe rendering or not. |

<a name="MD2CharacterComplex+setSkin"></a>

### mD2CharacterComplex.setSkin(index)
Sets the skin defined by the given skin index. This will result in a different texture
for the body mesh.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The skin index. |

<a name="MD2CharacterComplex+setWeapon"></a>

### mD2CharacterComplex.setWeapon(index)
Sets the weapon defined by the given weapon index. This will result in a different weapon
hold by the character.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The weapon index. |

<a name="MD2CharacterComplex+setAnimation"></a>

### mD2CharacterComplex.setAnimation(animationName)
Sets the defined animation clip as the active animation.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| animationName | <code>string</code> | The name of the animation clip. |

<a name="MD2CharacterComplex+updateAnimations"></a>

### mD2CharacterComplex.updateAnimations(delta)
Updates the animations of the mesh. Must be called inside the animation loop.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="MD2CharacterComplex+updateBehaviors"></a>

### mD2CharacterComplex.updateBehaviors()
Updates the animation state based on the control inputs.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+updateMovementModel"></a>

### mD2CharacterComplex.updateMovementModel(delta)
Transforms the character model based on the control input.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="MorphAnimMesh"></a>

## MorphAnimMesh ⇐ <code>Mesh</code>
A special type of an animated mesh with a simple interface
for animation playback. It allows to playback just one animation
without any transitions or fading between animation changes.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [MorphAnimMesh](#MorphAnimMesh) ⇐ <code>Mesh</code>
    * [new MorphAnimMesh([geometry], [material])](#new_MorphAnimMesh_new)
    * [.mixer](#MorphAnimMesh+mixer) : <code>AnimationMixer</code>
    * [.activeAction](#MorphAnimMesh+activeAction) : <code>AnimationAction</code>
    * [.setDirectionForward()](#MorphAnimMesh+setDirectionForward)
    * [.setDirectionBackward()](#MorphAnimMesh+setDirectionBackward)
    * [.playAnimation(label, fps)](#MorphAnimMesh+playAnimation)
    * [.updateAnimation(delta)](#MorphAnimMesh+updateAnimation)

<a name="new_MorphAnimMesh_new"></a>

### new MorphAnimMesh([geometry], [material])
Constructs a new morph anim mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |

<a name="MorphAnimMesh+mixer"></a>

### morphAnimMesh.mixer : <code>AnimationMixer</code>
The internal animation mixer.

**Kind**: instance property of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  
<a name="MorphAnimMesh+activeAction"></a>

### morphAnimMesh.activeAction : <code>AnimationAction</code>
The current active animation action.

**Kind**: instance property of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  
**Default**: <code>null</code>  
<a name="MorphAnimMesh+setDirectionForward"></a>

### morphAnimMesh.setDirectionForward()
Sets the animation playback direction to "forward".

**Kind**: instance method of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  
<a name="MorphAnimMesh+setDirectionBackward"></a>

### morphAnimMesh.setDirectionBackward()
Sets the animation playback direction to "backward".

**Kind**: instance method of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  
<a name="MorphAnimMesh+playAnimation"></a>

### morphAnimMesh.playAnimation(label, fps)
Plays the defined animation clip. The implementation assumes the animation
clips are stored in [Object3D#animations](Object3D#animations) or the geometry.

**Kind**: instance method of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  

| Param | Type | Description |
| --- | --- | --- |
| label | <code>string</code> | The name of the animation clip. |
| fps | <code>number</code> | The FPS of the animation clip. |

<a name="MorphAnimMesh+updateAnimation"></a>

### morphAnimMesh.updateAnimation(delta)
Updates the animations of the mesh. Must be called inside the animation loop.

**Kind**: instance method of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="MorphBlendMesh"></a>

## MorphBlendMesh ⇐ <code>Mesh</code>
A special type of an animated mesh with a more advanced interface
for animation playback. Unlike [MorphAnimMesh](MorphAnimMesh). It allows to
playback more than one morph animation at the same time but without
fading options.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [MorphBlendMesh](#MorphBlendMesh) ⇐ <code>Mesh</code>
    * [new MorphBlendMesh([geometry], [material])](#new_MorphBlendMesh_new)
    * [.animationsMap](#MorphBlendMesh+animationsMap) : <code>Object.&lt;string, Object&gt;</code>
    * [.animationsList](#MorphBlendMesh+animationsList) : <code>Array.&lt;Object&gt;</code>
    * [.createAnimation(name, start, end, fps)](#MorphBlendMesh+createAnimation)
    * [.autoCreateAnimations(fps)](#MorphBlendMesh+autoCreateAnimations)
    * [.setAnimationDirectionForward(name)](#MorphBlendMesh+setAnimationDirectionForward)
    * [.setAnimationDirectionBackward(name)](#MorphBlendMesh+setAnimationDirectionBackward)
    * [.setAnimationFPS(name, fps)](#MorphBlendMesh+setAnimationFPS)
    * [.setAnimationDuration(name, duration)](#MorphBlendMesh+setAnimationDuration)
    * [.setAnimationWeight(name, weight)](#MorphBlendMesh+setAnimationWeight)
    * [.setAnimationTime(name, time)](#MorphBlendMesh+setAnimationTime)
    * [.getAnimationTime(name)](#MorphBlendMesh+getAnimationTime) ⇒ <code>number</code>
    * [.getAnimationDuration(name)](#MorphBlendMesh+getAnimationDuration) ⇒ <code>number</code>
    * [.playAnimation(name)](#MorphBlendMesh+playAnimation)
    * [.stopAnimation(name)](#MorphBlendMesh+stopAnimation)
    * [.update(delta)](#MorphBlendMesh+update)

<a name="new_MorphBlendMesh_new"></a>

### new MorphBlendMesh([geometry], [material])
Constructs a new morph blend mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |

<a name="MorphBlendMesh+animationsMap"></a>

### morphBlendMesh.animationsMap : <code>Object.&lt;string, Object&gt;</code>
A dictionary of animations.

**Kind**: instance property of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  
<a name="MorphBlendMesh+animationsList"></a>

### morphBlendMesh.animationsList : <code>Array.&lt;Object&gt;</code>
A list of animations.

**Kind**: instance property of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  
<a name="MorphBlendMesh+createAnimation"></a>

### morphBlendMesh.createAnimation(name, start, end, fps)
Creates a new animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| start | <code>number</code> | The start time. |
| end | <code>number</code> | The end time. |
| fps | <code>number</code> | The FPS. |

<a name="MorphBlendMesh+autoCreateAnimations"></a>

### morphBlendMesh.autoCreateAnimations(fps)
Automatically creates animations based on the values in
[Mesh#morphTargetDictionary](Mesh#morphTargetDictionary).

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| fps | <code>number</code> | The FPS of all animations. |

<a name="MorphBlendMesh+setAnimationDirectionForward"></a>

### morphBlendMesh.setAnimationDirectionForward(name)
Sets the animation playback direction to "forward" for the
defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+setAnimationDirectionBackward"></a>

### morphBlendMesh.setAnimationDirectionBackward(name)
Sets the animation playback direction to "backward" for the
defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+setAnimationFPS"></a>

### morphBlendMesh.setAnimationFPS(name, fps)
Sets the FPS to the given value for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| fps | <code>number</code> | The FPS to set. |

<a name="MorphBlendMesh+setAnimationDuration"></a>

### morphBlendMesh.setAnimationDuration(name, duration)
Sets the duration to the given value for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| duration | <code>number</code> | The duration to set. |

<a name="MorphBlendMesh+setAnimationWeight"></a>

### morphBlendMesh.setAnimationWeight(name, weight)
Sets the weight to the given value for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| weight | <code>number</code> | The weight to set. |

<a name="MorphBlendMesh+setAnimationTime"></a>

### morphBlendMesh.setAnimationTime(name, time)
Sets the time to the given value for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| time | <code>number</code> | The time to set. |

<a name="MorphBlendMesh+getAnimationTime"></a>

### morphBlendMesh.getAnimationTime(name) ⇒ <code>number</code>
Returns the time for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  
**Returns**: <code>number</code> - The time.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+getAnimationDuration"></a>

### morphBlendMesh.getAnimationDuration(name) ⇒ <code>number</code>
Returns the duration for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  
**Returns**: <code>number</code> - The duration.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+playAnimation"></a>

### morphBlendMesh.playAnimation(name)
Plays the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+stopAnimation"></a>

### morphBlendMesh.stopAnimation(name)
Stops the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+update"></a>

### morphBlendMesh.update(delta)
Updates the animations of the mesh.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="ProgressiveLightMap"></a>

## ProgressiveLightMap
Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/).

To use, simply construct a `ProgressiveLightMap` object,
`plmap.addObjectsToLightMap(object)` an array of semi-static
objects and lights to the class once, and then call
`plmap.update(camera)` every frame to begin accumulating
lighting samples.

This should begin accumulating lightmaps which apply to
your objects, so you can start jittering lighting to achieve
the texture-space effect you're looking for.

This class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), import from `ProgressiveLightMapGPU.js`.

**Kind**: global class  

* [ProgressiveLightMap](#ProgressiveLightMap)
    * [new ProgressiveLightMap(renderer, [res])](#new_ProgressiveLightMap_new)
    * [.renderer](#ProgressiveLightMap+renderer) : <code>WebGLRenderer</code>
    * [.res](#ProgressiveLightMap+res) : <code>number</code>
    * [.addObjectsToLightMap(objects)](#ProgressiveLightMap+addObjectsToLightMap)
    * [.update(camera, [blendWindow], [blurEdges])](#ProgressiveLightMap+update)
    * [.showDebugLightmap(visible, [position])](#ProgressiveLightMap+showDebugLightmap)
    * [.dispose()](#ProgressiveLightMap+dispose)

<a name="new_ProgressiveLightMap_new"></a>

### new ProgressiveLightMap(renderer, [res])
Constructs a new progressive light map.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>WebGLRenderer</code> |  | The renderer. |
| [res] | <code>number</code> | <code>1024</code> | The side-long dimension of the total lightmap. |

<a name="ProgressiveLightMap+renderer"></a>

### progressiveLightMap.renderer : <code>WebGLRenderer</code>
The renderer.

**Kind**: instance property of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  
<a name="ProgressiveLightMap+res"></a>

### progressiveLightMap.res : <code>number</code>
The side-long dimension of the total lightmap.

**Kind**: instance property of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  
**Default**: <code>1024</code>  
<a name="ProgressiveLightMap+addObjectsToLightMap"></a>

### progressiveLightMap.addObjectsToLightMap(objects)
Sets these objects' materials' lightmaps and modifies their uv1's.

**Kind**: instance method of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  

| Param | Type | Description |
| --- | --- | --- |
| objects | <code>Array.&lt;Object3D&gt;</code> | An array of objects and lights to set up your lightmap. |

<a name="ProgressiveLightMap+update"></a>

### progressiveLightMap.update(camera, [blendWindow], [blurEdges])
This function renders each mesh one at a time into their respective surface maps.

**Kind**: instance method of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>Camera</code> |  | The camera the scene is rendered with. |
| [blendWindow] | <code>number</code> | <code>100</code> | When >1, samples will accumulate over time. |
| [blurEdges] | <code>boolean</code> | <code>true</code> | Whether to fix UV Edges via blurring. |

<a name="ProgressiveLightMap+showDebugLightmap"></a>

### progressiveLightMap.showDebugLightmap(visible, [position])
Draws the lightmap in the main scene. Call this after adding the objects to it.

**Kind**: instance method of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  

| Param | Type | Description |
| --- | --- | --- |
| visible | <code>boolean</code> | Whether the debug plane should be visible |
| [position] | <code>Vector3</code> | Where the debug plane should be drawn |

<a name="ProgressiveLightMap+dispose"></a>

### progressiveLightMap.dispose()
Frees all internal resources.

**Kind**: instance method of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  
## Classes

<dl>
<dt><a href="#RollerCoasterGeometry">RollerCoasterGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural roller coaster geometry.</p>
</dd>
<dt><a href="#RollerCoasterLiftersGeometry">RollerCoasterLiftersGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural roller coaster lifters geometry.</p>
</dd>
<dt><a href="#RollerCoasterShadowGeometry">RollerCoasterShadowGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural roller coaster shadow geometry.</p>
</dd>
<dt><a href="#SkyGeometry">SkyGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural sky geometry.</p>
</dd>
<dt><a href="#TreesGeometry">TreesGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural trees geometry.</p>
</dd>
</dl>

<a name="RollerCoasterGeometry"></a>

## RollerCoasterGeometry ⇐ <code>BufferGeometry</code>
A procedural roller coaster geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_RollerCoasterGeometry_new"></a>

### new RollerCoasterGeometry(curve, divisions)
Constructs a new geometry.


| Param | Type | Description |
| --- | --- | --- |
| curve | <code>Curve</code> | The curve to generate the geometry along. |
| divisions | <code>number</code> | The number of divisions which defines the detail of the geometry. |

<a name="RollerCoasterLiftersGeometry"></a>

## RollerCoasterLiftersGeometry ⇐ <code>BufferGeometry</code>
A procedural roller coaster lifters geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_RollerCoasterLiftersGeometry_new"></a>

### new RollerCoasterLiftersGeometry(curve, divisions)
Constructs a new geometry.


| Param | Type | Description |
| --- | --- | --- |
| curve | <code>Curve</code> | The curve to generate the geometry along. |
| divisions | <code>number</code> | The number of divisions which defines the detail of the geometry. |

<a name="RollerCoasterShadowGeometry"></a>

## RollerCoasterShadowGeometry ⇐ <code>BufferGeometry</code>
A procedural roller coaster shadow geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_RollerCoasterShadowGeometry_new"></a>

### new RollerCoasterShadowGeometry(curve, divisions)
Constructs a new geometry.


| Param | Type | Description |
| --- | --- | --- |
| curve | <code>Curve</code> | The curve to generate the geometry along. |
| divisions | <code>number</code> | The number of divisions which defines the detail of the geometry. |

<a name="SkyGeometry"></a>

## SkyGeometry ⇐ <code>BufferGeometry</code>
A procedural sky geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_SkyGeometry_new"></a>

### new SkyGeometry()
Constructs a new geometry.

<a name="TreesGeometry"></a>

## TreesGeometry ⇐ <code>BufferGeometry</code>
A procedural trees geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_TreesGeometry_new"></a>

### new TreesGeometry(landscape)
Constructs a new geometry.


| Param | Type | Description |
| --- | --- | --- |
| landscape | <code>Mesh</code> | A mesh representing the landscape. Trees will be positioned randomly on the landscape's surface. |

## Classes

<dl>
<dt><a href="#Timer">Timer</a></dt>
<dd><p>This class is an alternative to <a href="Clock">Clock</a> with a different API design and behavior.
The goal is to avoid the conceptual flaws that became apparent in <code>Clock</code> over time.</p>
<ul>
<li><code>Timer</code> has an <code>update()</code> method that updates its internal state. That makes it possible to
call <code>getDelta()</code> and <code>getElapsed()</code> multiple times per simulation step without getting different values.</li>
<li>The class can make use of the Page Visibility API to avoid large time delta values when the app
is inactive (e.g. tab switched or browser hidden).</li>
</ul>
<pre><code class="language-js">const timer = new Timer();
timer.connect( document ); // use Page Visibility API
</code></pre>
</dd>
<dt><a href="#FixedTimer">FixedTimer</a> ⇐ <code><a href="#Timer">Timer</a></code></dt>
<dd><p>A special version of a timer with a fixed time delta value.
Can be useful for testing and debugging purposes.</p>
</dd>
</dl>

<a name="Timer"></a>

## Timer
This class is an alternative to [Clock](Clock) with a different API design and behavior.
The goal is to avoid the conceptual flaws that became apparent in `Clock` over time.

- `Timer` has an `update()` method that updates its internal state. That makes it possible to
call `getDelta()` and `getElapsed()` multiple times per simulation step without getting different values.
- The class can make use of the Page Visibility API to avoid large time delta values when the app
is inactive (e.g. tab switched or browser hidden).

```js
const timer = new Timer();
timer.connect( document ); // use Page Visibility API
```

**Kind**: global class  

* [Timer](#Timer)
    * [new Timer()](#new_Timer_new)
    * [.connect(document)](#Timer+connect)
    * [.disconnect()](#Timer+disconnect)
    * [.getDelta()](#Timer+getDelta) ⇒ <code>number</code>
    * [.getElapsed()](#Timer+getElapsed) ⇒ <code>number</code>
    * [.getTimescale()](#Timer+getTimescale) ⇒ <code>number</code>
    * [.setTimescale(timescale)](#Timer+setTimescale) ⇒ [<code>Timer</code>](#Timer)
    * [.reset()](#Timer+reset) ⇒ [<code>Timer</code>](#Timer)
    * [.dispose()](#Timer+dispose)
    * [.update(timestamp)](#Timer+update) ⇒ [<code>Timer</code>](#Timer)

<a name="new_Timer_new"></a>

### new Timer()
Constructs a new timer.

<a name="Timer+connect"></a>

### timer.connect(document)
Connect the timer to the given document.Calling this method is not mandatory to
use the timer but enables the usage of the Page Visibility API to avoid large time
delta values.

**Kind**: instance method of [<code>Timer</code>](#Timer)  

| Param | Type | Description |
| --- | --- | --- |
| document | <code>Document</code> | The document. |

<a name="Timer+disconnect"></a>

### timer.disconnect()
Disconnects the timer from the DOM and also disables the usage of the Page Visibility API.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
<a name="Timer+getDelta"></a>

### timer.getDelta() ⇒ <code>number</code>
Returns the time delta in seconds.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: <code>number</code> - The time delta in second.  
<a name="Timer+getElapsed"></a>

### timer.getElapsed() ⇒ <code>number</code>
Returns the elapsed time in seconds.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: <code>number</code> - The elapsed time in second.  
<a name="Timer+getTimescale"></a>

### timer.getTimescale() ⇒ <code>number</code>
Returns the timescale.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: <code>number</code> - The timescale.  
<a name="Timer+setTimescale"></a>

### timer.setTimescale(timescale) ⇒ [<code>Timer</code>](#Timer)
Sets the given timescale which scale the time delta computation
in `update()`.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  

| Param | Type | Description |
| --- | --- | --- |
| timescale | <code>number</code> | The timescale to set. |

<a name="Timer+reset"></a>

### timer.reset() ⇒ [<code>Timer</code>](#Timer)
Resets the time computation for the current simulation step.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  
<a name="Timer+dispose"></a>

### timer.dispose()
Can be used to free all internal resources. Usually called when
the timer instance isn't required anymore.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
<a name="Timer+update"></a>

### timer.update(timestamp) ⇒ [<code>Timer</code>](#Timer)
Updates the internal state of the timer. This method should be called
once per simulation step and before you perform queries against the timer
(e.g. via `getDelta()`).

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  

| Param | Type | Description |
| --- | --- | --- |
| timestamp | <code>number</code> | The current time in milliseconds. Can be obtained from the `requestAnimationFrame` callback argument. If not provided, the current time will be determined with `performance.now`. |

<a name="FixedTimer"></a>

## FixedTimer ⇐ [<code>Timer</code>](#Timer)
A special version of a timer with a fixed time delta value.
Can be useful for testing and debugging purposes.

**Kind**: global class  
**Extends**: [<code>Timer</code>](#Timer)  

* [FixedTimer](#FixedTimer) ⇐ [<code>Timer</code>](#Timer)
    * [new FixedTimer([fps])](#new_FixedTimer_new)
    * [.connect(document)](#Timer+connect)
    * [.disconnect()](#Timer+disconnect)
    * [.getDelta()](#Timer+getDelta) ⇒ <code>number</code>
    * [.getElapsed()](#Timer+getElapsed) ⇒ <code>number</code>
    * [.getTimescale()](#Timer+getTimescale) ⇒ <code>number</code>
    * [.setTimescale(timescale)](#Timer+setTimescale) ⇒ [<code>Timer</code>](#Timer)
    * [.reset()](#Timer+reset) ⇒ [<code>Timer</code>](#Timer)
    * [.dispose()](#Timer+dispose)
    * [.update(timestamp)](#Timer+update) ⇒ [<code>Timer</code>](#Timer)

<a name="new_FixedTimer_new"></a>

### new FixedTimer([fps])
Constructs a new timer.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [fps] | <code>number</code> | <code>60</code> | The fixed FPS of this timer. |

<a name="Timer+connect"></a>

### fixedTimer.connect(document)
Connect the timer to the given document.Calling this method is not mandatory to
use the timer but enables the usage of the Page Visibility API to avoid large time
delta values.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>connect</code>](#Timer+connect)  

| Param | Type | Description |
| --- | --- | --- |
| document | <code>Document</code> | The document. |

<a name="Timer+disconnect"></a>

### fixedTimer.disconnect()
Disconnects the timer from the DOM and also disables the usage of the Page Visibility API.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>disconnect</code>](#Timer+disconnect)  
<a name="Timer+getDelta"></a>

### fixedTimer.getDelta() ⇒ <code>number</code>
Returns the time delta in seconds.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>getDelta</code>](#Timer+getDelta)  
**Returns**: <code>number</code> - The time delta in second.  
<a name="Timer+getElapsed"></a>

### fixedTimer.getElapsed() ⇒ <code>number</code>
Returns the elapsed time in seconds.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>getElapsed</code>](#Timer+getElapsed)  
**Returns**: <code>number</code> - The elapsed time in second.  
<a name="Timer+getTimescale"></a>

### fixedTimer.getTimescale() ⇒ <code>number</code>
Returns the timescale.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>getTimescale</code>](#Timer+getTimescale)  
**Returns**: <code>number</code> - The timescale.  
<a name="Timer+setTimescale"></a>

### fixedTimer.setTimescale(timescale) ⇒ [<code>Timer</code>](#Timer)
Sets the given timescale which scale the time delta computation
in `update()`.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>setTimescale</code>](#Timer+setTimescale)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  

| Param | Type | Description |
| --- | --- | --- |
| timescale | <code>number</code> | The timescale to set. |

<a name="Timer+reset"></a>

### fixedTimer.reset() ⇒ [<code>Timer</code>](#Timer)
Resets the time computation for the current simulation step.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>reset</code>](#Timer+reset)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  
<a name="Timer+dispose"></a>

### fixedTimer.dispose()
Can be used to free all internal resources. Usually called when
the timer instance isn't required anymore.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>dispose</code>](#Timer+dispose)  
<a name="Timer+update"></a>

### fixedTimer.update(timestamp) ⇒ [<code>Timer</code>](#Timer)
Updates the internal state of the timer. This method should be called
once per simulation step and before you perform queries against the timer
(e.g. via `getDelta()`).

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>update</code>](#Timer+update)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  

| Param | Type | Description |
| --- | --- | --- |
| timestamp | <code>number</code> | The current time in milliseconds. Can be obtained from the `requestAnimationFrame` callback argument. If not provided, the current time will be determined with `performance.now`. |

<a name="TubePainter"></a>

## TubePainter
This module can be used to paint tube-like meshes
along a sequence of points. This module is used in a XR
painter demo.

```js
const painter = new TubePainter();
scene.add( painter.mesh );
```

**Kind**: global class  

* [TubePainter](#TubePainter)
    * [.mesh](#TubePainter+mesh) : <code>Mesh</code>
    * [.moveTo(position)](#TubePainter+moveTo)
    * [.lineTo(position)](#TubePainter+lineTo)
    * [.setSize(size)](#TubePainter+setSize)
    * [.update()](#TubePainter+update)

<a name="TubePainter+mesh"></a>

### tubePainter.mesh : <code>Mesh</code>
The "painted" tube mesh. Must be added to the scene.

**Kind**: instance property of [<code>TubePainter</code>](#TubePainter)  
<a name="TubePainter+moveTo"></a>

### tubePainter.moveTo(position)
Moves the current painting position to the given value.

**Kind**: instance method of [<code>TubePainter</code>](#TubePainter)  

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Vector3</code> | The new painting position. |

<a name="TubePainter+lineTo"></a>

### tubePainter.lineTo(position)
Draw a stroke from the current position to the given one.
This method extends the tube while drawing with the XR
controllers.

**Kind**: instance method of [<code>TubePainter</code>](#TubePainter)  

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Vector3</code> | The destination position. |

<a name="TubePainter+setSize"></a>

### tubePainter.setSize(size)
Sets the size of newly rendered tube segments.

**Kind**: instance method of [<code>TubePainter</code>](#TubePainter)  

| Param | Type | Description |
| --- | --- | --- |
| size | <code>number</code> | The size. |

<a name="TubePainter+update"></a>

### tubePainter.update()
Updates the internal geometry buffers so the new painted
segments are rendered.

**Kind**: instance method of [<code>TubePainter</code>](#TubePainter)  
<a name="Volume"></a>

## Volume
This class had been written to handle the output of the [NRRDLoader](NRRDLoader).
It contains a volume of data and information about it. For now it only handles 3 dimensional data.

**Kind**: global class  

* [Volume](#Volume)
    * [new Volume([xLength], [yLength], [zLength], [type], [arrayBuffer])](#new_Volume_new)
    * [.xLength](#Volume+xLength) : <code>number</code>
    * [.yLength](#Volume+yLength) : <code>number</code>
    * [.zLength](#Volume+zLength) : <code>number</code>
    * [.axisOrder](#Volume+axisOrder) : <code>Array.&lt;string&gt;</code>
    * [.data](#Volume+data) : <code>TypedArray</code>
    * [.spacing](#Volume+spacing) : <code>Array.&lt;number&gt;</code>
    * [.offset](#Volume+offset) : <code>Array.&lt;number&gt;</code>
    * [.matrix](#Volume+matrix) : <code>Martrix3</code>
    * [.inverseMatrix](#Volume+inverseMatrix) : <code>Martrix3</code>
    * [.lowerThreshold](#Volume+lowerThreshold) : <code>number</code>
    * [.upperThreshold](#Volume+upperThreshold) : <code>number</code>
    * [.sliceList](#Volume+sliceList) : <code>Array</code>
    * [.segmentation](#Volume+segmentation) : <code>boolean</code>
    * [.RASDimensions](#Volume+RASDimensions) : <code>Array.&lt;number&gt;</code>
    * [.getData(i, j, k)](#Volume+getData) ⇒ <code>number</code>
    * [.access(i, j, k)](#Volume+access) ⇒ <code>number</code>
    * [.reverseAccess(index)](#Volume+reverseAccess) ⇒ <code>Array.&lt;number&gt;</code>
    * [.map(functionToMap, context)](#Volume+map) ⇒ [<code>Volume</code>](#Volume)
    * [.extractPerpendicularPlane(axis, RASIndex)](#Volume+extractPerpendicularPlane) ⇒ <code>Object</code>
    * [.extractSlice(axis, index)](#Volume+extractSlice) ⇒ <code>VolumeSlice</code>
    * [.repaintAllSlices()](#Volume+repaintAllSlices) ⇒ [<code>Volume</code>](#Volume)
    * [.computeMinMax()](#Volume+computeMinMax) ⇒ <code>Array.&lt;number&gt;</code>

<a name="new_Volume_new"></a>

### new Volume([xLength], [yLength], [zLength], [type], [arrayBuffer])
Constructs a new volume.


| Param | Type | Description |
| --- | --- | --- |
| [xLength] | <code>number</code> | Width of the volume. |
| [yLength] | <code>number</code> | Length of the volume. |
| [zLength] | <code>number</code> | Depth of the volume. |
| [type] | <code>string</code> | The type of data (uint8, uint16, ...). |
| [arrayBuffer] | <code>ArrayBuffer</code> | The buffer with volume data. |

<a name="Volume+xLength"></a>

### volume.xLength : <code>number</code>
Width of the volume in the IJK coordinate system.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
**Default**: <code>1</code>  
<a name="Volume+yLength"></a>

### volume.yLength : <code>number</code>
Height of the volume in the IJK coordinate system.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
**Default**: <code>1</code>  
<a name="Volume+zLength"></a>

### volume.zLength : <code>number</code>
Depth of the volume in the IJK coordinate system.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
**Default**: <code>1</code>  
<a name="Volume+axisOrder"></a>

### volume.axisOrder : <code>Array.&lt;string&gt;</code>
The order of the Axis dictated by the NRRD header

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+data"></a>

### volume.data : <code>TypedArray</code>
The data of the volume.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+spacing"></a>

### volume.spacing : <code>Array.&lt;number&gt;</code>
Spacing to apply to the volume from IJK to RAS coordinate system

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+offset"></a>

### volume.offset : <code>Array.&lt;number&gt;</code>
Offset of the volume in the RAS coordinate system

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+matrix"></a>

### volume.matrix : <code>Martrix3</code>
The IJK to RAS matrix.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+inverseMatrix"></a>

### volume.inverseMatrix : <code>Martrix3</code>
The RAS to IJK matrix.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+lowerThreshold"></a>

### volume.lowerThreshold : <code>number</code>
The voxels with values under this threshold won't appear in the slices.
If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume.

**Kind**: instance property of [<code>Volume</code>](#Volume)  

| Param | Type |
| --- | --- |
| value | <code>number</code> | 

<a name="Volume+upperThreshold"></a>

### volume.upperThreshold : <code>number</code>
The voxels with values over this threshold won't appear in the slices.
If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume

**Kind**: instance property of [<code>Volume</code>](#Volume)  

| Param | Type |
| --- | --- |
| value | <code>number</code> | 

<a name="Volume+sliceList"></a>

### volume.sliceList : <code>Array</code>
The list of all the slices associated to this volume

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+segmentation"></a>

### volume.segmentation : <code>boolean</code>
Whether to use segmentation mode or not.
It can load 16-bits nrrds correctly.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
**Default**: <code>false</code>  
<a name="Volume+RASDimensions"></a>

### volume.RASDimensions : <code>Array.&lt;number&gt;</code>
This array holds the dimensions of the volume in the RAS space

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+getData"></a>

### volume.getData(i, j, k) ⇒ <code>number</code>
Shortcut for data[access(i,j,k)].

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>number</code> - The value in the data array.  

| Param | Type | Description |
| --- | --- | --- |
| i | <code>number</code> | First coordinate. |
| j | <code>number</code> | Second coordinate. |
| k | <code>number</code> | Third coordinate. |

<a name="Volume+access"></a>

### volume.access(i, j, k) ⇒ <code>number</code>
Compute the index in the data array corresponding to the given coordinates in IJK system.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>number</code> - The index.  

| Param | Type | Description |
| --- | --- | --- |
| i | <code>number</code> | First coordinate. |
| j | <code>number</code> | Second coordinate. |
| k | <code>number</code> | Third coordinate. |

<a name="Volume+reverseAccess"></a>

### volume.reverseAccess(index) ⇒ <code>Array.&lt;number&gt;</code>
Retrieve the IJK coordinates of the voxel corresponding of the given index in the data.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>Array.&lt;number&gt;</code> - The IJK coordinates as `[x,y,z]`.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | Index of the voxel. |

<a name="Volume+map"></a>

### volume.map(functionToMap, context) ⇒ [<code>Volume</code>](#Volume)
Apply a function to all the voxels, be careful, the value will be replaced.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: [<code>Volume</code>](#Volume) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| functionToMap | <code>function</code> | A function to apply to every voxel, will be called with the following parameters: value of the voxel, index of the voxel, the data (TypedArray). |
| context | <code>Object</code> | You can specify a context in which call the function, default if this Volume. |

<a name="Volume+extractPerpendicularPlane"></a>

### volume.extractPerpendicularPlane(axis, RASIndex) ⇒ <code>Object</code>
Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess,
the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>Object</code> - An object containing all the useful information on the geometry of the slice.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code> | The normal axis to the slice. |
| RASIndex | <code>number</code> | The index of the slice. |

<a name="Volume+extractSlice"></a>

### volume.extractSlice(axis, index) ⇒ <code>VolumeSlice</code>
Returns a slice corresponding to the given axis and index.
The coordinate are given in the Right Anterior Superior coordinate format.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>VolumeSlice</code> - The extracted slice.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code> | The normal axis to the slice. |
| index | <code>number</code> | The index of the slice. |

<a name="Volume+repaintAllSlices"></a>

### volume.repaintAllSlices() ⇒ [<code>Volume</code>](#Volume)
Call repaint on all the slices extracted from this volume.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: [<code>Volume</code>](#Volume) - A reference to this volume.  
**See**: [VolumeSlice#repaint](VolumeSlice#repaint)  
<a name="Volume+computeMinMax"></a>

### volume.computeMinMax() ⇒ <code>Array.&lt;number&gt;</code>
Compute the minimum and the maximum of the data in the volume.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>Array.&lt;number&gt;</code> - The min/max data as `[min,max]`.  
<a name="VolumeSlice"></a>

## VolumeSlice
This class has been made to hold a slice of a volume data.

**Kind**: global class  
**See**: [Volume](Volume)  

* [VolumeSlice](#VolumeSlice)
    * [new VolumeSlice(volume, [index], [axis])](#new_VolumeSlice_new)
    * [.volume](#VolumeSlice+volume) : <code>Volume</code>
    * [.index](#VolumeSlice+index) ⇒ <code>number</code>
    * [.axis](#VolumeSlice+axis) : <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code>
    * [.canvas](#VolumeSlice+canvas) : <code>HTMLCanvasElement</code>
    * [.ctx](#VolumeSlice+ctx) : <code>CanvasRenderingContext2D</code>
    * [.canvasBuffer](#VolumeSlice+canvasBuffer) : <code>HTMLCanvasElement</code>
    * [.ctxBuffer](#VolumeSlice+ctxBuffer) : <code>CanvasRenderingContext2D</code>
    * [.mesh](#VolumeSlice+mesh) : <code>Mesh</code>
    * [.geometryNeedsUpdate](#VolumeSlice+geometryNeedsUpdate) : <code>boolean</code>
    * [.iLength](#VolumeSlice+iLength) : <code>number</code>
    * [.jLength](#VolumeSlice+jLength) : <code>number</code>
    * [.sliceAccess](#VolumeSlice+sliceAccess) : <code>function</code>
    * [.repaint()](#VolumeSlice+repaint)
    * [.updateGeometry()](#VolumeSlice+updateGeometry)

<a name="new_VolumeSlice_new"></a>

### new VolumeSlice(volume, [index], [axis])
Constructs a new volume slice.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| volume | <code>Volume</code> |  | The associated volume. |
| [index] | <code>number</code> | <code>0</code> | The index of the slice. |
| [axis] | <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code> | <code>&#x27;z&#x27;</code> | For now only 'x', 'y' or 'z' but later it will change to a normal vector. |

<a name="VolumeSlice+volume"></a>

### volumeSlice.volume : <code>Volume</code>
The associated volume.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+index"></a>

### volumeSlice.index ⇒ <code>number</code>
The index of the slice, if changed, will automatically call updateGeometry at the next repaint.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**Default**: <code>0</code>  

| Param | Type |
| --- | --- |
| value | <code>number</code> | 

<a name="VolumeSlice+axis"></a>

### volumeSlice.axis : <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code>
The normal axis.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+canvas"></a>

### volumeSlice.canvas : <code>HTMLCanvasElement</code>
The final canvas used for the texture.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+ctx"></a>

### volumeSlice.ctx : <code>CanvasRenderingContext2D</code>
The rendering context of the canvas.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+canvasBuffer"></a>

### volumeSlice.canvasBuffer : <code>HTMLCanvasElement</code>
The intermediary canvas used to paint the data.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+ctxBuffer"></a>

### volumeSlice.ctxBuffer : <code>CanvasRenderingContext2D</code>
The rendering context of the canvas buffer,

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+mesh"></a>

### volumeSlice.mesh : <code>Mesh</code>
The mesh ready to get used in the scene.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+geometryNeedsUpdate"></a>

### volumeSlice.geometryNeedsUpdate : <code>boolean</code>
If set to `true`, `updateGeometry()` will be triggered at the next repaint.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**Default**: <code>true</code>  
<a name="VolumeSlice+iLength"></a>

### volumeSlice.iLength : <code>number</code>
Width of slice in the original coordinate system, corresponds to the width of the buffer canvas.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**Default**: <code>0</code>  
<a name="VolumeSlice+jLength"></a>

### volumeSlice.jLength : <code>number</code>
Height of slice in the original coordinate system, corresponds to the height of the buffer canvas.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**Default**: <code>0</code>  
<a name="VolumeSlice+sliceAccess"></a>

### volumeSlice.sliceAccess : <code>function</code>
Function that allow the slice to access right data.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**See**: [Volume#extractPerpendicularPlane](Volume#extractPerpendicularPlane)  
<a name="VolumeSlice+repaint"></a>

### volumeSlice.repaint()
Refresh the texture and the geometry if geometryNeedsUpdate is set to `true`.

**Kind**: instance method of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+updateGeometry"></a>

### volumeSlice.updateGeometry()
Refresh the geometry according to axis and index.

**Kind**: instance method of [<code>VolumeSlice</code>](#VolumeSlice)  
**See**: [Volume#extractPerpendicularPlane](Volume#extractPerpendicularPlane)  
<a name="getUniforms"></a>

## getUniforms(splineTexture) ⇒ <code>Object</code>
Create a new set of uniforms for describing the curve modifier.

**Kind**: global function  
**Returns**: <code>Object</code> - The uniforms object to be used in the shader.  

| Param | Type | Description |
| --- | --- | --- |
| splineTexture | <code>DataTexture</code> | Which holds the curve description. |

<a name="EdgeSplitModifier"></a>

## EdgeSplitModifier
The modifier can be used to split faces at sharp edges. This allows to compute
normals without smoothing the edges which can lead to an improved visual result.

```js
const modifier = new EdgeSplitModifier();
geometry = modifier.modify( geometry, Math.PI * 0.4 );
```

**Kind**: global class  
<a name="EdgeSplitModifier+modify"></a>

### edgeSplitModifier.modify(geometry, cutOffAngle, [tryKeepNormals]) ⇒ <code>BufferGeometry</code>
Returns a new, modified version of the given geometry by applying an edge-split operation.
Please note that the resulting geometry is always indexed.

**Kind**: instance method of [<code>EdgeSplitModifier</code>](#EdgeSplitModifier)  
**Returns**: <code>BufferGeometry</code> - A new, modified geometry.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to modify. |
| cutOffAngle | <code>number</code> |  | The cut off angle in radians. |
| [tryKeepNormals] | <code>boolean</code> | <code>true</code> | Whether to try to keep normals or not. |

<a name="SimplifyModifier"></a>

## SimplifyModifier
This class can be used to modify a geometry by simplifying it. A typical use
case for such a modifier is automatic LOD generation.

The implementation is based on [Progressive Mesh type Polygon Reduction Algorithm](https://web.archive.org/web/20230610044040/http://www.melax.com/polychop/)
by Stan Melax in 1998.

```js
const modifier = new SimplifyModifier();
geometry = modifier.modify( geometry );
```

**Kind**: global class  
<a name="SimplifyModifier+modify"></a>

### simplifyModifier.modify(geometry, count) ⇒ <code>BufferGeometry</code>
Returns a new, modified version of the given geometry by applying a simplification.
Please note that the resulting geometry is always non-indexed.

**Kind**: instance method of [<code>SimplifyModifier</code>](#SimplifyModifier)  
**Returns**: <code>BufferGeometry</code> - A new, modified geometry.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to modify. |
| count | <code>number</code> | The number of vertices to remove. |

<a name="TessellateModifier"></a>

## TessellateModifier
This class can be used to modify a geometry by breaking its edges if they
are longer than maximum length.

```js
const modifier = new TessellateModifier( 8, 6 );
geometry = modifier.modify( geometry );
```

**Kind**: global class  

* [TessellateModifier](#TessellateModifier)
    * [new TessellateModifier([maxEdgeLength], [maxIterations])](#new_TessellateModifier_new)
    * [.maxEdgeLength](#TessellateModifier+maxEdgeLength) : <code>number</code>
    * [.maxIterations](#TessellateModifier+maxIterations) : <code>number</code>
    * [.modify(geometry)](#TessellateModifier+modify) ⇒ <code>BufferGeometry</code>

<a name="new_TessellateModifier_new"></a>

### new TessellateModifier([maxEdgeLength], [maxIterations])
Constructs a new Tessellate modifier.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [maxEdgeLength] | <code>number</code> | <code>0.1</code> | The maximum edge length. |
| [maxIterations] | <code>number</code> | <code>6</code> | The number of iterations. |

<a name="TessellateModifier+maxEdgeLength"></a>

### tessellateModifier.maxEdgeLength : <code>number</code>
The maximum edge length.

**Kind**: instance property of [<code>TessellateModifier</code>](#TessellateModifier)  
**Default**: <code>0.1</code>  
<a name="TessellateModifier+maxIterations"></a>

### tessellateModifier.maxIterations : <code>number</code>
The maximum edge length.

**Kind**: instance property of [<code>TessellateModifier</code>](#TessellateModifier)  
**Default**: <code>0.1</code>  
<a name="TessellateModifier+modify"></a>

### tessellateModifier.modify(geometry) ⇒ <code>BufferGeometry</code>
Returns a new, modified version of the given geometry by applying a tesselation.
Please note that the resulting geometry is always non-indexed.

**Kind**: instance method of [<code>TessellateModifier</code>](#TessellateModifier)  
**Returns**: <code>BufferGeometry</code> - A new, modified geometry.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to modify. |

<a name="GroundedSkybox"></a>

## GroundedSkybox ⇐ <code>Mesh</code>
A ground-projected skybox.

By default the object is centered at the camera, so it is often helpful to set
`skybox.position.y = height` to put the ground at the origin.

```js
const height = 15, radius = 100;

const skybox = new GroundedSkybox( envMap, height, radius );
skybox.position.y = height;
scene.add( skybox );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  
<a name="new_GroundedSkybox_new"></a>

### new GroundedSkybox(map, height, radius, [resolution])
Constructs a new ground-projected skybox.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| map | <code>Texture</code> |  | The environment map to use. |
| height | <code>number</code> |  | The height is how far the camera that took the photo was above the ground. A larger value will magnify the downward part of the image. |
| radius | <code>number</code> |  | The radius of the skybox. Must be large enough to ensure the scene's camera stays inside. |
| [resolution] | <code>number</code> | <code>128</code> | The geometry resolution of the skybox. |

## Classes

<dl>
<dt><a href="#Lensflare">Lensflare</a> ⇐ <code>Mesh</code></dt>
<dd><p>Creates a simulated lens flare that tracks a light.</p>
<p>Note that this class can only be used with <a href="WebGLRenderer">WebGLRenderer</a>.
When using <a href="WebGPURenderer">WebGPURenderer</a>, use <a href="LensflareMesh">LensflareMesh</a>.</p>
<pre><code class="language-js">const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );

const lensflare = new Lensflare();
lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) );

light.add( lensflare );
</code></pre>
</dd>
<dt><a href="#LensflareElement">LensflareElement</a></dt>
<dd><p>Represents a single flare that can be added to a <a href="#Lensflare">Lensflare</a> container.</p>
</dd>
</dl>

<a name="Lensflare"></a>

## Lensflare ⇐ <code>Mesh</code>
Creates a simulated lens flare that tracks a light.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [LensflareMesh](LensflareMesh).

```js
const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );

const lensflare = new Lensflare();
lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) );

light.add( lensflare );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Lensflare](#Lensflare) ⇐ <code>Mesh</code>
    * [new Lensflare()](#new_Lensflare_new)
    * [.isLensflare](#Lensflare+isLensflare) : <code>boolean</code>
    * [.frustumCulled](#Lensflare+frustumCulled) : <code>boolean</code>
    * [.renderOrder](#Lensflare+renderOrder) : <code>number</code>
    * [.addElement(element)](#Lensflare+addElement)
    * [.dispose()](#Lensflare+dispose)

<a name="new_Lensflare_new"></a>

### new Lensflare()
Constructs a new lensflare.

<a name="Lensflare+isLensflare"></a>

### lensflare.isLensflare : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Lensflare</code>](#Lensflare)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Lensflare+frustumCulled"></a>

### lensflare.frustumCulled : <code>boolean</code>
Overwritten to disable view-frustum culling by default.

**Kind**: instance property of [<code>Lensflare</code>](#Lensflare)  
**Default**: <code>false</code>  
<a name="Lensflare+renderOrder"></a>

### lensflare.renderOrder : <code>number</code>
Overwritten to make sure lensflares a rendered last.

**Kind**: instance property of [<code>Lensflare</code>](#Lensflare)  
**Default**: <code>Infinity</code>  
<a name="Lensflare+addElement"></a>

### lensflare.addElement(element)
Adds the given lensflare element to this instance.

**Kind**: instance method of [<code>Lensflare</code>](#Lensflare)  

| Param | Type | Description |
| --- | --- | --- |
| element | [<code>LensflareElement</code>](#LensflareElement) | The element to add. |

<a name="Lensflare+dispose"></a>

### lensflare.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Lensflare</code>](#Lensflare)  
<a name="LensflareElement"></a>

## LensflareElement
Represents a single flare that can be added to a [Lensflare](#Lensflare) container.

**Kind**: global class  

* [LensflareElement](#LensflareElement)
    * [new LensflareElement(texture, [size], [distance], [color])](#new_LensflareElement_new)
    * [.texture](#LensflareElement+texture) : <code>Texture</code>
    * [.size](#LensflareElement+size) : <code>number</code>
    * [.distance](#LensflareElement+distance) : <code>number</code>
    * [.color](#LensflareElement+color) : <code>Color</code>

<a name="new_LensflareElement_new"></a>

### new LensflareElement(texture, [size], [distance], [color])
Constructs a new lensflare element.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The flare's texture. |
| [size] | <code>number</code> | <code>1</code> | The size in pixels. |
| [distance] | <code>number</code> | <code>0</code> | The normalized distance (`[0,1]`) from the light source. A value of `0` means the flare is located at light source. |
| [color] | <code>Color</code> |  | The flare's color |

<a name="LensflareElement+texture"></a>

### lensflareElement.texture : <code>Texture</code>
The flare's texture.

**Kind**: instance property of [<code>LensflareElement</code>](#LensflareElement)  
<a name="LensflareElement+size"></a>

### lensflareElement.size : <code>number</code>
The size in pixels.

**Kind**: instance property of [<code>LensflareElement</code>](#LensflareElement)  
**Default**: <code>1</code>  
<a name="LensflareElement+distance"></a>

### lensflareElement.distance : <code>number</code>
The normalized distance (`[0,1]`) from the light source.
A value of `0` means the flare is located at light source.

**Kind**: instance property of [<code>LensflareElement</code>](#LensflareElement)  
**Default**: <code>0</code>  
<a name="LensflareElement+color"></a>

### lensflareElement.color : <code>Color</code>
The flare's color

**Kind**: instance property of [<code>LensflareElement</code>](#LensflareElement)  
**Default**: <code>(1,1,1)</code>  
<a name="LensflareMesh"></a>

## LensflareMesh ⇐ <code>Mesh</code>
Creates a simulated lens flare that tracks a light.

Note that this class can only be used with [WebGPURenderer](WebGPURenderer).
When using [WebGLRenderer](WebGLRenderer), use [Lensflare](Lensflare).

```js
const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );

const lensflare = new LensflareMesh();
lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) );

light.add( lensflare );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [LensflareMesh](#LensflareMesh) ⇐ <code>Mesh</code>
    * [new LensflareMesh()](#new_LensflareMesh_new)
    * [.isLensflareMesh](#LensflareMesh+isLensflareMesh) : <code>boolean</code>
    * [.frustumCulled](#LensflareMesh+frustumCulled) : <code>boolean</code>
    * [.renderOrder](#LensflareMesh+renderOrder) : <code>number</code>
    * [.addElement(element)](#LensflareMesh+addElement)
    * [.dispose()](#LensflareMesh+dispose)

<a name="new_LensflareMesh_new"></a>

### new LensflareMesh()
Constructs a new lensflare mesh.

<a name="LensflareMesh+isLensflareMesh"></a>

### lensflareMesh.isLensflareMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LensflareMesh</code>](#LensflareMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LensflareMesh+frustumCulled"></a>

### lensflareMesh.frustumCulled : <code>boolean</code>
Overwritten to disable view-frustum culling by default.

**Kind**: instance property of [<code>LensflareMesh</code>](#LensflareMesh)  
**Default**: <code>false</code>  
<a name="LensflareMesh+renderOrder"></a>

### lensflareMesh.renderOrder : <code>number</code>
Overwritten to make sure lensflares a rendered last.

**Kind**: instance property of [<code>LensflareMesh</code>](#LensflareMesh)  
**Default**: <code>Infinity</code>  
<a name="LensflareMesh+addElement"></a>

### lensflareMesh.addElement(element)
Adds the given lensflare element to this instance.

**Kind**: instance method of [<code>LensflareMesh</code>](#LensflareMesh)  

| Param | Type | Description |
| --- | --- | --- |
| element | <code>LensflareElement</code> | The element to add. |

<a name="LensflareMesh+dispose"></a>

### lensflareMesh.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>LensflareMesh</code>](#LensflareMesh)  
<a name="MarchingCubes"></a>

## MarchingCubes
A marching cubes implementation.

Port of: [http://webglsamples.org/blob/blob.html](http://webglsamples.org/blob/blob.html)

**Kind**: global class  

* [MarchingCubes](#MarchingCubes)
    * [new MarchingCubes(resolution, material, [enableUvs], [enableColors], [maxPolyCount])](#new_MarchingCubes_new)
    * [.isMarchingCubes](#MarchingCubes+isMarchingCubes) : <code>boolean</code>
    * [.enableUvs](#MarchingCubes+enableUvs) : <code>boolean</code>
    * [.enableColors](#MarchingCubes+enableColors) : <code>boolean</code>
    * [.addBall(ballx, bally, ballz, strength, subtract, colors)](#MarchingCubes+addBall)
    * [.addPlaneX(strength, subtract)](#MarchingCubes+addPlaneX)
    * [.addPlaneY(strength, subtract)](#MarchingCubes+addPlaneY)
    * [.addPlaneZ(strength, subtract)](#MarchingCubes+addPlaneZ)
    * [.setCell(x, y, z, value)](#MarchingCubes+setCell)
    * [.getCell(x, y, z)](#MarchingCubes+getCell) ⇒ <code>number</code>
    * [.blur([intensity])](#MarchingCubes+blur)
    * [.reset()](#MarchingCubes+reset)
    * [.update()](#MarchingCubes+update)

<a name="new_MarchingCubes_new"></a>

### new MarchingCubes(resolution, material, [enableUvs], [enableColors], [maxPolyCount])
Constructs a new marching cubes instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| resolution | <code>number</code> |  | The effect's resolution. |
| material | <code>Material</code> |  | The cube's material. |
| [enableUvs] | <code>boolean</code> | <code>false</code> | Whether texture coordinates should be animated or not. |
| [enableColors] | <code>boolean</code> | <code>false</code> | Whether colors should be animated or not. |
| [maxPolyCount] | <code>number</code> | <code>10000</code> | The maximum size of the geometry buffers. |

<a name="MarchingCubes+isMarchingCubes"></a>

### marchingCubes.isMarchingCubes : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MarchingCubes</code>](#MarchingCubes)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MarchingCubes+enableUvs"></a>

### marchingCubes.enableUvs : <code>boolean</code>
Whether texture coordinates should be animated or not.

**Kind**: instance property of [<code>MarchingCubes</code>](#MarchingCubes)  
**Default**: <code>false</code>  
<a name="MarchingCubes+enableColors"></a>

### marchingCubes.enableColors : <code>boolean</code>
Whether colors should be animated or not.

**Kind**: instance property of [<code>MarchingCubes</code>](#MarchingCubes)  
**Default**: <code>false</code>  
<a name="MarchingCubes+addBall"></a>

### marchingCubes.addBall(ballx, bally, ballz, strength, subtract, colors)
Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after
a fixed distance, determined by strength and subtract.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| ballx | <code>number</code> | The x-coordinate of the ball. |
| bally | <code>number</code> | The y-coordinate of the ball. |
| ballz | <code>number</code> | The z-coordinate of the ball. |
| strength | <code>number</code> | The strength factor. |
| subtract | <code>number</code> | The subtract factor. |
| colors | <code>Color</code> | The color. |

<a name="MarchingCubes+addPlaneX"></a>

### marchingCubes.addPlaneX(strength, subtract)
Adds a plane along the x-axis.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| strength | <code>number</code> | The strength factor. |
| subtract | <code>number</code> | The subtract factor. |

<a name="MarchingCubes+addPlaneY"></a>

### marchingCubes.addPlaneY(strength, subtract)
Adds a plane along the y-axis.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| strength | <code>number</code> | The strength factor. |
| subtract | <code>number</code> | The subtract factor. |

<a name="MarchingCubes+addPlaneZ"></a>

### marchingCubes.addPlaneZ(strength, subtract)
Adds a plane along the z-axis.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| strength | <code>number</code> | The strength factor. |
| subtract | <code>number</code> | The subtract factor. |

<a name="MarchingCubes+setCell"></a>

### marchingCubes.setCell(x, y, z, value)
Sets the cell value for the given coordinates.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value. |
| y | <code>number</code> | The y value. |
| z | <code>number</code> | The z value. |
| value | <code>number</code> | The value to set. |

<a name="MarchingCubes+getCell"></a>

### marchingCubes.getCell(x, y, z) ⇒ <code>number</code>
Returns the cell value for the given coordinates.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  
**Returns**: <code>number</code> - The value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value. |
| y | <code>number</code> | The y value. |
| z | <code>number</code> | The z value. |

<a name="MarchingCubes+blur"></a>

### marchingCubes.blur([intensity])
Applies a blur with the given intensity.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [intensity] | <code>number</code> | <code>1</code> | The intensity of the blur. |

<a name="MarchingCubes+reset"></a>

### marchingCubes.reset()
Resets the effect.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  
<a name="MarchingCubes+update"></a>

### marchingCubes.update()
Updates the effect.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  
<a name="Reflector"></a>

## Reflector ⇐ <code>Mesh</code>
Can be used to create a flat, reflective surface like a mirror.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [ReflectorNode](ReflectorNode).

```js
const geometry = new THREE.PlaneGeometry( 100, 100 );

const reflector = new Reflector( geometry, {
	clipBias: 0.003,
	textureWidth: window.innerWidth * window.devicePixelRatio,
	textureHeight: window.innerHeight * window.devicePixelRatio,
	color: 0xc1cbcb
} );

scene.add( reflector );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Reflector](#Reflector) ⇐ <code>Mesh</code>
    * [new Reflector(geometry, [options])](#new_Reflector_new)
    * _instance_
        * [.isReflector](#Reflector+isReflector) : <code>boolean</code>
        * [.forceUpdate](#Reflector+forceUpdate) : <code>boolean</code>
        * [.camera](#Reflector+camera) : <code>PerspectiveCamera</code>
        * [.getRenderTarget()](#Reflector+getRenderTarget) ⇒ <code>WebGLRenderTarget</code>
        * [.dispose()](#Reflector+dispose)
    * _inner_
        * [~Options](#Reflector..Options) : <code>Object</code>

<a name="new_Reflector_new"></a>

### new Reflector(geometry, [options])
Constructs a new reflector.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The reflector's geometry. |
| [options] | [<code>Options</code>](#Reflector..Options) | The configuration options. |

<a name="Reflector+isReflector"></a>

### reflector.isReflector : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Reflector</code>](#Reflector)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Reflector+forceUpdate"></a>

### reflector.forceUpdate : <code>boolean</code>
Whether to force an update, no matter if the reflector
is in view or not.

**Kind**: instance property of [<code>Reflector</code>](#Reflector)  
**Default**: <code>false</code>  
<a name="Reflector+camera"></a>

### reflector.camera : <code>PerspectiveCamera</code>
The reflector's virtual camera. This is used to render
the scene from the mirror's point of view.

**Kind**: instance property of [<code>Reflector</code>](#Reflector)  
<a name="Reflector+getRenderTarget"></a>

### reflector.getRenderTarget() ⇒ <code>WebGLRenderTarget</code>
Returns the reflector's internal render target.

**Kind**: instance method of [<code>Reflector</code>](#Reflector)  
**Returns**: <code>WebGLRenderTarget</code> - The internal render target  
<a name="Reflector+dispose"></a>

### reflector.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Reflector</code>](#Reflector)  
<a name="Reflector..Options"></a>

### Reflector~Options : <code>Object</code>
Constructor options of `Reflector`.

**Kind**: inner typedef of [<code>Reflector</code>](#Reflector)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The reflector's color. |
| [textureWidth] | <code>number</code> | <code>512</code> | The texture width. A higher value results in more clear reflections but is also more expensive. |
| [textureHeight] | <code>number</code> | <code>512</code> | The texture height. A higher value results in more clear reflections but is also more expensive. |
| [clipBias] | <code>number</code> | <code>0</code> | The clip bias. |
| [shader] | <code>Object</code> |  | Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry. |
| [multisample] | <code>number</code> | <code>4</code> | How many samples to use for MSAA. `0` disables MSAA. |

<a name="ReflectorForSSRPass"></a>

## ReflectorForSSRPass ⇐ <code>Mesh</code>
A special version of [Reflector](Reflector) for usage with [SSRPass](SSRPass).

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [ReflectorForSSRPass](#ReflectorForSSRPass) ⇐ <code>Mesh</code>
    * [new ReflectorForSSRPass(geometry, [options])](#new_ReflectorForSSRPass_new)
    * _instance_
        * [.getRenderTarget()](#ReflectorForSSRPass+getRenderTarget) ⇒ <code>WebGLRenderTarget</code>
        * [.dispose()](#ReflectorForSSRPass+dispose)
    * _inner_
        * [~Options](#ReflectorForSSRPass..Options) : <code>Object</code>

<a name="new_ReflectorForSSRPass_new"></a>

### new ReflectorForSSRPass(geometry, [options])
Constructs a new reflector.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The reflector's geometry. |
| [options] | [<code>Options</code>](#ReflectorForSSRPass..Options) | The configuration options. |

<a name="ReflectorForSSRPass+getRenderTarget"></a>

### reflectorForSSRPass.getRenderTarget() ⇒ <code>WebGLRenderTarget</code>
Returns the reflector's internal render target.

**Kind**: instance method of [<code>ReflectorForSSRPass</code>](#ReflectorForSSRPass)  
**Returns**: <code>WebGLRenderTarget</code> - The internal render target  
<a name="ReflectorForSSRPass+dispose"></a>

### reflectorForSSRPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>ReflectorForSSRPass</code>](#ReflectorForSSRPass)  
<a name="ReflectorForSSRPass..Options"></a>

### ReflectorForSSRPass~Options : <code>Object</code>
Constructor options of `ReflectorForSSRPass`.

**Kind**: inner typedef of [<code>ReflectorForSSRPass</code>](#ReflectorForSSRPass)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The reflector's color. |
| [textureWidth] | <code>number</code> | <code>512</code> | The texture width. A higher value results in more clear reflections but is also more expensive. |
| [textureHeight] | <code>number</code> | <code>512</code> | The texture height. A higher value results in more clear reflections but is also more expensive. |
| [clipBias] | <code>number</code> | <code>0</code> | The clip bias. |
| [shader] | <code>Object</code> |  | Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry. |
| [useDepthTexture] | <code>boolean</code> | <code>true</code> | Whether to store depth values in a texture or not. |

<a name="Refractor"></a>

## Refractor ⇐ <code>Mesh</code>
Can be used to create a flat, refractive surface like for special
windows or water effects.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [viewportSharedTexture](viewportSharedTexture).

```js
const geometry = new THREE.PlaneGeometry( 100, 100 );

const refractor = new Refractor( refractorGeometry, {
	color: 0xcbcbcb,
	textureWidth: 1024,
	textureHeight: 1024
} );

scene.add( refractor );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Refractor](#Refractor) ⇐ <code>Mesh</code>
    * [new Refractor(geometry, [options])](#new_Refractor_new)
    * _instance_
        * [.isRefractor](#Refractor+isRefractor) : <code>boolean</code>
        * [.camera](#Refractor+camera) : <code>PerspectiveCamera</code>
        * [.getRenderTarget()](#Refractor+getRenderTarget) ⇒ <code>WebGLRenderTarget</code>
        * [.dispose()](#Refractor+dispose)
    * _inner_
        * [~Options](#Refractor..Options) : <code>Object</code>

<a name="new_Refractor_new"></a>

### new Refractor(geometry, [options])
Constructs a new refractor.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The refractor's geometry. |
| [options] | [<code>Options</code>](#Refractor..Options) | The configuration options. |

<a name="Refractor+isRefractor"></a>

### refractor.isRefractor : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Refractor</code>](#Refractor)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Refractor+camera"></a>

### refractor.camera : <code>PerspectiveCamera</code>
The reflector's virtual camera.

**Kind**: instance property of [<code>Refractor</code>](#Refractor)  
<a name="Refractor+getRenderTarget"></a>

### refractor.getRenderTarget() ⇒ <code>WebGLRenderTarget</code>
Returns the reflector's internal render target.

**Kind**: instance method of [<code>Refractor</code>](#Refractor)  
**Returns**: <code>WebGLRenderTarget</code> - The internal render target  
<a name="Refractor+dispose"></a>

### refractor.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Refractor</code>](#Refractor)  
<a name="Refractor..Options"></a>

### Refractor~Options : <code>Object</code>
Constructor options of `Refractor`.

**Kind**: inner typedef of [<code>Refractor</code>](#Refractor)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The refractor's color. |
| [textureWidth] | <code>number</code> | <code>512</code> | The texture width. A higher value results in more clear refractions but is also more expensive. |
| [textureHeight] | <code>number</code> | <code>512</code> | The texture height. A higher value results in more clear refractions but is also more expensive. |
| [clipBias] | <code>number</code> | <code>0</code> | The clip bias. |
| [shader] | <code>Object</code> |  | Can be used to pass in a custom shader that defines how the refractive view is projected onto the reflector's geometry. |
| [multisample] | <code>number</code> | <code>4</code> | How many samples to use for MSAA. `0` disables MSAA. |

<a name="ShadowMesh"></a>

## ShadowMesh ⇐ <code>Mesh</code>
A Shadow Mesh that follows a shadow-casting mesh in the scene,
but is confined to a single plane. This technique can be used as
a very performant alternative to classic shadow mapping. However,
it has serious limitations like:

- Shadows can only be casted on flat planes.
- No soft shadows support.

```js
const cubeShadow = new ShadowMesh( cube );
scene.add( cubeShadow );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [ShadowMesh](#ShadowMesh) ⇐ <code>Mesh</code>
    * [new ShadowMesh(mesh)](#new_ShadowMesh_new)
    * [.isShadowMesh](#ShadowMesh+isShadowMesh) : <code>boolean</code>
    * [.meshMatrix](#ShadowMesh+meshMatrix) : <code>Matrix4</code>
    * [.frustumCulled](#ShadowMesh+frustumCulled) : <code>boolean</code>
    * [.matrixAutoUpdate](#ShadowMesh+matrixAutoUpdate) : <code>boolean</code>
    * [.update(plane, lightPosition4D)](#ShadowMesh+update)

<a name="new_ShadowMesh_new"></a>

### new ShadowMesh(mesh)
Constructs a new shadow mesh.


| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The shadow-casting reference mesh. |

<a name="ShadowMesh+isShadowMesh"></a>

### shadowMesh.isShadowMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowMesh</code>](#ShadowMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowMesh+meshMatrix"></a>

### shadowMesh.meshMatrix : <code>Matrix4</code>
Represent the world matrix of the reference mesh.

**Kind**: instance property of [<code>ShadowMesh</code>](#ShadowMesh)  
<a name="ShadowMesh+frustumCulled"></a>

### shadowMesh.frustumCulled : <code>boolean</code>
Overwritten to disable view-frustum culling by default.

**Kind**: instance property of [<code>ShadowMesh</code>](#ShadowMesh)  
**Default**: <code>false</code>  
<a name="ShadowMesh+matrixAutoUpdate"></a>

### shadowMesh.matrixAutoUpdate : <code>boolean</code>
Overwritten to disable automatic matrix update. The local
matrix is computed manually in [update](#ShadowMesh+update).

**Kind**: instance property of [<code>ShadowMesh</code>](#ShadowMesh)  
**Default**: <code>false</code>  
<a name="ShadowMesh+update"></a>

### shadowMesh.update(plane, lightPosition4D)
Updates the shadow mesh so it follows its shadow-casting reference mesh.

**Kind**: instance method of [<code>ShadowMesh</code>](#ShadowMesh)  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane onto the shadow mesh is projected. |
| lightPosition4D | <code>Vector4</code> | The light position. |

<a name="Sky"></a>

## Sky ⇐ <code>Mesh</code>
Represents a skydome for scene backgrounds. Based on [A Practical Analytic Model for Daylight](https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight)
aka The Preetham Model, the de facto standard for analytical skydomes.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [SkyMesh](SkyMesh).

More references:

- [http://simonwallner.at/project/atmospheric-scattering/](http://simonwallner.at/project/atmospheric-scattering/)
- [http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR](http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR)


```js
const sky = new Sky();
sky.scale.setScalar( 10000 );
scene.add( sky );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Sky](#Sky) ⇐ <code>Mesh</code>
    * [new Sky()](#new_Sky_new)
    * [.isSky](#Sky+isSky) : <code>boolean</code>

<a name="new_Sky_new"></a>

### new Sky()
Constructs a new skydome.

<a name="Sky+isSky"></a>

### sky.isSky : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Sky</code>](#Sky)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SkyMesh"></a>

## SkyMesh ⇐ <code>Mesh</code>
Represents a skydome for scene backgrounds. Based on [A Practical Analytic Model for Daylight](https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight)
aka The Preetham Model, the de facto standard for analytical skydomes.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [SkyMesh](#SkyMesh).

More references:

- [http://simonwallner.at/project/atmospheric-scattering/](http://simonwallner.at/project/atmospheric-scattering/)
- [http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR](http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR)

```js
const sky = new SkyMesh();
sky.scale.setScalar( 10000 );
scene.add( sky );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [SkyMesh](#SkyMesh) ⇐ <code>Mesh</code>
    * [new SkyMesh()](#new_SkyMesh_new)
    * [.turbidity](#SkyMesh+turbidity) : <code>UniformNode.&lt;float&gt;</code>
    * [.rayleigh](#SkyMesh+rayleigh) : <code>UniformNode.&lt;float&gt;</code>
    * [.mieCoefficient](#SkyMesh+mieCoefficient) : <code>UniformNode.&lt;float&gt;</code>
    * [.mieDirectionalG](#SkyMesh+mieDirectionalG) : <code>UniformNode.&lt;float&gt;</code>
    * [.sunPosition](#SkyMesh+sunPosition) : <code>UniformNode.&lt;vec3&gt;</code>
    * [.upUniform](#SkyMesh+upUniform) : <code>UniformNode.&lt;vec3&gt;</code>
    * [.isSky](#SkyMesh+isSky) : <code>boolean</code>

<a name="new_SkyMesh_new"></a>

### new SkyMesh()
Constructs a new skydome.

<a name="SkyMesh+turbidity"></a>

### skyMesh.turbidity : <code>UniformNode.&lt;float&gt;</code>
The turbidity uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+rayleigh"></a>

### skyMesh.rayleigh : <code>UniformNode.&lt;float&gt;</code>
The rayleigh uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+mieCoefficient"></a>

### skyMesh.mieCoefficient : <code>UniformNode.&lt;float&gt;</code>
The mieCoefficient uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+mieDirectionalG"></a>

### skyMesh.mieDirectionalG : <code>UniformNode.&lt;float&gt;</code>
The mieDirectionalG uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+sunPosition"></a>

### skyMesh.sunPosition : <code>UniformNode.&lt;vec3&gt;</code>
The sun position uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+upUniform"></a>

### skyMesh.upUniform : <code>UniformNode.&lt;vec3&gt;</code>
The up position.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+isSky"></a>

### skyMesh.isSky : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Water"></a>

## Water ⇐ <code>Mesh</code>
A basic flat, reflective water effect.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [WaterMesh](WaterMesh).

References:

- [Flat mirror for three.js](https://github.com/Slayvin)
- [An implementation of water shader based on the flat mirror](https://home.adelphi.edu/~stemkoski/)
- [Water shader explanations in WebGL](http://29a.ch/slides/2012/webglwater/)

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Water](#Water) ⇐ <code>Mesh</code>
    * [new Water(geometry, [options])](#new_Water_new)
    * _instance_
        * [.isWater](#Water+isWater) : <code>boolean</code>
    * _inner_
        * [~Options](#Water..Options) : <code>Object</code>

<a name="new_Water_new"></a>

### new Water(geometry, [options])
Constructs a new water instance.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The water's geometry. |
| [options] | [<code>Options</code>](#Water..Options) | The configuration options. |

<a name="Water+isWater"></a>

### water.isWater : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Water</code>](#Water)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Water..Options"></a>

### Water~Options : <code>Object</code>
Constructor options of `Water`.

**Kind**: inner typedef of [<code>Water</code>](#Water)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [textureWidth] | <code>number</code> | <code>512</code> | The texture width. A higher value results in more clear reflections but is also more expensive. |
| [textureHeight] | <code>number</code> | <code>512</code> | The texture height. A higher value results in more clear reflections but is also more expensive. |
| [clipBias] | <code>number</code> | <code>0</code> | The clip bias. |
| [alpha] | <code>number</code> | <code>1</code> | The alpha value. |
| [time] | <code>number</code> | <code>0</code> | The time value. |
| [waterNormals] | <code>Texture</code> | <code></code> | The water's normal map. |
| [sunDirection] | <code>Vector3</code> | <code>(0.70707,0.70707,0.0)</code> | The sun direction. |
| [sunColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The sun color. |
| [waterColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The water color. |
| [eye] | <code>Vector3</code> |  | The eye vector. |
| [distortionScale] | <code>number</code> | <code>20</code> | The distortion scale. |
| [side] | <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code> | <code>FrontSide</code> | The water material's `side` property. |
| [fog] | <code>boolean</code> | <code>false</code> | Whether the water should be affected by fog or not. |

<a name="WaterMesh"></a>

## WaterMesh ⇐ <code>Mesh</code>
A basic flat, reflective water effect.

Note that this class can only be used with [WebGPURenderer](WebGPURenderer).
When using [WebGLRenderer](WebGLRenderer), use [Water](Water).

References:

- [Flat mirror for three.js](https://github.com/Slayvin)
- [An implementation of water shader based on the flat mirror](https://home.adelphi.edu/~stemkoski/)
- [Water shader explanations in WebGL](http://29a.ch/slides/2012/webglwater/)

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [WaterMesh](#WaterMesh) ⇐ <code>Mesh</code>
    * [new WaterMesh(geometry, [options])](#new_WaterMesh_new)
    * _instance_
        * [.isWaterMesh](#WaterMesh+isWaterMesh) : <code>boolean</code>
        * [.resolution](#WaterMesh+resolution) : <code>number</code>
        * [.waterNormals](#WaterMesh+waterNormals) : <code>TextureNode</code>
        * [.alpha](#WaterMesh+alpha) : <code>UniformNode.&lt;float&gt;</code>
        * [.size](#WaterMesh+size) : <code>UniformNode.&lt;float&gt;</code>
        * [.sunColor](#WaterMesh+sunColor) : <code>UniformNode.&lt;color&gt;</code>
        * [.sunDirection](#WaterMesh+sunDirection) : <code>UniformNode.&lt;vec3&gt;</code>
        * [.waterColor](#WaterMesh+waterColor) : <code>UniformNode.&lt;color&gt;</code>
        * [.distortionScale](#WaterMesh+distortionScale) : <code>UniformNode.&lt;float&gt;</code>
    * _inner_
        * [~Options](#WaterMesh..Options) : <code>Object</code>

<a name="new_WaterMesh_new"></a>

### new WaterMesh(geometry, [options])
Constructs a new water mesh.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The water mesh's geometry. |
| [options] | [<code>Options</code>](#WaterMesh..Options) | The configuration options. |

<a name="WaterMesh+isWaterMesh"></a>

### waterMesh.isWaterMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WaterMesh+resolution"></a>

### waterMesh.resolution : <code>number</code>
The effect's resolution scale.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>0.5</code>  
<a name="WaterMesh+waterNormals"></a>

### waterMesh.waterNormals : <code>TextureNode</code>
The water's normal map.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
<a name="WaterMesh+alpha"></a>

### waterMesh.alpha : <code>UniformNode.&lt;float&gt;</code>
The alpha value.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>1</code>  
<a name="WaterMesh+size"></a>

### waterMesh.size : <code>UniformNode.&lt;float&gt;</code>
The size value.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>1</code>  
<a name="WaterMesh+sunColor"></a>

### waterMesh.sunColor : <code>UniformNode.&lt;color&gt;</code>
The sun color.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>0xffffff</code>  
<a name="WaterMesh+sunDirection"></a>

### waterMesh.sunDirection : <code>UniformNode.&lt;vec3&gt;</code>
The sun direction.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>(0.70707,0.70707,0.0)</code>  
<a name="WaterMesh+waterColor"></a>

### waterMesh.waterColor : <code>UniformNode.&lt;color&gt;</code>
The water color.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>0x7f7f7f</code>  
<a name="WaterMesh+distortionScale"></a>

### waterMesh.distortionScale : <code>UniformNode.&lt;float&gt;</code>
The distortion scale.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>20</code>  
<a name="WaterMesh..Options"></a>

### WaterMesh~Options : <code>Object</code>
Constructor options of `WaterMesh`.

**Kind**: inner typedef of [<code>WaterMesh</code>](#WaterMesh)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [resolution] | <code>number</code> | <code>0.5</code> | The resolution scale. |
| [waterNormals] | <code>Texture</code> | <code></code> | The water's normal map. |
| [alpha] | <code>number</code> | <code>1</code> | The alpha value. |
| [size] | <code>number</code> | <code>1</code> | The size value. |
| [sunColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The sun color. |
| [sunDirection] | <code>Vector3</code> | <code>(0.70707,0.70707,0.0)</code> | The sun direction. |
| [waterColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The water color. |
| [distortionScale] | <code>number</code> | <code>20</code> | The distortion scale. |

<a name="AmmoPhysics"></a>

## AmmoPhysics
Can be used to include Ammo.js as a Physics engine into
`three.js` apps. Make sure to include `ammo.wasm.js` first:
```
<script src="jsm/libs/ammo.wasm.js"></script>
```
It is then possible to initialize the API via:
```js
const physics = await AmmoPhysics();
```

**Kind**: global class  

* [AmmoPhysics](#AmmoPhysics)
    * [.addScene(scene)](#AmmoPhysics+addScene)
    * [.addMesh(mesh, [mass])](#AmmoPhysics+addMesh)
    * [.setMeshPosition(mesh, position, [index])](#AmmoPhysics+setMeshPosition)

<a name="AmmoPhysics+addScene"></a>

### ammoPhysics.addScene(scene)
Adds the given scene to this physics simulation. Only meshes with a
`physics` object in their [Object3D#userData](Object3D#userData) field will be honored.
The object can be used to store the mass of the mesh. E.g.:
```js
box.userData.physics = { mass: 1 };
```

**Kind**: instance method of [<code>AmmoPhysics</code>](#AmmoPhysics)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or any type of 3D object to add. |

<a name="AmmoPhysics+addMesh"></a>

### ammoPhysics.addMesh(mesh, [mass])
Adds the given mesh to this physics simulation.

**Kind**: instance method of [<code>AmmoPhysics</code>](#AmmoPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to add. |
| [mass] | <code>number</code> | <code>0</code> | The mass in kg of the mesh. |

<a name="AmmoPhysics+setMeshPosition"></a>

### ammoPhysics.setMeshPosition(mesh, position, [index])
Set the position of the given mesh which is part of the physics simulation. Calling this
method will reset the current simulated velocity of the mesh.

**Kind**: instance method of [<code>AmmoPhysics</code>](#AmmoPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to update the position for. |
| position | <code>Vector3</code> |  | The new position. |
| [index] | <code>number</code> | <code>0</code> | If the mesh is instanced, the index represents the instanced ID. |

<a name="JoltPhysics"></a>

## JoltPhysics
Can be used to include Jolt as a Physics engine into
`three.js` apps. The API can be initialized via:
```js
const physics = await JoltPhysics();
```
The component automatically imports Jolt from a CDN so make sure
to use the component with an active Internet connection.

**Kind**: global class  

* [JoltPhysics](#JoltPhysics)
    * [.addScene(scene)](#JoltPhysics+addScene)
    * [.addMesh(mesh, [mass], [restitution])](#JoltPhysics+addMesh)
    * [.setMeshPosition(mesh, position, [index])](#JoltPhysics+setMeshPosition)

<a name="JoltPhysics+addScene"></a>

### joltPhysics.addScene(scene)
Adds the given scene to this physics simulation. Only meshes with a
`physics` object in their [Object3D#userData](Object3D#userData) field will be honored.
The object can be used to store the mass and restitution of the mesh. E.g.:
```js
box.userData.physics = { mass: 1, restitution: 0 };
```

**Kind**: instance method of [<code>JoltPhysics</code>](#JoltPhysics)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or any type of 3D object to add. |

<a name="JoltPhysics+addMesh"></a>

### joltPhysics.addMesh(mesh, [mass], [restitution])
Adds the given mesh to this physics simulation.

**Kind**: instance method of [<code>JoltPhysics</code>](#JoltPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to add. |
| [mass] | <code>number</code> | <code>0</code> | The mass in kg of the mesh. |
| [restitution] | <code>number</code> | <code>0</code> | The restitution/friction of the mesh. |

<a name="JoltPhysics+setMeshPosition"></a>

### joltPhysics.setMeshPosition(mesh, position, [index])
Set the position of the given mesh which is part of the physics simulation. Calling this
method will reset the current simulated velocity of the mesh.

**Kind**: instance method of [<code>JoltPhysics</code>](#JoltPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to update the position for. |
| position | <code>Vector3</code> |  | The new position. |
| [index] | <code>number</code> | <code>0</code> | If the mesh is instanced, the index represents the instanced ID. |

<a name="RapierPhysics"></a>

## RapierPhysics
Can be used to include Rapier as a Physics engine into
`three.js` apps. The API can be initialized via:
```js
const physics = await RapierPhysics();
```
The component automatically imports Rapier from a CDN so make sure
to use the component with an active Internet connection.

**Kind**: global class  

* [RapierPhysics](#RapierPhysics)
    * [.addScene(scene)](#RapierPhysics+addScene)
    * [.addMesh(mesh, [mass], [restitution])](#RapierPhysics+addMesh)
    * [.setMeshPosition(mesh, position, [index])](#RapierPhysics+setMeshPosition)
    * [.setMeshVelocity(mesh, velocity, [index])](#RapierPhysics+setMeshVelocity)

<a name="RapierPhysics+addScene"></a>

### rapierPhysics.addScene(scene)
Adds the given scene to this physics simulation. Only meshes with a
`physics` object in their [Object3D#userData](Object3D#userData) field will be honored.
The object can be used to store the mass and restitution of the mesh. E.g.:
```js
box.userData.physics = { mass: 1, restitution: 0 };
```

**Kind**: instance method of [<code>RapierPhysics</code>](#RapierPhysics)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or any type of 3D object to add. |

<a name="RapierPhysics+addMesh"></a>

### rapierPhysics.addMesh(mesh, [mass], [restitution])
Adds the given mesh to this physics simulation.

**Kind**: instance method of [<code>RapierPhysics</code>](#RapierPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to add. |
| [mass] | <code>number</code> | <code>0</code> | The mass in kg of the mesh. |
| [restitution] | <code>number</code> | <code>0</code> | The restitution/friction of the mesh. |

<a name="RapierPhysics+setMeshPosition"></a>

### rapierPhysics.setMeshPosition(mesh, position, [index])
Set the position of the given mesh which is part of the physics simulation. Calling this
method will reset the current simulated velocity of the mesh.

**Kind**: instance method of [<code>RapierPhysics</code>](#RapierPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to update the position for. |
| position | <code>Vector3</code> |  | The new position. |
| [index] | <code>number</code> | <code>0</code> | If the mesh is instanced, the index represents the instanced ID. |

<a name="RapierPhysics+setMeshVelocity"></a>

### rapierPhysics.setMeshVelocity(mesh, velocity, [index])
Set the velocity of the given mesh which is part of the physics simulation.

**Kind**: instance method of [<code>RapierPhysics</code>](#RapierPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to update the velocity for. |
| velocity | <code>Vector3</code> |  | The new velocity. |
| [index] | <code>number</code> | <code>0</code> | If the mesh is instanced, the index represents the instanced ID. |

<a name="AfterimagePass"></a>

## AfterimagePass ⇐ <code>Pass</code>
Pass for a basic after image effect.

```js
const afterimagePass = new AfterimagePass( 0.9 );
composer.addPass( afterimagePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [AfterimagePass](#AfterimagePass) ⇐ <code>Pass</code>
    * [new AfterimagePass([damp])](#new_AfterimagePass_new)
    * [.uniforms](#AfterimagePass+uniforms) : <code>Object</code>
    * [.compFsMaterial](#AfterimagePass+compFsMaterial) : <code>ShaderMaterial</code>
    * [.copyFsMaterial](#AfterimagePass+copyFsMaterial) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#AfterimagePass+render)
    * [.setSize(width, height)](#AfterimagePass+setSize)
    * [.dispose()](#AfterimagePass+dispose)

<a name="new_AfterimagePass_new"></a>

### new AfterimagePass([damp])
Constructs a new after image pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [damp] | <code>number</code> | <code>0.96</code> | The damping intensity. A higher value means a stronger after image effect. |

<a name="AfterimagePass+uniforms"></a>

### afterimagePass.uniforms : <code>Object</code>
The pass uniforms. Use this object if you want to update the
`damp` value at runtime.
```js
pass.uniforms.damp.value = 0.9;
```

**Kind**: instance property of [<code>AfterimagePass</code>](#AfterimagePass)  
<a name="AfterimagePass+compFsMaterial"></a>

### afterimagePass.compFsMaterial : <code>ShaderMaterial</code>
The composition material.

**Kind**: instance property of [<code>AfterimagePass</code>](#AfterimagePass)  
<a name="AfterimagePass+copyFsMaterial"></a>

### afterimagePass.copyFsMaterial : <code>ShaderMaterial</code>
The copy material.

**Kind**: instance property of [<code>AfterimagePass</code>](#AfterimagePass)  
<a name="AfterimagePass+render"></a>

### afterimagePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the after image pass.

**Kind**: instance method of [<code>AfterimagePass</code>](#AfterimagePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="AfterimagePass+setSize"></a>

### afterimagePass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>AfterimagePass</code>](#AfterimagePass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="AfterimagePass+dispose"></a>

### afterimagePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>AfterimagePass</code>](#AfterimagePass)  
<a name="BloomPass"></a>

## BloomPass ⇐ <code>Pass</code>
A pass for a basic Bloom effect.

[UnrealBloomPass](UnrealBloomPass) produces a more advanced Bloom but is also
more expensive.

```js
const effectBloom = new BloomPass( 0.75 );
composer.addPass( effectBloom );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [BloomPass](#BloomPass) ⇐ <code>Pass</code>
    * [new BloomPass([strength], [kernelSize], [sigma])](#new_BloomPass_new)
    * [.combineUniforms](#BloomPass+combineUniforms) : <code>Object</code>
    * [.materialCombine](#BloomPass+materialCombine) : <code>ShaderMaterial</code>
    * [.convolutionUniforms](#BloomPass+convolutionUniforms) : <code>Object</code>
    * [.materialConvolution](#BloomPass+materialConvolution) : <code>ShaderMaterial</code>
    * [.needsSwap](#BloomPass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#BloomPass+render)
    * [.setSize(width, height)](#BloomPass+setSize)
    * [.dispose()](#BloomPass+dispose)

<a name="new_BloomPass_new"></a>

### new BloomPass([strength], [kernelSize], [sigma])
Constructs a new Bloom pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [strength] | <code>number</code> | <code>1</code> | The Bloom strength. |
| [kernelSize] | <code>number</code> | <code>25</code> | The kernel size. |
| [sigma] | <code>number</code> | <code>4</code> | The sigma. |

<a name="BloomPass+combineUniforms"></a>

### bloomPass.combineUniforms : <code>Object</code>
The combine pass uniforms.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
<a name="BloomPass+materialCombine"></a>

### bloomPass.materialCombine : <code>ShaderMaterial</code>
The combine pass material.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
<a name="BloomPass+convolutionUniforms"></a>

### bloomPass.convolutionUniforms : <code>Object</code>
The convolution pass uniforms.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
<a name="BloomPass+materialConvolution"></a>

### bloomPass.materialConvolution : <code>ShaderMaterial</code>
The convolution pass material.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
<a name="BloomPass+needsSwap"></a>

### bloomPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
**Default**: <code>false</code>  
<a name="BloomPass+render"></a>

### bloomPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the Bloom pass.

**Kind**: instance method of [<code>BloomPass</code>](#BloomPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="BloomPass+setSize"></a>

### bloomPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>BloomPass</code>](#BloomPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="BloomPass+dispose"></a>

### bloomPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>BloomPass</code>](#BloomPass)  
<a name="BokehPass"></a>

## BokehPass ⇐ <code>Pass</code>
Pass for creating depth of field (DOF) effect.

```js
const bokehPass = new BokehPass( scene, camera, {
	focus: 500
	aperture: 5,
	maxblur: 0.01
} );
composer.addPass( bokehPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [BokehPass](#BokehPass) ⇐ <code>Pass</code>
    * [new BokehPass(scene, camera, params)](#new_BokehPass_new)
    * _instance_
        * [.scene](#BokehPass+scene) : <code>Scene</code>
        * [.camera](#BokehPass+camera) : <code>Camera</code>
        * [.materialBokeh](#BokehPass+materialBokeh) : <code>ShaderMaterial</code>
        * [.uniforms](#BokehPass+uniforms) : <code>Object</code>
        * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#BokehPass+render)
        * [.setSize(width, height)](#BokehPass+setSize)
        * [.dispose()](#BokehPass+dispose)
    * _inner_
        * [~Options](#BokehPass..Options) : <code>Object</code>

<a name="new_BokehPass_new"></a>

### new BokehPass(scene, camera, params)
Constructs a new Bokeh pass.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render the DOF for. |
| camera | <code>Camera</code> | The camera. |
| params | [<code>Options</code>](#BokehPass..Options) | The pass options. |

<a name="BokehPass+scene"></a>

### bokehPass.scene : <code>Scene</code>
The scene to render the DOF for.

**Kind**: instance property of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass+camera"></a>

### bokehPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass+materialBokeh"></a>

### bokehPass.materialBokeh : <code>ShaderMaterial</code>
The pass bokeh material.

**Kind**: instance property of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass+uniforms"></a>

### bokehPass.uniforms : <code>Object</code>
The pass uniforms.  Use this object if you want to update the
`focus`, `aperture` or `maxblur` values at runtime.

```js
pass.uniforms.focus.value = focus;
pass.uniforms.aperture.value = aperture;
pass.uniforms.maxblur.value = maxblur;
```

**Kind**: instance property of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass+render"></a>

### bokehPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the Bokeh pass.

**Kind**: instance method of [<code>BokehPass</code>](#BokehPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="BokehPass+setSize"></a>

### bokehPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>BokehPass</code>](#BokehPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="BokehPass+dispose"></a>

### bokehPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass..Options"></a>

### BokehPass~Options : <code>Object</code>
Constructor options of `BokehPass`.

**Kind**: inner typedef of [<code>BokehPass</code>](#BokehPass)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [focus] | <code>number</code> | <code>1</code> | Defines the effect's focus which is the distance along the camera's look direction in world units. |
| [aperture] | <code>number</code> | <code>0.025</code> | Defines the effect's aperture. |
| [maxblur] | <code>number</code> | <code>1</code> | Defines the effect's maximum blur. |

<a name="ClearPass"></a>

## ClearPass ⇐ <code>Pass</code>
This class can be used to force a clear operation for the current read or
default framebuffer (when rendering to screen).

```js
const clearPass = new ClearPass();
composer.addPass( clearPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [ClearPass](#ClearPass) ⇐ <code>Pass</code>
    * [new ClearPass([clearColor], [clearAlpha])](#new_ClearPass_new)
    * [.needsSwap](#ClearPass+needsSwap) : <code>boolean</code>
    * [.clearColor](#ClearPass+clearColor) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.clearAlpha](#ClearPass+clearAlpha) : <code>number</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#ClearPass+render)

<a name="new_ClearPass_new"></a>

### new ClearPass([clearColor], [clearAlpha])
Constructs a new clear pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [clearColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x000000</code> | The clear color. |
| [clearAlpha] | <code>number</code> | <code>0</code> | The clear alpha. |

<a name="ClearPass+needsSwap"></a>

### clearPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>ClearPass</code>](#ClearPass)  
**Default**: <code>false</code>  
<a name="ClearPass+clearColor"></a>

### clearPass.clearColor : <code>number</code> \| <code>Color</code> \| <code>string</code>
The clear color.

**Kind**: instance property of [<code>ClearPass</code>](#ClearPass)  
**Default**: <code>0x000000</code>  
<a name="ClearPass+clearAlpha"></a>

### clearPass.clearAlpha : <code>number</code>
The clear alpha.

**Kind**: instance property of [<code>ClearPass</code>](#ClearPass)  
**Default**: <code>0</code>  
<a name="ClearPass+render"></a>

### clearPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the clear operation. This affects the current read or the default framebuffer.

**Kind**: instance method of [<code>ClearPass</code>](#ClearPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="CubeTexturePass"></a>

## CubeTexturePass ⇐ <code>Pass</code>
This pass can be used to render a cube texture over the entire screen.

```js
const cubeMap = new THREE.CubeTextureLoader().load( urls );

const cubeTexturePass = new CubeTexturePass( camera, cubemap );
composer.addPass( cubeTexturePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [CubeTexturePass](#CubeTexturePass) ⇐ <code>Pass</code>
    * [new CubeTexturePass(camera, tCube, [opacity])](#new_CubeTexturePass_new)
    * [.camera](#CubeTexturePass+camera) : <code>PerspectiveCamera</code>
    * [.tCube](#CubeTexturePass+tCube) : <code>CubeTexture</code>
    * [.opacity](#CubeTexturePass+opacity) : <code>number</code>
    * [.needsSwap](#CubeTexturePass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#CubeTexturePass+render)
    * [.dispose()](#CubeTexturePass+dispose)

<a name="new_CubeTexturePass_new"></a>

### new CubeTexturePass(camera, tCube, [opacity])
Constructs a new cube texture pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>PerspectiveCamera</code> |  | The camera. |
| tCube | <code>CubeTexture</code> |  | The cube texture to render. |
| [opacity] | <code>number</code> | <code>1</code> | The opacity. |

<a name="CubeTexturePass+camera"></a>

### cubeTexturePass.camera : <code>PerspectiveCamera</code>
The camera.

**Kind**: instance property of [<code>CubeTexturePass</code>](#CubeTexturePass)  
<a name="CubeTexturePass+tCube"></a>

### cubeTexturePass.tCube : <code>CubeTexture</code>
The cube texture to render.

**Kind**: instance property of [<code>CubeTexturePass</code>](#CubeTexturePass)  
<a name="CubeTexturePass+opacity"></a>

### cubeTexturePass.opacity : <code>number</code>
The opacity.

**Kind**: instance property of [<code>CubeTexturePass</code>](#CubeTexturePass)  
**Default**: <code>1</code>  
<a name="CubeTexturePass+needsSwap"></a>

### cubeTexturePass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>CubeTexturePass</code>](#CubeTexturePass)  
**Default**: <code>false</code>  
<a name="CubeTexturePass+render"></a>

### cubeTexturePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the cube texture pass.

**Kind**: instance method of [<code>CubeTexturePass</code>](#CubeTexturePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="CubeTexturePass+dispose"></a>

### cubeTexturePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>CubeTexturePass</code>](#CubeTexturePass)  
<a name="DotScreenPass"></a>

## DotScreenPass ⇐ <code>Pass</code>
Pass for creating a dot-screen effect.

```js
const pass = new DotScreenPass( new THREE.Vector2( 0, 0 ), 0.5, 0.8 );
composer.addPass( pass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [DotScreenPass](#DotScreenPass) ⇐ <code>Pass</code>
    * [new DotScreenPass(center, angle, scale)](#new_DotScreenPass_new)
    * [.uniforms](#DotScreenPass+uniforms) : <code>Object</code>
    * [.material](#DotScreenPass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#DotScreenPass+render)
    * [.dispose()](#DotScreenPass+dispose)

<a name="new_DotScreenPass_new"></a>

### new DotScreenPass(center, angle, scale)
Constructs a new dot screen pass.


| Param | Type | Description |
| --- | --- | --- |
| center | <code>Vector2</code> | The center point. |
| angle | <code>number</code> | The rotation of the effect in radians. |
| scale | <code>number</code> | The scale of the effect. A higher value means smaller dots. |

<a name="DotScreenPass+uniforms"></a>

### dotScreenPass.uniforms : <code>Object</code>
The pass uniforms. Use this object if you want to update the
`center`, `angle` or `scale` values at runtime.
```js
pass.uniforms.center.value.copy( center );
pass.uniforms.angle.value = 0;
pass.uniforms.scale.value = 0.5;
```

**Kind**: instance property of [<code>DotScreenPass</code>](#DotScreenPass)  
<a name="DotScreenPass+material"></a>

### dotScreenPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>DotScreenPass</code>](#DotScreenPass)  
<a name="DotScreenPass+render"></a>

### dotScreenPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the dot screen pass.

**Kind**: instance method of [<code>DotScreenPass</code>](#DotScreenPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="DotScreenPass+dispose"></a>

### dotScreenPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>DotScreenPass</code>](#DotScreenPass)  
<a name="EffectComposer"></a>

## EffectComposer
Used to implement post-processing effects in three.js.
The class manages a chain of post-processing passes to produce the final visual result.
Post-processing passes are executed in order of their addition/insertion.
The last pass is automatically rendered to screen.

This module can only be used with [WebGLRenderer](WebGLRenderer).

```js
const composer = new EffectComposer( renderer );

// adding some passes
const renderPass = new RenderPass( scene, camera );
composer.addPass( renderPass );

const glitchPass = new GlitchPass();
composer.addPass( glitchPass );

const outputPass = new OutputPass()
composer.addPass( outputPass );

function animate() {

	composer.render(); // instead of renderer.render()

}
```

**Kind**: global class  

* [EffectComposer](#EffectComposer)
    * [new EffectComposer(renderer, [renderTarget])](#new_EffectComposer_new)
    * [.renderer](#EffectComposer+renderer) : <code>WebGLRenderer</code>
    * [.writeBuffer](#EffectComposer+writeBuffer) : <code>WebGLRenderTarget</code>
    * [.readBuffer](#EffectComposer+readBuffer) : <code>WebGLRenderTarget</code>
    * [.renderToScreen](#EffectComposer+renderToScreen) : <code>boolean</code>
    * [.passes](#EffectComposer+passes) : <code>Array.&lt;Pass&gt;</code>
    * [.swapBuffers()](#EffectComposer+swapBuffers)
    * [.addPass(pass)](#EffectComposer+addPass)
    * [.insertPass(pass, index)](#EffectComposer+insertPass)
    * [.removePass(pass)](#EffectComposer+removePass)
    * [.isLastEnabledPass(passIndex)](#EffectComposer+isLastEnabledPass) ⇒ <code>boolean</code>
    * [.render(deltaTime)](#EffectComposer+render)
    * [.reset([renderTarget])](#EffectComposer+reset)
    * [.setSize(width, height)](#EffectComposer+setSize)
    * [.setPixelRatio(pixelRatio)](#EffectComposer+setPixelRatio)
    * [.dispose()](#EffectComposer+dispose)

<a name="new_EffectComposer_new"></a>

### new EffectComposer(renderer, [renderTarget])
Constructs a new effect composer.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| [renderTarget] | <code>WebGLRenderTarget</code> | This render target and a clone will be used as the internal read and write buffers. If not given, the composer creates the buffers automatically. |

<a name="EffectComposer+renderer"></a>

### effectComposer.renderer : <code>WebGLRenderer</code>
The renderer.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+writeBuffer"></a>

### effectComposer.writeBuffer : <code>WebGLRenderTarget</code>
A reference to the internal write buffer. Passes usually write
their result into this buffer.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+readBuffer"></a>

### effectComposer.readBuffer : <code>WebGLRenderTarget</code>
A reference to the internal read buffer. Passes usually read
the previous render result from this buffer.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+renderToScreen"></a>

### effectComposer.renderToScreen : <code>boolean</code>
Whether the final pass is rendered to the screen (default framebuffer) or not.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
**Default**: <code>true</code>  
<a name="EffectComposer+passes"></a>

### effectComposer.passes : <code>Array.&lt;Pass&gt;</code>
An array representing the (ordered) chain of post-processing passes.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+swapBuffers"></a>

### effectComposer.swapBuffers()
Swaps the internal read/write buffers.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+addPass"></a>

### effectComposer.addPass(pass)
Adds the given pass to the pass chain.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| pass | <code>Pass</code> | The pass to add. |

<a name="EffectComposer+insertPass"></a>

### effectComposer.insertPass(pass, index)
Inserts the given pass at a given index.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| pass | <code>Pass</code> | The pass to insert. |
| index | <code>number</code> | The index into the pass chain. |

<a name="EffectComposer+removePass"></a>

### effectComposer.removePass(pass)
Removes the given pass from the pass chain.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| pass | <code>Pass</code> | The pass to remove. |

<a name="EffectComposer+isLastEnabledPass"></a>

### effectComposer.isLastEnabledPass(passIndex) ⇒ <code>boolean</code>
Returns `true` if the pass for the given index is the last enabled pass in the pass chain.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  
**Returns**: <code>boolean</code> - Whether the the pass for the given index is the last pass in the pass chain.  

| Param | Type | Description |
| --- | --- | --- |
| passIndex | <code>number</code> | The pass index. |

<a name="EffectComposer+render"></a>

### effectComposer.render(deltaTime)
Executes all enabled post-processing passes in order to produce the final frame.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| deltaTime | <code>number</code> | The delta time in seconds. If not given, the composer computes its own time delta value. |

<a name="EffectComposer+reset"></a>

### effectComposer.reset([renderTarget])
Resets the internal state of the EffectComposer.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| [renderTarget] | <code>WebGLRenderTarget</code> | This render target has the same purpose like the one from the constructor. If set, it is used to setup the read and write buffers. |

<a name="EffectComposer+setSize"></a>

### effectComposer.setSize(width, height)
Resizes the internal read and write buffers as well as all passes. Similar to [WebGLRenderer#setSize](WebGLRenderer#setSize),
this method honors the current pixel ration.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width in logical pixels. |
| height | <code>number</code> | The height in logical pixels. |

<a name="EffectComposer+setPixelRatio"></a>

### effectComposer.setPixelRatio(pixelRatio)
Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
Setting the pixel ratio will automatically resize the composer.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| pixelRatio | <code>number</code> | The pixel ratio to set. |

<a name="EffectComposer+dispose"></a>

### effectComposer.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the composer is no longer used in your app.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  
<a name="FilmPass"></a>

## FilmPass ⇐ <code>Pass</code>
This pass can be used to create a film grain effect.

```js
const filmPass = new FilmPass();
composer.addPass( filmPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [FilmPass](#FilmPass) ⇐ <code>Pass</code>
    * [new FilmPass([intensity], [grayscale])](#new_FilmPass_new)
    * [.uniforms](#FilmPass+uniforms) : <code>Object</code>
    * [.material](#FilmPass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#FilmPass+render)
    * [.dispose()](#FilmPass+dispose)

<a name="new_FilmPass_new"></a>

### new FilmPass([intensity], [grayscale])
Constructs a new film pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [intensity] | <code>number</code> | <code>0.5</code> | The grain intensity in the range `[0,1]` (0 = no effect, 1 = full effect). |
| [grayscale] | <code>boolean</code> | <code>false</code> | Whether to apply a grayscale effect or not. |

<a name="FilmPass+uniforms"></a>

### filmPass.uniforms : <code>Object</code>
The pass uniforms. Use this object if you want to update the
`intensity` or `grayscale` values at runtime.
```js
pass.uniforms.intensity.value = 1;
pass.uniforms.grayscale.value = true;
```

**Kind**: instance property of [<code>FilmPass</code>](#FilmPass)  
<a name="FilmPass+material"></a>

### filmPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>FilmPass</code>](#FilmPass)  
<a name="FilmPass+render"></a>

### filmPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the film pass.

**Kind**: instance method of [<code>FilmPass</code>](#FilmPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="FilmPass+dispose"></a>

### filmPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>FilmPass</code>](#FilmPass)  
<a name="GTAOPass"></a>

## GTAOPass ⇐ <code>Pass</code>
A pass for an GTAO effect.

`GTAOPass` provides better quality than [SSAOPass](SSAOPass) but is also more expensive.

```js
const gtaoPass = new GTAOPass( scene, camera, width, height );
gtaoPass.output = GTAOPass.OUTPUT.Denoise;
composer.addPass( gtaoPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [GTAOPass](#GTAOPass) ⇐ <code>Pass</code>
    * [new GTAOPass(scene, camera, [width], [height], [parameters], [aoParameters], [pdParameters])](#new_GTAOPass_new)
    * [.width](#GTAOPass+width) : <code>number</code>
    * [.height](#GTAOPass+height) : <code>number</code>
    * [.clear](#GTAOPass+clear) : <code>boolean</code>
    * [.camera](#GTAOPass+camera) : <code>Camera</code>
    * [.scene](#GTAOPass+scene) : <code>Scene</code>
    * [.output](#GTAOPass+output) : <code>number</code>
    * [.blendIntensity](#GTAOPass+blendIntensity) : <code>number</code>
    * [.pdRings](#GTAOPass+pdRings) : <code>number</code>
    * [.pdRadiusExponent](#GTAOPass+pdRadiusExponent) : <code>number</code>
    * [.pdSamples](#GTAOPass+pdSamples) : <code>number</code>
    * [.gtaoMap](#GTAOPass+gtaoMap) : <code>Texture</code>
    * [.setSize(width, height)](#GTAOPass+setSize)
    * [.dispose()](#GTAOPass+dispose)
    * [.setGBuffer([depthTexture], [normalTexture])](#GTAOPass+setGBuffer)
    * [.setSceneClipBox(box)](#GTAOPass+setSceneClipBox)
    * [.updateGtaoMaterial(parameters)](#GTAOPass+updateGtaoMaterial)
    * [.updatePdMaterial(parameters)](#GTAOPass+updatePdMaterial)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#GTAOPass+render)

<a name="new_GTAOPass_new"></a>

### new GTAOPass(scene, camera, [width], [height], [parameters], [aoParameters], [pdParameters])
Constructs a new GTAO pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to compute the AO for. |
| camera | <code>Camera</code> |  | The camera. |
| [width] | <code>number</code> | <code>512</code> | The width of the effect. |
| [height] | <code>number</code> | <code>512</code> | The height of the effect. |
| [parameters] | <code>Object</code> |  | The pass parameters. |
| [aoParameters] | <code>Object</code> |  | The AO parameters. |
| [pdParameters] | <code>Object</code> |  | The denoise parameters. |

<a name="GTAOPass+width"></a>

### gtaoPass.width : <code>number</code>
The width of the effect.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>512</code>  
<a name="GTAOPass+height"></a>

### gtaoPass.height : <code>number</code>
The height of the effect.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>512</code>  
<a name="GTAOPass+clear"></a>

### gtaoPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>true</code>  
<a name="GTAOPass+camera"></a>

### gtaoPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
<a name="GTAOPass+scene"></a>

### gtaoPass.scene : <code>Scene</code>
The scene to render the AO for.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
<a name="GTAOPass+output"></a>

### gtaoPass.output : <code>number</code>
The output configuration.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>0</code>  
<a name="GTAOPass+blendIntensity"></a>

### gtaoPass.blendIntensity : <code>number</code>
The AO blend intensity.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>1</code>  
<a name="GTAOPass+pdRings"></a>

### gtaoPass.pdRings : <code>number</code>
The number of Poisson Denoise rings.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>2</code>  
<a name="GTAOPass+pdRadiusExponent"></a>

### gtaoPass.pdRadiusExponent : <code>number</code>
The Poisson Denoise radius exponent.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>2</code>  
<a name="GTAOPass+pdSamples"></a>

### gtaoPass.pdSamples : <code>number</code>
The Poisson Denoise sample count.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>16</code>  
<a name="GTAOPass+gtaoMap"></a>

### gtaoPass.gtaoMap : <code>Texture</code>
A texture holding the computed AO.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Read only**: true  
<a name="GTAOPass+setSize"></a>

### gtaoPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="GTAOPass+dispose"></a>

### gtaoPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  
<a name="GTAOPass+setGBuffer"></a>

### gtaoPass.setGBuffer([depthTexture], [normalTexture])
Configures the GBuffer of this pass. If no arguments are passed,
the pass creates an internal render target for holding depth
and normal data.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| [depthTexture] | <code>DepthTexture</code> | The depth texture. |
| [normalTexture] | <code>DepthTexture</code> | The normal texture. |

<a name="GTAOPass+setSceneClipBox"></a>

### gtaoPass.setSceneClipBox(box)
Configures the clip box of the GTAO shader with the given AABB.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The AABB enclosing the scene that should receive AO. When passing `null`, to clip box is used. |

<a name="GTAOPass+updateGtaoMaterial"></a>

### gtaoPass.updateGtaoMaterial(parameters)
Updates the GTAO material from the given paramter object.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| parameters | <code>Object</code> | The GTAO material parameters. |

<a name="GTAOPass+updatePdMaterial"></a>

### gtaoPass.updatePdMaterial(parameters)
Updates the Denoise material from the given paramter object.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| parameters | <code>Object</code> | The denoise parameters. |

<a name="GTAOPass+render"></a>

### gtaoPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the GTAO pass.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="GlitchPass"></a>

## GlitchPass ⇐ <code>Pass</code>
Pass for creating a glitch effect.

```js
const glitchPass = new GlitchPass();
composer.addPass( glitchPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [GlitchPass](#GlitchPass) ⇐ <code>Pass</code>
    * [new GlitchPass([dt_size])](#new_GlitchPass_new)
    * [.uniforms](#GlitchPass+uniforms) : <code>Object</code>
    * [.material](#GlitchPass+material) : <code>ShaderMaterial</code>
    * [.goWild](#GlitchPass+goWild) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#GlitchPass+render)
    * [.dispose()](#GlitchPass+dispose)

<a name="new_GlitchPass_new"></a>

### new GlitchPass([dt_size])
Constructs a new glitch pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [dt_size] | <code>number</code> | <code>64</code> | The size of the displacement texture for digital glitch squares. |

<a name="GlitchPass+uniforms"></a>

### glitchPass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>GlitchPass</code>](#GlitchPass)  
<a name="GlitchPass+material"></a>

### glitchPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>GlitchPass</code>](#GlitchPass)  
<a name="GlitchPass+goWild"></a>

### glitchPass.goWild : <code>boolean</code>
Whether to noticeably increase the effect instensity or not.

**Kind**: instance property of [<code>GlitchPass</code>](#GlitchPass)  
**Default**: <code>false</code>  
<a name="GlitchPass+render"></a>

### glitchPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the glitch pass.

**Kind**: instance method of [<code>GlitchPass</code>](#GlitchPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="GlitchPass+dispose"></a>

### glitchPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>GlitchPass</code>](#GlitchPass)  
<a name="HalftonePass"></a>

## HalftonePass ⇐ <code>Pass</code>
Pass for creating a RGB halftone effect.

```js
const params = {
	shape: 1,
	radius: 4,
	rotateR: Math.PI / 12,
	rotateB: Math.PI / 12 * 2,
	rotateG: Math.PI / 12 * 3,
	scatter: 0,
	blending: 1,
	blendingMode: 1,
	greyscale: false,
	disable: false
};
const halftonePass = new HalftonePass( params );
composer.addPass( halftonePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [HalftonePass](#HalftonePass) ⇐ <code>Pass</code>
    * [new HalftonePass(params)](#new_HalftonePass_new)
    * [.uniforms](#HalftonePass+uniforms) : <code>Object</code>
    * [.material](#HalftonePass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#HalftonePass+render)
    * [.setSize(width, height)](#HalftonePass+setSize)
    * [.dispose()](#HalftonePass+dispose)

<a name="new_HalftonePass_new"></a>

### new HalftonePass(params)
Constructs a new halftone pass.


| Param | Type | Description |
| --- | --- | --- |
| params | <code>Object</code> | The halftone shader parameter. |

<a name="HalftonePass+uniforms"></a>

### halftonePass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>HalftonePass</code>](#HalftonePass)  
<a name="HalftonePass+material"></a>

### halftonePass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>HalftonePass</code>](#HalftonePass)  
<a name="HalftonePass+render"></a>

### halftonePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the halftone pass.

**Kind**: instance method of [<code>HalftonePass</code>](#HalftonePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="HalftonePass+setSize"></a>

### halftonePass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>HalftonePass</code>](#HalftonePass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="HalftonePass+dispose"></a>

### halftonePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>HalftonePass</code>](#HalftonePass)  
<a name="LUTPass"></a>

## LUTPass ⇐ <code>ShaderPass</code>
Pass for color grading via lookup tables.

```js
const lutPass = new LUTPass( { lut: lut.texture3D } );
composer.addPass( lutPass );
```

**Kind**: global class  
**Extends**: <code>ShaderPass</code>  

* [LUTPass](#LUTPass) ⇐ <code>ShaderPass</code>
    * [new LUTPass([options])](#new_LUTPass_new)
    * [.lut](#LUTPass+lut) : <code>Data3DTexture</code>
    * [.intensity](#LUTPass+intensity) : <code>number</code>

<a name="new_LUTPass_new"></a>

### new LUTPass([options])
Constructs a LUT pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [options] | <code>Object</code> | <code>{}</code> | The pass options. |

<a name="LUTPass+lut"></a>

### lutPass.lut : <code>Data3DTexture</code>
The LUT as a 3D texture.

**Kind**: instance property of [<code>LUTPass</code>](#LUTPass)  
**Default**: <code>null</code>  
<a name="LUTPass+intensity"></a>

### lutPass.intensity : <code>number</code>
The intensity.

**Kind**: instance property of [<code>LUTPass</code>](#LUTPass)  
**Default**: <code>1</code>  
## Classes

<dl>
<dt><a href="#MaskPass">MaskPass</a> ⇐ <code>Pass</code></dt>
<dd><p>This pass can be used to define a mask during post processing.
Meaning only areas of subsequent post processing are affected
which lie in the masking area of this pass. Internally, the masking
is implemented with the stencil buffer.</p>
<pre><code class="language-js">const maskPass = new MaskPass( scene, camera );
composer.addPass( maskPass );
</code></pre>
</dd>
<dt><a href="#ClearMaskPass">ClearMaskPass</a> ⇐ <code>Pass</code></dt>
<dd><p>This pass can be used to clear a mask previously defined with <a href="#MaskPass">MaskPass</a>.</p>
<pre><code class="language-js">const clearPass = new ClearMaskPass();
composer.addPass( clearPass );
</code></pre>
</dd>
</dl>

<a name="MaskPass"></a>

## MaskPass ⇐ <code>Pass</code>
This pass can be used to define a mask during post processing.
Meaning only areas of subsequent post processing are affected
which lie in the masking area of this pass. Internally, the masking
is implemented with the stencil buffer.

```js
const maskPass = new MaskPass( scene, camera );
composer.addPass( maskPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [MaskPass](#MaskPass) ⇐ <code>Pass</code>
    * [new MaskPass(scene, camera)](#new_MaskPass_new)
    * [.scene](#MaskPass+scene) : <code>Scene</code>
    * [.camera](#MaskPass+camera) : <code>Camera</code>
    * [.clear](#MaskPass+clear) : <code>boolean</code>
    * [.needsSwap](#MaskPass+needsSwap) : <code>boolean</code>
    * [.inverse](#MaskPass+inverse) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#MaskPass+render)

<a name="new_MaskPass_new"></a>

### new MaskPass(scene, camera)
Constructs a new mask pass.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The 3D objects in this scene will define the mask. |
| camera | <code>Camera</code> | The camera. |

<a name="MaskPass+scene"></a>

### maskPass.scene : <code>Scene</code>
The scene that defines the mask.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
<a name="MaskPass+camera"></a>

### maskPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
<a name="MaskPass+clear"></a>

### maskPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
**Default**: <code>true</code>  
<a name="MaskPass+needsSwap"></a>

### maskPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
**Default**: <code>false</code>  
<a name="MaskPass+inverse"></a>

### maskPass.inverse : <code>boolean</code>
Whether to inverse the mask or not.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
**Default**: <code>false</code>  
<a name="MaskPass+render"></a>

### maskPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs a mask pass with the configured scene and camera.

**Kind**: instance method of [<code>MaskPass</code>](#MaskPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="ClearMaskPass"></a>

## ClearMaskPass ⇐ <code>Pass</code>
This pass can be used to clear a mask previously defined with [MaskPass](#MaskPass).

```js
const clearPass = new ClearMaskPass();
composer.addPass( clearPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [ClearMaskPass](#ClearMaskPass) ⇐ <code>Pass</code>
    * [new ClearMaskPass()](#new_ClearMaskPass_new)
    * [.needsSwap](#ClearMaskPass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#ClearMaskPass+render)

<a name="new_ClearMaskPass_new"></a>

### new ClearMaskPass()
Constructs a new clear mask pass.

<a name="ClearMaskPass+needsSwap"></a>

### clearMaskPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>ClearMaskPass</code>](#ClearMaskPass)  
**Default**: <code>false</code>  
<a name="ClearMaskPass+render"></a>

### clearMaskPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the clear of the currently defined mask.

**Kind**: instance method of [<code>ClearMaskPass</code>](#ClearMaskPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="OutlinePass"></a>

## OutlinePass ⇐ <code>Pass</code>
A pass for rendering outlines around selected objects.

```js
const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );
const outlinePass = new OutlinePass( resolution, scene, camera );
composer.addPass( outlinePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [OutlinePass](#OutlinePass) ⇐ <code>Pass</code>
    * [new OutlinePass([resolution], scene, camera, [selectedObjects])](#new_OutlinePass_new)
    * [.renderScene](#OutlinePass+renderScene) : <code>Object</code>
    * [.renderCamera](#OutlinePass+renderCamera) : <code>Object</code>
    * [.selectedObjects](#OutlinePass+selectedObjects) : <code>Array.&lt;Object3D&gt;</code>
    * [.visibleEdgeColor](#OutlinePass+visibleEdgeColor) : <code>Color</code>
    * [.hiddenEdgeColor](#OutlinePass+hiddenEdgeColor) : <code>Color</code>
    * [.edgeGlow](#OutlinePass+edgeGlow) : <code>number</code>
    * [.usePatternTexture](#OutlinePass+usePatternTexture) : <code>boolean</code>
    * [.patternTexture](#OutlinePass+patternTexture) : <code>Texture</code>
    * [.edgeThickness](#OutlinePass+edgeThickness) : <code>number</code>
    * [.edgeStrength](#OutlinePass+edgeStrength) : <code>number</code>
    * [.downSampleRatio](#OutlinePass+downSampleRatio) : <code>number</code>
    * [.pulsePeriod](#OutlinePass+pulsePeriod) : <code>number</code>
    * [.resolution](#OutlinePass+resolution) : <code>Vector2</code>
    * [.dispose()](#OutlinePass+dispose)
    * [.setSize(width, height)](#OutlinePass+setSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#OutlinePass+render)

<a name="new_OutlinePass_new"></a>

### new OutlinePass([resolution], scene, camera, [selectedObjects])
Constructs a new outline pass.


| Param | Type | Description |
| --- | --- | --- |
| [resolution] | <code>Vector2</code> | The effect's resolution. |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |
| [selectedObjects] | <code>Array.&lt;Object3D&gt;</code> | The selected 3D objects that should receive an outline. |

<a name="OutlinePass+renderScene"></a>

### outlinePass.renderScene : <code>Object</code>
The scene to render.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
<a name="OutlinePass+renderCamera"></a>

### outlinePass.renderCamera : <code>Object</code>
The camera.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
<a name="OutlinePass+selectedObjects"></a>

### outlinePass.selectedObjects : <code>Array.&lt;Object3D&gt;</code>
The selected 3D objects that should receive an outline.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
<a name="OutlinePass+visibleEdgeColor"></a>

### outlinePass.visibleEdgeColor : <code>Color</code>
The visible edge color.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>(1,1,1)</code>  
<a name="OutlinePass+hiddenEdgeColor"></a>

### outlinePass.hiddenEdgeColor : <code>Color</code>
The hidden edge color.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>(0.1,0.04,0.02)</code>  
<a name="OutlinePass+edgeGlow"></a>

### outlinePass.edgeGlow : <code>number</code>
Can be used for an animated glow/pulse effect.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>0</code>  
<a name="OutlinePass+usePatternTexture"></a>

### outlinePass.usePatternTexture : <code>boolean</code>
Whether to use a pattern texture for to highlight selected
3D objects or not.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>false</code>  
<a name="OutlinePass+patternTexture"></a>

### outlinePass.patternTexture : <code>Texture</code>
Can be used to highlight selected 3D objects. Requires to set
[usePatternTexture](#OutlinePass+usePatternTexture) to `true`.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>null</code>  
<a name="OutlinePass+edgeThickness"></a>

### outlinePass.edgeThickness : <code>number</code>
The edge thickness.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>1</code>  
<a name="OutlinePass+edgeStrength"></a>

### outlinePass.edgeStrength : <code>number</code>
The edge strength.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>3</code>  
<a name="OutlinePass+downSampleRatio"></a>

### outlinePass.downSampleRatio : <code>number</code>
The downsample ratio. The effect can be rendered in a much
lower resolution than the beauty pass.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>2</code>  
<a name="OutlinePass+pulsePeriod"></a>

### outlinePass.pulsePeriod : <code>number</code>
The pulse period.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>0</code>  
<a name="OutlinePass+resolution"></a>

### outlinePass.resolution : <code>Vector2</code>
The effect's resolution.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>(256,256)</code>  
<a name="OutlinePass+dispose"></a>

### outlinePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>OutlinePass</code>](#OutlinePass)  
<a name="OutlinePass+setSize"></a>

### outlinePass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>OutlinePass</code>](#OutlinePass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="OutlinePass+render"></a>

### outlinePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the Outline pass.

**Kind**: instance method of [<code>OutlinePass</code>](#OutlinePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="OutputPass"></a>

## OutputPass ⇐ <code>Pass</code>
This pass is responsible for including tone mapping and color space conversion
into your pass chain. In most cases, this pass should be included at the end
of each pass chain. If a pass requires sRGB input (e.g. like FXAA), the pass
must follow `OutputPass` in the pass chain.

The tone mapping and color space settings are extracted from the renderer.

```js
const outputPass = new OutputPass();
composer.addPass( outputPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [OutputPass](#OutputPass) ⇐ <code>Pass</code>
    * [new OutputPass()](#new_OutputPass_new)
    * [.uniforms](#OutputPass+uniforms) : <code>Object</code>
    * [.material](#OutputPass+material) : <code>RawShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#OutputPass+render)
    * [.dispose()](#OutputPass+dispose)

<a name="new_OutputPass_new"></a>

### new OutputPass()
Constructs a new output pass.

<a name="OutputPass+uniforms"></a>

### outputPass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>OutputPass</code>](#OutputPass)  
<a name="OutputPass+material"></a>

### outputPass.material : <code>RawShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>OutputPass</code>](#OutputPass)  
<a name="OutputPass+render"></a>

### outputPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the output pass.

**Kind**: instance method of [<code>OutputPass</code>](#OutputPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="OutputPass+dispose"></a>

### outputPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>OutputPass</code>](#OutputPass)  
## Classes

<dl>
<dt><a href="#Pass">Pass</a></dt>
<dd><p>Abstract base class for all post processing passes.</p>
<p>This module is only relevant for post processing with <a href="WebGLRenderer">WebGLRenderer</a>.</p>
</dd>
<dt><a href="#FullScreenQuad">FullScreenQuad</a> ⇐ <code>Mesh</code></dt>
<dd><p>This module is a helper for passes which need to render a full
screen effect which is quite common in context of post processing.</p>
<p>The intended usage is to reuse a single full screen quad for rendering
subsequent passes by just reassigning the <code>material</code> reference.</p>
<p>This module can only be used with <a href="WebGLRenderer">WebGLRenderer</a>.</p>
</dd>
</dl>

<a name="Pass"></a>

## *Pass*
Abstract base class for all post processing passes.

This module is only relevant for post processing with [WebGLRenderer](WebGLRenderer).

**Kind**: global abstract class  

* *[Pass](#Pass)*
    * *[new Pass()](#new_Pass_new)*
    * *[.isPass](#Pass+isPass) : <code>boolean</code>*
    * *[.enabled](#Pass+enabled) : <code>boolean</code>*
    * *[.needsSwap](#Pass+needsSwap) : <code>boolean</code>*
    * *[.clear](#Pass+clear) : <code>boolean</code>*
    * *[.renderToScreen](#Pass+renderToScreen) : <code>boolean</code>*
    * **[.setSize(width, height)](#Pass+setSize)**
    * **[.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#Pass+render)**
    * **[.dispose()](#Pass+dispose)**

<a name="new_Pass_new"></a>

### *new Pass()*
Constructs a new pass.

<a name="Pass+isPass"></a>

### *pass.isPass : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Pass+enabled"></a>

### *pass.enabled : <code>boolean</code>*
If set to `true`, the pass is processed by the composer.

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>true</code>  
<a name="Pass+needsSwap"></a>

### *pass.needsSwap : <code>boolean</code>*
If set to `true`, the pass indicates to swap read and write buffer after rendering.

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>true</code>  
<a name="Pass+clear"></a>

### *pass.clear : <code>boolean</code>*
If set to `true`, the pass clears its buffer before rendering

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>false</code>  
<a name="Pass+renderToScreen"></a>

### *pass.renderToScreen : <code>boolean</code>*
If set to `true`, the result of the pass is rendered to screen. The last pass in the composers
pass chain gets automatically rendered to screen, no matter how this property is configured.

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>false</code>  
<a name="Pass+setSize"></a>

### **pass.setSize(width, height)**
Sets the size of the pass.

**Kind**: instance abstract method of [<code>Pass</code>](#Pass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="Pass+render"></a>

### **pass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)**
This method holds the render logic of a pass. It must be implemented in all derived classes.

**Kind**: instance abstract method of [<code>Pass</code>](#Pass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="Pass+dispose"></a>

### **pass.dispose()**
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance abstract method of [<code>Pass</code>](#Pass)  
<a name="FullScreenQuad"></a>

## FullScreenQuad ⇐ <code>Mesh</code>
This module is a helper for passes which need to render a full
screen effect which is quite common in context of post processing.

The intended usage is to reuse a single full screen quad for rendering
subsequent passes by just reassigning the `material` reference.

This module can only be used with [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [FullScreenQuad](#FullScreenQuad) ⇐ <code>Mesh</code>
    * [new FullScreenQuad(material)](#new_FullScreenQuad_new)
    * [.material](#FullScreenQuad+material) : <code>Material</code>
    * [.dispose()](#FullScreenQuad+dispose)
    * [.render(renderer)](#FullScreenQuad+render)

<a name="new_FullScreenQuad_new"></a>

### new FullScreenQuad(material)
Constructs a new full screen quad.


| Param | Type | Description |
| --- | --- | --- |
| material | <code>Material</code> | The material to render te full screen quad with. |

<a name="FullScreenQuad+material"></a>

### fullScreenQuad.material : <code>Material</code>
The quad's material.

**Kind**: instance property of [<code>FullScreenQuad</code>](#FullScreenQuad)  
<a name="FullScreenQuad+dispose"></a>

### fullScreenQuad.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the instance is no longer used in your app.

**Kind**: instance method of [<code>FullScreenQuad</code>](#FullScreenQuad)  
<a name="FullScreenQuad+render"></a>

### fullScreenQuad.render(renderer)
Renders the full screen quad.

**Kind**: instance method of [<code>FullScreenQuad</code>](#FullScreenQuad)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="RenderPass"></a>

## RenderPass ⇐ <code>Pass</code>
This class represents a render pass. It takes a camera and a scene and produces
a beauty pass for subsequent post processing effects.

```js
const renderPass = new RenderPass( scene, camera );
composer.addPass( renderPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [RenderPass](#RenderPass) ⇐ <code>Pass</code>
    * [new RenderPass(scene, camera, [overrideMaterial], [clearColor], [clearAlpha])](#new_RenderPass_new)
    * [.scene](#RenderPass+scene) : <code>Scene</code>
    * [.camera](#RenderPass+camera) : <code>Camera</code>
    * [.overrideMaterial](#RenderPass+overrideMaterial) : <code>Material</code>
    * [.clearColor](#RenderPass+clearColor) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.clearAlpha](#RenderPass+clearAlpha) : <code>number</code>
    * [.clear](#RenderPass+clear) : <code>boolean</code>
    * [.clearDepth](#RenderPass+clearDepth) : <code>boolean</code>
    * [.needsSwap](#RenderPass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#RenderPass+render)

<a name="new_RenderPass_new"></a>

### new RenderPass(scene, camera, [overrideMaterial], [clearColor], [clearAlpha])
Constructs a new render pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera. |
| [overrideMaterial] | <code>Material</code> | <code></code> | The override material. If set, this material is used for all objects in the scene. |
| [clearColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code></code> | The clear color of the render pass. |
| [clearAlpha] | <code>number</code> | <code></code> | The clear alpha of the render pass. |

<a name="RenderPass+scene"></a>

### renderPass.scene : <code>Scene</code>
The scene to render.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
<a name="RenderPass+camera"></a>

### renderPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
<a name="RenderPass+overrideMaterial"></a>

### renderPass.overrideMaterial : <code>Material</code>
The override material. If set, this material is used
for all objects in the scene.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>null</code>  
<a name="RenderPass+clearColor"></a>

### renderPass.clearColor : <code>number</code> \| <code>Color</code> \| <code>string</code>
The clear color of the render pass.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>null</code>  
<a name="RenderPass+clearAlpha"></a>

### renderPass.clearAlpha : <code>number</code>
The clear alpha of the render pass.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>null</code>  
<a name="RenderPass+clear"></a>

### renderPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>true</code>  
<a name="RenderPass+clearDepth"></a>

### renderPass.clearDepth : <code>boolean</code>
If set to `true`, only the depth can be cleared when `clear` is to `false`.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>false</code>  
<a name="RenderPass+needsSwap"></a>

### renderPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>false</code>  
<a name="RenderPass+render"></a>

### renderPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs a beauty pass with the configured scene and camera.

**Kind**: instance method of [<code>RenderPass</code>](#RenderPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="RenderPixelatedPass"></a>

## RenderPixelatedPass ⇐ <code>Pass</code>
A special type of render pass that produces a pixelated beauty pass.

```js
const renderPixelatedPass = new RenderPixelatedPass( 6, scene, camera );
composer.addPass( renderPixelatedPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [RenderPixelatedPass](#RenderPixelatedPass) ⇐ <code>Pass</code>
    * [new RenderPixelatedPass(pixelSize, scene, camera, options)](#new_RenderPixelatedPass_new)
    * [.pixelSize](#RenderPixelatedPass+pixelSize) : <code>number</code>
    * [.scene](#RenderPixelatedPass+scene) : <code>Scene</code>
    * [.camera](#RenderPixelatedPass+camera) : <code>Camera</code>
    * [.normalEdgeStrength](#RenderPixelatedPass+normalEdgeStrength) : <code>number</code>
    * [.depthEdgeStrength](#RenderPixelatedPass+depthEdgeStrength) : <code>number</code>
    * [.pixelatedMaterial](#RenderPixelatedPass+pixelatedMaterial) : <code>ShaderMaterial</code>
    * [.dispose()](#RenderPixelatedPass+dispose)
    * [.setSize(width, height)](#RenderPixelatedPass+setSize)
    * [.setPixelSize(pixelSize)](#RenderPixelatedPass+setPixelSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#RenderPixelatedPass+render)

<a name="new_RenderPixelatedPass_new"></a>

### new RenderPixelatedPass(pixelSize, scene, camera, options)
Constructs a new render pixelated pass.


| Param | Type | Description |
| --- | --- | --- |
| pixelSize | <code>number</code> | The effect's pixel size. |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |
| options | <code>Object</code> | The pass options. |

<a name="RenderPixelatedPass+pixelSize"></a>

### renderPixelatedPass.pixelSize : <code>number</code>
The effect's pixel size.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+scene"></a>

### renderPixelatedPass.scene : <code>Scene</code>
The scene to render.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+camera"></a>

### renderPixelatedPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+normalEdgeStrength"></a>

### renderPixelatedPass.normalEdgeStrength : <code>number</code>
The normal edge strength.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
**Default**: <code>0.3</code>  
<a name="RenderPixelatedPass+depthEdgeStrength"></a>

### renderPixelatedPass.depthEdgeStrength : <code>number</code>
The normal edge strength.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
**Default**: <code>0.4</code>  
<a name="RenderPixelatedPass+pixelatedMaterial"></a>

### renderPixelatedPass.pixelatedMaterial : <code>ShaderMaterial</code>
The pixelated material.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+dispose"></a>

### renderPixelatedPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+setSize"></a>

### renderPixelatedPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="RenderPixelatedPass+setPixelSize"></a>

### renderPixelatedPass.setPixelSize(pixelSize)
Sets the effect's pixel size.

**Kind**: instance method of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  

| Param | Type | Description |
| --- | --- | --- |
| pixelSize | <code>number</code> | The pixel size to set. |

<a name="RenderPixelatedPass+render"></a>

### renderPixelatedPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the pixelation pass.

**Kind**: instance method of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="RenderTransitionPass"></a>

## RenderTransitionPass ⇐ <code>Pass</code>
A special type of render pass for implementing transition effects.
When active, the pass will transition from scene A to scene B.

```js
const renderTransitionPass = new RenderTransitionPass( fxSceneA.scene, fxSceneA.camera, fxSceneB.scene, fxSceneB.camera );
renderTransitionPass.setTexture( textures[ 0 ] );
composer.addPass( renderTransitionPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [RenderTransitionPass](#RenderTransitionPass) ⇐ <code>Pass</code>
    * [new RenderTransitionPass(sceneA, cameraA, sceneB, cameraB)](#new_RenderTransitionPass_new)
    * [.sceneA](#RenderTransitionPass+sceneA) : <code>Scene</code>
    * [.cameraA](#RenderTransitionPass+cameraA) : <code>Camera</code>
    * [.sceneB](#RenderTransitionPass+sceneB) : <code>Scene</code>
    * [.cameraB](#RenderTransitionPass+cameraB) : <code>Camera</code>
    * [.material](#RenderTransitionPass+material) : <code>ShaderMaterial</code>
    * [.setTransition(value)](#RenderTransitionPass+setTransition)
    * [.useTexture(value)](#RenderTransitionPass+useTexture)
    * [.setTexture(value)](#RenderTransitionPass+setTexture)
    * [.setTextureThreshold(value)](#RenderTransitionPass+setTextureThreshold)
    * [.setSize(width, height)](#RenderTransitionPass+setSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#RenderTransitionPass+render)
    * [.dispose()](#RenderTransitionPass+dispose)

<a name="new_RenderTransitionPass_new"></a>

### new RenderTransitionPass(sceneA, cameraA, sceneB, cameraB)
Constructs a render transition pass.


| Param | Type | Description |
| --- | --- | --- |
| sceneA | <code>Scene</code> | The first scene. |
| cameraA | <code>Camera</code> | The camera of the first scene. |
| sceneB | <code>Scene</code> | The second scene. |
| cameraB | <code>Camera</code> | The camera of the second scene. |

<a name="RenderTransitionPass+sceneA"></a>

### renderTransitionPass.sceneA : <code>Scene</code>
The first scene.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+cameraA"></a>

### renderTransitionPass.cameraA : <code>Camera</code>
The camera of the first scene.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+sceneB"></a>

### renderTransitionPass.sceneB : <code>Scene</code>
The second scene.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+cameraB"></a>

### renderTransitionPass.cameraB : <code>Camera</code>
The camera of the second scene.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+material"></a>

### renderTransitionPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+setTransition"></a>

### renderTransitionPass.setTransition(value)
Sets the transition factor. Must be in the range `[0,1]`.
This value determines to what degree both scenes are mixed.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolenumberan</code> | The transition factor. |

<a name="RenderTransitionPass+useTexture"></a>

### renderTransitionPass.useTexture(value)
Toggles the usage of a texture for the effect.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | Whether to use a texture for the transition effect or not. |

<a name="RenderTransitionPass+setTexture"></a>

### renderTransitionPass.setTexture(value)
Sets the effect texture.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Texture</code> | The effect texture. |

<a name="RenderTransitionPass+setTextureThreshold"></a>

### renderTransitionPass.setTextureThreshold(value)
Sets the texture threshold. This value defined how strong the texture effects
the transition. Must be in the range `[0,1]` (0 means full effect, 1 means no effect).

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolenumberan</code> | The threshold value. |

<a name="RenderTransitionPass+setSize"></a>

### renderTransitionPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="RenderTransitionPass+render"></a>

### renderTransitionPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the transition pass.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="RenderTransitionPass+dispose"></a>

### renderTransitionPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="SAOPass"></a>

## SAOPass ⇐ <code>Pass</code>
A SAO implementation inspired from @bhouston previous SAO work.

`SAOPass` provides better quality than [SSAOPass](SSAOPass) but is also more expensive.

```js
const saoPass = new SAOPass( scene, camera );
composer.addPass( saoPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SAOPass](#SAOPass) ⇐ <code>Pass</code>
    * [new SAOPass(scene, camera, [resolution])](#new_SAOPass_new)
    * [.scene](#SAOPass+scene) : <code>Scene</code>
    * [.camera](#SAOPass+camera) : <code>Camera</code>
    * [.clear](#SAOPass+clear) : <code>boolean</code>
    * [.needsSwap](#SAOPass+needsSwap) : <code>boolean</code>
    * [.params](#SAOPass+params) : <code>Object</code>
    * [.resolution](#SAOPass+resolution) : <code>Vector2</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SAOPass+render)
    * [.setSize(width, height)](#SAOPass+setSize)
    * [.dispose()](#SAOPass+dispose)

<a name="new_SAOPass_new"></a>

### new SAOPass(scene, camera, [resolution])
Constructs a new SAO pass.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to compute the AO for. |
| camera | <code>Camera</code> | The camera. |
| [resolution] | <code>Vector2</code> | The effect's resolution. |

<a name="SAOPass+scene"></a>

### saoPass.scene : <code>Scene</code>
The scene to render the AO for.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
<a name="SAOPass+camera"></a>

### saoPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
<a name="SAOPass+clear"></a>

### saoPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
**Default**: <code>true</code>  
<a name="SAOPass+needsSwap"></a>

### saoPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
**Default**: <code>false</code>  
<a name="SAOPass+params"></a>

### saoPass.params : <code>Object</code>
The SAO paramter.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
<a name="SAOPass+resolution"></a>

### saoPass.resolution : <code>Vector2</code>
The effect's resolution.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
**Default**: <code>(256,256)</code>  
<a name="SAOPass+render"></a>

### saoPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SAO pass.

**Kind**: instance method of [<code>SAOPass</code>](#SAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SAOPass+setSize"></a>

### saoPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SAOPass</code>](#SAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SAOPass+dispose"></a>

### saoPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SAOPass</code>](#SAOPass)  
<a name="SMAAPass"></a>

## SMAAPass ⇐ <code>Pass</code>
A pass for applying SMAA. Unlike [FXAAPass](FXAAPass), `SMAAPass` operates in
`linar-srgb` so this pass must be executed before [OutputPass](OutputPass).

```js
const smaaPass = new SMAAPass();
composer.addPass( smaaPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SMAAPass](#SMAAPass) ⇐ <code>Pass</code>
    * [new SMAAPass()](#new_SMAAPass_new)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SMAAPass+render)
    * [.setSize(width, height)](#SMAAPass+setSize)
    * [.dispose()](#SMAAPass+dispose)

<a name="new_SMAAPass_new"></a>

### new SMAAPass()
Constructs a new SMAA pass.

<a name="SMAAPass+render"></a>

### smaaPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SMAA pass.

**Kind**: instance method of [<code>SMAAPass</code>](#SMAAPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SMAAPass+setSize"></a>

### smaaPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SMAAPass</code>](#SMAAPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SMAAPass+dispose"></a>

### smaaPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SMAAPass</code>](#SMAAPass)  
<a name="SSAARenderPass"></a>

## SSAARenderPass ⇐ <code>Pass</code>
Supersample Anti-Aliasing Render Pass.

This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.

```js
const ssaaRenderPass = new SSAARenderPass( scene, camera );
ssaaRenderPass.sampleLevel = 3;
composer.addPass( ssaaRenderPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SSAARenderPass](#SSAARenderPass) ⇐ <code>Pass</code>
    * [new SSAARenderPass(scene, camera, [clearColor], [clearAlpha])](#new_SSAARenderPass_new)
    * [.scene](#SSAARenderPass+scene) : <code>Scene</code>
    * [.camera](#SSAARenderPass+camera) : <code>Camera</code>
    * [.sampleLevel](#SSAARenderPass+sampleLevel) : <code>number</code>
    * [.unbiased](#SSAARenderPass+unbiased) : <code>boolean</code>
    * [.stencilBuffer](#SSAARenderPass+stencilBuffer) : <code>boolean</code>
    * [.clearColor](#SSAARenderPass+clearColor) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.clearAlpha](#SSAARenderPass+clearAlpha) : <code>number</code>
    * [.dispose()](#SSAARenderPass+dispose)
    * [.setSize(width, height)](#SSAARenderPass+setSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SSAARenderPass+render)

<a name="new_SSAARenderPass_new"></a>

### new SSAARenderPass(scene, camera, [clearColor], [clearAlpha])
Constructs a new SSAA render pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera. |
| [clearColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x000000</code> | The clear color of the render pass. |
| [clearAlpha] | <code>number</code> | <code>0</code> | The clear alpha of the render pass. |

<a name="SSAARenderPass+scene"></a>

### ssaaRenderPass.scene : <code>Scene</code>
The scene to render.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
<a name="SSAARenderPass+camera"></a>

### ssaaRenderPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
<a name="SSAARenderPass+sampleLevel"></a>

### ssaaRenderPass.sampleLevel : <code>number</code>
The sample level. Specified as n, where the number of
samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>4</code>  
<a name="SSAARenderPass+unbiased"></a>

### ssaaRenderPass.unbiased : <code>boolean</code>
Whether the pass should be unbiased or not. This property has the most
visible effect when rendering to a RGBA8 buffer because it mitigates
rounding errors. By default RGBA16F is used.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>true</code>  
<a name="SSAARenderPass+stencilBuffer"></a>

### ssaaRenderPass.stencilBuffer : <code>boolean</code>
Whether to use a stencil buffer or not. This property can't
be changed after the first render.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>false</code>  
<a name="SSAARenderPass+clearColor"></a>

### ssaaRenderPass.clearColor : <code>number</code> \| <code>Color</code> \| <code>string</code>
The clear color of the render pass.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>0x000000</code>  
<a name="SSAARenderPass+clearAlpha"></a>

### ssaaRenderPass.clearAlpha : <code>number</code>
The clear alpha of the render pass.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>0</code>  
<a name="SSAARenderPass+dispose"></a>

### ssaaRenderPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SSAARenderPass</code>](#SSAARenderPass)  
<a name="SSAARenderPass+setSize"></a>

### ssaaRenderPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SSAARenderPass</code>](#SSAARenderPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SSAARenderPass+render"></a>

### ssaaRenderPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SSAA render pass.

**Kind**: instance method of [<code>SSAARenderPass</code>](#SSAARenderPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SSAOPass"></a>

## SSAOPass ⇐ <code>Pass</code>
A pass for a basic SSAO effect.

[SAOPass](SAOPass) and [GTAPass](GTAPass) produce a more advanced AO but are also
more expensive.

```js
const ssaoPass = new SSAOPass( scene, camera, width, height );
composer.addPass( ssaoPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SSAOPass](#SSAOPass) ⇐ <code>Pass</code>
    * [new SSAOPass(scene, camera, [width], [height], [kernelSize])](#new_SSAOPass_new)
    * [.width](#SSAOPass+width) : <code>number</code>
    * [.height](#SSAOPass+height) : <code>number</code>
    * [.clear](#SSAOPass+clear) : <code>boolean</code>
    * [.needsSwap](#SSAOPass+needsSwap) : <code>boolean</code>
    * [.camera](#SSAOPass+camera) : <code>Camera</code>
    * [.scene](#SSAOPass+scene) : <code>Scene</code>
    * [.kernelRadius](#SSAOPass+kernelRadius) : <code>number</code>
    * [.output](#SSAOPass+output) : <code>number</code>
    * [.minDistance](#SSAOPass+minDistance) : <code>number</code>
    * [.maxDistance](#SSAOPass+maxDistance) : <code>number</code>
    * [.dispose()](#SSAOPass+dispose)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SSAOPass+render)
    * [.setSize(width, height)](#SSAOPass+setSize)

<a name="new_SSAOPass_new"></a>

### new SSAOPass(scene, camera, [width], [height], [kernelSize])
Constructs a new SSAO pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to compute the AO for. |
| camera | <code>Camera</code> |  | The camera. |
| [width] | <code>number</code> | <code>512</code> | The width of the effect. |
| [height] | <code>number</code> | <code>512</code> | The height of the effect. |
| [kernelSize] | <code>number</code> | <code>32</code> | The kernel size. |

<a name="SSAOPass+width"></a>

### ssaoPass.width : <code>number</code>
The width of the effect.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>512</code>  
<a name="SSAOPass+height"></a>

### ssaoPass.height : <code>number</code>
The height of the effect.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>512</code>  
<a name="SSAOPass+clear"></a>

### ssaoPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>true</code>  
<a name="SSAOPass+needsSwap"></a>

### ssaoPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>false</code>  
<a name="SSAOPass+camera"></a>

### ssaoPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
<a name="SSAOPass+scene"></a>

### ssaoPass.scene : <code>Scene</code>
The scene to render the AO for.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
<a name="SSAOPass+kernelRadius"></a>

### ssaoPass.kernelRadius : <code>number</code>
The kernel radius controls how wide the
AO spreads.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>8</code>  
<a name="SSAOPass+output"></a>

### ssaoPass.output : <code>number</code>
The output configuration.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>0</code>  
<a name="SSAOPass+minDistance"></a>

### ssaoPass.minDistance : <code>number</code>
Defines the minimum distance that should be
affected by the AO.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>0.005</code>  
<a name="SSAOPass+maxDistance"></a>

### ssaoPass.maxDistance : <code>number</code>
Defines the maximum distance that should be
affected by the AO.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>0.1</code>  
<a name="SSAOPass+dispose"></a>

### ssaoPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SSAOPass</code>](#SSAOPass)  
<a name="SSAOPass+render"></a>

### ssaoPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SSAO pass.

**Kind**: instance method of [<code>SSAOPass</code>](#SSAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SSAOPass+setSize"></a>

### ssaoPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SSAOPass</code>](#SSAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SSRPass"></a>

## SSRPass ⇐ <code>Pass</code>
A pass for a basic SSR effect.

```js
const ssrPass = new SSRPass( {
	renderer,
	scene,
	camera,
	width: innerWidth,
	height: innerHeight
} );
composer.addPass( ssrPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SSRPass](#SSRPass) ⇐ <code>Pass</code>
    * [new SSRPass(options)](#new_SSRPass_new)
    * _instance_
        * [.width](#SSRPass+width) : <code>number</code>
        * [.height](#SSRPass+height) : <code>number</code>
        * [.clear](#SSRPass+clear) : <code>boolean</code>
        * [.renderer](#SSRPass+renderer) : <code>WebGLRenderer</code>
        * [.scene](#SSRPass+scene) : <code>Scene</code>
        * [.camera](#SSRPass+camera) : <code>Camera</code>
        * [.groundReflector](#SSRPass+groundReflector) : <code>ReflectorForSSRPass</code>
        * [.opacity](#SSRPass+opacity) : <code>number</code>
        * [.output](#SSRPass+output) : <code>number</code>
        * [.maxDistance](#SSRPass+maxDistance) : <code>number</code>
        * [.thickness](#SSRPass+thickness) : <code>number</code>
        * [.selective](#SSRPass+selective) : <code>boolean</code>
        * [.selects](#SSRPass+selects) : <code>Array.&lt;Object3D&gt;</code>
        * [.bouncing](#SSRPass+bouncing) : <code>boolean</code>
        * [.blur](#SSRPass+blur) : <code>boolean</code>
        * [.distanceAttenuation](#SSRPass+distanceAttenuation) : <code>boolean</code>
        * [.fresnel](#SSRPass+fresnel) : <code>boolean</code>
        * [.infiniteThick](#SSRPass+infiniteThick) : <code>boolean</code>
        * [.dispose()](#SSRPass+dispose)
        * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SSRPass+render)
        * [.setSize(width, height)](#SSRPass+setSize)
    * _inner_
        * [~Options](#SSRPass..Options) : <code>Object</code>

<a name="new_SSRPass_new"></a>

### new SSRPass(options)
Constructs a new SSR pass.


| Param | Type | Description |
| --- | --- | --- |
| options | [<code>Options</code>](#SSRPass..Options) | The pass options. |

<a name="SSRPass+width"></a>

### ssrPass.width : <code>number</code>
The width of the effect.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>512</code>  
<a name="SSRPass+height"></a>

### ssrPass.height : <code>number</code>
The height of the effect.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>512</code>  
<a name="SSRPass+clear"></a>

### ssrPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>true</code>  
<a name="SSRPass+renderer"></a>

### ssrPass.renderer : <code>WebGLRenderer</code>
The renderer.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
<a name="SSRPass+scene"></a>

### ssrPass.scene : <code>Scene</code>
The scene to render.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
<a name="SSRPass+camera"></a>

### ssrPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
<a name="SSRPass+groundReflector"></a>

### ssrPass.groundReflector : <code>ReflectorForSSRPass</code>
The ground reflector.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>0</code>  
<a name="SSRPass+opacity"></a>

### ssrPass.opacity : <code>number</code>
The opactiy.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>0.5</code>  
<a name="SSRPass+output"></a>

### ssrPass.output : <code>number</code>
The output configuration.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>0</code>  
<a name="SSRPass+maxDistance"></a>

### ssrPass.maxDistance : <code>number</code>
Controls how far a fragment can reflect.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>180</code>  
<a name="SSRPass+thickness"></a>

### ssrPass.thickness : <code>number</code>
Controls the cutoff between what counts as a
possible reflection hit and what does not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>.018</code>  
<a name="SSRPass+selective"></a>

### ssrPass.selective : <code>boolean</code>
Whether the pass is selective or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>false</code>  
<a name="SSRPass+selects"></a>

### ssrPass.selects : <code>Array.&lt;Object3D&gt;</code>
Which 3D objects should be affected by SSR. If not set, the entire scene is affected.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>null</code>  
<a name="SSRPass+bouncing"></a>

### ssrPass.bouncing : <code>boolean</code>
Whether bouncing is enabled or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>false</code>  
<a name="SSRPass+blur"></a>

### ssrPass.blur : <code>boolean</code>
Whether to blur reflections or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>true</code>  
<a name="SSRPass+distanceAttenuation"></a>

### ssrPass.distanceAttenuation : <code>boolean</code>
Whether to use distance attenutation or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>true</code>  
<a name="SSRPass+fresnel"></a>

### ssrPass.fresnel : <code>boolean</code>
Whether to use fresnel or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>true</code>  
<a name="SSRPass+infiniteThick"></a>

### ssrPass.infiniteThick : <code>boolean</code>
Whether to use infinite thickness or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>false</code>  
<a name="SSRPass+dispose"></a>

### ssrPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SSRPass</code>](#SSRPass)  
<a name="SSRPass+render"></a>

### ssrPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SSR pass.

**Kind**: instance method of [<code>SSRPass</code>](#SSRPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SSRPass+setSize"></a>

### ssrPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SSRPass</code>](#SSRPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SSRPass..Options"></a>

### SSRPass~Options : <code>Object</code>
Constructor options of `SSRPass`.

**Kind**: inner typedef of [<code>SSRPass</code>](#SSRPass)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>WebGLRenderer</code> |  | The renderer. |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera. |
| [width] | <code>number</code> | <code>512</code> | The width of the effect. |
| [height] | <code>number</code> | <code>512</code> | The width of the effect. |
| [selects] | <code>Array.&lt;Object3D&gt;</code> | <code></code> | Which 3D objects should be affected by SSR. If not set, the entire scene is affected. |
| [bouncing] | <code>boolean</code> | <code>false</code> | Whether bouncing is enabled or not. |
| [groundReflector] | <code>ReflectorForSSRPass</code> | <code></code> | A ground reflector. |

<a name="SavePass"></a>

## SavePass ⇐ <code>Pass</code>
A pass that saves the contents of the current read buffer in a render target.

```js
const savePass = new SavePass( customRenderTarget );
composer.addPass( savePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SavePass](#SavePass) ⇐ <code>Pass</code>
    * [new SavePass([renderTarget])](#new_SavePass_new)
    * [.uniforms](#SavePass+uniforms) : <code>Object</code>
    * [.material](#SavePass+material) : <code>ShaderMaterial</code>
    * [.renderTarget](#SavePass+renderTarget) : <code>WebGLRenderTarget</code>
    * [.needsSwap](#SavePass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SavePass+render)
    * [.setSize(width, height)](#SavePass+setSize)
    * [.dispose()](#SavePass+dispose)

<a name="new_SavePass_new"></a>

### new SavePass([renderTarget])
Constructs a new save pass.


| Param | Type | Description |
| --- | --- | --- |
| [renderTarget] | <code>WebGLRenderTarget</code> | The render target for saving the read buffer. If not provided, the pass automatically creates a render target. |

<a name="SavePass+uniforms"></a>

### savePass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>SavePass</code>](#SavePass)  
<a name="SavePass+material"></a>

### savePass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>SavePass</code>](#SavePass)  
<a name="SavePass+renderTarget"></a>

### savePass.renderTarget : <code>WebGLRenderTarget</code>
The render target which is used to save the read buffer.

**Kind**: instance property of [<code>SavePass</code>](#SavePass)  
<a name="SavePass+needsSwap"></a>

### savePass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>SavePass</code>](#SavePass)  
**Default**: <code>false</code>  
<a name="SavePass+render"></a>

### savePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the save pass.

**Kind**: instance method of [<code>SavePass</code>](#SavePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SavePass+setSize"></a>

### savePass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SavePass</code>](#SavePass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SavePass+dispose"></a>

### savePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SavePass</code>](#SavePass)  
<a name="ShaderPass"></a>

## ShaderPass ⇐ <code>Pass</code>
This pass can be used to create a post processing effect
with a raw GLSL shader object. Useful for implementing custom
effects.

```js
const fxaaPass = new ShaderPass( FXAAShader );
composer.addPass( fxaaPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [ShaderPass](#ShaderPass) ⇐ <code>Pass</code>
    * [new ShaderPass([shader], [textureID])](#new_ShaderPass_new)
    * [.textureID](#ShaderPass+textureID) : <code>string</code>
    * [.uniforms](#ShaderPass+uniforms) : <code>Object</code>
    * [.material](#ShaderPass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#ShaderPass+render)
    * [.dispose()](#ShaderPass+dispose)

<a name="new_ShaderPass_new"></a>

### new ShaderPass([shader], [textureID])
Constructs a new shader pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [shader] | <code>Object</code> \| <code>ShaderMaterial</code> |  | A shader object holding vertex and fragment shader as well as defines and uniforms. It's also valid to pass a custom shader material. |
| [textureID] | <code>string</code> | <code>&quot;&#x27;tDiffuse&#x27;&quot;</code> | The name of the texture uniform that should sample the read buffer. |

<a name="ShaderPass+textureID"></a>

### shaderPass.textureID : <code>string</code>
The name of the texture uniform that should sample the read buffer.

**Kind**: instance property of [<code>ShaderPass</code>](#ShaderPass)  
**Default**: <code>&quot;&#x27;tDiffuse&#x27;&quot;</code>  
<a name="ShaderPass+uniforms"></a>

### shaderPass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>ShaderPass</code>](#ShaderPass)  
<a name="ShaderPass+material"></a>

### shaderPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>ShaderPass</code>](#ShaderPass)  
<a name="ShaderPass+render"></a>

### shaderPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the shader pass.

**Kind**: instance method of [<code>ShaderPass</code>](#ShaderPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="ShaderPass+dispose"></a>

### shaderPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>ShaderPass</code>](#ShaderPass)  
<a name="TAARenderPass"></a>

## TAARenderPass ⇐ <code>SSAARenderPass</code>
Temporal Anti-Aliasing Render Pass.

When there is no motion in the scene, the TAA render pass accumulates jittered camera
samples across frames to create a high quality anti-aliased result.

Note: This effect uses no reprojection so it is no TRAA implementation.

```js
const taaRenderPass = new TAARenderPass( scene, camera );
taaRenderPass.unbiased = false;
composer.addPass( taaRenderPass );
```

**Kind**: global class  
**Extends**: <code>SSAARenderPass</code>  

* [TAARenderPass](#TAARenderPass) ⇐ <code>SSAARenderPass</code>
    * [new TAARenderPass(scene, camera, [clearColor], [clearAlpha])](#new_TAARenderPass_new)
    * [.sampleLevel](#TAARenderPass+sampleLevel) : <code>number</code>
    * [.accumulate](#TAARenderPass+accumulate) : <code>boolean</code>
    * [.accumulateIndex](#TAARenderPass+accumulateIndex) : <code>number</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#TAARenderPass+render)
    * [.dispose()](#TAARenderPass+dispose)

<a name="new_TAARenderPass_new"></a>

### new TAARenderPass(scene, camera, [clearColor], [clearAlpha])
Constructs a new TAA render pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera. |
| [clearColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x000000</code> | The clear color of the render pass. |
| [clearAlpha] | <code>number</code> | <code>0</code> | The clear alpha of the render pass. |

<a name="TAARenderPass+sampleLevel"></a>

### taaRenderPass.sampleLevel : <code>number</code>
Overwritten and set to 0 by default.

**Kind**: instance property of [<code>TAARenderPass</code>](#TAARenderPass)  
**Default**: <code>0</code>  
<a name="TAARenderPass+accumulate"></a>

### taaRenderPass.accumulate : <code>boolean</code>
Whether to accumulate frames or not. This enables
the TAA.

**Kind**: instance property of [<code>TAARenderPass</code>](#TAARenderPass)  
**Default**: <code>false</code>  
<a name="TAARenderPass+accumulateIndex"></a>

### taaRenderPass.accumulateIndex : <code>number</code>
The accumulation index.

**Kind**: instance property of [<code>TAARenderPass</code>](#TAARenderPass)  
**Default**: <code>-1</code>  
<a name="TAARenderPass+render"></a>

### taaRenderPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the TAA render pass.

**Kind**: instance method of [<code>TAARenderPass</code>](#TAARenderPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="TAARenderPass+dispose"></a>

### taaRenderPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>TAARenderPass</code>](#TAARenderPass)  
<a name="TexturePass"></a>

## TexturePass ⇐ <code>Pass</code>
This pass can be used to render a texture over the entire screen.

```js
const texture = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );
texture.colorSpace = THREE.SRGBColorSpace;

const texturePass = new TexturePass( texture );
composer.addPass( texturePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [TexturePass](#TexturePass) ⇐ <code>Pass</code>
    * [new TexturePass(map, [opacity])](#new_TexturePass_new)
    * [.map](#TexturePass+map) : <code>Texture</code>
    * [.opacity](#TexturePass+opacity) : <code>number</code>
    * [.needsSwap](#TexturePass+needsSwap) : <code>boolean</code>
    * [.uniforms](#TexturePass+uniforms) : <code>Object</code>
    * [.material](#TexturePass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#TexturePass+render)
    * [.dispose()](#TexturePass+dispose)

<a name="new_TexturePass_new"></a>

### new TexturePass(map, [opacity])
Constructs a new texture pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| map | <code>Texture</code> |  | The texture to render. |
| [opacity] | <code>number</code> | <code>1</code> | The opacity. |

<a name="TexturePass+map"></a>

### texturePass.map : <code>Texture</code>
The texture to render.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
<a name="TexturePass+opacity"></a>

### texturePass.opacity : <code>number</code>
The opacity.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
**Default**: <code>1</code>  
<a name="TexturePass+needsSwap"></a>

### texturePass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
**Default**: <code>false</code>  
<a name="TexturePass+uniforms"></a>

### texturePass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
<a name="TexturePass+material"></a>

### texturePass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
<a name="TexturePass+render"></a>

### texturePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the texture pass.

**Kind**: instance method of [<code>TexturePass</code>](#TexturePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="TexturePass+dispose"></a>

### texturePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>TexturePass</code>](#TexturePass)  
<a name="UnrealBloomPass"></a>

## UnrealBloomPass ⇐ <code>Pass</code>
This pass is inspired by the bloom pass of Unreal Engine. It creates a
mip map chain of bloom textures and blurs them with different radii. Because
of the weighted combination of mips, and because larger blurs are done on
higher mips, this effect provides good quality and performance.

When using this pass, tone mapping must be enabled in the renderer settings.

Reference:
- [Bloom in Unreal Engine](https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/)

```js
const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );
const bloomPass = new UnrealBloomPass( resolution, 1.5, 0.4, 0.85 );
composer.addPass( bloomPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [UnrealBloomPass](#UnrealBloomPass) ⇐ <code>Pass</code>
    * [new UnrealBloomPass([resolution], [strength], radius, threshold)](#new_UnrealBloomPass_new)
    * [.strength](#UnrealBloomPass+strength) : <code>number</code>
    * [.radius](#UnrealBloomPass+radius) : <code>number</code>
    * [.threshold](#UnrealBloomPass+threshold) : <code>number</code>
    * [.resolution](#UnrealBloomPass+resolution) : <code>Vector2</code>
    * [.clearColor](#UnrealBloomPass+clearColor) : <code>Color</code>
    * [.needsSwap](#UnrealBloomPass+needsSwap) : <code>boolean</code>
    * [.dispose()](#UnrealBloomPass+dispose)
    * [.setSize(width, height)](#UnrealBloomPass+setSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#UnrealBloomPass+render)

<a name="new_UnrealBloomPass_new"></a>

### new UnrealBloomPass([resolution], [strength], radius, threshold)
Constructs a new Unreal Bloom pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [resolution] | <code>Vector2</code> |  | The effect's resolution. |
| [strength] | <code>number</code> | <code>1</code> | The Bloom strength. |
| radius | <code>number</code> |  | The Bloom radius. |
| threshold | <code>number</code> |  | The luminance threshold limits which bright areas contribute to the Bloom effect. |

<a name="UnrealBloomPass+strength"></a>

### unrealBloomPass.strength : <code>number</code>
The Bloom strength.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
**Default**: <code>1</code>  
<a name="UnrealBloomPass+radius"></a>

### unrealBloomPass.radius : <code>number</code>
The Bloom radius.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
<a name="UnrealBloomPass+threshold"></a>

### unrealBloomPass.threshold : <code>number</code>
The luminance threshold limits which bright areas contribute to the Bloom effect.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
<a name="UnrealBloomPass+resolution"></a>

### unrealBloomPass.resolution : <code>Vector2</code>
The effect's resolution.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
**Default**: <code>(256,256)</code>  
<a name="UnrealBloomPass+clearColor"></a>

### unrealBloomPass.clearColor : <code>Color</code>
The effect's clear color

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
**Default**: <code>(0,0,0)</code>  
<a name="UnrealBloomPass+needsSwap"></a>

### unrealBloomPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
**Default**: <code>false</code>  
<a name="UnrealBloomPass+dispose"></a>

### unrealBloomPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
<a name="UnrealBloomPass+setSize"></a>

### unrealBloomPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="UnrealBloomPass+render"></a>

### unrealBloomPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the Bloom pass.

**Kind**: instance method of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

## Classes

<dl>
<dt><a href="#CSS2DObject">CSS2DObject</a> ⇐ <code>Object3D</code></dt>
<dd><p>The only type of 3D object that is supported by <a href="#CSS2DRenderer">CSS2DRenderer</a>.</p>
</dd>
<dt><a href="#CSS2DRenderer">CSS2DRenderer</a></dt>
<dd><p>This renderer is a simplified version of <a href="CSS3DRenderer">CSS3DRenderer</a>. The only transformation that is
supported is translation.</p>
<p>The renderer is very useful if you want to combine HTML based labels with 3D objects. Here too,
the respective DOM elements are wrapped into an instance of <a href="#CSS2DObject">CSS2DObject</a> and added to the
scene graph. All other types of renderable 3D objects (like meshes or point clouds) are ignored.</p>
<p><code>CSS2DRenderer</code> only supports 100% browser and display zoom.</p>
</dd>
</dl>

<a name="CSS2DObject"></a>

## CSS2DObject ⇐ <code>Object3D</code>
The only type of 3D object that is supported by [CSS2DRenderer](#CSS2DRenderer).

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [CSS2DObject](#CSS2DObject) ⇐ <code>Object3D</code>
    * [new CSS2DObject([element])](#new_CSS2DObject_new)
    * [.isCSS2DObject](#CSS2DObject+isCSS2DObject) : <code>boolean</code>
    * [.element](#CSS2DObject+element) : <code>DOMElement</code>
    * [.center](#CSS2DObject+center) : <code>Vector2</code>

<a name="new_CSS2DObject_new"></a>

### new CSS2DObject([element])
Constructs a new CSS2D object.


| Param | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | The DOM element. |

<a name="CSS2DObject+isCSS2DObject"></a>

### csS2DObject.isCSS2DObject : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CSS2DObject</code>](#CSS2DObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS2DObject+element"></a>

### csS2DObject.element : <code>DOMElement</code>
The DOM element which defines the appearance of this 3D object.

**Kind**: instance property of [<code>CSS2DObject</code>](#CSS2DObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS2DObject+center"></a>

### csS2DObject.center : <code>Vector2</code>
The 3D objects center point.
`( 0, 0 )` is the lower left, `( 1, 1 )` is the top right.

**Kind**: instance property of [<code>CSS2DObject</code>](#CSS2DObject)  
**Default**: <code>(0.5,0.5)</code>  
<a name="CSS2DRenderer"></a>

## CSS2DRenderer
This renderer is a simplified version of [CSS3DRenderer](CSS3DRenderer). The only transformation that is
supported is translation.

The renderer is very useful if you want to combine HTML based labels with 3D objects. Here too,
the respective DOM elements are wrapped into an instance of [CSS2DObject](#CSS2DObject) and added to the
scene graph. All other types of renderable 3D objects (like meshes or point clouds) are ignored.

`CSS2DRenderer` only supports 100% browser and display zoom.

**Kind**: global class  

* [CSS2DRenderer](#CSS2DRenderer)
    * [new CSS2DRenderer([parameters])](#new_CSS2DRenderer_new)
    * _instance_
        * [.domElement](#CSS2DRenderer+domElement) : <code>DOMElement</code>
        * [.getSize()](#CSS2DRenderer+getSize) ⇒ <code>Object</code>
        * [.render(scene, camera)](#CSS2DRenderer+render)
        * [.setSize(width, height)](#CSS2DRenderer+setSize)
    * _inner_
        * [~Parameters](#CSS2DRenderer..Parameters) : <code>Object</code>

<a name="new_CSS2DRenderer_new"></a>

### new CSS2DRenderer([parameters])
Constructs a new CSS2D renderer.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | [<code>Parameters</code>](#CSS2DRenderer..Parameters) | The parameters. |

<a name="CSS2DRenderer+domElement"></a>

### csS2DRenderer.domElement : <code>DOMElement</code>
The DOM where the renderer appends its child-elements.

**Kind**: instance property of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  
<a name="CSS2DRenderer+getSize"></a>

### csS2DRenderer.getSize() ⇒ <code>Object</code>
Returns an object containing the width and height of the renderer.

**Kind**: instance method of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  
**Returns**: <code>Object</code> - The size of the renderer.  
<a name="CSS2DRenderer+render"></a>

### csS2DRenderer.render(scene, camera)
Renders the given scene using the given camera.

**Kind**: instance method of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene or any other type of 3D object. |
| camera | <code>Camera</code> | The camera. |

<a name="CSS2DRenderer+setSize"></a>

### csS2DRenderer.setSize(width, height)
Resizes the renderer to the given width and height.

**Kind**: instance method of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the renderer. |
| height | <code>number</code> | The height of the renderer. |

<a name="CSS2DRenderer..Parameters"></a>

### CSS2DRenderer~Parameters : <code>Object</code>
Constructor parameters of `CSS2DRenderer`.

**Kind**: inner typedef of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | A DOM element where the renderer appends its child-elements. If not passed in here, a new div element will be created. |

## Classes

<dl>
<dt><a href="#CSS3DObject">CSS3DObject</a> ⇐ <code>Object3D</code></dt>
<dd><p>The base 3D object that is supported by <a href="#CSS3DRenderer">CSS3DRenderer</a>.</p>
</dd>
<dt><a href="#CSS3DSprite">CSS3DSprite</a> ⇐ <code><a href="#CSS3DObject">CSS3DObject</a></code></dt>
<dd><p>A specialized version of <a href="#CSS3DObject">CSS3DObject</a> that represents
DOM elements as sprites.</p>
</dd>
<dt><a href="#CSS3DRenderer">CSS3DRenderer</a></dt>
<dd><p>This renderer can be used to apply hierarchical 3D transformations to DOM elements
via the CSS3 <a href="https://www.w3schools.com/cssref/css3_pr_transform.asp">transform</a> property.
<code>CSS3DRenderer</code> is particularly interesting if you want to apply 3D effects to a website without
canvas based rendering. It can also be used in order to combine DOM elements with WebGLcontent.</p>
<p>There are, however, some important limitations:</p>
<ul>
<li>It&#39;s not possible to use the material system of <em>three.js</em>.</li>
<li>It&#39;s also not possible to use geometries.</li>
<li>The renderer only supports 100% browser and display zoom.</li>
</ul>
<p>So <code>CSS3DRenderer</code> is just focused on ordinary DOM elements. These elements are wrapped into special
3D objects (<a href="#CSS3DObject">CSS3DObject</a> or <a href="#CSS3DSprite">CSS3DSprite</a>) and then added to the scene graph.</p>
</dd>
</dl>

<a name="CSS3DObject"></a>

## CSS3DObject ⇐ <code>Object3D</code>
The base 3D object that is supported by [CSS3DRenderer](#CSS3DRenderer).

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [CSS3DObject](#CSS3DObject) ⇐ <code>Object3D</code>
    * [new CSS3DObject([element])](#new_CSS3DObject_new)
    * [.isCSS3DObject](#CSS3DObject+isCSS3DObject) : <code>boolean</code>
    * [.element](#CSS3DObject+element) : <code>DOMElement</code>

<a name="new_CSS3DObject_new"></a>

### new CSS3DObject([element])
Constructs a new CSS3D object.


| Param | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | The DOM element. |

<a name="CSS3DObject+isCSS3DObject"></a>

### csS3DObject.isCSS3DObject : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CSS3DObject</code>](#CSS3DObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS3DObject+element"></a>

### csS3DObject.element : <code>DOMElement</code>
The DOM element which defines the appearance of this 3D object.

**Kind**: instance property of [<code>CSS3DObject</code>](#CSS3DObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS3DSprite"></a>

## CSS3DSprite ⇐ [<code>CSS3DObject</code>](#CSS3DObject)
A specialized version of [CSS3DObject](#CSS3DObject) that represents
DOM elements as sprites.

**Kind**: global class  
**Extends**: [<code>CSS3DObject</code>](#CSS3DObject)  

* [CSS3DSprite](#CSS3DSprite) ⇐ [<code>CSS3DObject</code>](#CSS3DObject)
    * [new CSS3DSprite([element])](#new_CSS3DSprite_new)
    * [.isCSS3DSprite](#CSS3DSprite+isCSS3DSprite) : <code>boolean</code>
    * [.rotation2D](#CSS3DSprite+rotation2D) : <code>number</code>
    * [.isCSS3DObject](#CSS3DObject+isCSS3DObject) : <code>boolean</code>
    * [.element](#CSS3DObject+element) : <code>DOMElement</code>

<a name="new_CSS3DSprite_new"></a>

### new CSS3DSprite([element])
Constructs a new CSS3D sprite object.


| Param | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | The DOM element. |

<a name="CSS3DSprite+isCSS3DSprite"></a>

### csS3DSprite.isCSS3DSprite : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CSS3DSprite</code>](#CSS3DSprite)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS3DSprite+rotation2D"></a>

### csS3DSprite.rotation2D : <code>number</code>
The sprite's rotation in radians.

**Kind**: instance property of [<code>CSS3DSprite</code>](#CSS3DSprite)  
**Default**: <code>0</code>  
<a name="CSS3DObject+isCSS3DObject"></a>

### csS3DSprite.isCSS3DObject : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CSS3DSprite</code>](#CSS3DSprite)  
**Default**: <code>true</code>  
**Overrides**: [<code>isCSS3DObject</code>](#CSS3DObject+isCSS3DObject)  
**Read only**: true  
<a name="CSS3DObject+element"></a>

### csS3DSprite.element : <code>DOMElement</code>
The DOM element which defines the appearance of this 3D object.

**Kind**: instance property of [<code>CSS3DSprite</code>](#CSS3DSprite)  
**Default**: <code>true</code>  
**Overrides**: [<code>element</code>](#CSS3DObject+element)  
**Read only**: true  
<a name="CSS3DRenderer"></a>

## CSS3DRenderer
This renderer can be used to apply hierarchical 3D transformations to DOM elements
via the CSS3 [transform](https://www.w3schools.com/cssref/css3_pr_transform.asp) property.
`CSS3DRenderer` is particularly interesting if you want to apply 3D effects to a website without
canvas based rendering. It can also be used in order to combine DOM elements with WebGLcontent.

There are, however, some important limitations:

- It's not possible to use the material system of *three.js*.
- It's also not possible to use geometries.
- The renderer only supports 100% browser and display zoom.

So `CSS3DRenderer` is just focused on ordinary DOM elements. These elements are wrapped into special
3D objects ([CSS3DObject](#CSS3DObject) or [CSS3DSprite](#CSS3DSprite)) and then added to the scene graph.

**Kind**: global class  

* [CSS3DRenderer](#CSS3DRenderer)
    * [new CSS3DRenderer([parameters])](#new_CSS3DRenderer_new)
    * _instance_
        * [.domElement](#CSS3DRenderer+domElement) : <code>DOMElement</code>
        * [.getSize()](#CSS3DRenderer+getSize) ⇒ <code>Object</code>
        * [.render(scene, camera)](#CSS3DRenderer+render)
        * [.setSize(width, height)](#CSS3DRenderer+setSize)
    * _inner_
        * [~Parameters](#CSS3DRenderer..Parameters) : <code>Object</code>

<a name="new_CSS3DRenderer_new"></a>

### new CSS3DRenderer([parameters])
Constructs a new CSS3D renderer.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | [<code>Parameters</code>](#CSS3DRenderer..Parameters) | The parameters. |

<a name="CSS3DRenderer+domElement"></a>

### csS3DRenderer.domElement : <code>DOMElement</code>
The DOM where the renderer appends its child-elements.

**Kind**: instance property of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  
<a name="CSS3DRenderer+getSize"></a>

### csS3DRenderer.getSize() ⇒ <code>Object</code>
Returns an object containing the width and height of the renderer.

**Kind**: instance method of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  
**Returns**: <code>Object</code> - The size of the renderer.  
<a name="CSS3DRenderer+render"></a>

### csS3DRenderer.render(scene, camera)
Renders the given scene using the given camera.

**Kind**: instance method of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene or any other type of 3D object. |
| camera | <code>Camera</code> | The camera. |

<a name="CSS3DRenderer+setSize"></a>

### csS3DRenderer.setSize(width, height)
Resizes the renderer to the given width and height.

**Kind**: instance method of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the renderer. |
| height | <code>number</code> | The height of the renderer. |

<a name="CSS3DRenderer..Parameters"></a>

### CSS3DRenderer~Parameters : <code>Object</code>
Constructor parameters of `CSS3DRenderer`.

**Kind**: inner typedef of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | A DOM element where the renderer appends its child-elements. If not passed in here, a new div element will be created. |

<a name="Projector"></a>

## Projector
This class can project a given scene in 3D space into a 2D representation
used for rendering with a 2D API. `Projector` is currently used by [SVGRenderer](SVGRenderer)
and was previously used by the legacy `CanvasRenderer`.

**Kind**: global class  

* [Projector](#Projector)
    * [new Projector()](#new_Projector_new)
    * [.projectScene(scene, camera, sortObjects, sortElements)](#Projector+projectScene) ⇒ <code>Object</code>

<a name="new_Projector_new"></a>

### new Projector()
Constructs a new projector.

<a name="Projector+projectScene"></a>

### projector.projectScene(scene, camera, sortObjects, sortElements) ⇒ <code>Object</code>
Projects the given scene in 3D space into a 2D representation. The result
is an object with renderable items.

**Kind**: instance method of [<code>Projector</code>](#Projector)  
**Returns**: <code>Object</code> - The projected scene as renderable objects.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene or any other type of 3D object. |
| camera | <code>Camera</code> | The camera. |
| sortObjects | <code>boolean</code> | Whether to sort objects or not. |
| sortElements | <code>boolean</code> | Whether to sort elements (faces, lines and sprites) or not. |

## Classes

<dl>
<dt><a href="#SVGObject">SVGObject</a> ⇐ <code>Object3D</code></dt>
<dd><p>Can be used to wrap SVG elements into a 3D object.</p>
</dd>
<dt><a href="#SVGRenderer">SVGRenderer</a></dt>
<dd><p>This renderer an be used to render geometric data using SVG. The produced vector
graphics are particular useful in the following use cases:</p>
<ul>
<li>Animated logos or icons.</li>
<li>Interactive 2D/3D diagrams or graphs.</li>
<li>Interactive maps.</li>
<li>Complex or animated user interfaces.</li>
</ul>
<p><code>SVGRenderer</code> has various advantages. It produces crystal-clear and sharp output which
is independent of the actual viewport resolution.SVG elements can be styled via CSS.
And they have good accessibility since it&#39;s possible to add metadata like title or description
(useful for search engines or screen readers).</p>
<p>There are, however, some important limitations:</p>
<ul>
<li>No advanced shading.</li>
<li>No texture support.</li>
<li>No shadow support.</li>
</ul>
</dd>
</dl>

<a name="SVGObject"></a>

## SVGObject ⇐ <code>Object3D</code>
Can be used to wrap SVG elements into a 3D object.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [SVGObject](#SVGObject) ⇐ <code>Object3D</code>
    * [new SVGObject(node)](#new_SVGObject_new)
    * [.isSVGObject](#SVGObject+isSVGObject) : <code>boolean</code>
    * [.node](#SVGObject+node) : <code>SVGElement</code>

<a name="new_SVGObject_new"></a>

### new SVGObject(node)
Constructs a new SVG object.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>SVGElement</code> | The SVG element. |

<a name="SVGObject+isSVGObject"></a>

### svgObject.isSVGObject : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SVGObject</code>](#SVGObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SVGObject+node"></a>

### svgObject.node : <code>SVGElement</code>
This SVG element.

**Kind**: instance property of [<code>SVGObject</code>](#SVGObject)  
<a name="SVGRenderer"></a>

## SVGRenderer
This renderer an be used to render geometric data using SVG. The produced vector
graphics are particular useful in the following use cases:

- Animated logos or icons.
- Interactive 2D/3D diagrams or graphs.
- Interactive maps.
- Complex or animated user interfaces.

`SVGRenderer` has various advantages. It produces crystal-clear and sharp output which
is independent of the actual viewport resolution.SVG elements can be styled via CSS.
And they have good accessibility since it's possible to add metadata like title or description
(useful for search engines or screen readers).

There are, however, some important limitations:
- No advanced shading.
- No texture support.
- No shadow support.

**Kind**: global class  

* [SVGRenderer](#SVGRenderer)
    * [new SVGRenderer()](#new_SVGRenderer_new)
    * [.domElement](#SVGRenderer+domElement) : <code>DOMElement</code>
    * [.autoClear](#SVGRenderer+autoClear) : <code>boolean</code>
    * [.sortObjects](#SVGRenderer+sortObjects) : <code>boolean</code>
    * [.sortElements](#SVGRenderer+sortElements) : <code>boolean</code>
    * [.overdraw](#SVGRenderer+overdraw) : <code>number</code>
    * [.outputColorSpace](#SVGRenderer+outputColorSpace) : <code>SRGBColorSpace</code> \| <code>LinearSRGBColorSpace</code>
    * [.info](#SVGRenderer+info) : <code>Object</code>
    * [.setQuality(quality)](#SVGRenderer+setQuality)
    * [.setClearColor(color)](#SVGRenderer+setClearColor)
    * [.setSize(width, height)](#SVGRenderer+setSize)
    * [.getSize()](#SVGRenderer+getSize) ⇒ <code>Object</code>
    * [.setPrecision(precision)](#SVGRenderer+setPrecision)
    * [.clear()](#SVGRenderer+clear)
    * [.render(scene, camera)](#SVGRenderer+render)

<a name="new_SVGRenderer_new"></a>

### new SVGRenderer()
Constructs a new SVG renderer.

<a name="SVGRenderer+domElement"></a>

### svgRenderer.domElement : <code>DOMElement</code>
The DOM where the renderer appends its child-elements.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
<a name="SVGRenderer+autoClear"></a>

### svgRenderer.autoClear : <code>boolean</code>
Whether to automatically perform a clear before a render call or not.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>true</code>  
<a name="SVGRenderer+sortObjects"></a>

### svgRenderer.sortObjects : <code>boolean</code>
Whether to sort 3D objects or not.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>true</code>  
<a name="SVGRenderer+sortElements"></a>

### svgRenderer.sortElements : <code>boolean</code>
Whether to sort elements or not.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>true</code>  
<a name="SVGRenderer+overdraw"></a>

### svgRenderer.overdraw : <code>number</code>
Number of fractional pixels to enlarge polygons in order to
prevent anti-aliasing gaps. Range is `[0,1]`.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>0.5</code>  
<a name="SVGRenderer+outputColorSpace"></a>

### svgRenderer.outputColorSpace : <code>SRGBColorSpace</code> \| <code>LinearSRGBColorSpace</code>
The output color space.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>SRGBColorSpace</code>  
<a name="SVGRenderer+info"></a>

### svgRenderer.info : <code>Object</code>
Provides information about the number of
rendered vertices and faces.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
<a name="SVGRenderer+setQuality"></a>

### svgRenderer.setQuality(quality)
Sets the render quality. Setting to `high` means This value indicates that the browser
tries to improve the SVG quality over rendering speed and geometric precision.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| quality | <code>&#x27;low&#x27;</code> \| <code>&#x27;high&#x27;</code> | The quality. |

<a name="SVGRenderer+setClearColor"></a>

### svgRenderer.setClearColor(color)
Sets the clear color.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| color | <code>number</code> \| <code>Color</code> \| <code>string</code> | The clear color to set. |

<a name="SVGRenderer+setSize"></a>

### svgRenderer.setSize(width, height)
Resizes the renderer to the given width and height.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the renderer. |
| height | <code>number</code> | The height of the renderer. |

<a name="SVGRenderer+getSize"></a>

### svgRenderer.getSize() ⇒ <code>Object</code>
Returns an object containing the width and height of the renderer.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  
**Returns**: <code>Object</code> - The size of the renderer.  
<a name="SVGRenderer+setPrecision"></a>

### svgRenderer.setPrecision(precision)
Sets the precision of the data used to create a paths.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| precision | <code>number</code> | The precision to set. |

<a name="SVGRenderer+clear"></a>

### svgRenderer.clear()
Performs a manual clear with the defined clear color.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  
<a name="SVGRenderer+render"></a>

### svgRenderer.render(scene, camera)
Renders the given scene using the given camera.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene or any other type of 3D object. |
| camera | <code>Camera</code> | The camera. |

<a name="module_ACESFilmicToneMappingShader"></a>

## ACESFilmicToneMappingShader
<a name="module_ACESFilmicToneMappingShader..ACESFilmicToneMappingShader"></a>

### ACESFilmicToneMappingShader~ACESFilmicToneMappingShader : <code>ShaderMaterial~Shader</code>
ACES Filmic Tone Mapping Shader by Stephen Hill.
Reference: [ltc_blit.fs](https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs)

This implementation of ACES is modified to accommodate a brighter viewing environment.
The scale factor of 1/0.6 is subjective. See discussion in #19621.

**Kind**: inner constant of [<code>ACESFilmicToneMappingShader</code>](#module_ACESFilmicToneMappingShader)  
<a name="module_AfterimageShader"></a>

## AfterimageShader
<a name="module_AfterimageShader..AfterimageShader"></a>

### AfterimageShader~AfterimageShader : <code>ShaderMaterial~Shader</code>
Inspired by [Three.js FBO motion trails](https://codepen.io/brunoimbrizi/pen/MoRJaN?page=1&).

**Kind**: inner constant of [<code>AfterimageShader</code>](#module_AfterimageShader)  
<a name="module_BasicShader"></a>

## BasicShader
<a name="module_BasicShader..BasicShader"></a>

### BasicShader~BasicShader : <code>ShaderMaterial~Shader</code>
Simple shader for testing.

**Kind**: inner constant of [<code>BasicShader</code>](#module_BasicShader)  
<a name="module_BleachBypassShader"></a>

## BleachBypassShader
<a name="module_BleachBypassShader..BleachBypassShader"></a>

### BleachBypassShader~BleachBypassShader : <code>ShaderMaterial~Shader</code>
Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass] based on
[Nvidia Shader library](http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass).

**Kind**: inner constant of [<code>BleachBypassShader</code>](#module_BleachBypassShader)  
<a name="module_BlendShader"></a>

## BlendShader
<a name="module_BlendShader..BlendShader"></a>

### BlendShader~BlendShader : <code>ShaderMaterial~Shader</code>
Blends two textures.

**Kind**: inner constant of [<code>BlendShader</code>](#module_BlendShader)  
<a name="module_BokehShader"></a>

## BokehShader
<a name="module_BokehShader..BokehShader"></a>

### BokehShader~BokehShader : <code>ShaderMaterial~Shader</code>
Depth-of-field shader with bokeh ported from
[GLSL shader by Martins Upitis](http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html).

**Kind**: inner constant of [<code>BokehShader</code>](#module_BokehShader)  
<a name="module_BokehShader2"></a>

## BokehShader2
<a name="module_BokehShader2..BokehShader"></a>

### BokehShader2~BokehShader : <code>ShaderMaterial~Shader</code>
Depth-of-field shader with bokeh ported from
[GLSL shader by Martins Upitis](http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)).

Requires #define RINGS and SAMPLES integers

**Kind**: inner constant of [<code>BokehShader2</code>](#module_BokehShader2)  
<a name="module_BrightnessContrastShader"></a>

## BrightnessContrastShader
<a name="module_BrightnessContrastShader..BrightnessContrastShader"></a>

### BrightnessContrastShader~BrightnessContrastShader : <code>ShaderMaterial~Shader</code>
Brightness and contrast adjustment [https://github.com/evanw/glfx.js](https://github.com/evanw/glfx.js).
Brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
Contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)

**Kind**: inner constant of [<code>BrightnessContrastShader</code>](#module_BrightnessContrastShader)  
<a name="module_ColorCorrectionShader"></a>

## ColorCorrectionShader
<a name="module_ColorCorrectionShader..ColorCorrectionShader"></a>

### ColorCorrectionShader~ColorCorrectionShader : <code>ShaderMaterial~Shader</code>
Color correction shader.

**Kind**: inner constant of [<code>ColorCorrectionShader</code>](#module_ColorCorrectionShader)  
<a name="module_ColorifyShader"></a>

## ColorifyShader
<a name="module_ColorifyShader..ColorifyShader"></a>

### ColorifyShader~ColorifyShader : <code>ShaderMaterial~Shader</code>
Colorify shader.

**Kind**: inner constant of [<code>ColorifyShader</code>](#module_ColorifyShader)  
<a name="module_ConvolutionShader"></a>

## ConvolutionShader
<a name="module_ConvolutionShader..ConvolutionShader"></a>

### ConvolutionShader~ConvolutionShader : <code>ShaderMaterial~Shader</code>
Convolution shader ported from o3d sample to WebGL / GLSL.

**Kind**: inner constant of [<code>ConvolutionShader</code>](#module_ConvolutionShader)  
<a name="module_CopyShader"></a>

## CopyShader
<a name="module_CopyShader..CopyShader"></a>

### CopyShader~CopyShader : <code>ShaderMaterial~Shader</code>
Full-screen copy shader pass.

**Kind**: inner constant of [<code>CopyShader</code>](#module_CopyShader)  
<a name="module_DOFMipMapShader"></a>

## DOFMipMapShader
<a name="module_DOFMipMapShader..DOFMipMapShader"></a>

### DOFMipMapShader~DOFMipMapShader : <code>ShaderMaterial~Shader</code>
Depth-of-field shader using mipmaps from Matt Handley @applmak.

Requires power-of-2 sized render target with enabled mipmaps.

**Kind**: inner constant of [<code>DOFMipMapShader</code>](#module_DOFMipMapShader)  
<a name="module_DepthLimitedBlurShader"></a>

## DepthLimitedBlurShader
<a name="module_DepthLimitedBlurShader..DepthLimitedBlurShader"></a>

### DepthLimitedBlurShader~DepthLimitedBlurShader : <code>ShaderMaterial~Shader</code>
TODO

Used by [SAOPass](SAOPass).

**Kind**: inner constant of [<code>DepthLimitedBlurShader</code>](#module_DepthLimitedBlurShader)  
<a name="module_DigitalGlitch"></a>

## DigitalGlitch
<a name="module_DigitalGlitch..DigitalGlitch"></a>

### DigitalGlitch~DigitalGlitch : <code>ShaderMaterial~Shader</code>
Digital glitch shader.

**Kind**: inner constant of [<code>DigitalGlitch</code>](#module_DigitalGlitch)  
<a name="module_DotScreenShader"></a>

## DotScreenShader
<a name="module_DotScreenShader..DotScreenShader"></a>

### DotScreenShader~DotScreenShader : <code>ShaderMaterial~Shader</code>
Dot screen shader based on [glfx.js sepia shader](https://github.com/evanw/glfx.js).

**Kind**: inner constant of [<code>DotScreenShader</code>](#module_DotScreenShader)  
<a name="module_ExposureShader"></a>

## ExposureShader
<a name="module_ExposureShader..ExposureShader"></a>

### ExposureShader~ExposureShader : <code>ShaderMaterial~Shader</code>
TODO

**Kind**: inner constant of [<code>ExposureShader</code>](#module_ExposureShader)  
<a name="module_FXAAShader"></a>

## FXAAShader
<a name="module_FXAAShader..FXAAShader"></a>

### FXAAShader~FXAAShader : <code>ShaderMaterial~Shader</code>
FXAA algorithm from NVIDIA, C# implementation by Jasper Flick, GLSL port by Dave Hoskins.

References:
- [http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf](http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf).
- [https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/](https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/).

**Kind**: inner constant of [<code>FXAAShader</code>](#module_FXAAShader)  
<a name="module_FilmShader"></a>

## FilmShader
<a name="module_FilmShader..FilmShader"></a>

### FilmShader~FilmShader : <code>ShaderMaterial~Shader</code>
TODO

Used by [FilmPass](FilmPass).

**Kind**: inner constant of [<code>FilmShader</code>](#module_FilmShader)  
<a name="module_FocusShader"></a>

## FocusShader
<a name="module_FocusShader..FocusShader"></a>

### FocusShader~FocusShader : <code>ShaderMaterial~Shader</code>
Focus shader based on [PaintEffect postprocess from ro.me](http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js).

**Kind**: inner constant of [<code>FocusShader</code>](#module_FocusShader)  
<a name="module_FreiChenShader"></a>

## FreiChenShader
<a name="module_FreiChenShader..FreiChenShader"></a>

### FreiChenShader~FreiChenShader : <code>ShaderMaterial~Shader</code>
Edge Detection Shader using Frei-Chen filter.
Based on [http://rastergrid.com/blog/2011/01/frei-chen-edge-detector](http://rastergrid.com/blog/2011/01/frei-chen-edge-detector).

aspect: vec2 of (1/width, 1/height)

**Kind**: inner constant of [<code>FreiChenShader</code>](#module_FreiChenShader)  
<a name="module_GTAOShader"></a>

## GTAOShader

* [GTAOShader](#module_GTAOShader)
    * [~GTAOShader](#module_GTAOShader..GTAOShader) : <code>ShaderMaterial~Shader</code>
    * [~GTAODepthShader](#module_GTAOShader..GTAODepthShader) : <code>Object</code>
    * [~GTAOBlendShader](#module_GTAOShader..GTAOBlendShader) : <code>Object</code>

<a name="module_GTAOShader..GTAOShader"></a>

### GTAOShader~GTAOShader : <code>ShaderMaterial~Shader</code>
GTAO shader. Use by [GTAOPass](GTAOPass).

References:
- [Practical Realtime Strategies for Accurate Indirect Occlusion](https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf).
- [Horizon-Based Indirect Lighting (HBIL)](https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf)

**Kind**: inner constant of [<code>GTAOShader</code>](#module_GTAOShader)  
<a name="module_GTAOShader..GTAODepthShader"></a>

### GTAOShader~GTAODepthShader : <code>Object</code>
GTAO depth shader. Use by [GTAOPass](GTAOPass).

**Kind**: inner constant of [<code>GTAOShader</code>](#module_GTAOShader)  
<a name="module_GTAOShader..GTAOBlendShader"></a>

### GTAOShader~GTAOBlendShader : <code>Object</code>
GTAO blend shader. Use by [GTAOPass](GTAOPass).

**Kind**: inner constant of [<code>GTAOShader</code>](#module_GTAOShader)  
<a name="module_GammaCorrectionShader"></a>

## GammaCorrectionShader
<a name="module_GammaCorrectionShader..GammaCorrectionShader"></a>

### GammaCorrectionShader~GammaCorrectionShader : <code>ShaderMaterial~Shader</code>
Gamma Correction Shader

References:
- [http://en.wikipedia.org/wiki/gamma_correction](http://en.wikipedia.org/wiki/gamma_correction).

**Kind**: inner constant of [<code>GammaCorrectionShader</code>](#module_GammaCorrectionShader)  
<a name="module_GodRaysShader"></a>

## GodRaysShader

* [GodRaysShader](#module_GodRaysShader)
    * [~GodRaysDepthMaskShader](#module_GodRaysShader..GodRaysDepthMaskShader) : <code>ShaderMaterial~Shader</code>
    * [~GodRaysGenerateShader](#module_GodRaysShader..GodRaysGenerateShader) : <code>ShaderMaterial~Shader</code>
    * [~GodRaysCombineShader](#module_GodRaysShader..GodRaysCombineShader) : <code>ShaderMaterial~Shader</code>
    * [~GodRaysFakeSunShader](#module_GodRaysShader..GodRaysFakeSunShader) : <code>Object</code>

<a name="module_GodRaysShader..GodRaysDepthMaskShader"></a>

### GodRaysShader~GodRaysDepthMaskShader : <code>ShaderMaterial~Shader</code>
God-rays (crepuscular rays)

Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].
Blurs a mask generated from the depth map along radial lines emanating from the light
source. The blur repeatedly applies a blur filter of increasing support but constant
sample count to produce a blur filter with large support.

My implementation performs 3 passes, similar to the implementation from Sousa. I found
just 6 samples per pass produced acceptable results. The blur is applied three times,
with decreasing filter support. The result is equivalent to a single pass with
6*6*6 = 216 samples.

References:
- [Sousa2008, Crysis Next Gen Effects, GDC2008](http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt).

**Kind**: inner constant of [<code>GodRaysShader</code>](#module_GodRaysShader)  
<a name="module_GodRaysShader..GodRaysGenerateShader"></a>

### GodRaysShader~GodRaysGenerateShader : <code>ShaderMaterial~Shader</code>
The god-ray generation shader.

First pass:

The depth map is blurred along radial lines towards the "sun". The
output is written to a temporary render target (I used a 1/4 sized
target).

Pass two & three:

The results of the previous pass are re-blurred, each time with a
decreased distance between samples.

**Kind**: inner constant of [<code>GodRaysShader</code>](#module_GodRaysShader)  
<a name="module_GodRaysShader..GodRaysCombineShader"></a>

### GodRaysShader~GodRaysCombineShader : <code>ShaderMaterial~Shader</code>
Additively applies god rays from texture tGodRays to a background (tColors).
fGodRayIntensity attenuates the god rays.

**Kind**: inner constant of [<code>GodRaysShader</code>](#module_GodRaysShader)  
<a name="module_GodRaysShader..GodRaysFakeSunShader"></a>

### GodRaysShader~GodRaysFakeSunShader : <code>Object</code>
A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be
cheaper/faster/simpler to implement this as a simple sun sprite.

**Kind**: inner constant of [<code>GodRaysShader</code>](#module_GodRaysShader)  
<a name="module_HalftoneShader"></a>

## HalftoneShader
<a name="module_HalftoneShader..HalftoneShader"></a>

### HalftoneShader~HalftoneShader : <code>ShaderMaterial~Shader</code>
RGB Halftone shader.

Used by [HalftonePass](HalftonePass).

Shape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)
Blending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)

**Kind**: inner constant of [<code>HalftoneShader</code>](#module_HalftoneShader)  
<a name="module_HorizontalBlurShader"></a>

## HorizontalBlurShader
<a name="module_HorizontalBlurShader..HorizontalBlurShader"></a>

### HorizontalBlurShader~HorizontalBlurShader : <code>ShaderMaterial~Shader</code>
Two pass Gaussian blur filter (horizontal and vertical blur shaders).

References:
- [http://www.cake23.de/traveling-wavefronts-lit-up.html](http://www.cake23.de/traveling-wavefronts-lit-up.html).

- 9 samples per pass
- standard deviation 2.7
- "h" and "v" parameters should be set to "1 / width" and "1 / height"

**Kind**: inner constant of [<code>HorizontalBlurShader</code>](#module_HorizontalBlurShader)  
<a name="module_HorizontalTiltShiftShader"></a>

## HorizontalTiltShiftShader
<a name="module_HorizontalTiltShiftShader..HorizontalTiltShiftShader"></a>

### HorizontalTiltShiftShader~HorizontalTiltShiftShader : <code>ShaderMaterial~Shader</code>
Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position.

- 9 samples per pass
- standard deviation 2.7
- "h" and "v" parameters should be set to "1 / width" and "1 / height"
- "r" parameter control where "focused" horizontal line lies

**Kind**: inner constant of [<code>HorizontalTiltShiftShader</code>](#module_HorizontalTiltShiftShader)  
<a name="module_HueSaturationShader"></a>

## HueSaturationShader
<a name="module_HueSaturationShader..HueSaturationShader"></a>

### HueSaturationShader~HueSaturationShader : <code>ShaderMaterial~Shader</code>
Hue and saturation adjustment, [https://github.com/evanw/glfx.js](https://github.com/evanw/glfx.js).

hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.
saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)

**Kind**: inner constant of [<code>HueSaturationShader</code>](#module_HueSaturationShader)  
<a name="module_KaleidoShader"></a>

## KaleidoShader
<a name="module_KaleidoShader..KaleidoShader"></a>

### KaleidoShader~KaleidoShader : <code>ShaderMaterial~Shader</code>
Kaleidoscope Shader.
Radial reflection around center point
Ported from: [http://pixelshaders.com/editor/](http://pixelshaders.com/editor/)
by [Toby Schachman](http://tobyschachman.com/)

sides: number of reflections
angle: initial angle in radians

**Kind**: inner constant of [<code>KaleidoShader</code>](#module_KaleidoShader)  
<a name="module_LuminosityHighPassShader"></a>

## LuminosityHighPassShader
<a name="module_LuminosityHighPassShader..LuminosityHighPassShader"></a>

### LuminosityHighPassShader~LuminosityHighPassShader : <code>ShaderMaterial~Shader</code>
Luminosity high pass shader.

**Kind**: inner constant of [<code>LuminosityHighPassShader</code>](#module_LuminosityHighPassShader)  
<a name="module_LuminosityShader"></a>

## LuminosityShader
<a name="module_LuminosityShader..LuminosityShader"></a>

### LuminosityShader~LuminosityShader : <code>ShaderMaterial~Shader</code>
Luminosity shader.

**Kind**: inner constant of [<code>LuminosityShader</code>](#module_LuminosityShader)  
<a name="module_MirrorShader"></a>

## MirrorShader
<a name="module_MirrorShader..MirrorShader"></a>

### MirrorShader~MirrorShader : <code>ShaderMaterial~Shader</code>
Copies half the input to the other half.

side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom).

**Kind**: inner constant of [<code>MirrorShader</code>](#module_MirrorShader)  
<a name="module_NormalMapShader"></a>

## NormalMapShader
<a name="module_NormalMapShader..NormalMapShader"></a>

### NormalMapShader~NormalMapShader : <code>ShaderMaterial~Shader</code>
Normal map shader, compute normals from heightmap.

**Kind**: inner constant of [<code>NormalMapShader</code>](#module_NormalMapShader)  
<a name="module_OutputShader"></a>

## OutputShader
<a name="module_OutputShader..OutputShader"></a>

### OutputShader~OutputShader : <code>ShaderMaterial~Shader</code>
Performs tone mapping and color space conversion for
FX workflows.

Used by [OutputPass](OutputPass).

**Kind**: inner constant of [<code>OutputShader</code>](#module_OutputShader)  
<a name="module_PoissonDenoiseShader"></a>

## PoissonDenoiseShader
<a name="module_PoissonDenoiseShader..PoissonDenoiseShader"></a>

### PoissonDenoiseShader~PoissonDenoiseShader : <code>ShaderMaterial~Shader</code>
Poisson Denoise Shader.

References:
- [Self-Supervised Poisson-Gaussian Denoising](https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf).
- [Poisson2Sparse: Self-Supervised Poisson Denoising From a Single Image](https://arxiv.org/pdf/2206.01856.pdf)

**Kind**: inner constant of [<code>PoissonDenoiseShader</code>](#module_PoissonDenoiseShader)  
<a name="module_RGBShiftShader"></a>

## RGBShiftShader
<a name="module_RGBShiftShader..RGBShiftShader"></a>

### RGBShiftShader~RGBShiftShader : <code>ShaderMaterial~Shader</code>
RGB Shift Shader
Shifts red and blue channels from center in opposite directions
Ported from https://web.archive.org/web/20090820185047/http://kriss.cx/tom/2009/05/rgb-shift/
by Tom Butterworth / https://web.archive.org/web/20090810054752/http://kriss.cx/tom/

amount: shift distance (1 is width of input)
angle: shift angle in radians

**Kind**: inner constant of [<code>RGBShiftShader</code>](#module_RGBShiftShader)  
<a name="module_SAOShader"></a>

## SAOShader
<a name="module_SAOShader..SAOShader"></a>

### SAOShader~SAOShader : <code>ShaderMaterial~Shader</code>
SAO shader.

Used by [SAOPass](SAOPass).

**Kind**: inner constant of [<code>SAOShader</code>](#module_SAOShader)  
<a name="module_SMAAShader"></a>

## SMAAShader
WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8
Preset: SMAA 1x Medium (with color edge detection)

References:
- [https://github.com/iryoku/smaa/releases/tag/v2.8](https://github.com/iryoku/smaa/releases/tag/v2.8)


* [SMAAShader](#module_SMAAShader)
    * [~SMAAEdgesShader](#module_SMAAShader..SMAAEdgesShader) : <code>ShaderMaterial~Shader</code>
    * [~SMAAWeightsShader](#module_SMAAShader..SMAAWeightsShader) : <code>ShaderMaterial~Shader</code>
    * [~SMAABlendShader](#module_SMAAShader..SMAABlendShader) : <code>ShaderMaterial~Shader</code>

<a name="module_SMAAShader..SMAAEdgesShader"></a>

### SMAAShader~SMAAEdgesShader : <code>ShaderMaterial~Shader</code>
SMAA Edges shader.

**Kind**: inner constant of [<code>SMAAShader</code>](#module_SMAAShader)  
<a name="module_SMAAShader..SMAAWeightsShader"></a>

### SMAAShader~SMAAWeightsShader : <code>ShaderMaterial~Shader</code>
SMAA Weights shader.

**Kind**: inner constant of [<code>SMAAShader</code>](#module_SMAAShader)  
<a name="module_SMAAShader..SMAABlendShader"></a>

### SMAAShader~SMAABlendShader : <code>ShaderMaterial~Shader</code>
SMAA Blend shader.

**Kind**: inner constant of [<code>SMAAShader</code>](#module_SMAAShader)  
<a name="module_SSAOShader"></a>

## SSAOShader

* [SSAOShader](#module_SSAOShader)
    * [~SSAOShader](#module_SSAOShader..SSAOShader) : <code>ShaderMaterial~Shader</code>
    * [~SSAODepthShader](#module_SSAOShader..SSAODepthShader) : <code>ShaderMaterial~Shader</code>
    * [~SSAOBlurShader](#module_SSAOShader..SSAOBlurShader) : <code>Object</code>

<a name="module_SSAOShader..SSAOShader"></a>

### SSAOShader~SSAOShader : <code>ShaderMaterial~Shader</code>
SSAO shader.

References:
- [http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html](http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html)
- [https://learnopengl.com/Advanced-Lighting/SSAO](https://learnopengl.com/Advanced-Lighting/SSAO)
- [https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl](https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl)

**Kind**: inner constant of [<code>SSAOShader</code>](#module_SSAOShader)  
<a name="module_SSAOShader..SSAODepthShader"></a>

### SSAOShader~SSAODepthShader : <code>ShaderMaterial~Shader</code>
SSAO depth shader.

**Kind**: inner constant of [<code>SSAOShader</code>](#module_SSAOShader)  
<a name="module_SSAOShader..SSAOBlurShader"></a>

### SSAOShader~SSAOBlurShader : <code>Object</code>
SSAO blur shader.

**Kind**: inner constant of [<code>SSAOShader</code>](#module_SSAOShader)  
<a name="module_SSRShader"></a>

## SSRShader
A collection of shaders used for SSR.

References:
- [3D Game Shaders For Beginners, Screen Space Reflection (SSR)](https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html).


* [SSRShader](#module_SSRShader)
    * [~SSRShader](#module_SSRShader..SSRShader) : <code>ShaderMaterial~Shader</code>
    * [~SSRDepthShader](#module_SSRShader..SSRDepthShader) : <code>ShaderMaterial~Shader</code>
    * [~SSRBlurShader](#module_SSRShader..SSRBlurShader) : <code>ShaderMaterial~Shader</code>

<a name="module_SSRShader..SSRShader"></a>

### SSRShader~SSRShader : <code>ShaderMaterial~Shader</code>
SSR shader.

**Kind**: inner constant of [<code>SSRShader</code>](#module_SSRShader)  
<a name="module_SSRShader..SSRDepthShader"></a>

### SSRShader~SSRDepthShader : <code>ShaderMaterial~Shader</code>
SSR Depth shader.

**Kind**: inner constant of [<code>SSRShader</code>](#module_SSRShader)  
<a name="module_SSRShader..SSRBlurShader"></a>

### SSRShader~SSRBlurShader : <code>ShaderMaterial~Shader</code>
SSR Blur shader.

**Kind**: inner constant of [<code>SSRShader</code>](#module_SSRShader)  
<a name="module_SepiaShader"></a>

## SepiaShader
<a name="module_SepiaShader..SepiaShader"></a>

### SepiaShader~SepiaShader : <code>ShaderMaterial~Shader</code>
Sepia tone shader based on [glfx.js sepia shader](https://github.com/evanw/glfx.js).

**Kind**: inner constant of [<code>SepiaShader</code>](#module_SepiaShader)  
<a name="module_SobelOperatorShader"></a>

## SobelOperatorShader
<a name="module_SobelOperatorShader..SobelOperatorShader"></a>

### SobelOperatorShader~SobelOperatorShader : <code>ShaderMaterial~Shader</code>
Sobel Edge Detection (see [https://youtu.be/uihBwtPIBxM](https://youtu.be/uihBwtPIBxM)).

As mentioned in the video the Sobel operator expects a grayscale image as input.

**Kind**: inner constant of [<code>SobelOperatorShader</code>](#module_SobelOperatorShader)  
<a name="module_SubsurfaceScatteringShader"></a>

## SubsurfaceScatteringShader
<a name="module_SubsurfaceScatteringShader..SubsurfaceScatteringShader"></a>

### SubsurfaceScatteringShader~SubsurfaceScatteringShader : <code>ShaderMaterial~Shader</code>
Subsurface Scattering shader.

Based on GDC 2011 – [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look](https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/)

**Kind**: inner constant of [<code>SubsurfaceScatteringShader</code>](#module_SubsurfaceScatteringShader)  
<a name="module_TriangleBlurShader"></a>

## TriangleBlurShader
<a name="module_TriangleBlurShader..TechnicolorShader"></a>

### TriangleBlurShader~TechnicolorShader : <code>ShaderMaterial~Shader</code>
Simulates the look of the two-strip technicolor process popular in early 20th century films.
More historical info here: [http://www.widescreenmuseum.com/oldcolor/technicolor1.htm](http://www.widescreenmuseum.com/oldcolor/technicolor1.htm)
Demo here: [http://charliehoey.com/technicolor_shader/shader_test.html](http://charliehoey.com/technicolor_shader/shader_test.html)

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader"></a>

## TriangleBlurShader
Collection of toon shaders.


* [TriangleBlurShader](#module_TriangleBlurShader)
    * [~ToonShader1](#module_TriangleBlurShader..ToonShader1) : <code>ShaderMaterial~Shader</code>
    * [~ToonShader2](#module_TriangleBlurShader..ToonShader2) : <code>Object</code>
    * [~ToonShaderHatching](#module_TriangleBlurShader..ToonShaderHatching) : <code>Object</code>
    * [~ToonShaderDotted](#module_TriangleBlurShader..ToonShaderDotted) : <code>Object</code>

<a name="module_TriangleBlurShader..ToonShader1"></a>

### TriangleBlurShader~ToonShader1 : <code>ShaderMaterial~Shader</code>
Toon1 shader.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader..ToonShader2"></a>

### TriangleBlurShader~ToonShader2 : <code>Object</code>
Toon2 shader.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader..ToonShaderHatching"></a>

### TriangleBlurShader~ToonShaderHatching : <code>Object</code>
Toon Hatching shader.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader..ToonShaderDotted"></a>

### TriangleBlurShader~ToonShaderDotted : <code>Object</code>
Toon Dotted shader.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader"></a>

## TriangleBlurShader
<a name="module_TriangleBlurShader..TriangleBlurShader"></a>

### TriangleBlurShader~TriangleBlurShader : <code>ShaderMaterial~Shader</code>
Triangle blur shader based on [glfx.js triangle blur shader](https://github.com/evanw/glfx.js).

A basic blur filter, which convolves the image with a
pyramid filter. The pyramid filter is separable and is applied as two
perpendicular triangle filters.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_UnpackDepthRGBAShader"></a>

## UnpackDepthRGBAShader
<a name="module_UnpackDepthRGBAShader..UnpackDepthRGBAShader"></a>

### UnpackDepthRGBAShader~UnpackDepthRGBAShader : <code>ShaderMaterial~Shader</code>
Unpack RGBA depth shader that shows RGBA encoded depth as monochrome color.

**Kind**: inner constant of [<code>UnpackDepthRGBAShader</code>](#module_UnpackDepthRGBAShader)  
<a name="module_VelocityShader"></a>

## VelocityShader
<a name="module_VelocityShader..VelocityShader"></a>

### VelocityShader~VelocityShader : <code>ShaderMaterial~Shader</code>
Mesh velocity shader by @bhouston.

**Kind**: inner constant of [<code>VelocityShader</code>](#module_VelocityShader)  
<a name="module_VerticalBlurShader"></a>

## VerticalBlurShader
<a name="module_VerticalBlurShader..VerticalBlurShader"></a>

### VerticalBlurShader~VerticalBlurShader : <code>ShaderMaterial~Shader</code>
Two pass Gaussian blur filter (horizontal and vertical blur shaders)
- see [http://www.cake23.de/traveling-wavefronts-lit-up.html](http://www.cake23.de/traveling-wavefronts-lit-up.html)

- 9 samples per pass
- standard deviation 2.7
- "h" and "v" parameters should be set to "1 / width" and "1 / height"

**Kind**: inner constant of [<code>VerticalBlurShader</code>](#module_VerticalBlurShader)  
<a name="module_VerticalTiltShiftShader"></a>

## VerticalTiltShiftShader
<a name="module_VerticalTiltShiftShader..VerticalTiltShiftShader"></a>

### VerticalTiltShiftShader~VerticalTiltShiftShader : <code>ShaderMaterial~Shader</code>
Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position

- 9 samples per pass
- standard deviation 2.7
- "h" and "v" parameters should be set to "1 / width" and "1 / height"
- "r" parameter control where "focused" horizontal line lies

**Kind**: inner constant of [<code>VerticalTiltShiftShader</code>](#module_VerticalTiltShiftShader)  
<a name="module_VignetteShader"></a>

## VignetteShader
<a name="module_VignetteShader..VignetteShader"></a>

### VignetteShader~VignetteShader : <code>ShaderMaterial~Shader</code>
Based on [PaintEffect postprocess from ro.me](http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js).

**Kind**: inner constant of [<code>VignetteShader</code>](#module_VignetteShader)  
<a name="module_VolumeShader"></a>

## VolumeShader
<a name="module_VolumeShader..VolumeRenderShader1"></a>

### VolumeShader~VolumeRenderShader1 : <code>ShaderMaterial~Shader</code>
Shaders to render 3D volumes using raycasting.
The applied techniques are based on similar implementations in the Visvis and Vispy projects.
This is not the only approach, therefore it's marked 1.

**Kind**: inner constant of [<code>VolumeShader</code>](#module_VolumeShader)  
<a name="module_WaterRefractionShader"></a>

## WaterRefractionShader
<a name="module_WaterRefractionShader..WaterRefractionShader"></a>

### WaterRefractionShader~WaterRefractionShader : <code>ShaderMaterial~Shader</code>
Basic water refraction shader.

**Kind**: inner constant of [<code>WaterRefractionShader</code>](#module_WaterRefractionShader)  
<a name="FlakesTexture"></a>

## FlakesTexture
Utility class for generating a flakes texture image. This image might be used
as a normal map to produce a car paint like effect.

**Kind**: global class  
<a name="new_FlakesTexture_new"></a>

### new FlakesTexture([width], [height])
Generates a new flakes texture image. The result is a canvas
that can be used as an input for [CanvasTexture](CanvasTexture).

**Returns**: <code>HTMLCanvasElement</code> - The generated image.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>512</code> | The width of the image. |
| [height] | <code>number</code> | <code>512</code> | The height of the image. |

<a name="Transpiler"></a>

## Transpiler
A class that transpiles shader code from one language into another.

`Transpiler` can only be used to convert GLSL into TSL right now. It is intended
to support developers when they want to migrate their custom materials from the
current to the new node-based material system.

**Kind**: global class  

* [Transpiler](#Transpiler)
    * [new Transpiler(decoder, encoder)](#new_Transpiler_new)
    * [.decoder](#Transpiler+decoder) : <code>GLSLDecoder</code>
    * [.encoder](#Transpiler+encoder) : <code>TSLEncoder</code>
    * [.parse(source)](#Transpiler+parse) ⇒ <code>string</code>

<a name="new_Transpiler_new"></a>

### new Transpiler(decoder, encoder)
Constructs a new transpiler.


| Param | Type | Description |
| --- | --- | --- |
| decoder | <code>GLSLDecoder</code> | The GLSL decoder. |
| encoder | <code>TSLEncoder</code> | The TSL encoder. |

<a name="Transpiler+decoder"></a>

### transpiler.decoder : <code>GLSLDecoder</code>
The GLSL decoder. This component parse GLSL and produces
a language-independent AST for further processing.

**Kind**: instance property of [<code>Transpiler</code>](#Transpiler)  
<a name="Transpiler+encoder"></a>

### transpiler.encoder : <code>TSLEncoder</code>
The TSL encoder. It takes the AST and emits TSL code.

**Kind**: instance property of [<code>Transpiler</code>](#Transpiler)  
<a name="Transpiler+parse"></a>

### transpiler.parse(source) ⇒ <code>string</code>
Parses the given GLSL source and returns TSL syntax.

**Kind**: instance method of [<code>Transpiler</code>](#Transpiler)  
**Returns**: <code>string</code> - The TSL code.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The GLSL source. |

## Classes

<dl>
<dt><a href="#AfterImageNode">AfterImageNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating an after image effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#afterImage">afterImage(node, [damp])</a> ⇒ <code><a href="#AfterImageNode">AfterImageNode</a></code></dt>
<dd><p>TSL function for creating an after image node for post processing.</p>
</dd>
</dl>

<a name="AfterImageNode"></a>

## AfterImageNode ⇐ <code>TempNode</code>
Post processing node for creating an after image effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [AfterImageNode](#AfterImageNode) ⇐ <code>TempNode</code>
    * [new AfterImageNode(textureNode, [damp])](#new_AfterImageNode_new)
    * [.textureNode](#AfterImageNode+textureNode) : <code>TextureNode</code>
    * [.textureNodeOld](#AfterImageNode+textureNodeOld) : <code>TextureNode</code>
    * [.damp](#AfterImageNode+damp) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateBeforeType](#AfterImageNode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#AfterImageNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#AfterImageNode+setSize)
    * [.updateBefore(frame)](#AfterImageNode+updateBefore)
    * [.setup(builder)](#AfterImageNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#AfterImageNode+dispose)

<a name="new_AfterImageNode_new"></a>

### new AfterImageNode(textureNode, [damp])
Constructs a new after image node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that represents the input of the effect. |
| [damp] | <code>number</code> | <code>0.96</code> | The damping intensity. A higher value means a stronger after image effect. |

<a name="AfterImageNode+textureNode"></a>

### afterImageNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>AfterImageNode</code>](#AfterImageNode)  
<a name="AfterImageNode+textureNodeOld"></a>

### afterImageNode.textureNodeOld : <code>TextureNode</code>
The texture represents the pervious frame.

**Kind**: instance property of [<code>AfterImageNode</code>](#AfterImageNode)  
<a name="AfterImageNode+damp"></a>

### afterImageNode.damp : <code>UniformNode.&lt;float&gt;</code>
How quickly the after-image fades. A higher value means the after-image
persists longer, while a lower value means it fades faster. Should be in
the range `[0, 1]`.

**Kind**: instance property of [<code>AfterImageNode</code>](#AfterImageNode)  
<a name="AfterImageNode+updateBeforeType"></a>

### afterImageNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>AfterImageNode</code>](#AfterImageNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="AfterImageNode+getTextureNode"></a>

### afterImageNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="AfterImageNode+setSize"></a>

### afterImageNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="AfterImageNode+updateBefore"></a>

### afterImageNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="AfterImageNode+setup"></a>

### afterImageNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AfterImageNode+dispose"></a>

### afterImageNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  
<a name="afterImage"></a>

## afterImage(node, [damp]) ⇒ [<code>AfterImageNode</code>](#AfterImageNode)
TSL function for creating an after image node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [damp] | <code>number</code> | <code>0.96</code> | The damping intensity. A higher value means a stronger after image effect. |

## Classes

<dl>
<dt><a href="#AnaglyphPassNode">AnaglyphPassNode</a> ⇐ <code>StereoCompositePassNode</code></dt>
<dd><p>A render pass node that creates an anaglyph effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#anaglyphPass">anaglyphPass(scene, camera)</a> ⇒ <code><a href="#AnaglyphPassNode">AnaglyphPassNode</a></code></dt>
<dd><p>TSL function for creating an anaglyph pass node.</p>
</dd>
</dl>

<a name="AnaglyphPassNode"></a>

## AnaglyphPassNode ⇐ <code>StereoCompositePassNode</code>
A render pass node that creates an anaglyph effect.

**Kind**: global class  
**Extends**: <code>StereoCompositePassNode</code>  

* [AnaglyphPassNode](#AnaglyphPassNode) ⇐ <code>StereoCompositePassNode</code>
    * [new AnaglyphPassNode(scene, camera)](#new_AnaglyphPassNode_new)
    * [.isAnaglyphPassNode](#AnaglyphPassNode+isAnaglyphPassNode) : <code>boolean</code>
    * [._colorMatrixLeft](#AnaglyphPassNode+_colorMatrixLeft) : <code>UniformNode.&lt;mat3&gt;</code>
    * [._colorMatrixRight](#AnaglyphPassNode+_colorMatrixRight) : <code>UniformNode.&lt;mat3&gt;</code>
    * [.setup(builder)](#AnaglyphPassNode+setup) ⇒ <code>PassTextureNode</code>

<a name="new_AnaglyphPassNode_new"></a>

### new AnaglyphPassNode(scene, camera)
Constructs a new anaglyph pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="AnaglyphPassNode+isAnaglyphPassNode"></a>

### anaglyphPassNode.isAnaglyphPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="AnaglyphPassNode+_colorMatrixLeft"></a>

### anaglyphPassNode.\_colorMatrixLeft : <code>UniformNode.&lt;mat3&gt;</code>
Color matrix node for the left eye.

**Kind**: instance property of [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)  
<a name="AnaglyphPassNode+_colorMatrixRight"></a>

### anaglyphPassNode.\_colorMatrixRight : <code>UniformNode.&lt;mat3&gt;</code>
Color matrix node for the right eye.

**Kind**: instance property of [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)  
<a name="AnaglyphPassNode+setup"></a>

### anaglyphPassNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="anaglyphPass"></a>

## anaglyphPass(scene, camera) ⇒ [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)
TSL function for creating an anaglyph pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#AnamorphicNode">AnamorphicNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for adding an anamorphic flare effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#anamorphic">anamorphic(node, [threshold], [scale], [samples])</a> ⇒ <code><a href="#AnamorphicNode">AnamorphicNode</a></code></dt>
<dd><p>TSL function for creating an anamorphic flare effect.</p>
</dd>
</dl>

<a name="AnamorphicNode"></a>

## AnamorphicNode ⇐ <code>TempNode</code>
Post processing node for adding an anamorphic flare effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [AnamorphicNode](#AnamorphicNode) ⇐ <code>TempNode</code>
    * [new AnamorphicNode(textureNode, tresholdNode, scaleNode, samples)](#new_AnamorphicNode_new)
    * [.textureNode](#AnamorphicNode+textureNode) : <code>TextureNode</code>
    * [.tresholdNode](#AnamorphicNode+tresholdNode) : <code>Node.&lt;float&gt;</code>
    * [.scaleNode](#AnamorphicNode+scaleNode) : <code>Node.&lt;float&gt;</code>
    * [.colorNode](#AnamorphicNode+colorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.samples](#AnamorphicNode+samples) : <code>Node.&lt;float&gt;</code>
    * [.resolution](#AnamorphicNode+resolution) : <code>Vector2</code>
    * [.updateBeforeType](#AnamorphicNode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#AnamorphicNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#AnamorphicNode+setSize)
    * [.updateBefore(frame)](#AnamorphicNode+updateBefore)
    * [.setup(builder)](#AnamorphicNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#AnamorphicNode+dispose)

<a name="new_AnamorphicNode_new"></a>

### new AnamorphicNode(textureNode, tresholdNode, scaleNode, samples)
Constructs a new anamorphic node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |
| tresholdNode | <code>Node.&lt;float&gt;</code> | The threshold is one option to control the intensity and size of the effect. |
| scaleNode | <code>Node.&lt;float&gt;</code> | Defines the vertical scale of the flares. |
| samples | <code>number</code> | More samples result in larger flares and a more expensive runtime behavior. |

<a name="AnamorphicNode+textureNode"></a>

### anamorphicNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+tresholdNode"></a>

### anamorphicNode.tresholdNode : <code>Node.&lt;float&gt;</code>
The threshold is one option to control the intensity and size of the effect.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+scaleNode"></a>

### anamorphicNode.scaleNode : <code>Node.&lt;float&gt;</code>
Defines the vertical scale of the flares.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+colorNode"></a>

### anamorphicNode.colorNode : <code>Node.&lt;vec3&gt;</code>
The color of the flares.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+samples"></a>

### anamorphicNode.samples : <code>Node.&lt;float&gt;</code>
More samples result in larger flares and a more expensive runtime behavior.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+resolution"></a>

### anamorphicNode.resolution : <code>Vector2</code>
The resolution scale.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+updateBeforeType"></a>

### anamorphicNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="AnamorphicNode+getTextureNode"></a>

### anamorphicNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="AnamorphicNode+setSize"></a>

### anamorphicNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="AnamorphicNode+updateBefore"></a>

### anamorphicNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="AnamorphicNode+setup"></a>

### anamorphicNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AnamorphicNode+dispose"></a>

### anamorphicNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="anamorphic"></a>

## anamorphic(node, [threshold], [scale], [samples]) ⇒ [<code>AnamorphicNode</code>](#AnamorphicNode)
TSL function for creating an anamorphic flare effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>TextureNode</code> |  | The node that represents the input of the effect. |
| [threshold] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.9</code> | The threshold is one option to control the intensity and size of the effect. |
| [scale] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>3</code> | Defines the vertical scale of the flares. |
| [samples] | <code>number</code> | <code>32</code> | More samples result in larger flares and a more expensive runtime behavior. |

<a name="bleach"></a>

## bleach(color, [opacity]) ⇒ <code>Node.&lt;vec4&gt;</code>
Applies a bleach bypass effect to the given color node.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The updated color node.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node.&lt;vec4&gt;</code> |  | The color node to apply the sepia for. |
| [opacity] | <code>Node.&lt;float&gt;</code> | <code>1</code> | Influences how strong the effect is blended with the original color. |

## Classes

<dl>
<dt><a href="#BloomNode">BloomNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating a bloom effect.</p>
<pre><code class="language-js">const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
const scenePassColor = scenePass.getTextureNode( &#39;output&#39; );

const bloomPass = bloom( scenePassColor );

postProcessing.outputNode = scenePassColor.add( bloomPass );
</code></pre>
<p>By default, the node affects the entire image. For a selective bloom,
use the <code>emissive</code> material property to control which objects should
contribute to bloom or not. This can be achieved via MRT.</p>
<pre><code class="language-js">const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
scenePass.setMRT( mrt( {
    output,
    emissive
} ) );

const scenePassColor = scenePass.getTextureNode( &#39;output&#39; );
const emissivePass = scenePass.getTextureNode( &#39;emissive&#39; );

const bloomPass = bloom( emissivePass );
postProcessing.outputNode = scenePassColor.add( bloomPass );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bloom">bloom(node, [strength], [radius], [threshold])</a> ⇒ <code><a href="#BloomNode">BloomNode</a></code></dt>
<dd><p>TSL function for creating a bloom effect.</p>
</dd>
</dl>

<a name="BloomNode"></a>

## BloomNode ⇐ <code>TempNode</code>
Post processing node for creating a bloom effect.
```js
const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
const scenePassColor = scenePass.getTextureNode( 'output' );

const bloomPass = bloom( scenePassColor );

postProcessing.outputNode = scenePassColor.add( bloomPass );
```
By default, the node affects the entire image. For a selective bloom,
use the `emissive` material property to control which objects should
contribute to bloom or not. This can be achieved via MRT.
```js
const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
scenePass.setMRT( mrt( {
	output,
	emissive
} ) );

const scenePassColor = scenePass.getTextureNode( 'output' );
const emissivePass = scenePass.getTextureNode( 'emissive' );

const bloomPass = bloom( emissivePass );
postProcessing.outputNode = scenePassColor.add( bloomPass );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [BloomNode](#BloomNode) ⇐ <code>TempNode</code>
    * [new BloomNode(inputNode, [strength], [radius], [threshold])](#new_BloomNode_new)
    * [.inputNode](#BloomNode+inputNode) : <code>Node.&lt;vec4&gt;</code>
    * [.strength](#BloomNode+strength) : <code>UniformNode.&lt;float&gt;</code>
    * [.radius](#BloomNode+radius) : <code>UniformNode.&lt;float&gt;</code>
    * [.threshold](#BloomNode+threshold) : <code>UniformNode.&lt;float&gt;</code>
    * [.smoothWidth](#BloomNode+smoothWidth) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateBeforeType](#BloomNode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#BloomNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#BloomNode+setSize)
    * [.updateBefore(frame)](#BloomNode+updateBefore)
    * [.setup(builder)](#BloomNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#BloomNode+dispose)
    * [._getSeparableBlurMaterial(builder, kernelRadius)](#BloomNode+_getSeparableBlurMaterial) ⇒ <code>NodeMaterial</code>

<a name="new_BloomNode_new"></a>

### new BloomNode(inputNode, [strength], [radius], [threshold])
Constructs a new bloom node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [strength] | <code>number</code> | <code>1</code> | The strength of the bloom. |
| [radius] | <code>number</code> | <code>0</code> | The radius of the bloom. |
| [threshold] | <code>number</code> | <code>0</code> | The luminance threshold limits which bright areas contribute to the bloom effect. |

<a name="BloomNode+inputNode"></a>

### bloomNode.inputNode : <code>Node.&lt;vec4&gt;</code>
The node that represents the input of the effect.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+strength"></a>

### bloomNode.strength : <code>UniformNode.&lt;float&gt;</code>
The strength of the bloom.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+radius"></a>

### bloomNode.radius : <code>UniformNode.&lt;float&gt;</code>
The radius of the bloom.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+threshold"></a>

### bloomNode.threshold : <code>UniformNode.&lt;float&gt;</code>
The luminance threshold limits which bright areas contribute to the bloom effect.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+smoothWidth"></a>

### bloomNode.smoothWidth : <code>UniformNode.&lt;float&gt;</code>
Can be used to tweak the extracted luminance from the scene.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+updateBeforeType"></a>

### bloomNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="BloomNode+getTextureNode"></a>

### bloomNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="BloomNode+setSize"></a>

### bloomNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="BloomNode+updateBefore"></a>

### bloomNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="BloomNode+setup"></a>

### bloomNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BloomNode+dispose"></a>

### bloomNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+_getSeparableBlurMaterial"></a>

### bloomNode.\_getSeparableBlurMaterial(builder, kernelRadius) ⇒ <code>NodeMaterial</code>
Create a separable blur material for the given kernel radius.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| kernelRadius | <code>number</code> | The kernel radius. |

<a name="bloom"></a>

## bloom(node, [strength], [radius], [threshold]) ⇒ [<code>BloomNode</code>](#BloomNode)
TSL function for creating a bloom effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [strength] | <code>number</code> | <code>1</code> | The strength of the bloom. |
| [radius] | <code>number</code> | <code>0</code> | The radius of the bloom. |
| [threshold] | <code>number</code> | <code>0</code> | The luminance threshold limits which bright areas contribute to the bloom effect. |

## Classes

<dl>
<dt><a href="#DenoiseNode">DenoiseNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for denoising data like raw screen-space ambient occlusion output.
Denoise can noticeably improve the quality of ambient occlusion but also add quite some
overhead to the post processing setup. It&#39;s best to make its usage optional (e.g. via
graphic settings).</p>
<p>Reference: <a href="https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf">https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#generateDenoiseSamples">generateDenoiseSamples(numSamples, numRings, radiusExponent)</a> ⇒ <code>Array.&lt;Vector3&gt;</code></dt>
<dd><p>Generates denoise samples based on the given parameters.</p>
</dd>
<dt><a href="#generateDefaultNoise">generateDefaultNoise([size])</a> ⇒ <code>DataTexture</code></dt>
<dd><p>Generates a default noise texture for the given size.</p>
</dd>
<dt><a href="#denoise">denoise(node, depthNode, normalNode, camera)</a> ⇒ <code><a href="#DenoiseNode">DenoiseNode</a></code></dt>
<dd><p>TSL function for creating a denoise effect.</p>
</dd>
</dl>

<a name="DenoiseNode"></a>

## DenoiseNode ⇐ <code>TempNode</code>
Post processing node for denoising data like raw screen-space ambient occlusion output.
Denoise can noticeably improve the quality of ambient occlusion but also add quite some
overhead to the post processing setup. It's best to make its usage optional (e.g. via
graphic settings).

Reference: [https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf](https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [DenoiseNode](#DenoiseNode) ⇐ <code>TempNode</code>
    * [new DenoiseNode(textureNode, depthNode, normalNode, camera)](#new_DenoiseNode_new)
    * [.textureNode](#DenoiseNode+textureNode) : <code>TextureNode</code>
    * [.depthNode](#DenoiseNode+depthNode) : <code>Node.&lt;float&gt;</code>
    * [.normalNode](#DenoiseNode+normalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.noiseNode](#DenoiseNode+noiseNode) : <code>TextureNode</code>
    * [.lumaPhi](#DenoiseNode+lumaPhi) : <code>UniformNode.&lt;float&gt;</code>
    * [.depthPhi](#DenoiseNode+depthPhi) : <code>UniformNode.&lt;float&gt;</code>
    * [.normalPhi](#DenoiseNode+normalPhi) : <code>UniformNode.&lt;float&gt;</code>
    * [.radius](#DenoiseNode+radius) : <code>UniformNode.&lt;float&gt;</code>
    * [.index](#DenoiseNode+index) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateBeforeType](#DenoiseNode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#DenoiseNode+updateBefore)
    * [.setup(builder)](#DenoiseNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_DenoiseNode_new"></a>

### new DenoiseNode(textureNode, depthNode, normalNode, camera)
Constructs a new denoise node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect (e.g. AO). |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the scene's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the scene's normals. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="DenoiseNode+textureNode"></a>

### denoiseNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect (e.g. AO).

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+depthNode"></a>

### denoiseNode.depthNode : <code>Node.&lt;float&gt;</code>
A node that represents the scene's depth.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+normalNode"></a>

### denoiseNode.normalNode : <code>Node.&lt;vec3&gt;</code>
A node that represents the scene's normals. If no normals are passed to the
constructor (because MRT is not available), normals can be automatically
reconstructed from depth values in the shader.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+noiseNode"></a>

### denoiseNode.noiseNode : <code>TextureNode</code>
The node represents the internal noise texture.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+lumaPhi"></a>

### denoiseNode.lumaPhi : <code>UniformNode.&lt;float&gt;</code>
The luma Phi value.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+depthPhi"></a>

### denoiseNode.depthPhi : <code>UniformNode.&lt;float&gt;</code>
The depth Phi value.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+normalPhi"></a>

### denoiseNode.normalPhi : <code>UniformNode.&lt;float&gt;</code>
The normal Phi value.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+radius"></a>

### denoiseNode.radius : <code>UniformNode.&lt;float&gt;</code>
The radius.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+index"></a>

### denoiseNode.index : <code>UniformNode.&lt;float&gt;</code>
The index.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+updateBeforeType"></a>

### denoiseNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="DenoiseNode+updateBefore"></a>

### denoiseNode.updateBefore(frame)
This method is used to update internal uniforms once per frame.

**Kind**: instance method of [<code>DenoiseNode</code>](#DenoiseNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="DenoiseNode+setup"></a>

### denoiseNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>DenoiseNode</code>](#DenoiseNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="generateDenoiseSamples"></a>

## generateDenoiseSamples(numSamples, numRings, radiusExponent) ⇒ <code>Array.&lt;Vector3&gt;</code>
Generates denoise samples based on the given parameters.

**Kind**: global function  
**Returns**: <code>Array.&lt;Vector3&gt;</code> - The denoise samples.  

| Param | Type | Description |
| --- | --- | --- |
| numSamples | <code>number</code> | The number of samples. |
| numRings | <code>number</code> | The number of rings. |
| radiusExponent | <code>number</code> | The radius exponent. |

<a name="generateDefaultNoise"></a>

## generateDefaultNoise([size]) ⇒ <code>DataTexture</code>
Generates a default noise texture for the given size.

**Kind**: global function  
**Returns**: <code>DataTexture</code> - The generated noise texture.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>64</code> | The texture size. |

<a name="denoise"></a>

## denoise(node, depthNode, normalNode, camera) ⇒ [<code>DenoiseNode</code>](#DenoiseNode)
TSL function for creating a denoise effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that represents the input of the effect (e.g. AO). |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the scene's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the scene's normals. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

## Classes

<dl>
<dt><a href="#DepthOfFieldNode">DepthOfFieldNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating depth of field (DOF) effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#dof">dof(node, viewZNode, focus, aperture, maxblur)</a> ⇒ <code><a href="#DepthOfFieldNode">DepthOfFieldNode</a></code></dt>
<dd><p>TSL function for creating a depth-of-field effect (DOF) for post processing.</p>
</dd>
</dl>

<a name="DepthOfFieldNode"></a>

## DepthOfFieldNode ⇐ <code>TempNode</code>
Post processing node for creating depth of field (DOF) effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [DepthOfFieldNode](#DepthOfFieldNode) ⇐ <code>TempNode</code>
    * [new DepthOfFieldNode(textureNode, viewZNode, focusNode, apertureNode, maxblurNode)](#new_DepthOfFieldNode_new)
    * [.textureNode](#DepthOfFieldNode+textureNode) : <code>TextureNode</code>
    * [.viewZNode](#DepthOfFieldNode+viewZNode) : <code>Node.&lt;float&gt;</code>
    * [.focusNode](#DepthOfFieldNode+focusNode) : <code>Node.&lt;float&gt;</code>
    * [.apertureNode](#DepthOfFieldNode+apertureNode) : <code>Node.&lt;float&gt;</code>
    * [.maxblurNode](#DepthOfFieldNode+maxblurNode) : <code>Node.&lt;float&gt;</code>
    * [.updateBeforeType](#DepthOfFieldNode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#DepthOfFieldNode+updateBefore)
    * [.setup(builder)](#DepthOfFieldNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_DepthOfFieldNode_new"></a>

### new DepthOfFieldNode(textureNode, viewZNode, focusNode, apertureNode, maxblurNode)
Constructs a new DOF node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |
| viewZNode | <code>Node.&lt;float&gt;</code> | Represents the viewZ depth values of the scene. |
| focusNode | <code>Node.&lt;float&gt;</code> | Defines the effect's focus which is the distance along the camera's look direction in world units. |
| apertureNode | <code>Node.&lt;float&gt;</code> | Defines the effect's aperture. |
| maxblurNode | <code>Node.&lt;float&gt;</code> | Defines the effect's maximum blur. |

<a name="DepthOfFieldNode+textureNode"></a>

### depthOfFieldNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+viewZNode"></a>

### depthOfFieldNode.viewZNode : <code>Node.&lt;float&gt;</code>
Represents the viewZ depth values of the scene.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+focusNode"></a>

### depthOfFieldNode.focusNode : <code>Node.&lt;float&gt;</code>
Defines the effect's focus which is the distance along the camera's look direction in world units.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+apertureNode"></a>

### depthOfFieldNode.apertureNode : <code>Node.&lt;float&gt;</code>
Defines the effect's aperture.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+maxblurNode"></a>

### depthOfFieldNode.maxblurNode : <code>Node.&lt;float&gt;</code>
Defines the effect's maximum blur.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+updateBeforeType"></a>

### depthOfFieldNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="DepthOfFieldNode+updateBefore"></a>

### depthOfFieldNode.updateBefore(frame)
This method is used to update the effect's uniforms once per frame.

**Kind**: instance method of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="DepthOfFieldNode+setup"></a>

### depthOfFieldNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="dof"></a>

## dof(node, viewZNode, focus, aperture, maxblur) ⇒ [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)
TSL function for creating a depth-of-field effect (DOF) for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |
| viewZNode | <code>Node.&lt;float&gt;</code> | Represents the viewZ depth values of the scene. |
| focus | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Defines the effect's focus which is the distance along the camera's look direction in world units. |
| aperture | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Defines the effect's aperture. |
| maxblur | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Defines the effect's maximum blur. |

## Classes

<dl>
<dt><a href="#DotScreenNode">DotScreenNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating dot-screen effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#dotScreen">dotScreen(node, [angle], [scale])</a> ⇒ <code><a href="#DotScreenNode">DotScreenNode</a></code></dt>
<dd><p>TSL function for creating a dot-screen node for post processing.</p>
</dd>
</dl>

<a name="DotScreenNode"></a>

## DotScreenNode ⇐ <code>TempNode</code>
Post processing node for creating dot-screen effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [DotScreenNode](#DotScreenNode) ⇐ <code>TempNode</code>
    * [new DotScreenNode(inputNode, [angle], [scale])](#new_DotScreenNode_new)
    * [.inputNode](#DotScreenNode+inputNode) : <code>Node</code>
    * [.angle](#DotScreenNode+angle) : <code>UniformNode.&lt;float&gt;</code>
    * [.scale](#DotScreenNode+scale) : <code>UniformNode.&lt;float&gt;</code>
    * [.setup(builder)](#DotScreenNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_DotScreenNode_new"></a>

### new DotScreenNode(inputNode, [angle], [scale])
Constructs a new dot screen node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node</code> |  | The node that represents the input of the effect. |
| [angle] | <code>number</code> | <code>1.57</code> | The rotation of the effect in radians. |
| [scale] | <code>number</code> | <code>1</code> | The scale of the effect. A higher value means smaller dots. |

<a name="DotScreenNode+inputNode"></a>

### dotScreenNode.inputNode : <code>Node</code>
The node that represents the input of the effect.

**Kind**: instance property of [<code>DotScreenNode</code>](#DotScreenNode)  
<a name="DotScreenNode+angle"></a>

### dotScreenNode.angle : <code>UniformNode.&lt;float&gt;</code>
A uniform node that represents the rotation of the effect in radians.

**Kind**: instance property of [<code>DotScreenNode</code>](#DotScreenNode)  
<a name="DotScreenNode+scale"></a>

### dotScreenNode.scale : <code>UniformNode.&lt;float&gt;</code>
A uniform node that represents the scale of the effect. A higher value means smaller dots.

**Kind**: instance property of [<code>DotScreenNode</code>](#DotScreenNode)  
<a name="DotScreenNode+setup"></a>

### dotScreenNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>DotScreenNode</code>](#DotScreenNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="dotScreen"></a>

## dotScreen(node, [angle], [scale]) ⇒ [<code>DotScreenNode</code>](#DotScreenNode)
TSL function for creating a dot-screen node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [angle] | <code>number</code> | <code>1.57</code> | The rotation of the effect in radians. |
| [scale] | <code>number</code> | <code>1</code> | The scale of the effect. A higher value means smaller dots. |

## Classes

<dl>
<dt><a href="#FXAANode">FXAANode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for applying FXAA. This node requires sRGB input
so tone mapping and color space conversion must happen before the anti-aliasing.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#fxaa">fxaa(node)</a> ⇒ <code><a href="#FXAANode">FXAANode</a></code></dt>
<dd><p>TSL function for creating a FXAA node for anti-aliasing via post processing.</p>
</dd>
</dl>

<a name="FXAANode"></a>

## FXAANode ⇐ <code>TempNode</code>
Post processing node for applying FXAA. This node requires sRGB input
so tone mapping and color space conversion must happen before the anti-aliasing.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [FXAANode](#FXAANode) ⇐ <code>TempNode</code>
    * [new FXAANode(textureNode)](#new_FXAANode_new)
    * [.textureNode](#FXAANode+textureNode) : <code>TextureNode</code>
    * [.updateBeforeType](#FXAANode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#FXAANode+updateBefore)
    * [.setup(builder)](#FXAANode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_FXAANode_new"></a>

### new FXAANode(textureNode)
Constructs a new FXAA node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |

<a name="FXAANode+textureNode"></a>

### fxaaNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>FXAANode</code>](#FXAANode)  
<a name="FXAANode+updateBeforeType"></a>

### fxaaNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>FXAANode</code>](#FXAANode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="FXAANode+updateBefore"></a>

### fxaaNode.updateBefore(frame)
This method is used to update the effect's uniforms once per frame.

**Kind**: instance method of [<code>FXAANode</code>](#FXAANode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="FXAANode+setup"></a>

### fxaaNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>FXAANode</code>](#FXAANode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="fxaa"></a>

## fxaa(node) ⇒ [<code>FXAANode</code>](#FXAANode)
TSL function for creating a FXAA node for anti-aliasing via post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |

## Classes

<dl>
<dt><a href="#FilmNode">FilmNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating a film grain effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#film">film(inputNode, [intensityNode], [uvNode])</a> ⇒ <code><a href="#FilmNode">FilmNode</a></code></dt>
<dd><p>TSL function for creating a film node for post processing.</p>
</dd>
</dl>

<a name="FilmNode"></a>

## FilmNode ⇐ <code>TempNode</code>
Post processing node for creating a film grain effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [FilmNode](#FilmNode) ⇐ <code>TempNode</code>
    * [new FilmNode(inputNode, [intensityNode], [uvNode])](#new_FilmNode_new)
    * [.inputNode](#FilmNode+inputNode) : <code>Node</code>
    * [.intensityNode](#FilmNode+intensityNode) : <code>Node.&lt;float&gt;</code>
    * [.uvNode](#FilmNode+uvNode) : <code>Node.&lt;vec2&gt;</code>
    * [.setup(builder)](#FilmNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_FilmNode_new"></a>

### new FilmNode(inputNode, [intensityNode], [uvNode])
Constructs a new film node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node</code> |  | The node that represents the input of the effect. |
| [intensityNode] | <code>Node.&lt;float&gt;</code> | <code></code> | A node that represents the effect's intensity. |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | A node that allows to pass custom (e.g. animated) uv data. |

<a name="FilmNode+inputNode"></a>

### filmNode.inputNode : <code>Node</code>
The node that represents the input of the effect.

**Kind**: instance property of [<code>FilmNode</code>](#FilmNode)  
<a name="FilmNode+intensityNode"></a>

### filmNode.intensityNode : <code>Node.&lt;float&gt;</code>
A node that represents the effect's intensity.

**Kind**: instance property of [<code>FilmNode</code>](#FilmNode)  
**Default**: <code>null</code>  
<a name="FilmNode+uvNode"></a>

### filmNode.uvNode : <code>Node.&lt;vec2&gt;</code>
A node that allows to pass custom (e.g. animated) uv data.

**Kind**: instance property of [<code>FilmNode</code>](#FilmNode)  
**Default**: <code>null</code>  
<a name="FilmNode+setup"></a>

### filmNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>FilmNode</code>](#FilmNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="film"></a>

## film(inputNode, [intensityNode], [uvNode]) ⇒ [<code>FilmNode</code>](#FilmNode)
TSL function for creating a film node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [intensityNode] | <code>Node.&lt;float&gt;</code> | <code></code> | A node that represents the effect's intensity. |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | A node that allows to pass custom (e.g. animated) uv data. |

## Classes

<dl>
<dt><a href="#GTAONode">GTAONode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for applying Ground Truth Ambient Occlusion (GTAO) to a scene.</p>
<pre><code class="language-js">const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
scenePass.setMRT( mrt( {
    output: output,
    normal: normalView
} ) );

const scenePassColor = scenePass.getTextureNode( &#39;output&#39; );
const scenePassNormal = scenePass.getTextureNode( &#39;normal&#39; );
const scenePassDepth = scenePass.getTextureNode( &#39;depth&#39; );

const aoPass = ao( scenePassDepth, scenePassNormal, camera );

postProcessing.outputNod = aoPass.getTextureNode().mul( scenePassColor );
</code></pre>
<p>Reference: <a href="https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf">https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#generateMagicSquareNoise">generateMagicSquareNoise([size])</a> ⇒ <code>DataTexture</code></dt>
<dd><p>Generates the AO&#39;s noise texture for the given size.</p>
</dd>
<dt><a href="#generateMagicSquare">generateMagicSquare(size)</a> ⇒ <code>Array.&lt;number&gt;</code></dt>
<dd><p>Computes an array of magic square values required to generate the noise texture.</p>
</dd>
<dt><a href="#ao">ao(depthNode, normalNode, camera)</a> ⇒ <code><a href="#GTAONode">GTAONode</a></code></dt>
<dd><p>TSL function for creating a Ground Truth Ambient Occlusion (GTAO) effect.</p>
</dd>
</dl>

<a name="GTAONode"></a>

## GTAONode ⇐ <code>TempNode</code>
Post processing node for applying Ground Truth Ambient Occlusion (GTAO) to a scene.
```js
const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
scenePass.setMRT( mrt( {
	output: output,
	normal: normalView
} ) );

const scenePassColor = scenePass.getTextureNode( 'output' );
const scenePassNormal = scenePass.getTextureNode( 'normal' );
const scenePassDepth = scenePass.getTextureNode( 'depth' );

const aoPass = ao( scenePassDepth, scenePassNormal, camera );

postProcessing.outputNod = aoPass.getTextureNode().mul( scenePassColor );
```

Reference: [https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf](https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [GTAONode](#GTAONode) ⇐ <code>TempNode</code>
    * [new GTAONode(depthNode, normalNode, camera)](#new_GTAONode_new)
    * [.depthNode](#GTAONode+depthNode) : <code>Node.&lt;float&gt;</code>
    * [.normalNode](#GTAONode+normalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.resolutionScale](#GTAONode+resolutionScale) : <code>number</code>
    * [.updateBeforeType](#GTAONode+updateBeforeType) : <code>string</code>
    * [.radius](#GTAONode+radius) : <code>UniformNode.&lt;float&gt;</code>
    * [.resolution](#GTAONode+resolution) : <code>UniformNode.&lt;vec2&gt;</code>
    * [.thickness](#GTAONode+thickness) : <code>UniformNode.&lt;float&gt;</code>
    * [.distanceExponent](#GTAONode+distanceExponent) : <code>UniformNode.&lt;float&gt;</code>
    * [.distanceFallOff](#GTAONode+distanceFallOff) : <code>UniformNode.&lt;float&gt;</code>
    * [.scale](#GTAONode+scale) : <code>UniformNode.&lt;float&gt;</code>
    * [.samples](#GTAONode+samples) : <code>UniformNode.&lt;float&gt;</code>
    * [.getTextureNode()](#GTAONode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#GTAONode+setSize)
    * [.updateBefore(frame)](#GTAONode+updateBefore)
    * [.setup(builder)](#GTAONode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#GTAONode+dispose)

<a name="new_GTAONode_new"></a>

### new GTAONode(depthNode, normalNode, camera)
Constructs a new GTAO node.


| Param | Type | Description |
| --- | --- | --- |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the scene's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the scene's normals. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="GTAONode+depthNode"></a>

### gtaoNode.depthNode : <code>Node.&lt;float&gt;</code>
A node that represents the scene's depth.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+normalNode"></a>

### gtaoNode.normalNode : <code>Node.&lt;vec3&gt;</code>
A node that represents the scene's normals. If no normals are passed to the
constructor (because MRT is not available), normals can be automatically
reconstructed from depth values in the shader.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+resolutionScale"></a>

### gtaoNode.resolutionScale : <code>number</code>
The resolution scale. By default the effect is rendered in full resolution
for best quality but a value of `0.5` should be sufficient for most scenes.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
**Default**: <code>1</code>  
<a name="GTAONode+updateBeforeType"></a>

### gtaoNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="GTAONode+radius"></a>

### gtaoNode.radius : <code>UniformNode.&lt;float&gt;</code>
The radius of the ambient occlusion.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+resolution"></a>

### gtaoNode.resolution : <code>UniformNode.&lt;vec2&gt;</code>
The resolution of the effect. Can be scaled via
`resolutionScale`.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+thickness"></a>

### gtaoNode.thickness : <code>UniformNode.&lt;float&gt;</code>
The thickness of the ambient occlusion.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+distanceExponent"></a>

### gtaoNode.distanceExponent : <code>UniformNode.&lt;float&gt;</code>
Another option to tweak the occlusion. The recommended range is
`[1,2]` for attenuating the AO.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+distanceFallOff"></a>

### gtaoNode.distanceFallOff : <code>UniformNode.&lt;float&gt;</code>
The distance fall off value of the ambient occlusion.
A lower value leads to a larger AO effect. The value
should lie in the range `[0,1]`.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+scale"></a>

### gtaoNode.scale : <code>UniformNode.&lt;float&gt;</code>
The scale of the ambient occlusion.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+samples"></a>

### gtaoNode.samples : <code>UniformNode.&lt;float&gt;</code>
How many samples are used to compute the AO.
A higher value results in better quality but also
in a more expensive runtime behavior.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+getTextureNode"></a>

### gtaoNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="GTAONode+setSize"></a>

### gtaoNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="GTAONode+updateBefore"></a>

### gtaoNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="GTAONode+setup"></a>

### gtaoNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="GTAONode+dispose"></a>

### gtaoNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  
<a name="generateMagicSquareNoise"></a>

## generateMagicSquareNoise([size]) ⇒ <code>DataTexture</code>
Generates the AO's noise texture for the given size.

**Kind**: global function  
**Returns**: <code>DataTexture</code> - The generated noise texture.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>5</code> | The noise size. |

<a name="generateMagicSquare"></a>

## generateMagicSquare(size) ⇒ <code>Array.&lt;number&gt;</code>
Computes an array of magic square values required to generate the noise texture.

**Kind**: global function  
**Returns**: <code>Array.&lt;number&gt;</code> - The magic square values.  

| Param | Type | Description |
| --- | --- | --- |
| size | <code>number</code> | The noise size. |

<a name="ao"></a>

## ao(depthNode, normalNode, camera) ⇒ [<code>GTAONode</code>](#GTAONode)
TSL function for creating a Ground Truth Ambient Occlusion (GTAO) effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the scene's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the scene's normals. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

## Classes

<dl>
<dt><a href="#GaussianBlurNode">GaussianBlurNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating a gaussian blur effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#gaussianBlur">gaussianBlur(node, directionNode, sigma)</a> ⇒ <code><a href="#GaussianBlurNode">GaussianBlurNode</a></code></dt>
<dd><p>TSL function for creating a gaussian blur node for post processing.</p>
</dd>
<dt><a href="#premultipliedGaussianBlur">premultipliedGaussianBlur(node, directionNode, sigma)</a> ⇒ <code><a href="#GaussianBlurNode">GaussianBlurNode</a></code></dt>
<dd><p>TSL function for creating a gaussian blur node for post processing with enabled premultiplied alpha.</p>
</dd>
</dl>

<a name="GaussianBlurNode"></a>

## GaussianBlurNode ⇐ <code>TempNode</code>
Post processing node for creating a gaussian blur effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [GaussianBlurNode](#GaussianBlurNode) ⇐ <code>TempNode</code>
    * [new GaussianBlurNode(textureNode, directionNode, sigma)](#new_GaussianBlurNode_new)
    * [.textureNode](#GaussianBlurNode+textureNode) : <code>TextureNode</code>
    * [.directionNode](#GaussianBlurNode+directionNode) : <code>Node.&lt;(vec2\|float)&gt;</code>
    * [.sigma](#GaussianBlurNode+sigma) : <code>number</code>
    * [.updateBeforeType](#GaussianBlurNode+updateBeforeType) : <code>string</code>
    * [.resolution](#GaussianBlurNode+resolution) : <code>Vector2</code>
    * [.premultipliedAlpha](#GaussianBlurNode+premultipliedAlpha) : <code>boolean</code>
    * [.setPremultipliedAlpha(value)](#GaussianBlurNode+setPremultipliedAlpha) ⇒ [<code>GaussianBlurNode</code>](#GaussianBlurNode)
    * [.getPremultipliedAlpha()](#GaussianBlurNode+getPremultipliedAlpha) ⇒ <code>boolean</code>
    * [.setSize(width, height)](#GaussianBlurNode+setSize)
    * [.updateBefore(frame)](#GaussianBlurNode+updateBefore)
    * [.getTextureNode()](#GaussianBlurNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setup(builder)](#GaussianBlurNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#GaussianBlurNode+dispose)

<a name="new_GaussianBlurNode_new"></a>

### new GaussianBlurNode(textureNode, directionNode, sigma)
Constructs a new gaussian blur node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that represents the input of the effect. |
| directionNode | <code>Node.&lt;(vec2\|float)&gt;</code> | <code></code> | Defines the direction and radius of the blur. |
| sigma | <code>number</code> | <code>2</code> | Controls the kernel of the blur filter. Higher values mean a wider blur radius. |

<a name="GaussianBlurNode+textureNode"></a>

### gaussianBlurNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
<a name="GaussianBlurNode+directionNode"></a>

### gaussianBlurNode.directionNode : <code>Node.&lt;(vec2\|float)&gt;</code>
Defines the direction and radius of the blur.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
<a name="GaussianBlurNode+sigma"></a>

### gaussianBlurNode.sigma : <code>number</code>
Controls the kernel of the blur filter. Higher values mean a wider blur radius.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
<a name="GaussianBlurNode+updateBeforeType"></a>

### gaussianBlurNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="GaussianBlurNode+resolution"></a>

### gaussianBlurNode.resolution : <code>Vector2</code>
Controls the resolution of the effect.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Default**: <code>(1,1)</code>  
<a name="GaussianBlurNode+premultipliedAlpha"></a>

### gaussianBlurNode.premultipliedAlpha : <code>boolean</code>
Whether the effect should use premultiplied alpha or not. Set this to `true`
if you are going to blur texture input with transparency.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Default**: <code>false</code>  
<a name="GaussianBlurNode+setPremultipliedAlpha"></a>

### gaussianBlurNode.setPremultipliedAlpha(value) ⇒ [<code>GaussianBlurNode</code>](#GaussianBlurNode)
Sets the given premultiplied alpha value.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Returns**: [<code>GaussianBlurNode</code>](#GaussianBlurNode) - height - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | Whether the effect should use premultiplied alpha or not. |

<a name="GaussianBlurNode+getPremultipliedAlpha"></a>

### gaussianBlurNode.getPremultipliedAlpha() ⇒ <code>boolean</code>
Returns the premultiplied alpha value.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Returns**: <code>boolean</code> - Whether the effect should use premultiplied alpha or not.  
<a name="GaussianBlurNode+setSize"></a>

### gaussianBlurNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="GaussianBlurNode+updateBefore"></a>

### gaussianBlurNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="GaussianBlurNode+getTextureNode"></a>

### gaussianBlurNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="GaussianBlurNode+setup"></a>

### gaussianBlurNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="GaussianBlurNode+dispose"></a>

### gaussianBlurNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
<a name="gaussianBlur"></a>

## gaussianBlur(node, directionNode, sigma) ⇒ [<code>GaussianBlurNode</code>](#GaussianBlurNode)
TSL function for creating a gaussian blur node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |
| directionNode | <code>Node.&lt;(vec2\|float)&gt;</code> | Defines the direction and radius of the blur. |
| sigma | <code>number</code> | Controls the kernel of the blur filter. Higher values mean a wider blur radius. |

<a name="premultipliedGaussianBlur"></a>

## premultipliedGaussianBlur(node, directionNode, sigma) ⇒ [<code>GaussianBlurNode</code>](#GaussianBlurNode)
TSL function for creating a gaussian blur node for post processing with enabled premultiplied alpha.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |
| directionNode | <code>Node.&lt;(vec2\|float)&gt;</code> | Defines the direction and radius of the blur. |
| sigma | <code>number</code> | Controls the kernel of the blur filter. Higher values mean a wider blur radius. |

## Classes

<dl>
<dt><a href="#LensflareNode">LensflareNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for adding a bloom-based lens flare effect. This effect
requires that you extract the bloom of the scene via a bloom pass first.</p>
<p>References:</p>
<ul>
<li><a href="https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html">https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html</a>.</li>
<li><a href="https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html">https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html</a>.</li>
</ul>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#lensflare">lensflare(node, params)</a> ⇒ <code><a href="#LensflareNode">LensflareNode</a></code></dt>
<dd><p>TSL function for creating a bloom-based lens flare effect.</p>
</dd>
</dl>

<a name="LensflareNode"></a>

## LensflareNode ⇐ <code>TempNode</code>
Post processing node for adding a bloom-based lens flare effect. This effect
requires that you extract the bloom of the scene via a bloom pass first.

References:
- [https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html](https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html).
- [https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html](https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [LensflareNode](#LensflareNode) ⇐ <code>TempNode</code>
    * [new LensflareNode(textureNode, params)](#new_LensflareNode_new)
    * [.textureNode](#LensflareNode+textureNode) : <code>TextureNode</code>
    * [.ghostTintNode](#LensflareNode+ghostTintNode) : <code>Node.&lt;vec3&gt;</code>
    * [.thresholdNode](#LensflareNode+thresholdNode) : <code>Node.&lt;float&gt;</code>
    * [.ghostSamplesNode](#LensflareNode+ghostSamplesNode) : <code>Node.&lt;float&gt;</code>
    * [.ghostSpacingNode](#LensflareNode+ghostSpacingNode) : <code>Node.&lt;float&gt;</code>
    * [.ghostAttenuationFactorNode](#LensflareNode+ghostAttenuationFactorNode) : <code>Node.&lt;float&gt;</code>
    * [.downSampleRatio](#LensflareNode+downSampleRatio) : <code>number</code>
    * [.updateBeforeType](#LensflareNode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#LensflareNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#LensflareNode+setSize)
    * [.updateBefore(frame)](#LensflareNode+updateBefore)
    * [.setup(builder)](#LensflareNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#LensflareNode+dispose)

<a name="new_LensflareNode_new"></a>

### new LensflareNode(textureNode, params)
Constructs a new lens flare node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that represents the scene's bloom. |
| params | <code>Object</code> |  | The parameter object for configuring the effect. |
| [params.ghostTint] | <code>Node.&lt;vec3&gt;</code> \| <code>Color</code> | <code>vec3(1, 1, 1)</code> | Defines the tint of the flare/ghosts. |
| [params.threshold] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(0.5)</code> | Controls the size and strength of the effect. A higher threshold results in smaller flares. |
| [params.ghostSamples] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(4)</code> | Represents the number of flares/ghosts per bright spot which pivot around the center. |
| [params.ghostSpacing] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(0.25)</code> | Defines the spacing of the flares/ghosts. |
| [params.ghostAttenuationFactor] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(25)</code> | Defines the attenuation factor of flares/ghosts. |
| [params.downSampleRatio] | <code>number</code> | <code>4</code> | Defines how downsampling since the effect is usually not rendered at full resolution. |

<a name="LensflareNode+textureNode"></a>

### lensflareNode.textureNode : <code>TextureNode</code>
The texture node that represents the scene's bloom.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+ghostTintNode"></a>

### lensflareNode.ghostTintNode : <code>Node.&lt;vec3&gt;</code>
Defines the tint of the flare/ghosts.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+thresholdNode"></a>

### lensflareNode.thresholdNode : <code>Node.&lt;float&gt;</code>
Controls the size and strength of the effect. A higher threshold results in smaller flares.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+ghostSamplesNode"></a>

### lensflareNode.ghostSamplesNode : <code>Node.&lt;float&gt;</code>
Represents the number of flares/ghosts per bright spot which pivot around the center.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+ghostSpacingNode"></a>

### lensflareNode.ghostSpacingNode : <code>Node.&lt;float&gt;</code>
Defines the spacing of the flares/ghosts.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+ghostAttenuationFactorNode"></a>

### lensflareNode.ghostAttenuationFactorNode : <code>Node.&lt;float&gt;</code>
Defines the attenuation factor of flares/ghosts.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+downSampleRatio"></a>

### lensflareNode.downSampleRatio : <code>number</code>
Defines how downsampling since the effect is usually not rendered at full resolution.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+updateBeforeType"></a>

### lensflareNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="LensflareNode+getTextureNode"></a>

### lensflareNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="LensflareNode+setSize"></a>

### lensflareNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="LensflareNode+updateBefore"></a>

### lensflareNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="LensflareNode+setup"></a>

### lensflareNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LensflareNode+dispose"></a>

### lensflareNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  
<a name="lensflare"></a>

## lensflare(node, params) ⇒ [<code>LensflareNode</code>](#LensflareNode)
TSL function for creating a bloom-based lens flare effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>TextureNode</code> |  | The node that represents the scene's bloom. |
| params | <code>Object</code> |  | The parameter object for configuring the effect. |
| [params.ghostTint] | <code>Node.&lt;vec3&gt;</code> \| <code>Color</code> | <code>vec3(1, 1, 1)</code> | Defines the tint of the flare/ghosts. |
| [params.threshold] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(0.5)</code> | Controls the size and strength of the effect. A higher threshold results in smaller flares. |
| [params.ghostSamples] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(4)</code> | Represents the number of flares/ghosts per bright spot which pivot around the center. |
| [params.ghostSpacing] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(0.25)</code> | Defines the spacing of the flares/ghosts. |
| [params.ghostAttenuationFactor] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(25)</code> | Defines the attenuation factor of flares/ghosts. |
| [params.downSampleRatio] | <code>number</code> | <code>4</code> | Defines how downsampling since the effect is usually not rendered at full resolution. |

## Classes

<dl>
<dt><a href="#Lut3DNode">Lut3DNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>A post processing node for color grading via lookup tables.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#lut3D">lut3D(node, lut, size, intensity)</a> ⇒ <code><a href="#Lut3DNode">Lut3DNode</a></code></dt>
<dd><p>TSL function for creating a LUT node for color grading via post processing.</p>
</dd>
</dl>

<a name="Lut3DNode"></a>

## Lut3DNode ⇐ <code>TempNode</code>
A post processing node for color grading via lookup tables.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [Lut3DNode](#Lut3DNode) ⇐ <code>TempNode</code>
    * [new Lut3DNode(inputNode, lutNode, size, intensityNode)](#new_Lut3DNode_new)
    * [.inputNode](#Lut3DNode+inputNode) : <code>Node</code>
    * [.lutNode](#Lut3DNode+lutNode) : <code>TextureNode</code>
    * [.size](#Lut3DNode+size) : <code>UniformNode.&lt;float&gt;</code>
    * [.intensityNode](#Lut3DNode+intensityNode) : <code>Node.&lt;float&gt;</code>
    * [.setup(builder)](#Lut3DNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_Lut3DNode_new"></a>

### new Lut3DNode(inputNode, lutNode, size, intensityNode)
Constructs a new LUT node.


| Param | Type | Description |
| --- | --- | --- |
| inputNode | <code>Node</code> | The node that represents the input of the effect. |
| lutNode | <code>TextureNode</code> | A texture node that represents the lookup table. |
| size | <code>number</code> | The size of the lookup table. |
| intensityNode | <code>Node.&lt;float&gt;</code> | Controls the intensity of the effect. |

<a name="Lut3DNode+inputNode"></a>

### lut3DNode.inputNode : <code>Node</code>
The node that represents the input of the effect.

**Kind**: instance property of [<code>Lut3DNode</code>](#Lut3DNode)  
<a name="Lut3DNode+lutNode"></a>

### lut3DNode.lutNode : <code>TextureNode</code>
A texture node that represents the lookup table.

**Kind**: instance property of [<code>Lut3DNode</code>](#Lut3DNode)  
<a name="Lut3DNode+size"></a>

### lut3DNode.size : <code>UniformNode.&lt;float&gt;</code>
The size of the lookup table.

**Kind**: instance property of [<code>Lut3DNode</code>](#Lut3DNode)  
<a name="Lut3DNode+intensityNode"></a>

### lut3DNode.intensityNode : <code>Node.&lt;float&gt;</code>
Controls the intensity of the effect.

**Kind**: instance property of [<code>Lut3DNode</code>](#Lut3DNode)  
<a name="Lut3DNode+setup"></a>

### lut3DNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>Lut3DNode</code>](#Lut3DNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="lut3D"></a>

## lut3D(node, lut, size, intensity) ⇒ [<code>Lut3DNode</code>](#Lut3DNode)
TSL function for creating a LUT node for color grading via post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that represents the input of the effect. |
| lut | <code>TextureNode</code> | A texture node that represents the lookup table. |
| size | <code>number</code> | The size of the lookup table. |
| intensity | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Controls the intensity of the effect. |

<a name="motionBlur"></a>

## motionBlur(inputNode, velocity, [numSamples]) ⇒ <code>Node.&lt;vec4&gt;</code>
Applies a motion blur effect to the given input node.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The input node with the motion blur effect applied.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node.&lt;vec4&gt;</code> |  | The input node to apply the motion blur for. |
| velocity | <code>Node.&lt;vec2&gt;</code> |  | The motion vectors of the beauty pass. |
| [numSamples] | <code>Node.&lt;int&gt;</code> | <code>int(16)</code> | How many samples the effect should use. A higher value results in better quality but is also more expensive. |

## Classes

<dl>
<dt><a href="#OutlineNode">OutlineNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for rendering outlines around selected objects. The node
gives you great flexibility in composing the final outline look depending on
your requirements.</p>
<pre><code class="language-js">const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );

// outline parameter

const edgeStrength = uniform( 3.0 );
const edgeGlow = uniform( 0.0 );
const edgeThickness = uniform( 1.0 );
const visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );
const hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );

outlinePass = outline( scene, camera, {
    selectedObjects,
    edgeGlow,
    edgeThickness
} );

// compose custom outline

const { visibleEdge, hiddenEdge } = outlinePass;
const outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );

postProcessing.outputNode = outlineColor.add( scenePass );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#outline">outline(scene, camera, params)</a> ⇒ <code><a href="#OutlineNode">OutlineNode</a></code></dt>
<dd><p>TSL function for creating an outline effect around selected objects.</p>
</dd>
</dl>

<a name="OutlineNode"></a>

## OutlineNode ⇐ <code>TempNode</code>
Post processing node for rendering outlines around selected objects. The node
gives you great flexibility in composing the final outline look depending on
your requirements.
```js
const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );

// outline parameter

const edgeStrength = uniform( 3.0 );
const edgeGlow = uniform( 0.0 );
const edgeThickness = uniform( 1.0 );
const visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );
const hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );

outlinePass = outline( scene, camera, {
	selectedObjects,
	edgeGlow,
	edgeThickness
} );

// compose custom outline

const { visibleEdge, hiddenEdge } = outlinePass;
const outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );

postProcessing.outputNode = outlineColor.add( scenePass );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [OutlineNode](#OutlineNode) ⇐ <code>TempNode</code>
    * [new OutlineNode(scene, camera, params)](#new_OutlineNode_new)
    * [.scene](#OutlineNode+scene) : <code>Scene</code>
    * [.camera](#OutlineNode+camera) : <code>Camera</code>
    * [.selectedObjects](#OutlineNode+selectedObjects) : <code>Array.&lt;Object3D&gt;</code>
    * [.edgeThicknessNode](#OutlineNode+edgeThicknessNode) : <code>Node.&lt;float&gt;</code>
    * [.edgeGlowNode](#OutlineNode+edgeGlowNode) : <code>Node.&lt;float&gt;</code>
    * [.downSampleRatio](#OutlineNode+downSampleRatio) : <code>number</code>
    * [.updateBeforeType](#OutlineNode+updateBeforeType) : <code>string</code>
    * [.visibleEdge](#OutlineNode+visibleEdge) ⇒ <code>Node.&lt;float&gt;</code>
    * [.hiddenEdge](#OutlineNode+hiddenEdge) ⇒ <code>Node.&lt;float&gt;</code>
    * [.getTextureNode()](#OutlineNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#OutlineNode+setSize)
    * [.updateBefore(frame)](#OutlineNode+updateBefore)
    * [.setup(builder)](#OutlineNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#OutlineNode+dispose)

<a name="new_OutlineNode_new"></a>

### new OutlineNode(scene, camera, params)
Constructs a new outline node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | A reference to the scene. |
| camera | <code>Camera</code> |  | The camera the scene is rendered with. |
| params | <code>Object</code> |  | The configuration parameters. |
| params.selectedObjects | <code>Array.&lt;Object3D&gt;</code> |  | An array of selected objects. |
| [params.edgeThickness] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The thickness of the edges. |
| [params.edgeGlow] | <code>Node.&lt;float&gt;</code> | <code>float(0)</code> | Can be used for an animated glow/pulse effects. |
| [params.downSampleRatio] | <code>number</code> | <code>2</code> | The downsample ratio. |

<a name="OutlineNode+scene"></a>

### outlineNode.scene : <code>Scene</code>
A reference to the scene.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+camera"></a>

### outlineNode.camera : <code>Camera</code>
The camera the scene is rendered with.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+selectedObjects"></a>

### outlineNode.selectedObjects : <code>Array.&lt;Object3D&gt;</code>
An array of selected objects.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+edgeThicknessNode"></a>

### outlineNode.edgeThicknessNode : <code>Node.&lt;float&gt;</code>
The thickness of the edges.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+edgeGlowNode"></a>

### outlineNode.edgeGlowNode : <code>Node.&lt;float&gt;</code>
Can be used for an animated glow/pulse effect.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+downSampleRatio"></a>

### outlineNode.downSampleRatio : <code>number</code>
The downsample ratio.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
**Default**: <code>2</code>  
<a name="OutlineNode+updateBeforeType"></a>

### outlineNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="OutlineNode+visibleEdge"></a>

### outlineNode.visibleEdge ⇒ <code>Node.&lt;float&gt;</code>
A mask value that represents the visible edge.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The visible edge.  
<a name="OutlineNode+hiddenEdge"></a>

### outlineNode.hiddenEdge ⇒ <code>Node.&lt;float&gt;</code>
A mask value that represents the hidden edge.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The hidden edge.  
<a name="OutlineNode+getTextureNode"></a>

### outlineNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="OutlineNode+setSize"></a>

### outlineNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="OutlineNode+updateBefore"></a>

### outlineNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="OutlineNode+setup"></a>

### outlineNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="OutlineNode+dispose"></a>

### outlineNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  
<a name="outline"></a>

## outline(scene, camera, params) ⇒ [<code>OutlineNode</code>](#OutlineNode)
TSL function for creating an outline effect around selected objects.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | A reference to the scene. |
| camera | <code>Camera</code> |  | The camera the scene is rendered with. |
| params | <code>Object</code> |  | The configuration parameters. |
| params.selectedObjects | <code>Array.&lt;Object3D&gt;</code> |  | An array of selected objects. |
| [params.edgeThickness] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The thickness of the edges. |
| [params.edgeGlow] | <code>Node.&lt;float&gt;</code> | <code>float(0)</code> | Can be used for animated glow/pulse effects. |
| [params.downSampleRatio] | <code>number</code> | <code>2</code> | The downsample ratio. |

## Classes

<dl>
<dt><a href="#ParallaxBarrierPassNode">ParallaxBarrierPassNode</a> ⇐ <code>StereoCompositePassNode</code></dt>
<dd><p>A render pass node that creates a parallax barrier effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#parallaxBarrierPass">parallaxBarrierPass(scene, camera)</a> ⇒ <code><a href="#ParallaxBarrierPassNode">ParallaxBarrierPassNode</a></code></dt>
<dd><p>TSL function for creating an parallax barrier pass node.</p>
</dd>
</dl>

<a name="ParallaxBarrierPassNode"></a>

## ParallaxBarrierPassNode ⇐ <code>StereoCompositePassNode</code>
A render pass node that creates a parallax barrier effect.

**Kind**: global class  
**Extends**: <code>StereoCompositePassNode</code>  

* [ParallaxBarrierPassNode](#ParallaxBarrierPassNode) ⇐ <code>StereoCompositePassNode</code>
    * [new ParallaxBarrierPassNode(scene, camera)](#new_ParallaxBarrierPassNode_new)
    * [.isParallaxBarrierPassNode](#ParallaxBarrierPassNode+isParallaxBarrierPassNode) : <code>boolean</code>
    * [.setup(builder)](#ParallaxBarrierPassNode+setup) ⇒ <code>PassTextureNode</code>

<a name="new_ParallaxBarrierPassNode_new"></a>

### new ParallaxBarrierPassNode(scene, camera)
Constructs a new parallax barrier pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="ParallaxBarrierPassNode+isParallaxBarrierPassNode"></a>

### parallaxBarrierPassNode.isParallaxBarrierPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ParallaxBarrierPassNode</code>](#ParallaxBarrierPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ParallaxBarrierPassNode+setup"></a>

### parallaxBarrierPassNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>ParallaxBarrierPassNode</code>](#ParallaxBarrierPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="parallaxBarrierPass"></a>

## parallaxBarrierPass(scene, camera) ⇒ [<code>ParallaxBarrierPassNode</code>](#ParallaxBarrierPassNode)
TSL function for creating an parallax barrier pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#PixelationNode">PixelationNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>A inner node definition that implements the actual pixelation TSL code.</p>
</dd>
<dt><a href="#PixelationPassNode">PixelationPassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>A special render pass node that renders the scene with a pixelation effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#pixelationPass">pixelationPass(scene, camera, [pixelSize], [normalEdgeStrength], [depthEdgeStrength])</a> ⇒ <code><a href="#PixelationPassNode">PixelationPassNode</a></code></dt>
<dd><p>TSL function for creating a pixelation render pass node for post processing.</p>
</dd>
</dl>

<a name="PixelationNode"></a>

## PixelationNode ⇐ <code>TempNode</code>
A inner node definition that implements the actual pixelation TSL code.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [PixelationNode](#PixelationNode) ⇐ <code>TempNode</code>
    * [new PixelationNode(textureNode, depthNode, normalNode, pixelSize, normalEdgeStrength, depthEdgeStrength)](#new_PixelationNode_new)
    * [.textureNode](#PixelationNode+textureNode) : <code>TextureNode</code>
    * [.depthNode](#PixelationNode+depthNode) : <code>TextureNode</code>
    * [.normalNode](#PixelationNode+normalNode) : <code>TextureNode</code>
    * [.pixelSize](#PixelationNode+pixelSize) : <code>Node.&lt;float&gt;</code>
    * [.normalEdgeStrength](#PixelationNode+normalEdgeStrength) : <code>Node.&lt;float&gt;</code>
    * [.depthEdgeStrength](#PixelationNode+depthEdgeStrength) : <code>Node.&lt;float&gt;</code>
    * [._resolution](#PixelationNode+_resolution) : <code>Node.&lt;vec4&gt;</code>
    * [.updateBeforeType](#PixelationNode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#PixelationNode+updateBefore)
    * [.setup(builder)](#PixelationNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_PixelationNode_new"></a>

### new PixelationNode(textureNode, depthNode, normalNode, pixelSize, normalEdgeStrength, depthEdgeStrength)
Constructs a new pixelation node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the beauty pass. |
| depthNode | <code>TextureNode</code> | The texture that represents the beauty's depth. |
| normalNode | <code>TextureNode</code> | The texture that represents the beauty's normals. |
| pixelSize | <code>Node.&lt;float&gt;</code> | The pixel size. |
| normalEdgeStrength | <code>Node.&lt;float&gt;</code> | The normal edge strength. |
| depthEdgeStrength | <code>Node.&lt;float&gt;</code> | The depth edge strength. |

<a name="PixelationNode+textureNode"></a>

### pixelationNode.textureNode : <code>TextureNode</code>
The texture node that represents the beauty pass.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+depthNode"></a>

### pixelationNode.depthNode : <code>TextureNode</code>
The texture that represents the beauty's depth.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+normalNode"></a>

### pixelationNode.normalNode : <code>TextureNode</code>
The texture that represents the beauty's normals.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+pixelSize"></a>

### pixelationNode.pixelSize : <code>Node.&lt;float&gt;</code>
The pixel size.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+normalEdgeStrength"></a>

### pixelationNode.normalEdgeStrength : <code>Node.&lt;float&gt;</code>
The pixel size.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+depthEdgeStrength"></a>

### pixelationNode.depthEdgeStrength : <code>Node.&lt;float&gt;</code>
The depth edge strength.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+_resolution"></a>

### pixelationNode.\_resolution : <code>Node.&lt;vec4&gt;</code>
Uniform node that represents the resolution.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+updateBeforeType"></a>

### pixelationNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="PixelationNode+updateBefore"></a>

### pixelationNode.updateBefore(frame)
This method is used to update uniforms once per frame.

**Kind**: instance method of [<code>PixelationNode</code>](#PixelationNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="PixelationNode+setup"></a>

### pixelationNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>PixelationNode</code>](#PixelationNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PixelationPassNode"></a>

## PixelationPassNode ⇐ <code>PassNode</code>
A special render pass node that renders the scene with a pixelation effect.

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [PixelationPassNode](#PixelationPassNode) ⇐ <code>PassNode</code>
    * [new PixelationPassNode(scene, camera, [pixelSize], [normalEdgeStrength], [depthEdgeStrength])](#new_PixelationPassNode_new)
    * [.pixelSize](#PixelationPassNode+pixelSize) : <code>number</code>
    * [.normalEdgeStrength](#PixelationPassNode+normalEdgeStrength) : <code>number</code>
    * [.depthEdgeStrength](#PixelationPassNode+depthEdgeStrength) : <code>number</code>
    * [.isPixelationPassNode](#PixelationPassNode+isPixelationPassNode) : <code>boolean</code>
    * [.setSize(width, height)](#PixelationPassNode+setSize)
    * [.setup(builder)](#PixelationPassNode+setup) ⇒ [<code>PixelationNode</code>](#PixelationNode)

<a name="new_PixelationPassNode_new"></a>

### new PixelationPassNode(scene, camera, [pixelSize], [normalEdgeStrength], [depthEdgeStrength])
Constructs a new pixelation pass node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera to render the scene with. |
| [pixelSize] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>6</code> | The pixel size. |
| [normalEdgeStrength] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.3</code> | The normal edge strength. |
| [depthEdgeStrength] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.4</code> | The depth edge strength. |

<a name="PixelationPassNode+pixelSize"></a>

### pixelationPassNode.pixelSize : <code>number</code>
The pixel size.

**Kind**: instance property of [<code>PixelationPassNode</code>](#PixelationPassNode)  
**Default**: <code>6</code>  
<a name="PixelationPassNode+normalEdgeStrength"></a>

### pixelationPassNode.normalEdgeStrength : <code>number</code>
The normal edge strength.

**Kind**: instance property of [<code>PixelationPassNode</code>](#PixelationPassNode)  
**Default**: <code>0.3</code>  
<a name="PixelationPassNode+depthEdgeStrength"></a>

### pixelationPassNode.depthEdgeStrength : <code>number</code>
The depth edge strength.

**Kind**: instance property of [<code>PixelationPassNode</code>](#PixelationPassNode)  
**Default**: <code>0.4</code>  
<a name="PixelationPassNode+isPixelationPassNode"></a>

### pixelationPassNode.isPixelationPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PixelationPassNode</code>](#PixelationPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PixelationPassNode+setSize"></a>

### pixelationPassNode.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>PixelationPassNode</code>](#PixelationPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the pass. |
| height | <code>number</code> | The height of the pass. |

<a name="PixelationPassNode+setup"></a>

### pixelationPassNode.setup(builder) ⇒ [<code>PixelationNode</code>](#PixelationNode)
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>PixelationPassNode</code>](#PixelationPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="pixelationPass"></a>

## pixelationPass(scene, camera, [pixelSize], [normalEdgeStrength], [depthEdgeStrength]) ⇒ [<code>PixelationPassNode</code>](#PixelationPassNode)
TSL function for creating a pixelation render pass node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera to render the scene with. |
| [pixelSize] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>6</code> | The pixel size. |
| [normalEdgeStrength] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.3</code> | The normal edge strength. |
| [depthEdgeStrength] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.4</code> | The depth edge strength. |

## Classes

<dl>
<dt><a href="#RGBShiftNode">RGBShiftNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for shifting/splitting RGB color channels. The effect
separates color channels and offsets them from each other.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#rgbShift">rgbShift(node, [amount], [angle])</a> ⇒ <code><a href="#RGBShiftNode">RGBShiftNode</a></code></dt>
<dd><p>TSL function for creating a RGB shift or split effect for post processing.</p>
</dd>
</dl>

<a name="RGBShiftNode"></a>

## RGBShiftNode ⇐ <code>TempNode</code>
Post processing node for shifting/splitting RGB color channels. The effect
separates color channels and offsets them from each other.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [RGBShiftNode](#RGBShiftNode) ⇐ <code>TempNode</code>
    * [new RGBShiftNode(textureNode, [amount], [angle])](#new_RGBShiftNode_new)
    * [.textureNode](#RGBShiftNode+textureNode) : <code>TextureNode</code>
    * [.amount](#RGBShiftNode+amount) : <code>UniformNode.&lt;float&gt;</code>
    * [.angle](#RGBShiftNode+angle) : <code>UniformNode.&lt;float&gt;</code>
    * [.setup(builder)](#RGBShiftNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_RGBShiftNode_new"></a>

### new RGBShiftNode(textureNode, [amount], [angle])
Constructs a new RGB shift node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that represents the input of the effect. |
| [amount] | <code>number</code> | <code>0.005</code> | The amount of the RGB shift. |
| [angle] | <code>number</code> | <code>0</code> | Defines the orientation in which colors are shifted. |

<a name="RGBShiftNode+textureNode"></a>

### rgbShiftNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>RGBShiftNode</code>](#RGBShiftNode)  
<a name="RGBShiftNode+amount"></a>

### rgbShiftNode.amount : <code>UniformNode.&lt;float&gt;</code>
The amount of the RGB shift.

**Kind**: instance property of [<code>RGBShiftNode</code>](#RGBShiftNode)  
<a name="RGBShiftNode+angle"></a>

### rgbShiftNode.angle : <code>UniformNode.&lt;float&gt;</code>
Defines in which direction colors are shifted.

**Kind**: instance property of [<code>RGBShiftNode</code>](#RGBShiftNode)  
<a name="RGBShiftNode+setup"></a>

### rgbShiftNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>RGBShiftNode</code>](#RGBShiftNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="rgbShift"></a>

## rgbShift(node, [amount], [angle]) ⇒ [<code>RGBShiftNode</code>](#RGBShiftNode)
TSL function for creating a RGB shift or split effect for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [amount] | <code>number</code> | <code>0.005</code> | The amount of the RGB shift. |
| [angle] | <code>number</code> | <code>0</code> | Defines in which direction colors are shifted. |

## Classes

<dl>
<dt><a href="#SMAANode">SMAANode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for applying SMAA. Unlike FXAA, this node
should be applied before converting colors to sRGB. SMAA should produce
better results than FXAA but is also more expensive to execute.</p>
<p>Used Preset: SMAA 1x Medium (with color edge detection)
Reference: <a href="https://github.com/iryoku/smaa/releases/tag/v2.8">https://github.com/iryoku/smaa/releases/tag/v2.8</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#smaa">smaa(node)</a> ⇒ <code><a href="#SMAANode">SMAANode</a></code></dt>
<dd><p>TSL function for creating a SMAA node for anti-aliasing via post processing.</p>
</dd>
</dl>

<a name="SMAANode"></a>

## SMAANode ⇐ <code>TempNode</code>
Post processing node for applying SMAA. Unlike FXAA, this node
should be applied before converting colors to sRGB. SMAA should produce
better results than FXAA but is also more expensive to execute.

Used Preset: SMAA 1x Medium (with color edge detection)
Reference: [https://github.com/iryoku/smaa/releases/tag/v2.8](https://github.com/iryoku/smaa/releases/tag/v2.8).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [SMAANode](#SMAANode) ⇐ <code>TempNode</code>
    * [new SMAANode(textureNode)](#new_SMAANode_new)
    * [.textureNode](#SMAANode+textureNode) : <code>TextureNode</code>
    * [.updateBeforeType](#SMAANode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#SMAANode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#SMAANode+setSize)
    * [.updateBefore(frame)](#SMAANode+updateBefore)
    * [.setup(builder)](#SMAANode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#SMAANode+dispose)

<a name="new_SMAANode_new"></a>

### new SMAANode(textureNode)
Constructs a new SMAA node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |

<a name="SMAANode+textureNode"></a>

### smaaNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>SMAANode</code>](#SMAANode)  
<a name="SMAANode+updateBeforeType"></a>

### smaaNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>SMAANode</code>](#SMAANode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="SMAANode+getTextureNode"></a>

### smaaNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="SMAANode+setSize"></a>

### smaaNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="SMAANode+updateBefore"></a>

### smaaNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="SMAANode+setup"></a>

### smaaNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SMAANode+dispose"></a>

### smaaNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  
<a name="smaa"></a>

## smaa(node) ⇒ [<code>SMAANode</code>](#SMAANode)
TSL function for creating a SMAA node for anti-aliasing via post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |

## Classes

<dl>
<dt><a href="#SSAAPassNode">SSAAPassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>A special render pass node that renders the scene with SSAA (Supersampling Anti-Aliasing).
This manual SSAA approach re-renders the scene ones for each sample with camera jitter and accumulates the results.</p>
<p>This node produces a high-quality anti-aliased output but is also extremely expensive because of
its brute-force approach of re-rendering the entire scene multiple times.</p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Supersampling">https://en.wikipedia.org/wiki/Supersampling</a></p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#ssaaPass">ssaaPass(scene, camera)</a> ⇒ <code><a href="#SSAAPassNode">SSAAPassNode</a></code></dt>
<dd><p>TSL function for creating a SSAA pass node for Supersampling Anti-Aliasing.</p>
</dd>
</dl>

<a name="SSAAPassNode"></a>

## SSAAPassNode ⇐ <code>PassNode</code>
A special render pass node that renders the scene with SSAA (Supersampling Anti-Aliasing).
This manual SSAA approach re-renders the scene ones for each sample with camera jitter and accumulates the results.

This node produces a high-quality anti-aliased output but is also extremely expensive because of
its brute-force approach of re-rendering the entire scene multiple times.

Reference: [https://en.wikipedia.org/wiki/Supersampling](https://en.wikipedia.org/wiki/Supersampling)

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [SSAAPassNode](#SSAAPassNode) ⇐ <code>PassNode</code>
    * [new SSAAPassNode(scene, camera)](#new_SSAAPassNode_new)
    * [.isSSAAPassNode](#SSAAPassNode+isSSAAPassNode) : <code>boolean</code>
    * [.sampleLevel](#SSAAPassNode+sampleLevel) : <code>number</code>
    * [.unbiased](#SSAAPassNode+unbiased) : <code>boolean</code>
    * [.clearColor](#SSAAPassNode+clearColor) : <code>Color</code>
    * [.clearAlpha](#SSAAPassNode+clearAlpha) : <code>number</code>
    * [.sampleWeight](#SSAAPassNode+sampleWeight) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateBefore(frame)](#SSAAPassNode+updateBefore)
    * [.setup(builder)](#SSAAPassNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#SSAAPassNode+dispose)

<a name="new_SSAAPassNode_new"></a>

### new SSAAPassNode(scene, camera)
Constructs a new SSAA pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="SSAAPassNode+isSSAAPassNode"></a>

### ssaaPassNode.isSSAAPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SSAAPassNode+sampleLevel"></a>

### ssaaPassNode.sampleLevel : <code>number</code>
The sample level specified  as n, where the number of samples is 2^n,
so sampleLevel = 4, is 2^4 samples, 16.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>4</code>  
<a name="SSAAPassNode+unbiased"></a>

### ssaaPassNode.unbiased : <code>boolean</code>
Whether rounding errors should be mitigated or not.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>true</code>  
<a name="SSAAPassNode+clearColor"></a>

### ssaaPassNode.clearColor : <code>Color</code>
The clear color of the pass.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>0x000000</code>  
<a name="SSAAPassNode+clearAlpha"></a>

### ssaaPassNode.clearAlpha : <code>number</code>
The clear alpha of the pass.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>0</code>  
<a name="SSAAPassNode+sampleWeight"></a>

### ssaaPassNode.sampleWeight : <code>UniformNode.&lt;float&gt;</code>
A uniform node representing the sample weight.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>1</code>  
<a name="SSAAPassNode+updateBefore"></a>

### ssaaPassNode.updateBefore(frame)
This method is used to render the SSAA effect once per frame.

**Kind**: instance method of [<code>SSAAPassNode</code>](#SSAAPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="SSAAPassNode+setup"></a>

### ssaaPassNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's MRT configuration and quad mesh.

**Kind**: instance method of [<code>SSAAPassNode</code>](#SSAAPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SSAAPassNode+dispose"></a>

### ssaaPassNode.dispose()
Frees internal resources. This method should be called
when the pass is no longer required.

**Kind**: instance method of [<code>SSAAPassNode</code>](#SSAAPassNode)  
<a name="ssaaPass"></a>

## ssaaPass(scene, camera) ⇒ [<code>SSAAPassNode</code>](#SSAAPassNode)
TSL function for creating a SSAA pass node for Supersampling Anti-Aliasing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#SSRNode">SSRNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for computing screen space reflections (SSR).</p>
<p>Reference: <a href="https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html">https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html</a></p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#ssr">ssr(colorNode, depthNode, normalNode, metalnessNode, camera)</a> ⇒ <code><a href="#SSRNode">SSRNode</a></code></dt>
<dd><p>TSL function for creating screen space reflections (SSR).</p>
</dd>
</dl>

<a name="SSRNode"></a>

## SSRNode ⇐ <code>TempNode</code>
Post processing node for computing screen space reflections (SSR).

Reference: [https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html](https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html)

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [SSRNode](#SSRNode) ⇐ <code>TempNode</code>
    * [new SSRNode(colorNode, depthNode, normalNode, metalnessNode, camera)](#new_SSRNode_new)
    * [.colorNode](#SSRNode+colorNode) : <code>Node.&lt;vec4&gt;</code>
    * [.depthNode](#SSRNode+depthNode) : <code>Node.&lt;float&gt;</code>
    * [.normalNode](#SSRNode+normalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.metalnessNode](#SSRNode+metalnessNode) : <code>Node.&lt;float&gt;</code>
    * [.camera](#SSRNode+camera) : <code>Camera</code>
    * [.resolutionScale](#SSRNode+resolutionScale) : <code>number</code>
    * [.updateBeforeType](#SSRNode+updateBeforeType) : <code>string</code>
    * [.maxDistance](#SSRNode+maxDistance) : <code>UniformNode.&lt;float&gt;</code>
    * [.thickness](#SSRNode+thickness) : <code>UniformNode.&lt;float&gt;</code>
    * [.opacity](#SSRNode+opacity) : <code>UniformNode.&lt;float&gt;</code>
    * [.getTextureNode()](#SSRNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#SSRNode+setSize)
    * [.updateBefore(frame)](#SSRNode+updateBefore)
    * [.setup(builder)](#SSRNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#SSRNode+dispose)

<a name="new_SSRNode_new"></a>

### new SSRNode(colorNode, depthNode, normalNode, metalnessNode, camera)
Constructs a new SSR node.


| Param | Type | Description |
| --- | --- | --- |
| colorNode | <code>Node.&lt;vec4&gt;</code> | The node that represents the beauty pass. |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the beauty pass's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the beauty pass's normals. |
| metalnessNode | <code>Node.&lt;float&gt;</code> | A node that represents the beauty pass's metalness. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="SSRNode+colorNode"></a>

### ssrNode.colorNode : <code>Node.&lt;vec4&gt;</code>
The node that represents the beauty pass.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+depthNode"></a>

### ssrNode.depthNode : <code>Node.&lt;float&gt;</code>
A node that represents the beauty pass's depth.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+normalNode"></a>

### ssrNode.normalNode : <code>Node.&lt;vec3&gt;</code>
A node that represents the beauty pass's normals.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+metalnessNode"></a>

### ssrNode.metalnessNode : <code>Node.&lt;float&gt;</code>
A node that represents the beauty pass's metalness.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+camera"></a>

### ssrNode.camera : <code>Camera</code>
The camera the scene is rendered with.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+resolutionScale"></a>

### ssrNode.resolutionScale : <code>number</code>
The resolution scale. By default SSR reflections
are computed in half resolutions. Setting the value
to `1` improves quality but also results in more
computational overhead.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
**Default**: <code>0.5</code>  
<a name="SSRNode+updateBeforeType"></a>

### ssrNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="SSRNode+maxDistance"></a>

### ssrNode.maxDistance : <code>UniformNode.&lt;float&gt;</code>
Controls how far a fragment can reflect.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+thickness"></a>

### ssrNode.thickness : <code>UniformNode.&lt;float&gt;</code>
Controls the cutoff between what counts as a possible reflection hit and what does not.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+opacity"></a>

### ssrNode.opacity : <code>UniformNode.&lt;float&gt;</code>
Controls the transparency of the reflected colors.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+getTextureNode"></a>

### ssrNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="SSRNode+setSize"></a>

### ssrNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="SSRNode+updateBefore"></a>

### ssrNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="SSRNode+setup"></a>

### ssrNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SSRNode+dispose"></a>

### ssrNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  
<a name="ssr"></a>

## ssr(colorNode, depthNode, normalNode, metalnessNode, camera) ⇒ [<code>SSRNode</code>](#SSRNode)
TSL function for creating screen space reflections (SSR).

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| colorNode | <code>Node.&lt;vec4&gt;</code> | The node that represents the beauty pass. |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the beauty pass's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the beauty pass's normals. |
| metalnessNode | <code>Node.&lt;float&gt;</code> | A node that represents the beauty pass's metalness. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="sepia"></a>

## sepia(color) ⇒ <code>Node.&lt;vec4&gt;</code>
Applies a sepia effect to the given color node.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The updated color node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec4&gt;</code> | The color node to apply the sepia for. |

## Classes

<dl>
<dt><a href="#SobelOperatorNode">SobelOperatorNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for detecting edges with a sobel filter.
A sobel filter should be applied after tone mapping and output color
space conversion.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#sobel">sobel(node)</a> ⇒ <code><a href="#SobelOperatorNode">SobelOperatorNode</a></code></dt>
<dd><p>TSL function for creating a sobel operator node which performs edge detection with a sobel filter.</p>
</dd>
</dl>

<a name="SobelOperatorNode"></a>

## SobelOperatorNode ⇐ <code>TempNode</code>
Post processing node for detecting edges with a sobel filter.
A sobel filter should be applied after tone mapping and output color
space conversion.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [SobelOperatorNode](#SobelOperatorNode) ⇐ <code>TempNode</code>
    * [new SobelOperatorNode(textureNode)](#new_SobelOperatorNode_new)
    * [.textureNode](#SobelOperatorNode+textureNode) : <code>TextureNode</code>
    * [.updateBeforeType](#SobelOperatorNode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#SobelOperatorNode+updateBefore)
    * [.setup(builder)](#SobelOperatorNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_SobelOperatorNode_new"></a>

### new SobelOperatorNode(textureNode)
Constructs a new sobel operator node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |

<a name="SobelOperatorNode+textureNode"></a>

### sobelOperatorNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>SobelOperatorNode</code>](#SobelOperatorNode)  
<a name="SobelOperatorNode+updateBeforeType"></a>

### sobelOperatorNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>SobelOperatorNode</code>](#SobelOperatorNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="SobelOperatorNode+updateBefore"></a>

### sobelOperatorNode.updateBefore(frame)
This method is used to update the effect's uniforms once per frame.

**Kind**: instance method of [<code>SobelOperatorNode</code>](#SobelOperatorNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="SobelOperatorNode+setup"></a>

### sobelOperatorNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>SobelOperatorNode</code>](#SobelOperatorNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="sobel"></a>

## sobel(node) ⇒ [<code>SobelOperatorNode</code>](#SobelOperatorNode)
TSL function for creating a sobel operator node which performs edge detection with a sobel filter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |

<a name="StereoCompositePassNode"></a>

## *StereoCompositePassNode ⇐ <code>PassNode</code>*
A special (abstract) render pass node that renders the scene
as a stereoscopic image. Unlike [StereoPassNode](StereoPassNode), this
node merges the image for the left and right eye
into a single one. That is required for effects like
anaglyph or parallax barrier.

**Kind**: global abstract class  
**Extends**: <code>PassNode</code>  

* *[StereoCompositePassNode](#StereoCompositePassNode) ⇐ <code>PassNode</code>*
    * *[new StereoCompositePassNode(scene, camera)](#new_StereoCompositePassNode_new)*
    * *[.isStereoCompositePassNode](#StereoCompositePassNode+isStereoCompositePassNode) : <code>boolean</code>*
    * *[.stereo](#StereoCompositePassNode+stereo) : <code>StereoCamera</code>*
    * *[._renderTargetL](#StereoCompositePassNode+_renderTargetL) : <code>RenderTarget</code>*
    * *[._renderTargetR](#StereoCompositePassNode+_renderTargetR) : <code>RenderTarget</code>*
    * *[._mapLeft](#StereoCompositePassNode+_mapLeft) : <code>TextureNode</code>*
    * *[._mapRight](#StereoCompositePassNode+_mapRight) : <code>TextureNode</code>*
    * *[._material](#StereoCompositePassNode+_material) : <code>NodeMaterial</code>*
    * *[.updateStereoCamera(coordinateSystem)](#StereoCompositePassNode+updateStereoCamera)*
    * *[.setSize(width, height)](#StereoCompositePassNode+setSize)*
    * *[.updateBefore(frame)](#StereoCompositePassNode+updateBefore)*
    * *[.dispose()](#StereoCompositePassNode+dispose)*

<a name="new_StereoCompositePassNode_new"></a>

### *new StereoCompositePassNode(scene, camera)*
Constructs a new stereo composite pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="StereoCompositePassNode+isStereoCompositePassNode"></a>

### *stereoCompositePassNode.isStereoCompositePassNode : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StereoCompositePassNode+stereo"></a>

### *stereoCompositePassNode.stereo : <code>StereoCamera</code>*
The internal stereo camera that is used to render the scene.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_renderTargetL"></a>

### *stereoCompositePassNode.\_renderTargetL : <code>RenderTarget</code>*
The render target for rendering the left eye's view.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_renderTargetR"></a>

### *stereoCompositePassNode.\_renderTargetR : <code>RenderTarget</code>*
The render target for rendering the right eye's view.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_mapLeft"></a>

### *stereoCompositePassNode.\_mapLeft : <code>TextureNode</code>*
A texture node representing the left's eye view.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_mapRight"></a>

### *stereoCompositePassNode.\_mapRight : <code>TextureNode</code>*
A texture node representing the right's eye view.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_material"></a>

### *stereoCompositePassNode.\_material : <code>NodeMaterial</code>*
The node material that implements the composite. All
derived effect passes must provide an instance for rendering.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+updateStereoCamera"></a>

### *stereoCompositePassNode.updateStereoCamera(coordinateSystem)*
Updates the internal stereo camera.

**Kind**: instance method of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  

| Param | Type | Description |
| --- | --- | --- |
| coordinateSystem | <code>number</code> | The current coordinate system. |

<a name="StereoCompositePassNode+setSize"></a>

### *stereoCompositePassNode.setSize(width, height)*
Sets the size of the pass.

**Kind**: instance method of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the pass. |
| height | <code>number</code> | The height of the pass. |

<a name="StereoCompositePassNode+updateBefore"></a>

### *stereoCompositePassNode.updateBefore(frame)*
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="StereoCompositePassNode+dispose"></a>

### *stereoCompositePassNode.dispose()*
Frees internal resources. This method should be called
when the pass is no longer required.

**Kind**: instance method of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
## Classes

<dl>
<dt><a href="#StereoPassNode">StereoPassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>A special render pass node that renders the scene as a stereoscopic image.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#stereoPass">stereoPass(scene, camera)</a> ⇒ <code><a href="#StereoPassNode">StereoPassNode</a></code></dt>
<dd><p>TSL function for creating a stereo pass node for stereoscopic rendering.</p>
</dd>
</dl>

<a name="StereoPassNode"></a>

## StereoPassNode ⇐ <code>PassNode</code>
A special render pass node that renders the scene as a stereoscopic image.

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [StereoPassNode](#StereoPassNode) ⇐ <code>PassNode</code>
    * [new StereoPassNode(scene, camera)](#new_StereoPassNode_new)
    * [.isStereoPassNode](#StereoPassNode+isStereoPassNode) : <code>boolean</code>
    * [.stereo](#StereoPassNode+stereo) : <code>StereoCamera</code>
    * [.updateBefore(frame)](#StereoPassNode+updateBefore)

<a name="new_StereoPassNode_new"></a>

### new StereoPassNode(scene, camera)
Constructs a new stereo pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="StereoPassNode+isStereoPassNode"></a>

### stereoPassNode.isStereoPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StereoPassNode</code>](#StereoPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StereoPassNode+stereo"></a>

### stereoPassNode.stereo : <code>StereoCamera</code>
The internal stereo camera that is used to render the scene.

**Kind**: instance property of [<code>StereoPassNode</code>](#StereoPassNode)  
<a name="StereoPassNode+updateBefore"></a>

### stereoPassNode.updateBefore(frame)
This method is used to render the stereo effect once per frame.

**Kind**: instance method of [<code>StereoPassNode</code>](#StereoPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="stereoPass"></a>

## stereoPass(scene, camera) ⇒ [<code>StereoPassNode</code>](#StereoPassNode)
TSL function for creating a stereo pass node for stereoscopic rendering.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#TRAAPassNode">TRAAPassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>A special render pass node that renders the scene with TRAA (Temporal Reprojection Anti-Aliasing).</p>
<p>Note: The current implementation does not yet support MRT setups.</p>
<p>References:</p>
<ul>
<li><a href="https://alextardif.com/TAA.html">https://alextardif.com/TAA.html</a></li>
<li><a href="https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/">https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/</a></li>
</ul>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#traaPass">traaPass(scene, camera)</a> ⇒ <code><a href="#TRAAPassNode">TRAAPassNode</a></code></dt>
<dd><p>TSL function for creating a TRAA pass node for Temporal Reprojection Anti-Aliasing.</p>
</dd>
</dl>

<a name="TRAAPassNode"></a>

## TRAAPassNode ⇐ <code>PassNode</code>
A special render pass node that renders the scene with TRAA (Temporal Reprojection Anti-Aliasing).

Note: The current implementation does not yet support MRT setups.

References:
- [https://alextardif.com/TAA.html](https://alextardif.com/TAA.html)
- [https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/](https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/)

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [TRAAPassNode](#TRAAPassNode) ⇐ <code>PassNode</code>
    * [new TRAAPassNode(scene, camera)](#new_TRAAPassNode_new)
    * [.isTRAAPassNode](#TRAAPassNode+isTRAAPassNode) : <code>boolean</code>
    * [.clearColor](#TRAAPassNode+clearColor) : <code>Color</code>
    * [.clearAlpha](#TRAAPassNode+clearAlpha) : <code>number</code>
    * [.setSize(width, height)](#TRAAPassNode+setSize) ⇒ <code>boolean</code>
    * [.updateBefore(frame)](#TRAAPassNode+updateBefore)
    * [.setup(builder)](#TRAAPassNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#TRAAPassNode+dispose)

<a name="new_TRAAPassNode_new"></a>

### new TRAAPassNode(scene, camera)
Constructs a new TRAA pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="TRAAPassNode+isTRAAPassNode"></a>

### traaPassNode.isTRAAPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>TRAAPassNode</code>](#TRAAPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TRAAPassNode+clearColor"></a>

### traaPassNode.clearColor : <code>Color</code>
The clear color of the pass.

**Kind**: instance property of [<code>TRAAPassNode</code>](#TRAAPassNode)  
**Default**: <code>0x000000</code>  
<a name="TRAAPassNode+clearAlpha"></a>

### traaPassNode.clearAlpha : <code>number</code>
The clear alpha of the pass.

**Kind**: instance property of [<code>TRAAPassNode</code>](#TRAAPassNode)  
**Default**: <code>0</code>  
<a name="TRAAPassNode+setSize"></a>

### traaPassNode.setSize(width, height) ⇒ <code>boolean</code>
Sets the size of the effect.

**Kind**: instance method of [<code>TRAAPassNode</code>](#TRAAPassNode)  
**Returns**: <code>boolean</code> - Whether the TRAA needs a restart or not. That is required after a resize since buffer data with different sizes can't be resolved.  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="TRAAPassNode+updateBefore"></a>

### traaPassNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>TRAAPassNode</code>](#TRAAPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="TRAAPassNode+setup"></a>

### traaPassNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's render targets and TSL code.

**Kind**: instance method of [<code>TRAAPassNode</code>](#TRAAPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TRAAPassNode+dispose"></a>

### traaPassNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>TRAAPassNode</code>](#TRAAPassNode)  
<a name="traaPass"></a>

## traaPass(scene, camera) ⇒ [<code>TRAAPassNode</code>](#TRAAPassNode)
TSL function for creating a TRAA pass node for Temporal Reprojection Anti-Aliasing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#TransitionNode">TransitionNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating a transition effect between scenes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#transition">transition(nodeA, nodeB, mixTextureNode, mixRatio, threshold, useTexture)</a> ⇒ <code><a href="#TransitionNode">TransitionNode</a></code></dt>
<dd><p>TSL function for creating a transition node for post processing.</p>
</dd>
</dl>

<a name="TransitionNode"></a>

## TransitionNode ⇐ <code>TempNode</code>
Post processing node for creating a transition effect between scenes.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [TransitionNode](#TransitionNode) ⇐ <code>TempNode</code>
    * [new TransitionNode(textureNodeA, textureNodeB, mixTextureNode, mixRatioNode, thresholdNode, useTextureNode)](#new_TransitionNode_new)
    * [.textureNodeA](#TransitionNode+textureNodeA) : <code>TextureNode</code>
    * [.textureNodeB](#TransitionNode+textureNodeB) : <code>TextureNode</code>
    * [.mixTextureNode](#TransitionNode+mixTextureNode) : <code>TextureNode</code>
    * [.mixRatioNode](#TransitionNode+mixRatioNode) : <code>Node.&lt;float&gt;</code>
    * [.thresholdNode](#TransitionNode+thresholdNode) : <code>Node.&lt;float&gt;</code>
    * [.useTextureNode](#TransitionNode+useTextureNode) : <code>Node.&lt;float&gt;</code>
    * [.setup(builder)](#TransitionNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_TransitionNode_new"></a>

### new TransitionNode(textureNodeA, textureNodeB, mixTextureNode, mixRatioNode, thresholdNode, useTextureNode)
Constructs a new transition node.


| Param | Type | Description |
| --- | --- | --- |
| textureNodeA | <code>TextureNode</code> | A texture node that represents the beauty pass of the first scene. |
| textureNodeB | <code>TextureNode</code> | A texture node that represents the beauty pass of the second scene. |
| mixTextureNode | <code>TextureNode</code> | A texture node that defines how the transition effect should look like. |
| mixRatioNode | <code>Node.&lt;float&gt;</code> | The interpolation factor that controls the mix. |
| thresholdNode | <code>Node.&lt;float&gt;</code> | Can be used to tweak the linear interpolation. |
| useTextureNode | <code>Node.&lt;float&gt;</code> | Whether `mixTextureNode` should influence the transition or not. |

<a name="TransitionNode+textureNodeA"></a>

### transitionNode.textureNodeA : <code>TextureNode</code>
A texture node that represents the beauty pass of the first scene.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+textureNodeB"></a>

### transitionNode.textureNodeB : <code>TextureNode</code>
A texture node that represents the beauty pass of the second scene.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+mixTextureNode"></a>

### transitionNode.mixTextureNode : <code>TextureNode</code>
A texture that defines how the transition effect should look like.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+mixRatioNode"></a>

### transitionNode.mixRatioNode : <code>Node.&lt;float&gt;</code>
The interpolation factor that controls the mix.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+thresholdNode"></a>

### transitionNode.thresholdNode : <code>Node.&lt;float&gt;</code>
Can be used to tweak the linear interpolation.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+useTextureNode"></a>

### transitionNode.useTextureNode : <code>Node.&lt;float&gt;</code>
Whether `mixTextureNode` should influence the transition or not.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+setup"></a>

### transitionNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>TransitionNode</code>](#TransitionNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="transition"></a>

## transition(nodeA, nodeB, mixTextureNode, mixRatio, threshold, useTexture) ⇒ [<code>TransitionNode</code>](#TransitionNode)
TSL function for creating a transition node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| nodeA | <code>Node.&lt;vec4&gt;</code> | A texture node that represents the beauty pass of the first scene. |
| nodeB | <code>Node.&lt;vec4&gt;</code> | A texture node that represents the beauty pass of the second scene. |
| mixTextureNode | <code>Node.&lt;vec4&gt;</code> | A texture that defines how the transition effect should look like. |
| mixRatio | <code>Node.&lt;float&gt;</code> \| <code>number</code> | The interpolation factor that controls the mix. |
| threshold | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Can be used to tweak the linear interpolation. |
| useTexture | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Whether `mixTextureNode` should influence the transition or not. |

<a name="hashBlur"></a>

## hashBlur(textureNode, [bluramount], [repeats]) ⇒ <code>Node.&lt;vec4&gt;</code>
Applies a hash blur effect to the given texture node.

Reference: [https://www.shadertoy.com/view/4lXXWn](https://www.shadertoy.com/view/4lXXWn).

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The blurred texture node.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>Node.&lt;vec4&gt;</code> |  | The texture node that should be blurred. |
| [bluramount] | <code>Node.&lt;float&gt;</code> | <code>float(0.1)</code> | This node determines the amount of blur. |
| [repeats] | <code>Node.&lt;float&gt;</code> | <code>float(45)</code> | This node determines the quality of the blur. A higher value produces a less grainy result but is also more expensive. |

<a name="TiledLightsNode"></a>

## TiledLightsNode ⇐ <code>LightsNode</code>
A custom version of `LightsNode` implementing tiled lighting. This node is used in
[TiledLighting](TiledLighting) to overwrite the renderer's default lighting with
a custom implementation.

**Kind**: global class  
**Extends**: <code>LightsNode</code>  

* [TiledLightsNode](#TiledLightsNode) ⇐ <code>LightsNode</code>
    * [new TiledLightsNode([maxLights], [tileSize])](#new_TiledLightsNode_new)
    * [.maxLights](#TiledLightsNode+maxLights) : <code>number</code>
    * [.tileSize](#TiledLightsNode+tileSize) : <code>number</code>

<a name="new_TiledLightsNode_new"></a>

### new TiledLightsNode([maxLights], [tileSize])
Constructs a new tiled lights node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [maxLights] | <code>number</code> | <code>1024</code> | The maximum number of lights. |
| [tileSize] | <code>number</code> | <code>32</code> | The tile size. |

<a name="TiledLightsNode+maxLights"></a>

### tiledLightsNode.maxLights : <code>number</code>
The maximum number of lights.

**Kind**: instance property of [<code>TiledLightsNode</code>](#TiledLightsNode)  
**Default**: <code>1024</code>  
<a name="TiledLightsNode+tileSize"></a>

### tiledLightsNode.tileSize : <code>number</code>
The tile size.

**Kind**: instance property of [<code>TiledLightsNode</code>](#TiledLightsNode)  
**Default**: <code>32</code>  
<a name="module_Bayer"></a>

## Bayer
<a name="module_Bayer.bayer16"></a>

### Bayer.bayer16(uv) ⇒ <code>Node.&lt;vec4&gt;</code>
This TSL function can be used to sample a Bayer16 texture which is a 16x16 texture with a Bayer Matrix pattern.
It can be used for dithering effects but also as an alternative to blue-noise. When used with Ray Marching
specifically in [VolumeNodeMaterial#offsetNode](VolumeNodeMaterial#offsetNode), it reduces banding problem, thus being able to use
fewer steps without affecting the visuals as much.

**Kind**: static method of [<code>Bayer</code>](#module_Bayer)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The sampled bayer value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The uv to sample the bayer16 texture. |

<a name="module_Raymarching"></a>

## Raymarching
<a name="module_Raymarching.RaymarchingBox"></a>

### Raymarching.RaymarchingBox(steps, callback)
TSL function for performing raymarching in a box-area using the specified number of steps
and a callback function.

```js
RaymarchingBox( count, ( { positionRay } ) => {

} );
```

**Kind**: static method of [<code>Raymarching</code>](#module_Raymarching)  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| steps | <code>number</code> \| <code>Node</code> | The number of steps for raymarching. |
| callback | <code>function</code> \| <code>FunctionNode</code> | The callback function to execute at each step. |

<a name="module_BufferGeometryUtils"></a>

## BufferGeometryUtils

* [BufferGeometryUtils](#module_BufferGeometryUtils)
    * [~computeMikkTSpaceTangents(geometry, MikkTSpace, [negateSign])](#module_BufferGeometryUtils..computeMikkTSpaceTangents) ⇒ <code>BufferGeometry</code>
    * [~mergeGeometries(geometries, [useGroups])](#module_BufferGeometryUtils..mergeGeometries) ⇒ <code>BufferGeometry</code>
    * [~mergeAttributes(attributes)](#module_BufferGeometryUtils..mergeAttributes) ⇒ <code>BufferAttribute</code>
    * [~deepCloneAttribute(attribute)](#module_BufferGeometryUtils..deepCloneAttribute) ⇒ <code>BufferAttribute</code>
    * [~interleaveAttributes(attributes)](#module_BufferGeometryUtils..interleaveAttributes) ⇒ <code>Array.&lt;InterleavedBufferAttribute&gt;</code>
    * [~deinterleaveAttribute(attribute)](#module_BufferGeometryUtils..deinterleaveAttribute) ⇒ <code>BufferAttribute</code>
    * [~deinterleaveGeometry(geometry)](#module_BufferGeometryUtils..deinterleaveGeometry)
    * [~estimateBytesUsed(geometry)](#module_BufferGeometryUtils..estimateBytesUsed) ⇒ <code>number</code>
    * [~mergeVertices(geometry, [tolerance])](#module_BufferGeometryUtils..mergeVertices) ⇒ <code>BufferGeometry</code>
    * [~toTrianglesDrawMode(geometry, drawMode)](#module_BufferGeometryUtils..toTrianglesDrawMode) ⇒ <code>BufferGeometry</code>
    * [~computeMorphedAttributes(object)](#module_BufferGeometryUtils..computeMorphedAttributes) ⇒ <code>Object</code>
    * [~mergeGroups(geometry)](#module_BufferGeometryUtils..mergeGroups) ⇒ <code>BufferGeometry</code>
    * [~toCreasedNormals(geometry, [creaseAngle])](#module_BufferGeometryUtils..toCreasedNormals) ⇒ <code>BufferGeometry</code>

<a name="module_BufferGeometryUtils..computeMikkTSpaceTangents"></a>

### BufferGeometryUtils~computeMikkTSpaceTangents(geometry, MikkTSpace, [negateSign]) ⇒ <code>BufferGeometry</code>
Computes vertex tangents using the MikkTSpace algorithm. MikkTSpace generates the same tangents consistently,
and is used in most modelling tools and normal map bakers. Use MikkTSpace for materials with normal maps,
because inconsistent tangents may lead to subtle visual issues in the normal map, particularly around mirrored
UV seams.

In comparison to this method, [BufferGeometry#computeTangents](BufferGeometry#computeTangents) (a custom algorithm) generates tangents that
probably will not match the tangents in other software. The custom algorithm is sufficient for general use with a
custom material, and may be faster than MikkTSpace.

Returns the original BufferGeometry. Indexed geometries will be de-indexed. Requires position, normal, and uv attributes.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - The updated geometry.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to compute tangents for. |
| MikkTSpace | <code>Object</code> |  | Instance of `examples/jsm/libs/mikktspace.module.js`, or `mikktspace` npm package. Await `MikkTSpace.ready` before use. |
| [negateSign] | <code>boolean</code> | <code>true</code> | Whether to negate the sign component (.w) of each tangent. Required for normal map conventions in some formats, including glTF. |

<a name="module_BufferGeometryUtils..mergeGeometries"></a>

### BufferGeometryUtils~mergeGeometries(geometries, [useGroups]) ⇒ <code>BufferGeometry</code>
Merges a set of geometries into a single instance. All geometries must have compatible attributes.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - The merged geometry. Returns `null` if the merge does not succeed.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometries | <code>Array.&lt;BufferGeometry&gt;</code> |  | The geometries to merge. |
| [useGroups] | <code>boolean</code> | <code>false</code> | Whether to use groups or not. |

<a name="module_BufferGeometryUtils..mergeAttributes"></a>

### BufferGeometryUtils~mergeAttributes(attributes) ⇒ <code>BufferAttribute</code>
Merges a set of attributes into a single instance. All attributes must have compatible properties and types.
Instances of [InterleavedBufferAttribute](InterleavedBufferAttribute) are not supported.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferAttribute</code> - The merged attribute. Returns `null` if the merge does not succeed.  

| Param | Type | Description |
| --- | --- | --- |
| attributes | <code>Array.&lt;BufferAttribute&gt;</code> | The attributes to merge. |

<a name="module_BufferGeometryUtils..deepCloneAttribute"></a>

### BufferGeometryUtils~deepCloneAttribute(attribute) ⇒ <code>BufferAttribute</code>
Performs a deep clone of the given buffer attribute.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferAttribute</code> - The cloned attribute.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The attribute to clone. |

<a name="module_BufferGeometryUtils..interleaveAttributes"></a>

### BufferGeometryUtils~interleaveAttributes(attributes) ⇒ <code>Array.&lt;InterleavedBufferAttribute&gt;</code>
Interleaves a set of attributes and returns a new array of corresponding attributes that share a
single [InterleavedBuffer](InterleavedBuffer) instance. All attributes must have compatible types.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>Array.&lt;InterleavedBufferAttribute&gt;</code> - An array of interleaved attributes. If interleave does not succeed, the method returns `null`.  

| Param | Type | Description |
| --- | --- | --- |
| attributes | <code>Array.&lt;BufferAttribute&gt;</code> | The attributes to interleave. |

<a name="module_BufferGeometryUtils..deinterleaveAttribute"></a>

### BufferGeometryUtils~deinterleaveAttribute(attribute) ⇒ <code>BufferAttribute</code>
Returns a new, non-interleaved version of the given attribute.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferAttribute</code> - The non-interleaved attribute.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>InterleavedBufferAttribute</code> | The interleaved attribute. |

<a name="module_BufferGeometryUtils..deinterleaveGeometry"></a>

### BufferGeometryUtils~deinterleaveGeometry(geometry)
Deinterleaves all attributes on the given geometry.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to deinterleave. |

<a name="module_BufferGeometryUtils..estimateBytesUsed"></a>

### BufferGeometryUtils~estimateBytesUsed(geometry) ⇒ <code>number</code>
Returns the amount of bytes used by all attributes to represent the geometry.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>number</code> - The estimate bytes used.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry. |

<a name="module_BufferGeometryUtils..mergeVertices"></a>

### BufferGeometryUtils~mergeVertices(geometry, [tolerance]) ⇒ <code>BufferGeometry</code>
Returns a new geometry with vertices for which all similar vertex attributes (within tolerance) are merged.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - - The new geometry with merged vertices.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to merge vertices for. |
| [tolerance] | <code>number</code> | <code>1e-4</code> | The tolerance value. |

<a name="module_BufferGeometryUtils..toTrianglesDrawMode"></a>

### BufferGeometryUtils~toTrianglesDrawMode(geometry, drawMode) ⇒ <code>BufferGeometry</code>
Returns a new indexed geometry based on `TrianglesDrawMode` draw mode.
This mode corresponds to the `gl.TRIANGLES` primitive in WebGL.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - The new geometry using `TrianglesDrawMode`.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to convert. |
| drawMode | <code>number</code> | The current draw mode. |

<a name="module_BufferGeometryUtils..computeMorphedAttributes"></a>

### BufferGeometryUtils~computeMorphedAttributes(object) ⇒ <code>Object</code>
Calculates the morphed attributes of a morphed/skinned BufferGeometry.

Helpful for Raytracing or Decals (i.e. a `DecalGeometry` applied to a morphed Object with a `BufferGeometry`
will use the original `BufferGeometry`, not the morphed/skinned one, generating an incorrect result.
Using this function to create a shadow `Object3`D the `DecalGeometry` can be correctly generated).

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>Object</code> - An object with original position/normal attributes and morphed ones.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Mesh</code> \| <code>Line</code> \| <code>Points</code> | The 3D object to compute morph attributes for. |

<a name="module_BufferGeometryUtils..mergeGroups"></a>

### BufferGeometryUtils~mergeGroups(geometry) ⇒ <code>BufferGeometry</code>
Merges the [BufferGeometry#groups](BufferGeometry#groups) for the given geometry.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - - The updated geometry  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to modify. |

<a name="module_BufferGeometryUtils..toCreasedNormals"></a>

### BufferGeometryUtils~toCreasedNormals(geometry, [creaseAngle]) ⇒ <code>BufferGeometry</code>
Modifies the supplied geometry if it is non-indexed, otherwise creates a new,
non-indexed geometry. Returns the geometry with smooth normals everywhere except
faces that meet at an angle greater than the crease angle.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - - The updated geometry  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to modify. |
| [creaseAngle] | <code>number</code> | <code>Math.PI/3</code> | The crease angle in radians. |

<a name="module_CameraUtils"></a>

## CameraUtils
<a name="module_CameraUtils..frameCorners"></a>

### CameraUtils~frameCorners(camera, bottomLeftCorner, bottomRightCorner, topLeftCorner, [estimateViewFrustum])
Set projection matrix and the orientation of a perspective camera
to exactly frame the corners of an arbitrary rectangle.
NOTE: This function ignores the standard parameters;
do not call `updateProjectionMatrix()` after this.

**Kind**: inner method of [<code>CameraUtils</code>](#module_CameraUtils)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>PerspectiveCamera</code> |  | The camera. |
| bottomLeftCorner | <code>Vector3</code> |  | The bottom-left corner point. |
| bottomRightCorner | <code>Vector3</code> |  | The bottom-right corner point. |
| topLeftCorner | <code>Vector3</code> |  | The top-left corner point. |
| [estimateViewFrustum] | <code>boolean</code> | <code>false</code> | If set to `true`, the function tries to estimate the camera's FOV. |

<a name="module_GeometryCompressionUtils"></a>

## GeometryCompressionUtils

* [GeometryCompressionUtils](#module_GeometryCompressionUtils)
    * [~compressNormals(geometry, encodeMethod)](#module_GeometryCompressionUtils..compressNormals)
    * [~compressPositions(geometry)](#module_GeometryCompressionUtils..compressPositions)
    * [~compressUvs(geometry)](#module_GeometryCompressionUtils..compressUvs)

<a name="module_GeometryCompressionUtils..compressNormals"></a>

### GeometryCompressionUtils~compressNormals(geometry, encodeMethod)
Compressed the given geometry's `normal` attribute by the selected encode method.

**Kind**: inner method of [<code>GeometryCompressionUtils</code>](#module_GeometryCompressionUtils)  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry whose normals should be compressed. |
| encodeMethod | <code>&#x27;DEFAULT&#x27;</code> \| <code>&#x27;OCT1Byte&#x27;</code> \| <code>&#x27;OCT2Byte&#x27;</code> \| <code>&#x27;ANGLES&#x27;</code> | The compression method. |

<a name="module_GeometryCompressionUtils..compressPositions"></a>

### GeometryCompressionUtils~compressPositions(geometry)
Compressed the given geometry's `position` attribute.

**Kind**: inner method of [<code>GeometryCompressionUtils</code>](#module_GeometryCompressionUtils)  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry whose position values should be compressed. |

<a name="module_GeometryCompressionUtils..compressUvs"></a>

### GeometryCompressionUtils~compressUvs(geometry)
Compressed the given geometry's `uv` attribute.

**Kind**: inner method of [<code>GeometryCompressionUtils</code>](#module_GeometryCompressionUtils)  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry whose texture coordinates should be compressed. |

<a name="module_GeometryUtils"></a>

## GeometryUtils

* [GeometryUtils](#module_GeometryUtils)
    * [~hilbert2D([center], [size], [iterations], [v0], [v1], [v2], [v3])](#module_GeometryUtils..hilbert2D) ⇒ <code>Array.&lt;Vector3&gt;</code>
    * [~hilbert3D([center], [size], [iterations], [v0], [v1], [v2], [v3], [v4], [v5], [v6], [v7])](#module_GeometryUtils..hilbert3D) ⇒ <code>Array.&lt;Vector3&gt;</code>
    * [~gosper([size])](#module_GeometryUtils..gosper) ⇒ <code>Array.&lt;number&gt;</code>

<a name="module_GeometryUtils..hilbert2D"></a>

### GeometryUtils~hilbert2D([center], [size], [iterations], [v0], [v1], [v2], [v3]) ⇒ <code>Array.&lt;Vector3&gt;</code>
Generates 2D-Coordinates along a Hilbert curve.

Based on work by: [http://www.openprocessing.org/sketch/15493](http://www.openprocessing.org/sketch/15493)

**Kind**: inner method of [<code>GeometryUtils</code>](#module_GeometryUtils)  
**Returns**: <code>Array.&lt;Vector3&gt;</code> - The Hilbert curve points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [center] | <code>Vector3</code> |  | Center of Hilbert curve. |
| [size] | <code>number</code> | <code>10</code> | Total width of Hilbert curve. |
| [iterations] | <code>number</code> | <code>10</code> | Number of subdivisions. |
| [v0] | <code>number</code> | <code>0</code> | Corner index -X, -Z. |
| [v1] | <code>number</code> | <code>1</code> | Corner index -X, +Z. |
| [v2] | <code>number</code> | <code>2</code> | Corner index +X, +Z. |
| [v3] | <code>number</code> | <code>3</code> | Corner index +X, -Z. |

<a name="module_GeometryUtils..hilbert3D"></a>

### GeometryUtils~hilbert3D([center], [size], [iterations], [v0], [v1], [v2], [v3], [v4], [v5], [v6], [v7]) ⇒ <code>Array.&lt;Vector3&gt;</code>
Generates 3D-Coordinates along a Hilbert curve.

Based on work by: [https://openprocessing.org/user/5654](https://openprocessing.org/user/5654)

**Kind**: inner method of [<code>GeometryUtils</code>](#module_GeometryUtils)  
**Returns**: <code>Array.&lt;Vector3&gt;</code> - - The Hilbert curve points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [center] | <code>Vector3</code> |  | Center of Hilbert curve. |
| [size] | <code>number</code> | <code>10</code> | Total width of Hilbert curve. |
| [iterations] | <code>number</code> | <code>1</code> | Number of subdivisions. |
| [v0] | <code>number</code> | <code>0</code> | Corner index -X, +Y, -Z. |
| [v1] | <code>number</code> | <code>1</code> | Corner index -X, +Y, +Z. |
| [v2] | <code>number</code> | <code>2</code> | Corner index -X, -Y, +Z. |
| [v3] | <code>number</code> | <code>3</code> | Corner index -X, -Y, -Z. |
| [v4] | <code>number</code> | <code>4</code> | Corner index +X, -Y, -Z. |
| [v5] | <code>number</code> | <code>5</code> | Corner index +X, -Y, +Z. |
| [v6] | <code>number</code> | <code>6</code> | Corner index +X, +Y, +Z. |
| [v7] | <code>number</code> | <code>7</code> | Corner index +X, +Y, -Z. |

<a name="module_GeometryUtils..gosper"></a>

### GeometryUtils~gosper([size]) ⇒ <code>Array.&lt;number&gt;</code>
Generates a Gosper curve (lying in the XY plane).

Reference: [https://gist.github.com/nitaku/6521802](https://gist.github.com/nitaku/6521802)

**Kind**: inner method of [<code>GeometryUtils</code>](#module_GeometryUtils)  
**Returns**: <code>Array.&lt;number&gt;</code> - The gosper island points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>1</code> | The size of a single gosper island. |

<a name="LDrawUtils"></a>

## LDrawUtils
Utility class for LDraw models.

**Kind**: global class  
<a name="LDrawUtils.mergeObject"></a>

### LDrawUtils.mergeObject(object) ⇒ <code>Group</code>
Merges geometries in the given object by materials and returns a new group object.
Use on not indexed geometries. The object buffers reference the old object ones.
Special treatment is done to the conditional lines generated by LDrawLoader.

**Kind**: static method of [<code>LDrawUtils</code>](#LDrawUtils)  
**Returns**: <code>Group</code> - The merged object.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The object to merge. |

<a name="SceneOptimizer"></a>

## SceneOptimizer
This class can be used to optimized scenes by converting
individual meshes into [BatchedMesh](BatchedMesh). This component
is an experimental attempt to implement auto-batching in three.js.

**Kind**: global class  

* [SceneOptimizer](#SceneOptimizer)
    * [new SceneOptimizer(scene, options)](#new_SceneOptimizer_new)
    * _instance_
        * [.removeEmptyNodes(object)](#SceneOptimizer+removeEmptyNodes)
        * [.disposeMeshes(meshesToRemove)](#SceneOptimizer+disposeMeshes)
        * [.toBatchedMesh()](#SceneOptimizer+toBatchedMesh) ⇒ <code>Scene</code>
        * *[.toInstancingMesh()](#SceneOptimizer+toInstancingMesh) ⇒ <code>Scene</code>*
    * _inner_
        * [~Options](#SceneOptimizer..Options) : <code>Object</code>

<a name="new_SceneOptimizer_new"></a>

### new SceneOptimizer(scene, options)
Constructs a new scene optimizer.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to optimize. |
| options | [<code>Options</code>](#SceneOptimizer..Options) | The configuration options. |

<a name="SceneOptimizer+removeEmptyNodes"></a>

### sceneOptimizer.removeEmptyNodes(object)
Removes empty nodes from all descendants of the given 3D object.

**Kind**: instance method of [<code>SceneOptimizer</code>](#SceneOptimizer)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to process. |

<a name="SceneOptimizer+disposeMeshes"></a>

### sceneOptimizer.disposeMeshes(meshesToRemove)
Removes the given array of meshes from the scene.

**Kind**: instance method of [<code>SceneOptimizer</code>](#SceneOptimizer)  

| Param | Type | Description |
| --- | --- | --- |
| meshesToRemove | <code>Set.&lt;Mesh&gt;</code> | The meshes to remove. |

<a name="SceneOptimizer+toBatchedMesh"></a>

### sceneOptimizer.toBatchedMesh() ⇒ <code>Scene</code>
Performs the auto-baching by identifying groups of meshes in the scene
that can be represented as a single [BatchedMesh](BatchedMesh). The method modifies
the scene by adding instances of `BatchedMesh` and removing the now redundant
individual meshes.

**Kind**: instance method of [<code>SceneOptimizer</code>](#SceneOptimizer)  
**Returns**: <code>Scene</code> - The optimized scene.  
<a name="SceneOptimizer+toInstancingMesh"></a>

### *sceneOptimizer.toInstancingMesh() ⇒ <code>Scene</code>*
Performs the auto-instancing by identifying groups of meshes in the scene
that can be represented as a single [InstancedMesh](InstancedMesh). The method modifies
the scene by adding instances of `InstancedMesh` and removing the now redundant
individual meshes.

This method is not yet implemented.

**Kind**: instance abstract method of [<code>SceneOptimizer</code>](#SceneOptimizer)  
**Returns**: <code>Scene</code> - The optimized scene.  
<a name="SceneOptimizer..Options"></a>

### SceneOptimizer~Options : <code>Object</code>
Constructor options of `SceneOptimizer`.

**Kind**: inner typedef of [<code>SceneOptimizer</code>](#SceneOptimizer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [debug] | <code>boolean</code> | <code>false</code> | Whether to enable debug mode or not. |

<a name="module_SceneUtils"></a>

## SceneUtils

* [SceneUtils](#module_SceneUtils)
    * [~createMeshesFromInstancedMesh(instancedMesh)](#module_SceneUtils..createMeshesFromInstancedMesh) ⇒ <code>Group</code>
    * [~createMeshesFromMultiMaterialMesh(mesh)](#module_SceneUtils..createMeshesFromMultiMaterialMesh) ⇒ <code>Group</code>
    * [~createMultiMaterialObject(geometry, materials)](#module_SceneUtils..createMultiMaterialObject) ⇒ <code>Group</code>
    * [~reduceVertices(object, func, initialValue)](#module_SceneUtils..reduceVertices) ⇒ <code>any</code>
    * [~sortInstancedMesh(mesh, compareFn)](#module_SceneUtils..sortInstancedMesh)
    * [~traverseGenerator(object)](#module_SceneUtils..traverseGenerator)
    * [~traverseVisibleGenerator(object)](#module_SceneUtils..traverseVisibleGenerator)
    * [~traverseAncestorsGenerator(object)](#module_SceneUtils..traverseAncestorsGenerator)

<a name="module_SceneUtils..createMeshesFromInstancedMesh"></a>

### SceneUtils~createMeshesFromInstancedMesh(instancedMesh) ⇒ <code>Group</code>
This function creates a mesh for each instance of the given instanced mesh and
adds it to a group. Each mesh will honor the current 3D transformation of its
corresponding instance.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  
**Returns**: <code>Group</code> - A group of meshes.  

| Param | Type | Description |
| --- | --- | --- |
| instancedMesh | <code>InstancedMesh</code> | The instanced mesh. |

<a name="module_SceneUtils..createMeshesFromMultiMaterialMesh"></a>

### SceneUtils~createMeshesFromMultiMaterialMesh(mesh) ⇒ <code>Group</code>
This function creates a mesh for each geometry-group of the given multi-material mesh and
adds it to a group.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  
**Returns**: <code>Group</code> - A group of meshes.  

| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The multi-material mesh. |

<a name="module_SceneUtils..createMultiMaterialObject"></a>

### SceneUtils~createMultiMaterialObject(geometry, materials) ⇒ <code>Group</code>
This function represents an alternative way to create 3D objects with multiple materials.
Normally, [BufferGeometry#groups](BufferGeometry#groups) are used which might introduce issues e.g. when
exporting the object to a 3D format. This function accepts a geometry and an array of
materials and creates for each material a mesh that is added to a group.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  
**Returns**: <code>Group</code> - A group representing a multi-material object.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry. |
| materials | <code>Array.&lt;Material&gt;</code> | An array of materials. |

<a name="module_SceneUtils..reduceVertices"></a>

### SceneUtils~reduceVertices(object, func, initialValue) ⇒ <code>any</code>
Executes a reducer function for each vertex of the given 3D object.
`reduceVertices()` returns a single value: the function's accumulated result.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  
**Returns**: <code>any</code> - The result.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object that should be processed. It must have a geometry with a `position` attribute. |
| func | <code>function</code> | The reducer function. First argument is the current value, second argument the current vertex. |
| initialValue | <code>any</code> | The initial value. |

<a name="module_SceneUtils..sortInstancedMesh"></a>

### SceneUtils~sortInstancedMesh(mesh, compareFn)
Sorts the instances of the given instanced mesh.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  

| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>InstancedMesh</code> | The instanced mesh to sort. |
| compareFn | <code>function</code> | A custom compare function for the sort. |

<a name="module_SceneUtils..traverseGenerator"></a>

### SceneUtils~traverseGenerator(object)
Generator based alternative to [Object3D#traverse](Object3D#traverse).

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | Object to traverse. |

<a name="module_SceneUtils..traverseVisibleGenerator"></a>

### SceneUtils~traverseVisibleGenerator(object)
Generator based alternative to [Object3D#traverseVisible](Object3D#traverseVisible).

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | Object to traverse. |

<a name="module_SceneUtils..traverseAncestorsGenerator"></a>

### SceneUtils~traverseAncestorsGenerator(object)
Generator based alternative to [Object3D#traverseAncestors](Object3D#traverseAncestors).

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | Object to traverse. |

<a name="ShadowMapViewer"></a>

## ShadowMapViewer
This is a helper for visualising a given light's shadow map.
It works for shadow casting lights: DirectionalLight and SpotLight.
It renders out the shadow map and displays it on a HUD.

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the class from `ShadowMapViewerGPU.js`.

```js
const lightShadowMapViewer = new ShadowMapViewer( light );
lightShadowMapViewer.position.x = 10;
lightShadowMapViewer.position.y = SCREEN_HEIGHT - ( SHADOW_MAP_HEIGHT / 4 ) - 10;
lightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 4;
lightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 4;
lightShadowMapViewer.update();
```

**Kind**: global class  

* [ShadowMapViewer](#ShadowMapViewer)
    * [new ShadowMapViewer(light)](#new_ShadowMapViewer_new)
    * [.enabled](#ShadowMapViewer+enabled) : <code>boolean</code>
    * [.size](#ShadowMapViewer+size) : <code>Object</code>
    * [.position](#ShadowMapViewer+position) : <code>Object</code>
    * [.render(renderer)](#ShadowMapViewer+render)
    * [.updateForWindowResize()](#ShadowMapViewer+updateForWindowResize)
    * [.update()](#ShadowMapViewer+update)

<a name="new_ShadowMapViewer_new"></a>

### new ShadowMapViewer(light)
Constructs a new shadow map viewer.


| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The shadow casting light. |

<a name="ShadowMapViewer+enabled"></a>

### shadowMapViewer.enabled : <code>boolean</code>
Whether to display the shadow map viewer or not.

**Kind**: instance property of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
**Default**: <code>true</code>  
<a name="ShadowMapViewer+size"></a>

### shadowMapViewer.size : <code>Object</code>
The size of the viewer. When changing this property, make sure
to call [update](#ShadowMapViewer+update).

**Kind**: instance property of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
**Default**: <code>true</code>  
<a name="ShadowMapViewer+position"></a>

### shadowMapViewer.position : <code>Object</code>
The position of the viewer. When changing this property, make sure
to call [update](#ShadowMapViewer+update).

**Kind**: instance property of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
**Default**: <code>true</code>  
<a name="ShadowMapViewer+render"></a>

### shadowMapViewer.render(renderer)
Renders the viewer. This method must be called in the app's animation loop.

**Kind**: instance method of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="ShadowMapViewer+updateForWindowResize"></a>

### shadowMapViewer.updateForWindowResize()
Resizes the viewer. This method should be called whenever the app's
window is resized.

**Kind**: instance method of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
<a name="ShadowMapViewer+update"></a>

### shadowMapViewer.update()
Updates the viewer.

**Kind**: instance method of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
<a name="module_SkeletonUtils"></a>

## SkeletonUtils

* [SkeletonUtils](#module_SkeletonUtils)
    * [~retarget(target, source, options)](#module_SkeletonUtils..retarget)
    * [~retargetClip(target, source, clip, options)](#module_SkeletonUtils..retargetClip) ⇒ <code>AnimationClip</code>
    * [~clone(source)](#module_SkeletonUtils..clone) ⇒ <code>Object3D</code>
    * [~RetargetOptions](#module_SkeletonUtils..RetargetOptions) : <code>Object</code>

<a name="module_SkeletonUtils..retarget"></a>

### SkeletonUtils~retarget(target, source, options)
Retargets the skeleton from the given source 3D object to the
target 3D object.

**Kind**: inner method of [<code>SkeletonUtils</code>](#module_SkeletonUtils)  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Object3D</code> | The target 3D object. |
| source | <code>Object3D</code> | The source 3D object. |
| options | [<code>RetargetOptions</code>](#module_SkeletonUtils..RetargetOptions) | The options. |

<a name="module_SkeletonUtils..retargetClip"></a>

### SkeletonUtils~retargetClip(target, source, clip, options) ⇒ <code>AnimationClip</code>
Retargets the animation clip of the source object to the
target 3D object.

**Kind**: inner method of [<code>SkeletonUtils</code>](#module_SkeletonUtils)  
**Returns**: <code>AnimationClip</code> - The retargeted animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Object3D</code> | The target 3D object. |
| source | <code>Object3D</code> | The source 3D object. |
| clip | <code>AnimationClip</code> | The animation clip. |
| options | [<code>RetargetOptions</code>](#module_SkeletonUtils..RetargetOptions) | The options. |

<a name="module_SkeletonUtils..clone"></a>

### SkeletonUtils~clone(source) ⇒ <code>Object3D</code>
Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are
correctly associated with their bones. Bones are also cloned, and must be descendants of the
object passed to this method. Other data, like geometries and materials, are reused by reference.

**Kind**: inner method of [<code>SkeletonUtils</code>](#module_SkeletonUtils)  
**Returns**: <code>Object3D</code> - The cloned 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>Object3D</code> | The 3D object to clone. |

<a name="module_SkeletonUtils..RetargetOptions"></a>

### SkeletonUtils~RetargetOptions : <code>Object</code>
Retarget options of `SkeletonUtils`.

**Kind**: inner typedef of [<code>SkeletonUtils</code>](#module_SkeletonUtils)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [useFirstFramePosition] | <code>boolean</code> | <code>false</code> | Whether to use the position of the first frame or not. |
| [fps] | <code>number</code> |  | The FPS of the clip. |
| [names] | <code>Object.&lt;string, string&gt;</code> |  | A dictionary for mapping target to source bone names. |
| [getBoneName] | <code>function</code> |  | A function for mapping bone names. Alternative to `names`. |
| [trim] | <code>Array.&lt;number&gt;</code> |  | Whether to trim the clip or not. If set the array should hold two values for the start and end. |
| [preserveBoneMatrix] | <code>boolean</code> | <code>true</code> | Whether to preserve bone matrices or not. |
| [preserveBonePositions] | <code>boolean</code> | <code>true</code> | Whether to preserve bone positions or not. |
| [useTargetMatrix] | <code>boolean</code> | <code>false</code> | Whether to use the target matrix or not. |
| [hip] | <code>string</code> | <code>&quot;&#x27;hip&#x27;&quot;</code> | The name of the source's hip bone. |
| [hipInfluence] | <code>Vector3</code> | <code>(1,1,1)</code> | The hip influence. |
| [scale] | <code>number</code> | <code>1</code> | The scale. |

<a name="module_SortUtils"></a>

## SortUtils
<a name="module_SortUtils.radixSort"></a>

### SortUtils.radixSort(arr, opt)
Hybrid radix sort from.

- [https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab](https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab)
- [https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271](https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271)

Expects unsigned 32b integer values.

**Kind**: static method of [<code>SortUtils</code>](#module_SortUtils)  

| Param | Type | Description |
| --- | --- | --- |
| arr | <code>Array.&lt;Object&gt;</code> | The array to sort. |
| opt | <code>Object</code> | The options |

<a name="module_UVsDebug"></a>

## UVsDebug
<a name="module_UVsDebug..UVsDebug"></a>

### UVsDebug~UVsDebug(geometry, [size]) ⇒ <code>HTMLCanvasElement</code>
Function for "unwrapping" and debugging three.js geometries UV mapping.

```js
document.body.appendChild( UVsDebug( new THREE.SphereGeometry() ) );
```

**Kind**: inner method of [<code>UVsDebug</code>](#module_UVsDebug)  
**Returns**: <code>HTMLCanvasElement</code> - A canvas element with visualized uv coordinates.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry whose uv coordinates should be inspected. |
| [size] | <code>number</code> | <code>1024</code> | The size of the debug canvas. |

<a name="module_WebGLTextureUtils"></a>

## WebGLTextureUtils
<a name="module_WebGLTextureUtils.decompress"></a>

### WebGLTextureUtils.decompress(texture, [maxTextureSize], [renderer]) ⇒ <code>CanvasTexture</code>
Returns an uncompressed version of the given compressed texture.

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the function from [WebGPUTextureUtils](WebGPUTextureUtils).

**Kind**: static method of [<code>WebGLTextureUtils</code>](#module_WebGLTextureUtils)  
**Returns**: <code>CanvasTexture</code> - The uncompressed texture.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>CompressedTexture</code> |  | The compressed texture. |
| [maxTextureSize] | <code>number</code> | <code>Infinity</code> | The maximum size of the uncompressed texture. |
| [renderer] | <code>WebGLRenderer</code> | <code></code> | A reference to a renderer. |

<a name="module_WebGPUTextureUtils"></a>

## WebGPUTextureUtils
<a name="module_WebGPUTextureUtils.decompress"></a>

### WebGPUTextureUtils.decompress(blitTexture, [maxTextureSize], [renderer]) ⇒ <code>Promise.&lt;CanvasTexture&gt;</code>
Returns an uncompressed version of the given compressed texture.

This module can only be used with [WebGPURenderer](WebGPURenderer). When using [WebGLRenderer](WebGLRenderer),
import the function from [WebGLTextureUtils](WebGLTextureUtils).

**Kind**: static method of [<code>WebGPUTextureUtils</code>](#module_WebGPUTextureUtils)  
**Returns**: <code>Promise.&lt;CanvasTexture&gt;</code> - A Promise that resolved with the uncompressed texture.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| blitTexture | <code>CompressedTexture</code> |  | The compressed texture. |
| [maxTextureSize] | <code>number</code> | <code>Infinity</code> | The maximum size of the uncompressed texture. |
| [renderer] | <code>WebGPURenderer</code> | <code></code> | A reference to a renderer. |

<a name="ARButton"></a>

## ARButton
A utility class for creating a button that allows to initiate
immersive AR sessions based on WebXR. The button can be created
with a factory method and then appended ot the website's DOM.

```js
document.body.appendChild( ARButton.createButton( renderer ) );
```

**Kind**: global class  
<a name="ARButton.createButton"></a>

### ARButton.createButton(renderer, [sessionInit]) ⇒ <code>HTMLElement</code>
Constructs a new AR button.

**Kind**: static method of [<code>ARButton</code>](#ARButton)  
**Returns**: <code>HTMLElement</code> - The button or an error message if `immersive-ar` isn't supported.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> \| <code>WebGPURenderer</code> | The renderer. |
| [sessionInit] | <code>XRSessionInit</code> | The a configuration object for the AR session. |

<a name="OculusHandModel"></a>

## OculusHandModel ⇐ <code>Object3D</code>
Represents an Oculus hand model.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [OculusHandModel](#OculusHandModel) ⇐ <code>Object3D</code>
    * [new OculusHandModel(controller, [loader], [onLoad])](#new_OculusHandModel_new)
    * [.controller](#OculusHandModel+controller) : <code>Group</code>
    * [.motionController](#OculusHandModel+motionController) : <code>MotionController</code>
    * [.envMap](#OculusHandModel+envMap) : <code>Texture</code>
    * [.loader](#OculusHandModel+loader) : <code>Loader</code>
    * [.onLoad](#OculusHandModel+onLoad) : <code>function</code>
    * [.path](#OculusHandModel+path) : <code>string</code>
    * [.mesh](#OculusHandModel+mesh) : <code>Mesh</code>
    * [.updateMatrixWorld([force])](#OculusHandModel+updateMatrixWorld)
    * [.getPointerPosition()](#OculusHandModel+getPointerPosition) ⇒ <code>Vector3</code> \| <code>null</code>
    * [.intersectBoxObject(boxObject)](#OculusHandModel+intersectBoxObject) ⇒ <code>boolean</code>
    * [.checkButton(button)](#OculusHandModel+checkButton)

<a name="new_OculusHandModel_new"></a>

### new OculusHandModel(controller, [loader], [onLoad])
Constructs a new Oculus hand model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| controller | <code>Group</code> |  | The hand controller. |
| [loader] | <code>Loader</code> | <code></code> | A loader that is used to load hand models. |
| [onLoad] | <code>function</code> | <code></code> | A callback that is executed when a hand model has been loaded. |

<a name="OculusHandModel+controller"></a>

### oculusHandModel.controller : <code>Group</code>
The hand controller.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
<a name="OculusHandModel+motionController"></a>

### oculusHandModel.motionController : <code>MotionController</code>
The motion controller.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+envMap"></a>

### oculusHandModel.envMap : <code>Texture</code>
The model's environment map.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+loader"></a>

### oculusHandModel.loader : <code>Loader</code>
A loader that is used to load hand models.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+onLoad"></a>

### oculusHandModel.onLoad : <code>function</code>
A callback that is executed when a hand model has been loaded.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+path"></a>

### oculusHandModel.path : <code>string</code>
The path to the model repository.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>&quot;null&quot;</code>  
<a name="OculusHandModel+mesh"></a>

### oculusHandModel.mesh : <code>Mesh</code>
The model mesh.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+updateMatrixWorld"></a>

### oculusHandModel.updateMatrixWorld([force])
Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.

**Kind**: instance method of [<code>OculusHandModel</code>](#OculusHandModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [Object3D#matrixWorldAutoUpdate](Object3D#matrixWorldAutoUpdate) is set to `false`. |

<a name="OculusHandModel+getPointerPosition"></a>

### oculusHandModel.getPointerPosition() ⇒ <code>Vector3</code> \| <code>null</code>
Returns the pointer position which is the position of the index finger tip.

**Kind**: instance method of [<code>OculusHandModel</code>](#OculusHandModel)  
**Returns**: <code>Vector3</code> \| <code>null</code> - The pointer position. Returns `null` if not index finger tip joint was found.  
<a name="OculusHandModel+intersectBoxObject"></a>

### oculusHandModel.intersectBoxObject(boxObject) ⇒ <code>boolean</code>
Returns `true` if the current pointer position (the index finger tip) intersections
with the given box object.

**Kind**: instance method of [<code>OculusHandModel</code>](#OculusHandModel)  
**Returns**: <code>boolean</code> - Whether an intersection was found or not.  

| Param | Type | Description |
| --- | --- | --- |
| boxObject | <code>Mesh</code> | The box object. |

<a name="OculusHandModel+checkButton"></a>

### oculusHandModel.checkButton(button)
Executed actions depending on the interaction state with
the given button.

**Kind**: instance method of [<code>OculusHandModel</code>](#OculusHandModel)  

| Param | Type | Description |
| --- | --- | --- |
| button | <code>Object</code> | The button. |

<a name="OculusHandPointerModel"></a>

## OculusHandPointerModel ⇐ <code>Object3D</code>
Represents an Oculus hand pointer model.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [OculusHandPointerModel](#OculusHandPointerModel) ⇐ <code>Object3D</code>
    * [new OculusHandPointerModel(hand, controller)](#new_OculusHandPointerModel_new)
    * [.hand](#OculusHandPointerModel+hand) : <code>Group</code>
    * [.controller](#OculusHandPointerModel+controller) : <code>Group</code>
    * [.pointerGeometry](#OculusHandPointerModel+pointerGeometry) : <code>BufferGeometry</code>
    * [.pointerMesh](#OculusHandPointerModel+pointerMesh) : <code>Mesh</code>
    * [.pointerObject](#OculusHandPointerModel+pointerObject) : <code>Object3D</code>
    * [.pinched](#OculusHandPointerModel+pinched) : <code>boolean</code>
    * [.attached](#OculusHandPointerModel+attached) : <code>boolean</code>
    * [.cursorObject](#OculusHandPointerModel+cursorObject) : <code>Mesh</code>
    * [.raycaster](#OculusHandPointerModel+raycaster) : <code>Raycaster</code>
    * [.createPointer()](#OculusHandPointerModel+createPointer)
    * [.updateMatrixWorld([force])](#OculusHandPointerModel+updateMatrixWorld)
    * [.isPinched()](#OculusHandPointerModel+isPinched) ⇒ <code>boolean</code>
    * [.setAttached(attached)](#OculusHandPointerModel+setAttached)
    * [.isAttached()](#OculusHandPointerModel+isAttached) ⇒ <code>boolean</code>
    * [.intersectObject(object, [recursive])](#OculusHandPointerModel+intersectObject) ⇒ <code>Array.&lt;Raycaster~Intersection&gt;</code>
    * [.intersectObjects(objects, [recursive])](#OculusHandPointerModel+intersectObjects) ⇒ <code>Array.&lt;Raycaster~Intersection&gt;</code>
    * [.checkIntersections(objects, [recursive])](#OculusHandPointerModel+checkIntersections)
    * [.setCursor(distance)](#OculusHandPointerModel+setCursor)
    * [.dispose()](#OculusHandPointerModel+dispose)

<a name="new_OculusHandPointerModel_new"></a>

### new OculusHandPointerModel(hand, controller)
Constructs a new Oculus hand model.


| Param | Type | Description |
| --- | --- | --- |
| hand | <code>Group</code> | The hand controller. |
| controller | <code>Group</code> | The WebXR controller in target ray space. |

<a name="OculusHandPointerModel+hand"></a>

### oculusHandPointerModel.hand : <code>Group</code>
The hand controller.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
<a name="OculusHandPointerModel+controller"></a>

### oculusHandPointerModel.controller : <code>Group</code>
The WebXR controller in target ray space.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
<a name="OculusHandPointerModel+pointerGeometry"></a>

### oculusHandPointerModel.pointerGeometry : <code>BufferGeometry</code>
The pointer geometry.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+pointerMesh"></a>

### oculusHandPointerModel.pointerMesh : <code>Mesh</code>
The pointer mesh.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+pointerObject"></a>

### oculusHandPointerModel.pointerObject : <code>Object3D</code>
The pointer object that holds the pointer mesh.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+pinched"></a>

### oculusHandPointerModel.pinched : <code>boolean</code>
Whether the model is pinched or not.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>false</code>  
<a name="OculusHandPointerModel+attached"></a>

### oculusHandPointerModel.attached : <code>boolean</code>
Whether the model is attached or not.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>false</code>  
<a name="OculusHandPointerModel+cursorObject"></a>

### oculusHandPointerModel.cursorObject : <code>Mesh</code>
The cursor object.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+raycaster"></a>

### oculusHandPointerModel.raycaster : <code>Raycaster</code>
The internal raycaster used for detecting
intersections.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+createPointer"></a>

### oculusHandPointerModel.createPointer()
Creates a pointer mesh and adds it to this model.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
<a name="OculusHandPointerModel+updateMatrixWorld"></a>

### oculusHandPointerModel.updateMatrixWorld([force])
Overwritten with a custom implementation. Makes sure the internal pointer and raycaster are updated.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [Object3D#matrixWorldAutoUpdate](Object3D#matrixWorldAutoUpdate) is set to `false`. |

<a name="OculusHandPointerModel+isPinched"></a>

### oculusHandPointerModel.isPinched() ⇒ <code>boolean</code>
Returns `true` is the model is pinched.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Returns**: <code>boolean</code> - Whether the model is pinched or not.  
<a name="OculusHandPointerModel+setAttached"></a>

### oculusHandPointerModel.setAttached(attached)
Sets the attached state.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  

| Param | Type | Description |
| --- | --- | --- |
| attached | <code>boolean</code> | Whether the model is attached or not. |

<a name="OculusHandPointerModel+isAttached"></a>

### oculusHandPointerModel.isAttached() ⇒ <code>boolean</code>
Returns `true` is the model is attached.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Returns**: <code>boolean</code> - Whether the model is attached or not.  
<a name="OculusHandPointerModel+intersectObject"></a>

### oculusHandPointerModel.intersectObject(object, [recursive]) ⇒ <code>Array.&lt;Raycaster~Intersection&gt;</code>
Performs an intersection test with the model's raycaster and the given object.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Returns**: <code>Array.&lt;Raycaster~Intersection&gt;</code> - An array holding the intersection points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object to check for intersection with the ray. |
| [recursive] | <code>boolean</code> | <code>true</code> | If set to `true`, it also checks all descendants. Otherwise it only checks intersection with the object. |

<a name="OculusHandPointerModel+intersectObjects"></a>

### oculusHandPointerModel.intersectObjects(objects, [recursive]) ⇒ <code>Array.&lt;Raycaster~Intersection&gt;</code>
Performs an intersection test with the model's raycaster and the given objects.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Returns**: <code>Array.&lt;Raycaster~Intersection&gt;</code> - An array holding the intersection points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| objects | <code>Array.&lt;Object3D&gt;</code> |  | The 3D objects to check for intersection with the ray. |
| [recursive] | <code>boolean</code> | <code>true</code> | If set to `true`, it also checks all descendants. Otherwise it only checks intersection with the object. |

<a name="OculusHandPointerModel+checkIntersections"></a>

### oculusHandPointerModel.checkIntersections(objects, [recursive])
Checks for intersections between the model's raycaster and the given objects. The method
updates the cursor object to the intersection point.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| objects | <code>Array.&lt;Object3D&gt;</code> |  | The 3D objects to check for intersection with the ray. |
| [recursive] | <code>boolean</code> | <code>false</code> | If set to `true`, it also checks all descendants. Otherwise it only checks intersection with the object. |

<a name="OculusHandPointerModel+setCursor"></a>

### oculusHandPointerModel.setCursor(distance)
Sets the cursor to the given distance.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The distance to set the cursor to. |

<a name="OculusHandPointerModel+dispose"></a>

### oculusHandPointerModel.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
<a name="module_Text2D"></a>

## Text2D
<a name="module_Text2D..createText"></a>

### Text2D~createText(message, height) ⇒ <code>Mesh</code>
A helper function for creating a simple plane mesh
that can be used as a text label. The mesh's material
holds a canvas texture that displays the given message.

**Kind**: inner method of [<code>Text2D</code>](#module_Text2D)  
**Returns**: <code>Mesh</code> - The plane mesh representing a text label.  

| Param | Type | Description |
| --- | --- | --- |
| message | <code>string</code> | The message to display. |
| height | <code>number</code> | The labels height. |

<a name="VRButton"></a>

## VRButton
A utility class for creating a button that allows to initiate
immersive VR sessions based on WebXR. The button can be created
with a factory method and then appended ot the website's DOM.

```js
document.body.appendChild( VRButton.createButton( renderer ) );
```

**Kind**: global class  

* [VRButton](#VRButton)
    * [.xrSessionIsGranted](#VRButton.xrSessionIsGranted) : <code>boolean</code>
    * [.createButton(renderer, [sessionInit])](#VRButton.createButton) ⇒ <code>HTMLElement</code>
    * [.registerSessionGrantedListener()](#VRButton.registerSessionGrantedListener)

<a name="VRButton.xrSessionIsGranted"></a>

### VRButton.xrSessionIsGranted : <code>boolean</code>
Whether a XR session has been granted or not.

**Kind**: static property of [<code>VRButton</code>](#VRButton)  
**Default**: <code>false</code>  
<a name="VRButton.createButton"></a>

### VRButton.createButton(renderer, [sessionInit]) ⇒ <code>HTMLElement</code>
Constructs a new VR button.

**Kind**: static method of [<code>VRButton</code>](#VRButton)  
**Returns**: <code>HTMLElement</code> - The button or an error message if `immersive-ar` isn't supported.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> \| <code>WebGPURenderer</code> | The renderer. |
| [sessionInit] | <code>XRSessionInit</code> | The a configuration object for the AR session. |

<a name="VRButton.registerSessionGrantedListener"></a>

### VRButton.registerSessionGrantedListener()
Registers a `sessiongranted` event listener. When a session is granted, the [VRButton#xrSessionIsGranted](VRButton#xrSessionIsGranted)
flag will evaluate to `true`. This method is automatically called by the module itself so there
should be no need to use it on app level.

**Kind**: static method of [<code>VRButton</code>](#VRButton)  
<a name="XRButton"></a>

## XRButton
A utility class for creating a button that allows to initiate
immersive XR sessions based on WebXR. The button can be created
with a factory method and then appended ot the website's DOM.

```js
document.body.appendChild( XRButton.createButton( renderer ) );
```

Compared to [ARButton](ARButton) and [VRButton](VRButton), this class will
try to offer an immersive AR session first. If the device does not
support this type of session, it uses an immersive VR session.

**Kind**: global class  
<a name="XRButton.createButton"></a>

### XRButton.createButton(renderer, [sessionInit]) ⇒ <code>HTMLElement</code>
Constructs a new XR button.

**Kind**: static method of [<code>XRButton</code>](#XRButton)  
**Returns**: <code>HTMLElement</code> - The button or an error message if WebXR isn't supported.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> \| <code>WebGPURenderer</code> | The renderer. |
| [sessionInit] | <code>XRSessionInit</code> | The a configuration object for the AR session. |

## Classes

<dl>
<dt><a href="#XRControllerModel">XRControllerModel</a> ⇐ <code>Object3D</code></dt>
<dd><p>Represents a XR controller model.</p>
</dd>
<dt><a href="#XRControllerModelFactory">XRControllerModelFactory</a></dt>
<dd><p>Allows to create controller models for WebXR controllers that can be added as a visual
representation to your scene. <code>XRControllerModelFactory</code> will automatically fetch controller
models that match what the user is holding as closely as possible. The models should be
attached to the object returned from getControllerGrip in order to match the orientation of
the held device.</p>
<p>This module depends on the <a href="https://github.com/immersive-web/webxr-input-profiles/blob/main/packages/motion-controllers/README.md">motion-controllers</a>
third-part library.</p>
<pre><code class="language-js">const controllerModelFactory = new XRControllerModelFactory();

const controllerGrip = renderer.xr.getControllerGrip( 0 );
controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
scene.add( controllerGrip );
</code></pre>
</dd>
</dl>

<a name="XRControllerModel"></a>

## XRControllerModel ⇐ <code>Object3D</code>
Represents a XR controller model.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [XRControllerModel](#XRControllerModel) ⇐ <code>Object3D</code>
    * [new XRControllerModel()](#new_XRControllerModel_new)
    * [.motionController](#XRControllerModel+motionController) : <code>MotionController</code>
    * [.envMap](#XRControllerModel+envMap) : <code>Texture</code>
    * [.setEnvironmentMap(envMap)](#XRControllerModel+setEnvironmentMap) ⇒ [<code>XRControllerModel</code>](#XRControllerModel)
    * [.updateMatrixWorld([force])](#XRControllerModel+updateMatrixWorld)

<a name="new_XRControllerModel_new"></a>

### new XRControllerModel()
Constructs a new XR controller model.

<a name="XRControllerModel+motionController"></a>

### xrControllerModel.motionController : <code>MotionController</code>
The motion controller.

**Kind**: instance property of [<code>XRControllerModel</code>](#XRControllerModel)  
**Default**: <code>null</code>  
<a name="XRControllerModel+envMap"></a>

### xrControllerModel.envMap : <code>Texture</code>
The controller's environment map.

**Kind**: instance property of [<code>XRControllerModel</code>](#XRControllerModel)  
**Default**: <code>null</code>  
<a name="XRControllerModel+setEnvironmentMap"></a>

### xrControllerModel.setEnvironmentMap(envMap) ⇒ [<code>XRControllerModel</code>](#XRControllerModel)
Sets an environment map that is applied to the controller model.

**Kind**: instance method of [<code>XRControllerModel</code>](#XRControllerModel)  
**Returns**: [<code>XRControllerModel</code>](#XRControllerModel) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| envMap | <code>Texture</code> | The environment map to apply. |

<a name="XRControllerModel+updateMatrixWorld"></a>

### xrControllerModel.updateMatrixWorld([force])
Overwritten with a custom implementation. Polls data from the XRInputSource and updates the
model's components to match the real world data.

**Kind**: instance method of [<code>XRControllerModel</code>](#XRControllerModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [Object3D#matrixWorldAutoUpdate](Object3D#matrixWorldAutoUpdate) is set to `false`. |

<a name="XRControllerModelFactory"></a>

## XRControllerModelFactory
Allows to create controller models for WebXR controllers that can be added as a visual
representation to your scene. `XRControllerModelFactory` will automatically fetch controller
models that match what the user is holding as closely as possible. The models should be
attached to the object returned from getControllerGrip in order to match the orientation of
the held device.

This module depends on the [motion-controllers](https://github.com/immersive-web/webxr-input-profiles/blob/main/packages/motion-controllers/README.md)
third-part library.

```js
const controllerModelFactory = new XRControllerModelFactory();

const controllerGrip = renderer.xr.getControllerGrip( 0 );
controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
scene.add( controllerGrip );
```

**Kind**: global class  

* [XRControllerModelFactory](#XRControllerModelFactory)
    * [new XRControllerModelFactory([gltfLoader], [onLoad])](#new_XRControllerModelFactory_new)
    * [.gltfLoader](#XRControllerModelFactory+gltfLoader) : <code>GLTFLoader</code>
    * [.path](#XRControllerModelFactory+path) : <code>string</code>
    * [.onLoad](#XRControllerModelFactory+onLoad) : <code>function</code>
    * [.setPath(path)](#XRControllerModelFactory+setPath) ⇒ [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)
    * [.createControllerModel(controller)](#XRControllerModelFactory+createControllerModel) ⇒ [<code>XRControllerModel</code>](#XRControllerModel)

<a name="new_XRControllerModelFactory_new"></a>

### new XRControllerModelFactory([gltfLoader], [onLoad])
Constructs a new XR controller model factory.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [gltfLoader] | <code>GLTFLoader</code> | <code></code> | A glTF loader that is used to load controller models. |
| [onLoad] | <code>function</code> | <code></code> | A callback that is executed when a controller model has been loaded. |

<a name="XRControllerModelFactory+gltfLoader"></a>

### xrControllerModelFactory.gltfLoader : <code>GLTFLoader</code>
A glTF loader that is used to load controller models.

**Kind**: instance property of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
**Default**: <code>null</code>  
<a name="XRControllerModelFactory+path"></a>

### xrControllerModelFactory.path : <code>string</code>
The path to the model repository.

**Kind**: instance property of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
<a name="XRControllerModelFactory+onLoad"></a>

### xrControllerModelFactory.onLoad : <code>function</code>
A callback that is executed when a controller model has been loaded.

**Kind**: instance property of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
**Default**: <code>null</code>  
<a name="XRControllerModelFactory+setPath"></a>

### xrControllerModelFactory.setPath(path) ⇒ [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)
Sets the path to the model repository.

**Kind**: instance method of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
**Returns**: [<code>XRControllerModelFactory</code>](#XRControllerModelFactory) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The path to set. |

<a name="XRControllerModelFactory+createControllerModel"></a>

### xrControllerModelFactory.createControllerModel(controller) ⇒ [<code>XRControllerModel</code>](#XRControllerModel)
Creates a controller model for the given WebXR controller.

**Kind**: instance method of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
**Returns**: [<code>XRControllerModel</code>](#XRControllerModel) - The XR controller model.  

| Param | Type | Description |
| --- | --- | --- |
| controller | <code>Group</code> | The controller. |

<a name="XRHandMeshModel"></a>

## XRHandMeshModel
Represents one of the hand model types [XRHandModelFactory](XRHandModelFactory) might produce
depending on the selected profile. `XRHandMeshModel` represents a hand with a
custom asset.

**Kind**: global class  

* [XRHandMeshModel](#XRHandMeshModel)
    * [new XRHandMeshModel(handModel, controller, path, handedness, [loader], [onLoad])](#new_XRHandMeshModel_new)
    * [.controller](#XRHandMeshModel+controller) : <code>Group</code>
    * [.handModel](#XRHandMeshModel+handModel) : <code>XRHandModel</code>
    * [.bones](#XRHandMeshModel+bones) : <code>Array.&lt;Bone&gt;</code>
    * [.updateMesh()](#XRHandMeshModel+updateMesh)

<a name="new_XRHandMeshModel_new"></a>

### new XRHandMeshModel(handModel, controller, path, handedness, [loader], [onLoad])
Constructs a new XR hand mesh model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| handModel | <code>XRHandModel</code> |  | The hand model. |
| controller | <code>Group</code> |  | The WebXR controller. |
| path | <code>string</code> |  | The model path. |
| handedness | <code>XRHandedness</code> |  | The handedness of the XR input source. |
| [loader] | <code>Loader</code> | <code></code> | The loader. If not provided, an instance of `GLTFLoader` will be used to load models. |
| [onLoad] | <code>function</code> | <code></code> | A callback that is executed when a controller model has been loaded. |

<a name="XRHandMeshModel+controller"></a>

### xrHandMeshModel.controller : <code>Group</code>
The WebXR controller.

**Kind**: instance property of [<code>XRHandMeshModel</code>](#XRHandMeshModel)  
<a name="XRHandMeshModel+handModel"></a>

### xrHandMeshModel.handModel : <code>XRHandModel</code>
The hand model.

**Kind**: instance property of [<code>XRHandMeshModel</code>](#XRHandMeshModel)  
<a name="XRHandMeshModel+bones"></a>

### xrHandMeshModel.bones : <code>Array.&lt;Bone&gt;</code>
An array of bones representing the bones
of the hand skeleton.

**Kind**: instance property of [<code>XRHandMeshModel</code>](#XRHandMeshModel)  
<a name="XRHandMeshModel+updateMesh"></a>

### xrHandMeshModel.updateMesh()
Updates the mesh based on the tracked XR joints data.

**Kind**: instance method of [<code>XRHandMeshModel</code>](#XRHandMeshModel)  
## Classes

<dl>
<dt><a href="#XRHandModel">XRHandModel</a> ⇐ <code>Object3D</code></dt>
<dd><p>Represents a XR hand model.</p>
</dd>
<dt><a href="#XRHandModelFactory">XRHandModelFactory</a></dt>
<dd><p>Similar to <a href="XRControllerModelFactory">XRControllerModelFactory</a>, this class allows to create hand models
for WebXR controllers that can be added as a visual representation to your scene.</p>
<pre><code class="language-js">const handModelFactory = new XRHandModelFactory();

const hand = renderer.xr.getHand( 0 );
hand.add( handModelFactory.createHandModel( hand ) );
scene.add( hand );
</code></pre>
</dd>
</dl>

<a name="XRHandModel"></a>

## XRHandModel ⇐ <code>Object3D</code>
Represents a XR hand model.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [XRHandModel](#XRHandModel) ⇐ <code>Object3D</code>
    * [new XRHandModel(controller)](#new_XRHandModel_new)
    * [.controller](#XRHandModel+controller) : <code>Group</code>
    * [.motionController](#XRHandModel+motionController) : <code>MotionController</code>
    * [.envMap](#XRHandModel+envMap) : <code>Texture</code>
    * [.mesh](#XRHandModel+mesh) : <code>Mesh</code>
    * [.updateMatrixWorld([force])](#XRHandModel+updateMatrixWorld)

<a name="new_XRHandModel_new"></a>

### new XRHandModel(controller)
Constructs a new XR hand model.


| Param | Type | Description |
| --- | --- | --- |
| controller | <code>Group</code> | The hand controller. |

<a name="XRHandModel+controller"></a>

### xrHandModel.controller : <code>Group</code>
The hand controller.

**Kind**: instance property of [<code>XRHandModel</code>](#XRHandModel)  
<a name="XRHandModel+motionController"></a>

### xrHandModel.motionController : <code>MotionController</code>
The motion controller.

**Kind**: instance property of [<code>XRHandModel</code>](#XRHandModel)  
**Default**: <code>null</code>  
<a name="XRHandModel+envMap"></a>

### xrHandModel.envMap : <code>Texture</code>
The controller's environment map.

**Kind**: instance property of [<code>XRHandModel</code>](#XRHandModel)  
**Default**: <code>null</code>  
<a name="XRHandModel+mesh"></a>

### xrHandModel.mesh : <code>Mesh</code>
The model mesh.

**Kind**: instance property of [<code>XRHandModel</code>](#XRHandModel)  
**Default**: <code>null</code>  
<a name="XRHandModel+updateMatrixWorld"></a>

### xrHandModel.updateMatrixWorld([force])
Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.

**Kind**: instance method of [<code>XRHandModel</code>](#XRHandModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [Object3D#matrixWorldAutoUpdate](Object3D#matrixWorldAutoUpdate) is set to `false`. |

<a name="XRHandModelFactory"></a>

## XRHandModelFactory
Similar to [XRControllerModelFactory](XRControllerModelFactory), this class allows to create hand models
for WebXR controllers that can be added as a visual representation to your scene.

```js
const handModelFactory = new XRHandModelFactory();

const hand = renderer.xr.getHand( 0 );
hand.add( handModelFactory.createHandModel( hand ) );
scene.add( hand );
```

**Kind**: global class  

* [XRHandModelFactory](#XRHandModelFactory)
    * [new XRHandModelFactory([gltfLoader], [onLoad])](#new_XRHandModelFactory_new)
    * [.gltfLoader](#XRHandModelFactory+gltfLoader) : <code>GLTFLoader</code>
    * [.path](#XRHandModelFactory+path) : <code>string</code>
    * [.onLoad](#XRHandModelFactory+onLoad) : <code>function</code>
    * [.setPath(path)](#XRHandModelFactory+setPath) ⇒ [<code>XRHandModelFactory</code>](#XRHandModelFactory)
    * [.createHandModel(controller, [profile])](#XRHandModelFactory+createHandModel) ⇒ [<code>XRHandModel</code>](#XRHandModel)

<a name="new_XRHandModelFactory_new"></a>

### new XRHandModelFactory([gltfLoader], [onLoad])
Constructs a new XR hand model factory.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [gltfLoader] | <code>GLTFLoader</code> | <code></code> | A glTF loader that is used to load hand models. |
| [onLoad] | <code>function</code> | <code></code> | A callback that is executed when a hand model has been loaded. |

<a name="XRHandModelFactory+gltfLoader"></a>

### xrHandModelFactory.gltfLoader : <code>GLTFLoader</code>
A glTF loader that is used to load hand models.

**Kind**: instance property of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Default**: <code>null</code>  
<a name="XRHandModelFactory+path"></a>

### xrHandModelFactory.path : <code>string</code>
The path to the model repository.

**Kind**: instance property of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Default**: <code>&quot;null&quot;</code>  
<a name="XRHandModelFactory+onLoad"></a>

### xrHandModelFactory.onLoad : <code>function</code>
A callback that is executed when a hand model has been loaded.

**Kind**: instance property of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Default**: <code>null</code>  
<a name="XRHandModelFactory+setPath"></a>

### xrHandModelFactory.setPath(path) ⇒ [<code>XRHandModelFactory</code>](#XRHandModelFactory)
Sets the path to the hand model repository.

**Kind**: instance method of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Returns**: [<code>XRHandModelFactory</code>](#XRHandModelFactory) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The path to set. |

<a name="XRHandModelFactory+createHandModel"></a>

### xrHandModelFactory.createHandModel(controller, [profile]) ⇒ [<code>XRHandModel</code>](#XRHandModel)
Creates a controller model for the given WebXR hand controller.

**Kind**: instance method of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Returns**: [<code>XRHandModel</code>](#XRHandModel) - The XR hand model.  

| Param | Type | Description |
| --- | --- | --- |
| controller | <code>Group</code> | The hand controller. |
| [profile] | <code>&#x27;spheres&#x27;</code> \| <code>&#x27;boxes&#x27;</code> \| <code>&#x27;mesh&#x27;</code> | The model profile that defines the model type. |

<a name="XRHandPrimitiveModel"></a>

## XRHandPrimitiveModel
Represents one of the hand model types [XRHandModelFactory](XRHandModelFactory) might produce
depending on the selected profile. `XRHandPrimitiveModel` represents a hand
with sphere or box primitives according to the selected `primitive` option.

**Kind**: global class  

* [XRHandPrimitiveModel](#XRHandPrimitiveModel)
    * [new XRHandPrimitiveModel(handModel, controller, path, handedness, options)](#new_XRHandPrimitiveModel_new)
    * _instance_
        * [.controller](#XRHandPrimitiveModel+controller) : <code>Group</code>
        * [.handModel](#XRHandPrimitiveModel+handModel) : <code>XRHandModel</code>
        * [.envMap](#XRHandPrimitiveModel+envMap) : <code>Texture</code>
        * [.updateMesh()](#XRHandPrimitiveModel+updateMesh)
    * _inner_
        * [~Options](#XRHandPrimitiveModel..Options) : <code>Object</code>

<a name="new_XRHandPrimitiveModel_new"></a>

### new XRHandPrimitiveModel(handModel, controller, path, handedness, options)
Constructs a new XR hand primitive model.


| Param | Type | Description |
| --- | --- | --- |
| handModel | <code>XRHandModel</code> | The hand model. |
| controller | <code>Group</code> | The WebXR controller. |
| path | <code>string</code> | The model path. |
| handedness | <code>XRHandedness</code> | The handedness of the XR input source. |
| options | [<code>Options</code>](#XRHandPrimitiveModel..Options) | The model options. |

<a name="XRHandPrimitiveModel+controller"></a>

### xrHandPrimitiveModel.controller : <code>Group</code>
The WebXR controller.

**Kind**: instance property of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
<a name="XRHandPrimitiveModel+handModel"></a>

### xrHandPrimitiveModel.handModel : <code>XRHandModel</code>
The hand model.

**Kind**: instance property of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
<a name="XRHandPrimitiveModel+envMap"></a>

### xrHandPrimitiveModel.envMap : <code>Texture</code>
The model's environment map.

**Kind**: instance property of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
**Default**: <code>null</code>  
<a name="XRHandPrimitiveModel+updateMesh"></a>

### xrHandPrimitiveModel.updateMesh()
Updates the mesh based on the tracked XR joints data.

**Kind**: instance method of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
<a name="XRHandPrimitiveModel..Options"></a>

### XRHandPrimitiveModel~Options : <code>Object</code>
Constructor options of `XRHandPrimitiveModel`.

**Kind**: inner typedef of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [primitive] | <code>&#x27;box&#x27;</code> \| <code>&#x27;sphere&#x27;</code> | The primitive type. |

<a name="XRPlanes"></a>

## XRPlanes ⇐ <code>Object3D</code>
A utility class for the WebXR Plane Detection Module. If planes
are detected by WebXR, this class will automatically add them
as thin box meshes to the scene when below code snippet is used.

```js
const planes = new XRPlanes( renderer );
scene.add( planes );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  
<a name="new_XRPlanes_new"></a>

### new XRPlanes(renderer)
Constructs a new XR plane container.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> \| <code>WebGPURenderer</code> | The renderer. |

<a name="AnimationAction"></a>

## AnimationAction
An instance of `AnimationAction` schedules the playback of an animation which is
stored in [AnimationClip](AnimationClip).

**Kind**: global class  

* [AnimationAction](#AnimationAction)
    * [new AnimationAction(mixer, clip, [localRoot], [blendMode])](#new_AnimationAction_new)
    * [.blendMode](#AnimationAction+blendMode) : <code>NormalAnimationBlendMode</code> \| <code>AdditiveAnimationBlendMode</code>
    * [.loop](#AnimationAction+loop) : <code>LoopRepeat</code> \| <code>LoopOnce</code> \| <code>LoopPingPong</code>
    * [.time](#AnimationAction+time) : <code>number</code>
    * [.timeScale](#AnimationAction+timeScale) : <code>number</code>
    * [.weight](#AnimationAction+weight) : <code>number</code>
    * [.repetitions](#AnimationAction+repetitions) : <code>number</code>
    * [.paused](#AnimationAction+paused) : <code>boolean</code>
    * [.enabled](#AnimationAction+enabled) : <code>boolean</code>
    * [.clampWhenFinished](#AnimationAction+clampWhenFinished) : <code>boolean</code>
    * [.zeroSlopeAtStart](#AnimationAction+zeroSlopeAtStart) : <code>boolean</code>
    * [.zeroSlopeAtEnd](#AnimationAction+zeroSlopeAtEnd) : <code>boolean</code>
    * [.play()](#AnimationAction+play) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.stop()](#AnimationAction+stop) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.reset()](#AnimationAction+reset) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.isRunning()](#AnimationAction+isRunning) ⇒ <code>boolean</code>
    * [.isScheduled()](#AnimationAction+isScheduled) ⇒ <code>boolean</code>
    * [.startAt(time)](#AnimationAction+startAt) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.setLoop(mode, repetitions)](#AnimationAction+setLoop) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.setEffectiveWeight(weight)](#AnimationAction+setEffectiveWeight) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.getEffectiveWeight()](#AnimationAction+getEffectiveWeight) ⇒ <code>number</code>
    * [.fadeIn(duration)](#AnimationAction+fadeIn) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.fadeOut(duration)](#AnimationAction+fadeOut) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.crossFadeFrom(fadeOutAction, duration, [warp])](#AnimationAction+crossFadeFrom) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.crossFadeTo(fadeInAction, duration, [warp])](#AnimationAction+crossFadeTo) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.stopFading()](#AnimationAction+stopFading) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.setEffectiveTimeScale(timeScale)](#AnimationAction+setEffectiveTimeScale) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.getEffectiveTimeScale()](#AnimationAction+getEffectiveTimeScale) ⇒ <code>number</code>
    * [.setDuration(duration)](#AnimationAction+setDuration) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.syncWith(action)](#AnimationAction+syncWith) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.halt(duration)](#AnimationAction+halt) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.warp(startTimeScale, endTimeScale, duration)](#AnimationAction+warp) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.stopWarping()](#AnimationAction+stopWarping) ⇒ [<code>AnimationAction</code>](#AnimationAction)
    * [.getMixer()](#AnimationAction+getMixer) ⇒ <code>AnimationMixer</code>
    * [.getClip()](#AnimationAction+getClip) ⇒ <code>AnimationClip</code>
    * [.getRoot()](#AnimationAction+getRoot) ⇒ <code>Object3D</code>

<a name="new_AnimationAction_new"></a>

### new AnimationAction(mixer, clip, [localRoot], [blendMode])
Constructs a new animation action.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mixer | <code>AnimationMixer</code> |  | The mixer that is controlled by this action. |
| clip | <code>AnimationClip</code> |  | The animation clip that holds the actual keyframes. |
| [localRoot] | <code>Object3D</code> | <code></code> | The root object on which this action is performed. |
| [blendMode] | <code>NormalAnimationBlendMode</code> \| <code>AdditiveAnimationBlendMode</code> |  | The blend mode. |

<a name="AnimationAction+blendMode"></a>

### animationAction.blendMode : <code>NormalAnimationBlendMode</code> \| <code>AdditiveAnimationBlendMode</code>
Defines how the animation is blended/combined when two or more animations
are simultaneously played.

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
<a name="AnimationAction+loop"></a>

### animationAction.loop : <code>LoopRepeat</code> \| <code>LoopOnce</code> \| <code>LoopPingPong</code>
The loop mode, set via [setLoop](#AnimationAction+setLoop).

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>LoopRepeat</code>  
<a name="AnimationAction+time"></a>

### animationAction.time : <code>number</code>
The local time of this action (in seconds, starting with `0`).

The value gets clamped or wrapped to `[0,clip.duration]` (according to the
loop state).

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>Infinity</code>  
<a name="AnimationAction+timeScale"></a>

### animationAction.timeScale : <code>number</code>
Scaling factor for the [time](#AnimationAction+time). A value of `0` causes the
animation to pause. Negative values cause the animation to play backwards.

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>1</code>  
<a name="AnimationAction+weight"></a>

### animationAction.weight : <code>number</code>
The degree of influence of this action (in the interval `[0, 1]`). Values
between `0` (no impact) and `1` (full impact) can be used to blend between
several actions.

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>1</code>  
<a name="AnimationAction+repetitions"></a>

### animationAction.repetitions : <code>number</code>
The number of repetitions of the performed clip over the course of this action.
Can be set via [setLoop](#AnimationAction+setLoop).

Setting this number has no effect if [loop](#AnimationAction+loop) is set to
`THREE:LoopOnce`.

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>Infinity</code>  
<a name="AnimationAction+paused"></a>

### animationAction.paused : <code>boolean</code>
If set to `true`, the playback of the action is paused.

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>false</code>  
<a name="AnimationAction+enabled"></a>

### animationAction.enabled : <code>boolean</code>
If set to `false`, the action is disabled so it has no impact.

When the action is re-enabled, the animation continues from its current
time (setting `enabled` to `false` doesn't reset the action).

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>true</code>  
<a name="AnimationAction+clampWhenFinished"></a>

### animationAction.clampWhenFinished : <code>boolean</code>
If set to true the animation will automatically be paused on its last frame.

If set to false, [enabled](#AnimationAction+enabled) will automatically be switched
to `false` when the last loop of the action has finished, so that this action has
no further impact.

Note: This member has no impact if the action is interrupted (it
has only an effect if its last loop has really finished).

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>false</code>  
<a name="AnimationAction+zeroSlopeAtStart"></a>

### animationAction.zeroSlopeAtStart : <code>boolean</code>
Enables smooth interpolation without separate clips for start, loop and end.

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>true</code>  
<a name="AnimationAction+zeroSlopeAtEnd"></a>

### animationAction.zeroSlopeAtEnd : <code>boolean</code>
Enables smooth interpolation without separate clips for start, loop and end.

**Kind**: instance property of [<code>AnimationAction</code>](#AnimationAction)  
**Default**: <code>true</code>  
<a name="AnimationAction+play"></a>

### animationAction.play() ⇒ [<code>AnimationAction</code>](#AnimationAction)
Starts the playback of the animation.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  
<a name="AnimationAction+stop"></a>

### animationAction.stop() ⇒ [<code>AnimationAction</code>](#AnimationAction)
Stops the playback of the animation.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  
<a name="AnimationAction+reset"></a>

### animationAction.reset() ⇒ [<code>AnimationAction</code>](#AnimationAction)
Resets the playback of the animation.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  
<a name="AnimationAction+isRunning"></a>

### animationAction.isRunning() ⇒ <code>boolean</code>
Returns `true` if the animation is running.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: <code>boolean</code> - Whether the animation is running or not.  
<a name="AnimationAction+isScheduled"></a>

### animationAction.isScheduled() ⇒ <code>boolean</code>
Returns `true` when [play](#AnimationAction+play) has been called.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: <code>boolean</code> - Whether the animation is scheduled or not.  
<a name="AnimationAction+startAt"></a>

### animationAction.startAt(time) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Defines the time when the animation should start.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| time | <code>number</code> | The start time in seconds. |

<a name="AnimationAction+setLoop"></a>

### animationAction.setLoop(mode, repetitions) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Configures the loop settings for this action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| mode | <code>LoopRepeat</code> \| <code>LoopOnce</code> \| <code>LoopPingPong</code> | The loop mode. |
| repetitions | <code>number</code> | The number of repetitions. |

<a name="AnimationAction+setEffectiveWeight"></a>

### animationAction.setEffectiveWeight(weight) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Sets the effective weight of this action.

An action has no effect and thus an effective weight of zero when the
action is disabled.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| weight | <code>number</code> | The weight to set. |

<a name="AnimationAction+getEffectiveWeight"></a>

### animationAction.getEffectiveWeight() ⇒ <code>number</code>
Returns the effective weight of this action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: <code>number</code> - The effective weight.  
<a name="AnimationAction+fadeIn"></a>

### animationAction.fadeIn(duration) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Fades the animation in by increasing its weight gradually from `0` to `1`,
within the passed time interval.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| duration | <code>number</code> | The duration of the fade. |

<a name="AnimationAction+fadeOut"></a>

### animationAction.fadeOut(duration) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Fades the animation out by decreasing its weight gradually from `1` to `0`,
within the passed time interval.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| duration | <code>number</code> | The duration of the fade. |

<a name="AnimationAction+crossFadeFrom"></a>

### animationAction.crossFadeFrom(fadeOutAction, duration, [warp]) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Causes this action to fade in and the given action to fade out,
within the passed time interval.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| fadeOutAction | [<code>AnimationAction</code>](#AnimationAction) |  | The animation action to fade out. |
| duration | <code>number</code> |  | The duration of the fade. |
| [warp] | <code>boolean</code> | <code>false</code> | Whether warping should be used or not. |

<a name="AnimationAction+crossFadeTo"></a>

### animationAction.crossFadeTo(fadeInAction, duration, [warp]) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Causes this action to fade out and the given action to fade in,
within the passed time interval.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| fadeInAction | [<code>AnimationAction</code>](#AnimationAction) |  | The animation action to fade in. |
| duration | <code>number</code> |  | The duration of the fade. |
| [warp] | <code>boolean</code> | <code>false</code> | Whether warping should be used or not. |

<a name="AnimationAction+stopFading"></a>

### animationAction.stopFading() ⇒ [<code>AnimationAction</code>](#AnimationAction)
Stops any fading which is applied to this action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  
<a name="AnimationAction+setEffectiveTimeScale"></a>

### animationAction.setEffectiveTimeScale(timeScale) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Sets the effective time scale of this action.

An action has no effect and thus an effective time scale of zero when the
action is paused.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| timeScale | <code>number</code> | The time scale to set. |

<a name="AnimationAction+getEffectiveTimeScale"></a>

### animationAction.getEffectiveTimeScale() ⇒ <code>number</code>
Returns the effective time scale of this action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: <code>number</code> - The effective time scale.  
<a name="AnimationAction+setDuration"></a>

### animationAction.setDuration(duration) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Sets the duration for a single loop of this action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| duration | <code>number</code> | The duration to set. |

<a name="AnimationAction+syncWith"></a>

### animationAction.syncWith(action) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Synchronizes this action with the passed other action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| action | [<code>AnimationAction</code>](#AnimationAction) | The action to sync with. |

<a name="AnimationAction+halt"></a>

### animationAction.halt(duration) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Decelerates this animation's speed to `0` within the passed time interval.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| duration | <code>number</code> | The duration. |

<a name="AnimationAction+warp"></a>

### animationAction.warp(startTimeScale, endTimeScale, duration) ⇒ [<code>AnimationAction</code>](#AnimationAction)
Changes the playback speed, within the passed time interval, by modifying
[timeScale](#AnimationAction+timeScale) gradually from `startTimeScale` to
`endTimeScale`.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  

| Param | Type | Description |
| --- | --- | --- |
| startTimeScale | <code>number</code> | The start time scale. |
| endTimeScale | <code>number</code> | The end time scale. |
| duration | <code>number</code> | The duration. |

<a name="AnimationAction+stopWarping"></a>

### animationAction.stopWarping() ⇒ [<code>AnimationAction</code>](#AnimationAction)
Stops any scheduled warping which is applied to this action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: [<code>AnimationAction</code>](#AnimationAction) - A reference to this animation action.  
<a name="AnimationAction+getMixer"></a>

### animationAction.getMixer() ⇒ <code>AnimationMixer</code>
Returns the animation mixer of this animation action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: <code>AnimationMixer</code> - The animation mixer.  
<a name="AnimationAction+getClip"></a>

### animationAction.getClip() ⇒ <code>AnimationClip</code>
Returns the animation clip of this animation action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: <code>AnimationClip</code> - The animation clip.  
<a name="AnimationAction+getRoot"></a>

### animationAction.getRoot() ⇒ <code>Object3D</code>
Returns the root object of this animation action.

**Kind**: instance method of [<code>AnimationAction</code>](#AnimationAction)  
**Returns**: <code>Object3D</code> - The root object.  
<a name="AnimationClip"></a>

## AnimationClip
A reusable set of keyframe tracks which represent an animation.

**Kind**: global class  

* [AnimationClip](#AnimationClip)
    * [new AnimationClip([name], [duration], tracks, [blendMode])](#new_AnimationClip_new)
    * _instance_
        * [.name](#AnimationClip+name) : <code>string</code>
        * [.tracks](#AnimationClip+tracks) : <code>Array.&lt;KeyframeTrack&gt;</code>
        * [.duration](#AnimationClip+duration) : <code>number</code>
        * [.blendMode](#AnimationClip+blendMode) : <code>NormalAnimationBlendMode</code> \| <code>AdditiveAnimationBlendMode</code>
        * [.uuid](#AnimationClip+uuid) : <code>string</code>
        * [.resetDuration()](#AnimationClip+resetDuration) ⇒ [<code>AnimationClip</code>](#AnimationClip)
        * [.trim()](#AnimationClip+trim) ⇒ [<code>AnimationClip</code>](#AnimationClip)
        * [.validate()](#AnimationClip+validate) ⇒ <code>boolean</code>
        * [.optimize()](#AnimationClip+optimize) ⇒ [<code>AnimationClip</code>](#AnimationClip)
        * [.clone()](#AnimationClip+clone) ⇒ [<code>AnimationClip</code>](#AnimationClip)
        * [.toJSON()](#AnimationClip+toJSON) ⇒ <code>Object</code>
    * _static_
        * [.parse(json)](#AnimationClip.parse) ⇒ [<code>AnimationClip</code>](#AnimationClip)
        * [.toJSON(clip)](#AnimationClip.toJSON) ⇒ <code>Object</code>
        * [.CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop)](#AnimationClip.CreateFromMorphTargetSequence) ⇒ [<code>AnimationClip</code>](#AnimationClip)
        * [.findByName(objectOrClipArray, name)](#AnimationClip.findByName) ⇒ [<code>AnimationClip</code>](#AnimationClip)
        * [.CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop)](#AnimationClip.CreateClipsFromMorphTargetSequences) ⇒ [<code>Array.&lt;AnimationClip&gt;</code>](#AnimationClip)
        * ~~[.parseAnimation(animation, bones)](#AnimationClip.parseAnimation) ⇒ [<code>AnimationClip</code>](#AnimationClip)~~

<a name="new_AnimationClip_new"></a>

### new AnimationClip([name], [duration], tracks, [blendMode])
Constructs a new animation clip.

Note: Instead of instantiating an AnimationClip directly with the constructor, you can
use the static interface of this class for creating clips. In most cases though, animation clips
will automatically be created by loaders when importing animated 3D assets.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The clip's name. |
| [duration] | <code>number</code> | <code>-1</code> | The clip's duration in seconds. If a negative value is passed, the duration will be calculated from the passed keyframes. |
| tracks | <code>Array.&lt;KeyframeTrack&gt;</code> |  | An array of keyframe tracks. |
| [blendMode] | <code>NormalAnimationBlendMode</code> \| <code>AdditiveAnimationBlendMode</code> | <code>NormalAnimationBlendMode</code> | Defines how the animation is blended/combined when two or more animations are simultaneously played. |

<a name="AnimationClip+name"></a>

### animationClip.name : <code>string</code>
The clip's name.

**Kind**: instance property of [<code>AnimationClip</code>](#AnimationClip)  
<a name="AnimationClip+tracks"></a>

### animationClip.tracks : <code>Array.&lt;KeyframeTrack&gt;</code>
An array of keyframe tracks.

**Kind**: instance property of [<code>AnimationClip</code>](#AnimationClip)  
<a name="AnimationClip+duration"></a>

### animationClip.duration : <code>number</code>
The clip's duration in seconds.

**Kind**: instance property of [<code>AnimationClip</code>](#AnimationClip)  
<a name="AnimationClip+blendMode"></a>

### animationClip.blendMode : <code>NormalAnimationBlendMode</code> \| <code>AdditiveAnimationBlendMode</code>
Defines how the animation is blended/combined when two or more animations
are simultaneously played.

**Kind**: instance property of [<code>AnimationClip</code>](#AnimationClip)  
<a name="AnimationClip+uuid"></a>

### animationClip.uuid : <code>string</code>
The UUID of the animation clip.

**Kind**: instance property of [<code>AnimationClip</code>](#AnimationClip)  
**Read only**: true  
<a name="AnimationClip+resetDuration"></a>

### animationClip.resetDuration() ⇒ [<code>AnimationClip</code>](#AnimationClip)
Sets the duration of this clip to the duration of its longest keyframe track.

**Kind**: instance method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>AnimationClip</code>](#AnimationClip) - A reference to this animation clip.  
<a name="AnimationClip+trim"></a>

### animationClip.trim() ⇒ [<code>AnimationClip</code>](#AnimationClip)
Trims all tracks to the clip's duration.

**Kind**: instance method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>AnimationClip</code>](#AnimationClip) - A reference to this animation clip.  
<a name="AnimationClip+validate"></a>

### animationClip.validate() ⇒ <code>boolean</code>
Performs minimal validation on each track in the clip. Returns `true` if all
tracks are valid.

**Kind**: instance method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: <code>boolean</code> - Whether the clip's keyframes are valid or not.  
<a name="AnimationClip+optimize"></a>

### animationClip.optimize() ⇒ [<code>AnimationClip</code>](#AnimationClip)
Optimizes each track by removing equivalent sequential keys (which are
common in morph target sequences).

**Kind**: instance method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>AnimationClip</code>](#AnimationClip) - A reference to this animation clip.  
<a name="AnimationClip+clone"></a>

### animationClip.clone() ⇒ [<code>AnimationClip</code>](#AnimationClip)
Returns a new animation clip with copied values from this instance.

**Kind**: instance method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>AnimationClip</code>](#AnimationClip) - A clone of this instance.  
<a name="AnimationClip+toJSON"></a>

### animationClip.toJSON() ⇒ <code>Object</code>
Serializes this animation clip into JSON.

**Kind**: instance method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: <code>Object</code> - The JSON object.  
<a name="AnimationClip.parse"></a>

### AnimationClip.parse(json) ⇒ [<code>AnimationClip</code>](#AnimationClip)
Factory method for creating an animation clip from the given JSON.

**Kind**: static method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>AnimationClip</code>](#AnimationClip) - The new animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized animation clip. |

<a name="AnimationClip.toJSON"></a>

### AnimationClip.toJSON(clip) ⇒ <code>Object</code>
Serializes the given animation clip into JSON.

**Kind**: static method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: <code>Object</code> - The JSON object.  

| Param | Type | Description |
| --- | --- | --- |
| clip | [<code>AnimationClip</code>](#AnimationClip) | The animation clip to serialize. |

<a name="AnimationClip.CreateFromMorphTargetSequence"></a>

### AnimationClip.CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) ⇒ [<code>AnimationClip</code>](#AnimationClip)
Returns a new animation clip from the passed morph targets array of a
geometry, taking a name and the number of frames per second.

Note: The fps parameter is required, but the animation speed can be
overridden via [AnimationAction#setDuration](AnimationAction#setDuration).

**Kind**: static method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>AnimationClip</code>](#AnimationClip) - The new animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the animation clip. |
| morphTargetSequence | <code>Array.&lt;Object&gt;</code> | A sequence of morph targets. |
| fps | <code>number</code> | The Frames-Per-Second value. |
| noLoop | <code>boolean</code> | Whether the clip should be no loop or not. |

<a name="AnimationClip.findByName"></a>

### AnimationClip.findByName(objectOrClipArray, name) ⇒ [<code>AnimationClip</code>](#AnimationClip)
Searches for an animation clip by name, taking as its first parameter
either an array of clips, or a mesh or geometry that contains an
array named "animations" property.

**Kind**: static method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>AnimationClip</code>](#AnimationClip) - The found animation clip. Returns `null` if no clip has been found.  

| Param | Type | Description |
| --- | --- | --- |
| objectOrClipArray | [<code>Array.&lt;AnimationClip&gt;</code>](#AnimationClip) \| <code>Object3D</code> | The array or object to search through. |
| name | <code>string</code> | The name to search for. |

<a name="AnimationClip.CreateClipsFromMorphTargetSequences"></a>

### AnimationClip.CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) ⇒ [<code>Array.&lt;AnimationClip&gt;</code>](#AnimationClip)
Returns an array of new AnimationClips created from the morph target
sequences of a geometry, trying to sort morph target names into
animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".

See [MD2Loader#parse](MD2Loader#parse) as an example for how the method should be used.

**Kind**: static method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>Array.&lt;AnimationClip&gt;</code>](#AnimationClip) - An array of new animation clips.  

| Param | Type | Description |
| --- | --- | --- |
| morphTargets | <code>Array.&lt;Object&gt;</code> | A sequence of morph targets. |
| fps | <code>number</code> | The Frames-Per-Second value. |
| noLoop | <code>boolean</code> | Whether the clip should be no loop or not. |

<a name="AnimationClip.parseAnimation"></a>

### ~~AnimationClip.parseAnimation(animation, bones) ⇒ [<code>AnimationClip</code>](#AnimationClip)~~
***since r175.***

Parses the `animation.hierarchy` format and returns a new animation clip.

**Kind**: static method of [<code>AnimationClip</code>](#AnimationClip)  
**Returns**: [<code>AnimationClip</code>](#AnimationClip) - The new animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| animation | <code>Object</code> | A serialized animation clip as JSON. |
| bones | <code>Array.&lt;Bones&gt;</code> | An array of bones. |

<a name="AnimationMixer"></a>

## AnimationMixer
`AnimationMixer` is a player for animations on a particular object in
the scene. When multiple objects in the scene are animated independently,
one `AnimationMixer` may be used for each object.

**Kind**: global class  

* [AnimationMixer](#AnimationMixer)
    * [new AnimationMixer(root)](#new_AnimationMixer_new)
    * [.time](#AnimationMixer+time) : <code>number</code>
    * [.timeScale](#AnimationMixer+timeScale) : <code>number</code>
    * [.clipAction(clip, [optionalRoot], [blendMode])](#AnimationMixer+clipAction) ⇒ <code>AnimationAction</code>
    * [.existingAction(clip, [optionalRoot])](#AnimationMixer+existingAction) ⇒ <code>AnimationAction</code>
    * [.stopAllAction()](#AnimationMixer+stopAllAction) ⇒ [<code>AnimationMixer</code>](#AnimationMixer)
    * [.update(deltaTime)](#AnimationMixer+update) ⇒ [<code>AnimationMixer</code>](#AnimationMixer)
    * [.setTime(time)](#AnimationMixer+setTime) ⇒ [<code>AnimationMixer</code>](#AnimationMixer)
    * [.getRoot()](#AnimationMixer+getRoot) ⇒ <code>Object3D</code>
    * [.uncacheClip(clip)](#AnimationMixer+uncacheClip)
    * [.uncacheRoot(root)](#AnimationMixer+uncacheRoot)
    * [.uncacheAction(clip, [optionalRoot])](#AnimationMixer+uncacheAction)

<a name="new_AnimationMixer_new"></a>

### new AnimationMixer(root)
Constructs a new animation mixer.


| Param | Type | Description |
| --- | --- | --- |
| root | <code>Object3D</code> | The object whose animations shall be played by this mixer. |

<a name="AnimationMixer+time"></a>

### animationMixer.time : <code>number</code>
The global mixer time (in seconds; starting with `0` on the mixer's creation).

**Kind**: instance property of [<code>AnimationMixer</code>](#AnimationMixer)  
**Default**: <code>0</code>  
<a name="AnimationMixer+timeScale"></a>

### animationMixer.timeScale : <code>number</code>
A scaling factor for the global time.

Note: Setting this member to `0` and later back to `1` is a
possibility to pause/unpause all actions that are controlled by this
mixer.

**Kind**: instance property of [<code>AnimationMixer</code>](#AnimationMixer)  
**Default**: <code>1</code>  
<a name="AnimationMixer+clipAction"></a>

### animationMixer.clipAction(clip, [optionalRoot], [blendMode]) ⇒ <code>AnimationAction</code>
Returns an instance of [AnimationAction](AnimationAction) for the passed clip.

If an action fitting the clip and root parameters doesn't yet exist, it
will be created by this method. Calling this method several times with the
same clip and root parameters always returns the same action.

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  
**Returns**: <code>AnimationAction</code> - The animation action.  

| Param | Type | Description |
| --- | --- | --- |
| clip | <code>AnimationClip</code> \| <code>string</code> | An animation clip or alternatively the name of the animation clip. |
| [optionalRoot] | <code>Object3D</code> | An alternative root object. |
| [blendMode] | <code>NormalAnimationBlendMode</code> \| <code>AdditiveAnimationBlendMode</code> | The blend mode. |

<a name="AnimationMixer+existingAction"></a>

### animationMixer.existingAction(clip, [optionalRoot]) ⇒ <code>AnimationAction</code>
Returns an existing animation action for the passed clip.

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  
**Returns**: <code>AnimationAction</code> - The animation action. Returns `null` if no action was found.  

| Param | Type | Description |
| --- | --- | --- |
| clip | <code>AnimationClip</code> \| <code>string</code> | An animation clip or alternatively the name of the animation clip. |
| [optionalRoot] | <code>Object3D</code> | An alternative root object. |

<a name="AnimationMixer+stopAllAction"></a>

### animationMixer.stopAllAction() ⇒ [<code>AnimationMixer</code>](#AnimationMixer)
Deactivates all previously scheduled actions on this mixer.

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  
**Returns**: [<code>AnimationMixer</code>](#AnimationMixer) - A reference to thi animation mixer.  
<a name="AnimationMixer+update"></a>

### animationMixer.update(deltaTime) ⇒ [<code>AnimationMixer</code>](#AnimationMixer)
Advances the global mixer time and updates the animation.

This is usually done in the render loop by passing the delta
time from [Clock](Clock) or [Timer](Timer).

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  
**Returns**: [<code>AnimationMixer</code>](#AnimationMixer) - A reference to thi animation mixer.  

| Param | Type | Description |
| --- | --- | --- |
| deltaTime | <code>number</code> | The delta time in seconds. |

<a name="AnimationMixer+setTime"></a>

### animationMixer.setTime(time) ⇒ [<code>AnimationMixer</code>](#AnimationMixer)
Sets the global mixer to a specific time and updates the animation accordingly.

This is useful when you need to jump to an exact time in an animation. The
input parameter will be scaled by [timeScale](#AnimationMixer+timeScale)

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  
**Returns**: [<code>AnimationMixer</code>](#AnimationMixer) - A reference to thi animation mixer.  

| Param | Type | Description |
| --- | --- | --- |
| time | <code>number</code> | The time to set in seconds. |

<a name="AnimationMixer+getRoot"></a>

### animationMixer.getRoot() ⇒ <code>Object3D</code>
Returns this mixer's root object.

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  
**Returns**: <code>Object3D</code> - The mixer's root object.  
<a name="AnimationMixer+uncacheClip"></a>

### animationMixer.uncacheClip(clip)
Deallocates all memory resources for a clip. Before using this method make
sure to call [AnimationAction#stop](AnimationAction#stop) for all related actions.

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  

| Param | Type | Description |
| --- | --- | --- |
| clip | <code>AnimationClip</code> | The clip to uncache. |

<a name="AnimationMixer+uncacheRoot"></a>

### animationMixer.uncacheRoot(root)
Deallocates all memory resources for a root object. Before using this
method make sure to call [AnimationAction#stop](AnimationAction#stop) for all related
actions or alternatively [stopAllAction](#AnimationMixer+stopAllAction) when the
mixer operates on a single root.

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  

| Param | Type | Description |
| --- | --- | --- |
| root | <code>Object3D</code> | The root object to uncache. |

<a name="AnimationMixer+uncacheAction"></a>

### animationMixer.uncacheAction(clip, [optionalRoot])
Deallocates all memory resources for an action. The action is identified by the
given clip and an optional root object. Before using this method make
sure to call [AnimationAction#stop](AnimationAction#stop) to deactivate the action.

**Kind**: instance method of [<code>AnimationMixer</code>](#AnimationMixer)  

| Param | Type | Description |
| --- | --- | --- |
| clip | <code>AnimationClip</code> \| <code>string</code> | An animation clip or alternatively the name of the animation clip. |
| [optionalRoot] | <code>Object3D</code> | An alternative root object. |

<a name="AnimationObjectGroup"></a>

## AnimationObjectGroup
A group of objects that receives a shared animation state.

Usage:

- Add objects you would otherwise pass as 'root' to the
constructor or the .clipAction method of AnimationMixer.
- Instead pass this object as 'root'.
- You can also add and remove objects later when the mixer is running.

Note:

- Objects of this class appear as one object to the mixer,
so cache control of the individual objects must be done on the group.

Limitation:

- The animated properties must be compatible among the all objects in the group.
- A single property can either be controlled through a target group or directly, but not both.

**Kind**: global class  

* [AnimationObjectGroup](#AnimationObjectGroup)
    * [new AnimationObjectGroup(...arguments)](#new_AnimationObjectGroup_new)
    * [.isAnimationObjectGroup](#AnimationObjectGroup+isAnimationObjectGroup) : <code>boolean</code>
    * [.uuid](#AnimationObjectGroup+uuid) : <code>string</code>
    * [.add(...arguments)](#AnimationObjectGroup+add)
    * [.remove(...arguments)](#AnimationObjectGroup+remove)
    * [.uncache(...arguments)](#AnimationObjectGroup+uncache)

<a name="new_AnimationObjectGroup_new"></a>

### new AnimationObjectGroup(...arguments)
Constructs a new animation group.


| Param | Type | Description |
| --- | --- | --- |
| ...arguments | <code>Object3D</code> | An arbitrary number of 3D objects that share the same animation state. |

<a name="AnimationObjectGroup+isAnimationObjectGroup"></a>

### animationObjectGroup.isAnimationObjectGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>AnimationObjectGroup</code>](#AnimationObjectGroup)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="AnimationObjectGroup+uuid"></a>

### animationObjectGroup.uuid : <code>string</code>
The UUID of the 3D object.

**Kind**: instance property of [<code>AnimationObjectGroup</code>](#AnimationObjectGroup)  
**Read only**: true  
<a name="AnimationObjectGroup+add"></a>

### animationObjectGroup.add(...arguments)
Adds an arbitrary number of objects to this animation group.

**Kind**: instance method of [<code>AnimationObjectGroup</code>](#AnimationObjectGroup)  

| Param | Type | Description |
| --- | --- | --- |
| ...arguments | <code>Object3D</code> | The 3D objects to add. |

<a name="AnimationObjectGroup+remove"></a>

### animationObjectGroup.remove(...arguments)
Removes an arbitrary number of objects to this animation group

**Kind**: instance method of [<code>AnimationObjectGroup</code>](#AnimationObjectGroup)  

| Param | Type | Description |
| --- | --- | --- |
| ...arguments | <code>Object3D</code> | The 3D objects to remove. |

<a name="AnimationObjectGroup+uncache"></a>

### animationObjectGroup.uncache(...arguments)
Deallocates all memory resources for the passed 3D objects of this animation group.

**Kind**: instance method of [<code>AnimationObjectGroup</code>](#AnimationObjectGroup)  

| Param | Type | Description |
| --- | --- | --- |
| ...arguments | <code>Object3D</code> | The 3D objects to uncache. |

## Classes

<dl>
<dt><a href="#AnimationUtils">AnimationUtils</a></dt>
<dd><p>A class with various methods to assist with animations.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#convertArray">convertArray(array, type)</a> ⇒ <code>TypedArray</code></dt>
<dd><p>Converts an array to a specific type.</p>
</dd>
<dt><a href="#isTypedArray">isTypedArray(object)</a> ⇒ <code>boolean</code></dt>
<dd><p>Returns <code>true</code> if the given object is a typed array.</p>
</dd>
<dt><a href="#getKeyframeOrder">getKeyframeOrder(times)</a> ⇒ <code>Array.&lt;number&gt;</code></dt>
<dd><p>Returns an array by which times and values can be sorted.</p>
</dd>
<dt><a href="#sortedArray">sortedArray(values, stride, order)</a> ⇒ <code>Array.&lt;number&gt;</code></dt>
<dd><p>Sorts the given array by the previously computed order via <code>getKeyframeOrder()</code>.</p>
</dd>
<dt><a href="#flattenJSON">flattenJSON(jsonKeys, times, values, valuePropertyName)</a></dt>
<dd><p>Used for parsing AOS keyframe formats.</p>
</dd>
<dt><a href="#subclip">subclip(sourceClip, name, startFrame, endFrame, [fps])</a> ⇒ <code>AnimationClip</code></dt>
<dd><p>Creates a new clip, containing only the segment of the original clip between the given frames.</p>
</dd>
<dt><a href="#makeClipAdditive">makeClipAdditive(targetClip, [referenceFrame], [referenceClip], [fps])</a> ⇒ <code>AnimationClip</code></dt>
<dd><p>Converts the keyframes of the given animation clip to an additive format.</p>
</dd>
</dl>

<a name="AnimationUtils"></a>

## AnimationUtils
A class with various methods to assist with animations.

**Kind**: global class  

* [AnimationUtils](#AnimationUtils)
    * [.convertArray(array, type)](#AnimationUtils.convertArray) ⇒ <code>TypedArray</code>
    * [.isTypedArray(object)](#AnimationUtils.isTypedArray) ⇒ <code>boolean</code>
    * [.getKeyframeOrder(times)](#AnimationUtils.getKeyframeOrder) ⇒ <code>Array.&lt;number&gt;</code>
    * [.sortedArray(values, stride, order)](#AnimationUtils.sortedArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.flattenJSON(jsonKeys, times, values, valuePropertyName)](#AnimationUtils.flattenJSON)
    * [.subclip(sourceClip, name, startFrame, endFrame, [fps])](#AnimationUtils.subclip) ⇒ <code>AnimationClip</code>
    * [.makeClipAdditive(targetClip, [referenceFrame], [referenceClip], [fps])](#AnimationUtils.makeClipAdditive) ⇒ <code>AnimationClip</code>

<a name="AnimationUtils.convertArray"></a>

### AnimationUtils.convertArray(array, type) ⇒ <code>TypedArray</code>
Converts an array to a specific type

**Kind**: static method of [<code>AnimationUtils</code>](#AnimationUtils)  
**Returns**: <code>TypedArray</code> - The converted array  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to convert. |
| type | <code>TypedArray.constructor</code> | The constructor of a type array. |

<a name="AnimationUtils.isTypedArray"></a>

### AnimationUtils.isTypedArray(object) ⇒ <code>boolean</code>
Returns `true` if the given object is a typed array.

**Kind**: static method of [<code>AnimationUtils</code>](#AnimationUtils)  
**Returns**: <code>boolean</code> - Whether the given object is a typed array.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>any</code> | The object to check. |

<a name="AnimationUtils.getKeyframeOrder"></a>

### AnimationUtils.getKeyframeOrder(times) ⇒ <code>Array.&lt;number&gt;</code>
Returns an array by which times and values can be sorted.

**Kind**: static method of [<code>AnimationUtils</code>](#AnimationUtils)  
**Returns**: <code>Array.&lt;number&gt;</code> - The array.  

| Param | Type | Description |
| --- | --- | --- |
| times | <code>Array.&lt;number&gt;</code> | The keyframe time values. |

<a name="AnimationUtils.sortedArray"></a>

### AnimationUtils.sortedArray(values, stride, order) ⇒ <code>Array.&lt;number&gt;</code>
Sorts the given array by the previously computed order via `getKeyframeOrder()`.

**Kind**: static method of [<code>AnimationUtils</code>](#AnimationUtils)  
**Returns**: <code>Array.&lt;number&gt;</code> - The sorted values.  

| Param | Type | Description |
| --- | --- | --- |
| values | <code>Array.&lt;number&gt;</code> | The values to sort. |
| stride | <code>number</code> | The stride. |
| order | <code>Array.&lt;number&gt;</code> | The sort order. |

<a name="AnimationUtils.flattenJSON"></a>

### AnimationUtils.flattenJSON(jsonKeys, times, values, valuePropertyName)
Used for parsing AOS keyframe formats.

**Kind**: static method of [<code>AnimationUtils</code>](#AnimationUtils)  

| Param | Type | Description |
| --- | --- | --- |
| jsonKeys | <code>Array.&lt;number&gt;</code> | A list of JSON keyframes. |
| times | <code>Array.&lt;number&gt;</code> | This array will be filled with keyframe times by this method. |
| values | <code>Array.&lt;number&gt;</code> | This array will be filled with keyframe values by this method. |
| valuePropertyName | <code>string</code> | The name of the property to use. |

<a name="AnimationUtils.subclip"></a>

### AnimationUtils.subclip(sourceClip, name, startFrame, endFrame, [fps]) ⇒ <code>AnimationClip</code>
Creates a new clip, containing only the segment of the original clip between the given frames.

**Kind**: static method of [<code>AnimationUtils</code>](#AnimationUtils)  
**Returns**: <code>AnimationClip</code> - The new sub clip.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| sourceClip | <code>AnimationClip</code> |  | The values to sort. |
| name | <code>string</code> |  | The name of the clip. |
| startFrame | <code>number</code> |  | The start frame. |
| endFrame | <code>number</code> |  | The end frame. |
| [fps] | <code>number</code> | <code>30</code> | The FPS. |

<a name="AnimationUtils.makeClipAdditive"></a>

### AnimationUtils.makeClipAdditive(targetClip, [referenceFrame], [referenceClip], [fps]) ⇒ <code>AnimationClip</code>
Converts the keyframes of the given animation clip to an additive format.

**Kind**: static method of [<code>AnimationUtils</code>](#AnimationUtils)  
**Returns**: <code>AnimationClip</code> - The updated clip which is now additive.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| targetClip | <code>AnimationClip</code> |  | The clip to make additive. |
| [referenceFrame] | <code>number</code> | <code>0</code> | The reference frame. |
| [referenceClip] | <code>AnimationClip</code> | <code>targetClip</code> | The reference clip. |
| [fps] | <code>number</code> | <code>30</code> | The FPS. |

<a name="convertArray"></a>

## convertArray(array, type) ⇒ <code>TypedArray</code>
Converts an array to a specific type.

**Kind**: global function  
**Returns**: <code>TypedArray</code> - The converted array.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to convert. |
| type | <code>TypedArray.constructor</code> | The constructor of a typed array that defines the new type. |

<a name="isTypedArray"></a>

## isTypedArray(object) ⇒ <code>boolean</code>
Returns `true` if the given object is a typed array.

**Kind**: global function  
**Returns**: <code>boolean</code> - Whether the given object is a typed array.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>any</code> | The object to check. |

<a name="getKeyframeOrder"></a>

## getKeyframeOrder(times) ⇒ <code>Array.&lt;number&gt;</code>
Returns an array by which times and values can be sorted.

**Kind**: global function  
**Returns**: <code>Array.&lt;number&gt;</code> - The array.  

| Param | Type | Description |
| --- | --- | --- |
| times | <code>Array.&lt;number&gt;</code> | The keyframe time values. |

<a name="sortedArray"></a>

## sortedArray(values, stride, order) ⇒ <code>Array.&lt;number&gt;</code>
Sorts the given array by the previously computed order via `getKeyframeOrder()`.

**Kind**: global function  
**Returns**: <code>Array.&lt;number&gt;</code> - The sorted values.  

| Param | Type | Description |
| --- | --- | --- |
| values | <code>Array.&lt;number&gt;</code> | The values to sort. |
| stride | <code>number</code> | The stride. |
| order | <code>Array.&lt;number&gt;</code> | The sort order. |

<a name="flattenJSON"></a>

## flattenJSON(jsonKeys, times, values, valuePropertyName)
Used for parsing AOS keyframe formats.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| jsonKeys | <code>Array.&lt;number&gt;</code> | A list of JSON keyframes. |
| times | <code>Array.&lt;number&gt;</code> | This array will be filled with keyframe times by this function. |
| values | <code>Array.&lt;number&gt;</code> | This array will be filled with keyframe values by this function. |
| valuePropertyName | <code>string</code> | The name of the property to use. |

<a name="subclip"></a>

## subclip(sourceClip, name, startFrame, endFrame, [fps]) ⇒ <code>AnimationClip</code>
Creates a new clip, containing only the segment of the original clip between the given frames.

**Kind**: global function  
**Returns**: <code>AnimationClip</code> - The new sub clip.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| sourceClip | <code>AnimationClip</code> |  | The values to sort. |
| name | <code>string</code> |  | The name of the clip. |
| startFrame | <code>number</code> |  | The start frame. |
| endFrame | <code>number</code> |  | The end frame. |
| [fps] | <code>number</code> | <code>30</code> | The FPS. |

<a name="makeClipAdditive"></a>

## makeClipAdditive(targetClip, [referenceFrame], [referenceClip], [fps]) ⇒ <code>AnimationClip</code>
Converts the keyframes of the given animation clip to an additive format.

**Kind**: global function  
**Returns**: <code>AnimationClip</code> - The updated clip which is now additive.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| targetClip | <code>AnimationClip</code> |  | The clip to make additive. |
| [referenceFrame] | <code>number</code> | <code>0</code> | The reference frame. |
| [referenceClip] | <code>AnimationClip</code> | <code>targetClip</code> | The reference clip. |
| [fps] | <code>number</code> | <code>30</code> | The FPS. |

<a name="KeyframeTrack"></a>

## KeyframeTrack
Represents s a timed sequence of keyframes, which are composed of lists of
times and related values, and which are used to animate a specific property
of an object.

**Kind**: global class  

* [KeyframeTrack](#KeyframeTrack)
    * [new KeyframeTrack(name, times, values, [interpolation])](#new_KeyframeTrack_new)
    * _instance_
        * [.name](#KeyframeTrack+name) : <code>string</code>
        * [.times](#KeyframeTrack+times) : <code>Float32Array</code>
        * [.values](#KeyframeTrack+values) : <code>Float32Array</code>
        * [.ValueTypeName](#KeyframeTrack+ValueTypeName) : <code>String</code>
        * [.TimeBufferType](#KeyframeTrack+TimeBufferType) : <code>TypedArray</code> \| <code>Array</code>
        * [.ValueBufferType](#KeyframeTrack+ValueBufferType) : <code>TypedArray</code> \| <code>Array</code>
        * [.DefaultInterpolation](#KeyframeTrack+DefaultInterpolation) : <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code>
        * [.InterpolantFactoryMethodDiscrete([result])](#KeyframeTrack+InterpolantFactoryMethodDiscrete) ⇒ <code>DiscreteInterpolant</code>
        * [.InterpolantFactoryMethodLinear([result])](#KeyframeTrack+InterpolantFactoryMethodLinear) ⇒ <code>LinearInterpolant</code>
        * [.InterpolantFactoryMethodSmooth([result])](#KeyframeTrack+InterpolantFactoryMethodSmooth) ⇒ <code>CubicInterpolant</code>
        * [.setInterpolation(interpolation)](#KeyframeTrack+setInterpolation) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
        * [.getInterpolation()](#KeyframeTrack+getInterpolation) ⇒ <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code>
        * [.getValueSize()](#KeyframeTrack+getValueSize) ⇒ <code>number</code>
        * [.shift(timeOffset)](#KeyframeTrack+shift) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
        * [.scale(timeScale)](#KeyframeTrack+scale) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
        * [.trim(startTime, endTime)](#KeyframeTrack+trim) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
        * [.validate()](#KeyframeTrack+validate) ⇒ <code>boolean</code>
        * [.optimize()](#KeyframeTrack+optimize) ⇒ <code>AnimationClip</code>
        * [.clone()](#KeyframeTrack+clone) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
    * _static_
        * [.toJSON(track)](#KeyframeTrack.toJSON) ⇒ <code>Object</code>

<a name="new_KeyframeTrack_new"></a>

### new KeyframeTrack(name, times, values, [interpolation])
Constructs a new keyframe track.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The keyframe track's name. |
| times | <code>Array.&lt;number&gt;</code> | A list of keyframe times. |
| values | <code>Array.&lt;number&gt;</code> | A list of keyframe values. |
| [interpolation] | <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code> | The interpolation type. |

<a name="KeyframeTrack+name"></a>

### keyframeTrack.name : <code>string</code>
The track's name can refer to morph targets or bones or
possibly other values within an animated object. See [PropertyBinding#parseTrackName](PropertyBinding#parseTrackName)
for the forms of strings that can be parsed for property binding.

**Kind**: instance property of [<code>KeyframeTrack</code>](#KeyframeTrack)  
<a name="KeyframeTrack+times"></a>

### keyframeTrack.times : <code>Float32Array</code>
The keyframe times.

**Kind**: instance property of [<code>KeyframeTrack</code>](#KeyframeTrack)  
<a name="KeyframeTrack+values"></a>

### keyframeTrack.values : <code>Float32Array</code>
The keyframe values.

**Kind**: instance property of [<code>KeyframeTrack</code>](#KeyframeTrack)  
<a name="KeyframeTrack+ValueTypeName"></a>

### keyframeTrack.ValueTypeName : <code>String</code>
The value type name.

**Kind**: instance property of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Default**: <code>&#x27;&#x27;</code>  
<a name="KeyframeTrack+TimeBufferType"></a>

### keyframeTrack.TimeBufferType : <code>TypedArray</code> \| <code>Array</code>
The time buffer type of this keyframe track.

**Kind**: instance property of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Default**: <code>Float32Array.constructor</code>  
<a name="KeyframeTrack+ValueBufferType"></a>

### keyframeTrack.ValueBufferType : <code>TypedArray</code> \| <code>Array</code>
The value buffer type of this keyframe track.

**Kind**: instance property of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Default**: <code>Float32Array.constructor</code>  
<a name="KeyframeTrack+DefaultInterpolation"></a>

### keyframeTrack.DefaultInterpolation : <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code>
The default interpolation type of this keyframe track.

**Kind**: instance property of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Default**: <code>InterpolateLinear</code>  
<a name="KeyframeTrack+InterpolantFactoryMethodDiscrete"></a>

### keyframeTrack.InterpolantFactoryMethodDiscrete([result]) ⇒ <code>DiscreteInterpolant</code>
Factory method for creating a new discrete interpolant.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: <code>DiscreteInterpolant</code> - The new interpolant.  

| Param | Type | Description |
| --- | --- | --- |
| [result] | <code>TypedArray</code> | The result buffer. |

<a name="KeyframeTrack+InterpolantFactoryMethodLinear"></a>

### keyframeTrack.InterpolantFactoryMethodLinear([result]) ⇒ <code>LinearInterpolant</code>
Factory method for creating a new linear interpolant.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: <code>LinearInterpolant</code> - The new interpolant.  

| Param | Type | Description |
| --- | --- | --- |
| [result] | <code>TypedArray</code> | The result buffer. |

<a name="KeyframeTrack+InterpolantFactoryMethodSmooth"></a>

### keyframeTrack.InterpolantFactoryMethodSmooth([result]) ⇒ <code>CubicInterpolant</code>
Factory method for creating a new smooth interpolant.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: <code>CubicInterpolant</code> - The new interpolant.  

| Param | Type | Description |
| --- | --- | --- |
| [result] | <code>TypedArray</code> | The result buffer. |

<a name="KeyframeTrack+setInterpolation"></a>

### keyframeTrack.setInterpolation(interpolation) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
Defines the interpolation factor method for this keyframe track.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: [<code>KeyframeTrack</code>](#KeyframeTrack) - A reference to this keyframe track.  

| Param | Type | Description |
| --- | --- | --- |
| interpolation | <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code> | The interpolation type. |

<a name="KeyframeTrack+getInterpolation"></a>

### keyframeTrack.getInterpolation() ⇒ <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code>
Returns the current interpolation type.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code> - The interpolation type.  
<a name="KeyframeTrack+getValueSize"></a>

### keyframeTrack.getValueSize() ⇒ <code>number</code>
Returns the value size.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: <code>number</code> - The value size.  
<a name="KeyframeTrack+shift"></a>

### keyframeTrack.shift(timeOffset) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
Moves all keyframes either forward or backward in time.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: [<code>KeyframeTrack</code>](#KeyframeTrack) - A reference to this keyframe track.  

| Param | Type | Description |
| --- | --- | --- |
| timeOffset | <code>number</code> | The offset to move the time values. |

<a name="KeyframeTrack+scale"></a>

### keyframeTrack.scale(timeScale) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
Scale all keyframe times by a factor (useful for frame - seconds conversions).

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: [<code>KeyframeTrack</code>](#KeyframeTrack) - A reference to this keyframe track.  

| Param | Type | Description |
| --- | --- | --- |
| timeScale | <code>number</code> | The time scale. |

<a name="KeyframeTrack+trim"></a>

### keyframeTrack.trim(startTime, endTime) ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
Removes keyframes before and after animation without changing any values within the defined time range.

Note: The method does not shift around keys to the start of the track time, because for interpolated
keys this will change their values

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: [<code>KeyframeTrack</code>](#KeyframeTrack) - A reference to this keyframe track.  

| Param | Type | Description |
| --- | --- | --- |
| startTime | <code>number</code> | The start time. |
| endTime | <code>number</code> | The end time. |

<a name="KeyframeTrack+validate"></a>

### keyframeTrack.validate() ⇒ <code>boolean</code>
Performs minimal validation on the keyframe track. Returns `true` if the values
are valid.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: <code>boolean</code> - Whether the keyframes are valid or not.  
<a name="KeyframeTrack+optimize"></a>

### keyframeTrack.optimize() ⇒ <code>AnimationClip</code>
Optimizes this keyframe track by removing equivalent sequential keys (which are
common in morph target sequences).

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: <code>AnimationClip</code> - A reference to this animation clip.  
<a name="KeyframeTrack+clone"></a>

### keyframeTrack.clone() ⇒ [<code>KeyframeTrack</code>](#KeyframeTrack)
Returns a new keyframe track with copied values from this instance.

**Kind**: instance method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: [<code>KeyframeTrack</code>](#KeyframeTrack) - A clone of this instance.  
<a name="KeyframeTrack.toJSON"></a>

### KeyframeTrack.toJSON(track) ⇒ <code>Object</code>
Converts the keyframe track to JSON.

**Kind**: static method of [<code>KeyframeTrack</code>](#KeyframeTrack)  
**Returns**: <code>Object</code> - The serialized keyframe track as JSON.  

| Param | Type | Description |
| --- | --- | --- |
| track | [<code>KeyframeTrack</code>](#KeyframeTrack) | The keyframe track to serialize. |

<a name="PropertyBinding"></a>

## PropertyBinding
This holds a reference to a real property in the scene graph; used internally.

**Kind**: global class  

* [PropertyBinding](#PropertyBinding)
    * [new PropertyBinding(rootNode, path, [parsedPath])](#new_PropertyBinding_new)
    * _instance_
        * [.path](#PropertyBinding+path) : <code>string</code>
        * [.parsedPath](#PropertyBinding+parsedPath) : <code>Object</code>
        * [.node](#PropertyBinding+node) : <code>Object</code>
        * [.rootNode](#PropertyBinding+rootNode) : <code>Object3D</code> \| <code>Skeleton</code>
        * [.bind()](#PropertyBinding+bind)
        * [.unbind()](#PropertyBinding+unbind)
    * _static_
        * [.create(root, path, [parsedPath])](#PropertyBinding.create) ⇒ [<code>PropertyBinding</code>](#PropertyBinding) \| <code>Composite</code>
        * [.sanitizeNodeName(name)](#PropertyBinding.sanitizeNodeName) ⇒ <code>string</code>
        * [.parseTrackName(trackName)](#PropertyBinding.parseTrackName) ⇒ <code>Object</code>
        * [.findNode(root, nodeName)](#PropertyBinding.findNode) ⇒ <code>Object</code>

<a name="new_PropertyBinding_new"></a>

### new PropertyBinding(rootNode, path, [parsedPath])
Constructs a new property binding.


| Param | Type | Description |
| --- | --- | --- |
| rootNode | <code>Object</code> | The root node. |
| path | <code>string</code> | The path. |
| [parsedPath] | <code>Object</code> | The parsed path. |

<a name="PropertyBinding+path"></a>

### propertyBinding.path : <code>string</code>
The object path to the animated property.

**Kind**: instance property of [<code>PropertyBinding</code>](#PropertyBinding)  
<a name="PropertyBinding+parsedPath"></a>

### propertyBinding.parsedPath : <code>Object</code>
An object holding information about the path.

**Kind**: instance property of [<code>PropertyBinding</code>](#PropertyBinding)  
<a name="PropertyBinding+node"></a>

### propertyBinding.node : <code>Object</code>
The object owns the animated property.

**Kind**: instance property of [<code>PropertyBinding</code>](#PropertyBinding)  
<a name="PropertyBinding+rootNode"></a>

### propertyBinding.rootNode : <code>Object3D</code> \| <code>Skeleton</code>
The root node.

**Kind**: instance property of [<code>PropertyBinding</code>](#PropertyBinding)  
<a name="PropertyBinding+bind"></a>

### propertyBinding.bind()
Creates a getter / setter pair for the property tracked by this binding.

**Kind**: instance method of [<code>PropertyBinding</code>](#PropertyBinding)  
<a name="PropertyBinding+unbind"></a>

### propertyBinding.unbind()
Unbinds the property.

**Kind**: instance method of [<code>PropertyBinding</code>](#PropertyBinding)  
<a name="PropertyBinding.create"></a>

### PropertyBinding.create(root, path, [parsedPath]) ⇒ [<code>PropertyBinding</code>](#PropertyBinding) \| <code>Composite</code>
Factory method for creating a property binding from the given parameters.

**Kind**: static method of [<code>PropertyBinding</code>](#PropertyBinding)  
**Returns**: [<code>PropertyBinding</code>](#PropertyBinding) \| <code>Composite</code> - The created property binding or composite.  

| Param | Type | Description |
| --- | --- | --- |
| root | <code>Object</code> | The root node. |
| path | <code>string</code> | The path. |
| [parsedPath] | <code>Object</code> | The parsed path. |

<a name="PropertyBinding.sanitizeNodeName"></a>

### PropertyBinding.sanitizeNodeName(name) ⇒ <code>string</code>
Replaces spaces with underscores and removes unsupported characters from
node names, to ensure compatibility with parseTrackName().

**Kind**: static method of [<code>PropertyBinding</code>](#PropertyBinding)  
**Returns**: <code>string</code> - The sanitized node name.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | Node name to be sanitized. |

<a name="PropertyBinding.parseTrackName"></a>

### PropertyBinding.parseTrackName(trackName) ⇒ <code>Object</code>
Parses the given track name (an object path to an animated property) and
returns an object with information about the path. Matches strings in the following forms:

- nodeName.property
- nodeName.property[accessor]
- nodeName.material.property[accessor]
- uuid.property[accessor]
- uuid.objectName[objectIndex].propertyName[propertyIndex]
- parentName/nodeName.property
- parentName/parentName/nodeName.property[index]
- .bone[Armature.DEF_cog].position
- scene:helium_balloon_model:helium_balloon_model.position

**Kind**: static method of [<code>PropertyBinding</code>](#PropertyBinding)  
**Returns**: <code>Object</code> - The parsed track name as an object.  

| Param | Type | Description |
| --- | --- | --- |
| trackName | <code>string</code> | The track name to parse. |

<a name="PropertyBinding.findNode"></a>

### PropertyBinding.findNode(root, nodeName) ⇒ <code>Object</code>
Searches for a node in the hierarchy of the given root object by the given
node name.

**Kind**: static method of [<code>PropertyBinding</code>](#PropertyBinding)  
**Returns**: <code>Object</code> - The found node. Returns `null` if no object was found.  

| Param | Type | Description |
| --- | --- | --- |
| root | <code>Object</code> | The root object. |
| nodeName | <code>string</code> \| <code>number</code> | The name of the node. |

<a name="PropertyMixer"></a>

## PropertyMixer
Buffered scene graph property that allows weighted accumulation; used internally.

**Kind**: global class  

* [PropertyMixer](#PropertyMixer)
    * [new PropertyMixer(binding, typeName, valueSize)](#new_PropertyMixer_new)
    * [.binding](#PropertyMixer+binding) : <code>PropertyBinding</code>
    * [.valueSize](#PropertyMixer+valueSize) : <code>number</code>
    * [.cumulativeWeight](#PropertyMixer+cumulativeWeight) : <code>number</code>
    * [.cumulativeWeightAdditive](#PropertyMixer+cumulativeWeightAdditive) : <code>number</code>
    * [.useCount](#PropertyMixer+useCount) : <code>number</code>
    * [.referenceCount](#PropertyMixer+referenceCount) : <code>number</code>
    * [.accumulate(accuIndex, weight)](#PropertyMixer+accumulate)
    * [.accumulateAdditive(weight)](#PropertyMixer+accumulateAdditive)
    * [.apply(accuIndex)](#PropertyMixer+apply)
    * [.saveOriginalState()](#PropertyMixer+saveOriginalState)
    * [.restoreOriginalState()](#PropertyMixer+restoreOriginalState)

<a name="new_PropertyMixer_new"></a>

### new PropertyMixer(binding, typeName, valueSize)
Constructs a new property mixer.


| Param | Type | Description |
| --- | --- | --- |
| binding | <code>PropertyBinding</code> | The property binding. |
| typeName | <code>string</code> | The keyframe track type name. |
| valueSize | <code>number</code> | The keyframe track value size. |

<a name="PropertyMixer+binding"></a>

### propertyMixer.binding : <code>PropertyBinding</code>
The property binding.

**Kind**: instance property of [<code>PropertyMixer</code>](#PropertyMixer)  
<a name="PropertyMixer+valueSize"></a>

### propertyMixer.valueSize : <code>number</code>
The keyframe track value size.

**Kind**: instance property of [<code>PropertyMixer</code>](#PropertyMixer)  
<a name="PropertyMixer+cumulativeWeight"></a>

### propertyMixer.cumulativeWeight : <code>number</code>
TODO

**Kind**: instance property of [<code>PropertyMixer</code>](#PropertyMixer)  
**Default**: <code>0</code>  
<a name="PropertyMixer+cumulativeWeightAdditive"></a>

### propertyMixer.cumulativeWeightAdditive : <code>number</code>
TODO

**Kind**: instance property of [<code>PropertyMixer</code>](#PropertyMixer)  
**Default**: <code>0</code>  
<a name="PropertyMixer+useCount"></a>

### propertyMixer.useCount : <code>number</code>
TODO

**Kind**: instance property of [<code>PropertyMixer</code>](#PropertyMixer)  
**Default**: <code>0</code>  
<a name="PropertyMixer+referenceCount"></a>

### propertyMixer.referenceCount : <code>number</code>
TODO

**Kind**: instance property of [<code>PropertyMixer</code>](#PropertyMixer)  
**Default**: <code>0</code>  
<a name="PropertyMixer+accumulate"></a>

### propertyMixer.accumulate(accuIndex, weight)
Accumulates data in the `incoming` region into `accu<i>`.

**Kind**: instance method of [<code>PropertyMixer</code>](#PropertyMixer)  

| Param | Type | Description |
| --- | --- | --- |
| accuIndex | <code>number</code> | The accumulation index. |
| weight | <code>number</code> | The weight. |

<a name="PropertyMixer+accumulateAdditive"></a>

### propertyMixer.accumulateAdditive(weight)
Accumulates data in the `incoming` region into `add`.

**Kind**: instance method of [<code>PropertyMixer</code>](#PropertyMixer)  

| Param | Type | Description |
| --- | --- | --- |
| weight | <code>number</code> | The weight. |

<a name="PropertyMixer+apply"></a>

### propertyMixer.apply(accuIndex)
Applies the state of `accu<i>` to the binding when accus differ.

**Kind**: instance method of [<code>PropertyMixer</code>](#PropertyMixer)  

| Param | Type | Description |
| --- | --- | --- |
| accuIndex | <code>number</code> | The accumulation index. |

<a name="PropertyMixer+saveOriginalState"></a>

### propertyMixer.saveOriginalState()
Remembers the state of the bound property and copy it to both accus.

**Kind**: instance method of [<code>PropertyMixer</code>](#PropertyMixer)  
<a name="PropertyMixer+restoreOriginalState"></a>

### propertyMixer.restoreOriginalState()
Applies the state previously taken via [saveOriginalState](#PropertyMixer+saveOriginalState) to the binding.

**Kind**: instance method of [<code>PropertyMixer</code>](#PropertyMixer)  
<a name="BooleanKeyframeTrack"></a>

## BooleanKeyframeTrack ⇐ <code>KeyframeTrack</code>
A track for boolean keyframe values.

**Kind**: global class  
**Extends**: <code>KeyframeTrack</code>  

* [BooleanKeyframeTrack](#BooleanKeyframeTrack) ⇐ <code>KeyframeTrack</code>
    * [new BooleanKeyframeTrack(name, times, values)](#new_BooleanKeyframeTrack_new)
    * [.ValueTypeName](#BooleanKeyframeTrack+ValueTypeName) : <code>String</code>
    * [.ValueBufferType](#BooleanKeyframeTrack+ValueBufferType) : <code>TypedArray</code> \| <code>Array</code>
    * [.DefaultInterpolation](#BooleanKeyframeTrack+DefaultInterpolation) : <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code>

<a name="new_BooleanKeyframeTrack_new"></a>

### new BooleanKeyframeTrack(name, times, values)
Constructs a new boolean keyframe track.

This keyframe track type has no `interpolation` parameter because the
interpolation is always discrete.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The keyframe track's name. |
| times | <code>Array.&lt;number&gt;</code> | A list of keyframe times. |
| values | <code>Array.&lt;number&gt;</code> | A list of keyframe values. |

<a name="BooleanKeyframeTrack+ValueTypeName"></a>

### booleanKeyframeTrack.ValueTypeName : <code>String</code>
The value type name.

**Kind**: instance property of [<code>BooleanKeyframeTrack</code>](#BooleanKeyframeTrack)  
**Default**: <code>&#x27;bool&#x27;</code>  
<a name="BooleanKeyframeTrack+ValueBufferType"></a>

### booleanKeyframeTrack.ValueBufferType : <code>TypedArray</code> \| <code>Array</code>
The value buffer type of this keyframe track.

**Kind**: instance property of [<code>BooleanKeyframeTrack</code>](#BooleanKeyframeTrack)  
**Default**: <code>Array.constructor</code>  
<a name="BooleanKeyframeTrack+DefaultInterpolation"></a>

### booleanKeyframeTrack.DefaultInterpolation : <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code>
The default interpolation type of this keyframe track.

**Kind**: instance property of [<code>BooleanKeyframeTrack</code>](#BooleanKeyframeTrack)  
**Default**: <code>InterpolateDiscrete</code>  
<a name="ColorKeyframeTrack"></a>

## ColorKeyframeTrack ⇐ <code>KeyframeTrack</code>
A track for color keyframe values.

**Kind**: global class  
**Extends**: <code>KeyframeTrack</code>  

* [ColorKeyframeTrack](#ColorKeyframeTrack) ⇐ <code>KeyframeTrack</code>
    * [new ColorKeyframeTrack(name, times, values, [interpolation])](#new_ColorKeyframeTrack_new)
    * [.ValueTypeName](#ColorKeyframeTrack+ValueTypeName) : <code>String</code>

<a name="new_ColorKeyframeTrack_new"></a>

### new ColorKeyframeTrack(name, times, values, [interpolation])
Constructs a new color keyframe track.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The keyframe track's name. |
| times | <code>Array.&lt;number&gt;</code> | A list of keyframe times. |
| values | <code>Array.&lt;number&gt;</code> | A list of keyframe values. |
| [interpolation] | <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code> | The interpolation type. |

<a name="ColorKeyframeTrack+ValueTypeName"></a>

### colorKeyframeTrack.ValueTypeName : <code>String</code>
The value type name.

**Kind**: instance property of [<code>ColorKeyframeTrack</code>](#ColorKeyframeTrack)  
**Default**: <code>&#x27;color&#x27;</code>  
<a name="NumberKeyframeTrack"></a>

## NumberKeyframeTrack ⇐ <code>KeyframeTrack</code>
A track for numeric keyframe values.

**Kind**: global class  
**Extends**: <code>KeyframeTrack</code>  

* [NumberKeyframeTrack](#NumberKeyframeTrack) ⇐ <code>KeyframeTrack</code>
    * [new NumberKeyframeTrack(name, times, values, [interpolation])](#new_NumberKeyframeTrack_new)
    * [.ValueTypeName](#NumberKeyframeTrack+ValueTypeName) : <code>String</code>

<a name="new_NumberKeyframeTrack_new"></a>

### new NumberKeyframeTrack(name, times, values, [interpolation])
Constructs a new number keyframe track.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The keyframe track's name. |
| times | <code>Array.&lt;number&gt;</code> | A list of keyframe times. |
| values | <code>Array.&lt;number&gt;</code> | A list of keyframe values. |
| [interpolation] | <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code> | The interpolation type. |

<a name="NumberKeyframeTrack+ValueTypeName"></a>

### numberKeyframeTrack.ValueTypeName : <code>String</code>
The value type name.

**Kind**: instance property of [<code>NumberKeyframeTrack</code>](#NumberKeyframeTrack)  
**Default**: <code>&#x27;number&#x27;</code>  
<a name="QuaternionKeyframeTrack"></a>

## QuaternionKeyframeTrack ⇐ <code>KeyframeTrack</code>
A track for Quaternion keyframe values.

**Kind**: global class  
**Extends**: <code>KeyframeTrack</code>  

* [QuaternionKeyframeTrack](#QuaternionKeyframeTrack) ⇐ <code>KeyframeTrack</code>
    * [new QuaternionKeyframeTrack(name, times, values, [interpolation])](#new_QuaternionKeyframeTrack_new)
    * [.ValueTypeName](#QuaternionKeyframeTrack+ValueTypeName) : <code>String</code>
    * [.InterpolantFactoryMethodLinear([result])](#QuaternionKeyframeTrack+InterpolantFactoryMethodLinear) ⇒ <code>QuaternionLinearInterpolant</code>

<a name="new_QuaternionKeyframeTrack_new"></a>

### new QuaternionKeyframeTrack(name, times, values, [interpolation])
Constructs a new Quaternion keyframe track.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The keyframe track's name. |
| times | <code>Array.&lt;number&gt;</code> | A list of keyframe times. |
| values | <code>Array.&lt;number&gt;</code> | A list of keyframe values. |
| [interpolation] | <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code> | The interpolation type. |

<a name="QuaternionKeyframeTrack+ValueTypeName"></a>

### quaternionKeyframeTrack.ValueTypeName : <code>String</code>
The value type name.

**Kind**: instance property of [<code>QuaternionKeyframeTrack</code>](#QuaternionKeyframeTrack)  
**Default**: <code>&#x27;quaternion&#x27;</code>  
<a name="QuaternionKeyframeTrack+InterpolantFactoryMethodLinear"></a>

### quaternionKeyframeTrack.InterpolantFactoryMethodLinear([result]) ⇒ <code>QuaternionLinearInterpolant</code>
Overwritten so the method returns Quaternion based interpolant.

**Kind**: instance method of [<code>QuaternionKeyframeTrack</code>](#QuaternionKeyframeTrack)  
**Returns**: <code>QuaternionLinearInterpolant</code> - The new interpolant.  

| Param | Type | Description |
| --- | --- | --- |
| [result] | <code>TypedArray</code> | The result buffer. |

<a name="StringKeyframeTrack"></a>

## StringKeyframeTrack ⇐ <code>KeyframeTrack</code>
A track for string keyframe values.

**Kind**: global class  
**Extends**: <code>KeyframeTrack</code>  

* [StringKeyframeTrack](#StringKeyframeTrack) ⇐ <code>KeyframeTrack</code>
    * [new StringKeyframeTrack(name, times, values)](#new_StringKeyframeTrack_new)
    * [.ValueTypeName](#StringKeyframeTrack+ValueTypeName) : <code>String</code>
    * [.ValueBufferType](#StringKeyframeTrack+ValueBufferType) : <code>TypedArray</code> \| <code>Array</code>
    * [.DefaultInterpolation](#StringKeyframeTrack+DefaultInterpolation) : <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code>

<a name="new_StringKeyframeTrack_new"></a>

### new StringKeyframeTrack(name, times, values)
Constructs a new string keyframe track.

This keyframe track type has no `interpolation` parameter because the
interpolation is always discrete.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The keyframe track's name. |
| times | <code>Array.&lt;number&gt;</code> | A list of keyframe times. |
| values | <code>Array.&lt;number&gt;</code> | A list of keyframe values. |

<a name="StringKeyframeTrack+ValueTypeName"></a>

### stringKeyframeTrack.ValueTypeName : <code>String</code>
The value type name.

**Kind**: instance property of [<code>StringKeyframeTrack</code>](#StringKeyframeTrack)  
**Default**: <code>&#x27;string&#x27;</code>  
<a name="StringKeyframeTrack+ValueBufferType"></a>

### stringKeyframeTrack.ValueBufferType : <code>TypedArray</code> \| <code>Array</code>
The value buffer type of this keyframe track.

**Kind**: instance property of [<code>StringKeyframeTrack</code>](#StringKeyframeTrack)  
**Default**: <code>Array.constructor</code>  
<a name="StringKeyframeTrack+DefaultInterpolation"></a>

### stringKeyframeTrack.DefaultInterpolation : <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code>
The default interpolation type of this keyframe track.

**Kind**: instance property of [<code>StringKeyframeTrack</code>](#StringKeyframeTrack)  
**Default**: <code>InterpolateDiscrete</code>  
<a name="VectorKeyframeTrack"></a>

## VectorKeyframeTrack ⇐ <code>KeyframeTrack</code>
A track for vector keyframe values.

**Kind**: global class  
**Extends**: <code>KeyframeTrack</code>  

* [VectorKeyframeTrack](#VectorKeyframeTrack) ⇐ <code>KeyframeTrack</code>
    * [new VectorKeyframeTrack(name, times, values, [interpolation])](#new_VectorKeyframeTrack_new)
    * [.ValueTypeName](#VectorKeyframeTrack+ValueTypeName) : <code>String</code>

<a name="new_VectorKeyframeTrack_new"></a>

### new VectorKeyframeTrack(name, times, values, [interpolation])
Constructs a new vector keyframe track.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The keyframe track's name. |
| times | <code>Array.&lt;number&gt;</code> | A list of keyframe times. |
| values | <code>Array.&lt;number&gt;</code> | A list of keyframe values. |
| [interpolation] | <code>InterpolateLinear</code> \| <code>InterpolateDiscrete</code> \| <code>InterpolateSmooth</code> | The interpolation type. |

<a name="VectorKeyframeTrack+ValueTypeName"></a>

### vectorKeyframeTrack.ValueTypeName : <code>String</code>
The value type name.

**Kind**: instance property of [<code>VectorKeyframeTrack</code>](#VectorKeyframeTrack)  
**Default**: <code>&#x27;vector&#x27;</code>  
<a name="Audio"></a>

## Audio ⇐ <code>Object3D</code>
Represents a non-positional ( global ) audio object.

This and related audio modules make use of the [Web Audio API](https://www.w3.org/TR/webaudio-1.1/).

```js
// create an AudioListener and add it to the camera
const listener = new THREE.AudioListener();
camera.add( listener );

// create a global audio source
const sound = new THREE.Audio( listener );

// load a sound and set it as the Audio object's buffer
const audioLoader = new THREE.AudioLoader();
audioLoader.load( 'sounds/ambient.ogg', function( buffer ) {
	sound.setBuffer( buffer );
	sound.setLoop( true );
	sound.setVolume( 0.5 );
	sound.play();
});
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Audio](#Audio) ⇐ <code>Object3D</code>
    * [new Audio(listener)](#new_Audio_new)
    * [.listener](#Audio+listener) : <code>AudioListener</code>
    * [.context](#Audio+context) : <code>AudioContext</code>
    * [.gain](#Audio+gain) : <code>GainNode</code>
    * [.autoplay](#Audio+autoplay) : <code>boolean</code>
    * [.buffer](#Audio+buffer) : <code>AudioBuffer</code>
    * [.detune](#Audio+detune) : <code>number</code>
    * [.loop](#Audio+loop) : <code>boolean</code>
    * [.loopStart](#Audio+loopStart) : <code>number</code>
    * [.loopEnd](#Audio+loopEnd) : <code>number</code>
    * [.offset](#Audio+offset) : <code>number</code>
    * [.duration](#Audio+duration) : <code>undefined</code> \| <code>number</code>
    * [.playbackRate](#Audio+playbackRate) : <code>number</code>
    * [.isPlaying](#Audio+isPlaying) : <code>boolean</code>
    * [.hasPlaybackControl](#Audio+hasPlaybackControl) : <code>boolean</code>
    * [.source](#Audio+source) : <code>AudioNode</code>
    * [.sourceType](#Audio+sourceType) : <code>&#x27;empty&#x27;</code> \| <code>&#x27;audioNode&#x27;</code> \| <code>&#x27;mediaNode&#x27;</code> \| <code>&#x27;mediaStreamNode&#x27;</code> \| <code>&#x27;buffer&#x27;</code>
    * [.filters](#Audio+filters) : <code>Array.&lt;AudioNode&gt;</code>
    * [.getOutput()](#Audio+getOutput) ⇒ <code>GainNode</code>
    * [.setNodeSource(audioNode)](#Audio+setNodeSource) ⇒ [<code>Audio</code>](#Audio)
    * [.setMediaElementSource(mediaElement)](#Audio+setMediaElementSource) ⇒ [<code>Audio</code>](#Audio)
    * [.setMediaStreamSource(mediaStream)](#Audio+setMediaStreamSource) ⇒ [<code>Audio</code>](#Audio)
    * [.setBuffer(audioBuffer)](#Audio+setBuffer) ⇒ [<code>Audio</code>](#Audio)
    * [.play([delay])](#Audio+play) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
    * [.pause()](#Audio+pause) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
    * [.stop([delay])](#Audio+stop) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
    * [.connect()](#Audio+connect) ⇒ [<code>Audio</code>](#Audio)
    * [.disconnect()](#Audio+disconnect) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
    * [.getFilters()](#Audio+getFilters) ⇒ <code>Array.&lt;AudioNode&gt;</code>
    * [.setFilters([value])](#Audio+setFilters) ⇒ [<code>Audio</code>](#Audio)
    * [.setDetune(value)](#Audio+setDetune) ⇒ [<code>Audio</code>](#Audio)
    * [.getDetune()](#Audio+getDetune) ⇒ <code>number</code>
    * [.getFilter()](#Audio+getFilter) ⇒ <code>AudioNode</code> \| <code>undefined</code>
    * [.setFilter([filter])](#Audio+setFilter) ⇒ [<code>Audio</code>](#Audio)
    * [.setPlaybackRate([value])](#Audio+setPlaybackRate) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
    * [.getPlaybackRate()](#Audio+getPlaybackRate) ⇒ <code>number</code>
    * [.onEnded()](#Audio+onEnded)
    * [.getLoop()](#Audio+getLoop) ⇒ <code>boolean</code>
    * [.setLoop(value)](#Audio+setLoop) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
    * [.setLoopStart(value)](#Audio+setLoopStart) ⇒ [<code>Audio</code>](#Audio)
    * [.setLoopEnd(value)](#Audio+setLoopEnd) ⇒ [<code>Audio</code>](#Audio)
    * [.getVolume()](#Audio+getVolume) ⇒ <code>number</code>
    * [.setVolume(value)](#Audio+setVolume) ⇒ [<code>Audio</code>](#Audio)

<a name="new_Audio_new"></a>

### new Audio(listener)
Constructs a new audio.


| Param | Type | Description |
| --- | --- | --- |
| listener | <code>AudioListener</code> | The global audio listener. |

<a name="Audio+listener"></a>

### audio.listener : <code>AudioListener</code>
The global audio listener.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Read only**: true  
<a name="Audio+context"></a>

### audio.context : <code>AudioContext</code>
The audio context.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Read only**: true  
<a name="Audio+gain"></a>

### audio.gain : <code>GainNode</code>
The gain node used for volume control.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Read only**: true  
<a name="Audio+autoplay"></a>

### audio.autoplay : <code>boolean</code>
Whether to start playback automatically or not.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>false</code>  
<a name="Audio+buffer"></a>

### audio.buffer : <code>AudioBuffer</code>
A reference to an audio buffer.

Defined via [setBuffer](#Audio+setBuffer).

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>null</code>  
**Read only**: true  
<a name="Audio+detune"></a>

### audio.detune : <code>number</code>
Modify pitch, measured in cents. +/- 100 is a semitone.
+/- 1200 is an octave.

Defined via [setDetune](#Audio+setDetune).

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Audio+loop"></a>

### audio.loop : <code>boolean</code>
Whether the audio should loop or not.

Defined via [setLoop](#Audio+setLoop).

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="Audio+loopStart"></a>

### audio.loopStart : <code>number</code>
Defines where in the audio buffer the replay should
start, in seconds.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>0</code>  
<a name="Audio+loopEnd"></a>

### audio.loopEnd : <code>number</code>
Defines where in the audio buffer the replay should
stop, in seconds.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>0</code>  
<a name="Audio+offset"></a>

### audio.offset : <code>number</code>
An offset to the time within the audio buffer the playback
should begin, in seconds.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>0</code>  
<a name="Audio+duration"></a>

### audio.duration : <code>undefined</code> \| <code>number</code>
Overrides the default duration of the audio.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>undefined</code>  
<a name="Audio+playbackRate"></a>

### audio.playbackRate : <code>number</code>
The playback speed.

Defined via [setPlaybackRate](#Audio+setPlaybackRate).

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>1</code>  
**Read only**: true  
<a name="Audio+isPlaying"></a>

### audio.isPlaying : <code>boolean</code>
Indicates whether the audio is playing or not.

This flag will be automatically set when using [play](#Audio+play),
[pause](#Audio+pause), [stop](#Audio+stop).

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="Audio+hasPlaybackControl"></a>

### audio.hasPlaybackControl : <code>boolean</code>
Indicates whether the audio playback can be controlled
with method like [play](#Audio+play) or [pause](#Audio+pause).

This flag will be automatically set when audio sources are
defined.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Audio+source"></a>

### audio.source : <code>AudioNode</code>
Holds a reference to the current audio source.

The property is automatically by one of the `set*()` methods.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>null</code>  
**Read only**: true  
<a name="Audio+sourceType"></a>

### audio.sourceType : <code>&#x27;empty&#x27;</code> \| <code>&#x27;audioNode&#x27;</code> \| <code>&#x27;mediaNode&#x27;</code> \| <code>&#x27;mediaStreamNode&#x27;</code> \| <code>&#x27;buffer&#x27;</code>
Defines the source type.

The property is automatically by one of the `set*()` methods.

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Default**: <code>&#x27;empty&#x27;</code>  
**Read only**: true  
<a name="Audio+filters"></a>

### audio.filters : <code>Array.&lt;AudioNode&gt;</code>
Can be used to apply a variety of low-order filters to create
more complex sound effects e.g. via `BiquadFilterNode`.

The property is automatically set by [setFilters](#Audio+setFilters).

**Kind**: instance property of [<code>Audio</code>](#Audio)  
**Read only**: true  
<a name="Audio+getOutput"></a>

### audio.getOutput() ⇒ <code>GainNode</code>
Returns the output audio node.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: <code>GainNode</code> - The output node.  
<a name="Audio+setNodeSource"></a>

### audio.setNodeSource(audioNode) ⇒ [<code>Audio</code>](#Audio)
Sets the given audio node as the source of this instance.

[sourceType](#Audio+sourceType) is set to `audioNode` and [hasPlaybackControl](#Audio+hasPlaybackControl) to `false`.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| audioNode | <code>AudioNode</code> | The audio node like an instance of `OscillatorNode`. |

<a name="Audio+setMediaElementSource"></a>

### audio.setMediaElementSource(mediaElement) ⇒ [<code>Audio</code>](#Audio)
Sets the given media element as the source of this instance.

[sourceType](#Audio+sourceType) is set to `mediaNode` and [hasPlaybackControl](#Audio+hasPlaybackControl) to `false`.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| mediaElement | <code>HTMLMediaElement</code> | The media element. |

<a name="Audio+setMediaStreamSource"></a>

### audio.setMediaStreamSource(mediaStream) ⇒ [<code>Audio</code>](#Audio)
Sets the given media stream as the source of this instance.

[sourceType](#Audio+sourceType) is set to `mediaStreamNode` and [hasPlaybackControl](#Audio+hasPlaybackControl) to `false`.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| mediaStream | <code>MediaStream</code> | The media stream. |

<a name="Audio+setBuffer"></a>

### audio.setBuffer(audioBuffer) ⇒ [<code>Audio</code>](#Audio)
Sets the given audio buffer as the source of this instance.

[sourceType](#Audio+sourceType) is set to `buffer` and [hasPlaybackControl](#Audio+hasPlaybackControl) to `true`.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| audioBuffer | <code>AudioBuffer</code> | The audio buffer. |

<a name="Audio+play"></a>

### audio.play([delay]) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
Starts the playback of the audio.

Can only be used with compatible audio sources that allow playback control.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) \| <code>undefined</code> - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [delay] | <code>number</code> | <code>0</code> | The delay, in seconds, at which the audio should start playing. |

<a name="Audio+pause"></a>

### audio.pause() ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
Pauses the playback of the audio.

Can only be used with compatible audio sources that allow playback control.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) \| <code>undefined</code> - A reference to this instance.  
<a name="Audio+stop"></a>

### audio.stop([delay]) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
Stops the playback of the audio.

Can only be used with compatible audio sources that allow playback control.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) \| <code>undefined</code> - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [delay] | <code>number</code> | <code>0</code> | The delay, in seconds, at which the audio should stop playing. |

<a name="Audio+connect"></a>

### audio.connect() ⇒ [<code>Audio</code>](#Audio)
Connects to the audio source. This is used internally on
initialisation and when setting / removing filters.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  
<a name="Audio+disconnect"></a>

### audio.disconnect() ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
Disconnects to the audio source. This is used internally on
initialisation and when setting / removing filters.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) \| <code>undefined</code> - A reference to this instance.  
<a name="Audio+getFilters"></a>

### audio.getFilters() ⇒ <code>Array.&lt;AudioNode&gt;</code>
Returns the current set filters.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: <code>Array.&lt;AudioNode&gt;</code> - The list of filters.  
<a name="Audio+setFilters"></a>

### audio.setFilters([value]) ⇒ [<code>Audio</code>](#Audio)
Sets an array of filters and connects them with the audio source.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| [value] | <code>Array.&lt;AudioNode&gt;</code> | A list of filters. |

<a name="Audio+setDetune"></a>

### audio.setDetune(value) ⇒ [<code>Audio</code>](#Audio)
Defines the detuning of oscillation in cents.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The detuning of oscillation in cents. |

<a name="Audio+getDetune"></a>

### audio.getDetune() ⇒ <code>number</code>
Returns the detuning of oscillation in cents.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: <code>number</code> - The detuning of oscillation in cents.  
<a name="Audio+getFilter"></a>

### audio.getFilter() ⇒ <code>AudioNode</code> \| <code>undefined</code>
Returns the first filter in the list of filters.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: <code>AudioNode</code> \| <code>undefined</code> - The first filter in the list of filters.  
<a name="Audio+setFilter"></a>

### audio.setFilter([filter]) ⇒ [<code>Audio</code>](#Audio)
Applies a single filter node to the audio.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| [filter] | <code>AudioNode</code> | The filter to set. |

<a name="Audio+setPlaybackRate"></a>

### audio.setPlaybackRate([value]) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
Sets the playback rate.

Can only be used with compatible audio sources that allow playback control.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) \| <code>undefined</code> - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| [value] | <code>number</code> | The playback rate to set. |

<a name="Audio+getPlaybackRate"></a>

### audio.getPlaybackRate() ⇒ <code>number</code>
Returns the current playback rate.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: <code>number</code> - The playback rate.  
<a name="Audio+onEnded"></a>

### audio.onEnded()
Automatically called when playback finished.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
<a name="Audio+getLoop"></a>

### audio.getLoop() ⇒ <code>boolean</code>
Returns the loop flag.

Can only be used with compatible audio sources that allow playback control.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: <code>boolean</code> - Whether the audio should loop or not.  
<a name="Audio+setLoop"></a>

### audio.setLoop(value) ⇒ [<code>Audio</code>](#Audio) \| <code>undefined</code>
Sets the loop flag.

Can only be used with compatible audio sources that allow playback control.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) \| <code>undefined</code> - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | Whether the audio should loop or not. |

<a name="Audio+setLoopStart"></a>

### audio.setLoopStart(value) ⇒ [<code>Audio</code>](#Audio)
Sets the loop start value which defines where in the audio buffer the replay should
start, in seconds.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The loop start value. |

<a name="Audio+setLoopEnd"></a>

### audio.setLoopEnd(value) ⇒ [<code>Audio</code>](#Audio)
Sets the loop end value which defines where in the audio buffer the replay should
stop, in seconds.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The loop end value. |

<a name="Audio+getVolume"></a>

### audio.getVolume() ⇒ <code>number</code>
Returns the volume.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: <code>number</code> - The volume.  
<a name="Audio+setVolume"></a>

### audio.setVolume(value) ⇒ [<code>Audio</code>](#Audio)
Sets the volume.

**Kind**: instance method of [<code>Audio</code>](#Audio)  
**Returns**: [<code>Audio</code>](#Audio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The volume to set. |

<a name="AudioAnalyser"></a>

## AudioAnalyser
This class can be used to analyse audio data.

```js
// create an AudioListener and add it to the camera
const listener = new THREE.AudioListener();
camera.add( listener );

// create an Audio source
const sound = new THREE.Audio( listener );

// load a sound and set it as the Audio object's buffer
const audioLoader = new THREE.AudioLoader();
audioLoader.load( 'sounds/ambient.ogg', function( buffer ) {
	sound.setBuffer( buffer );
	sound.setLoop(true);
	sound.setVolume(0.5);
	sound.play();
});

// create an AudioAnalyser, passing in the sound and desired fftSize
const analyser = new THREE.AudioAnalyser( sound, 32 );

// get the average frequency of the sound
const data = analyser.getAverageFrequency();
```

**Kind**: global class  

* [AudioAnalyser](#AudioAnalyser)
    * [new AudioAnalyser(audio, [fftSize])](#new_AudioAnalyser_new)
    * [.analyser](#AudioAnalyser+analyser) : <code>AnalyserNode</code>
    * [.data](#AudioAnalyser+data) : <code>Uint8Array</code>
    * [.getFrequencyData()](#AudioAnalyser+getFrequencyData) ⇒ <code>Uint8Array</code>
    * [.getAverageFrequency()](#AudioAnalyser+getAverageFrequency) ⇒ <code>number</code>

<a name="new_AudioAnalyser_new"></a>

### new AudioAnalyser(audio, [fftSize])
Constructs a new audio analyzer.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| audio | <code>Audio</code> |  | The audio to analyze. |
| [fftSize] | <code>number</code> | <code>2048</code> | The window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data. |

<a name="AudioAnalyser+analyser"></a>

### audioAnalyser.analyser : <code>AnalyserNode</code>
The global audio listener.

**Kind**: instance property of [<code>AudioAnalyser</code>](#AudioAnalyser)  
<a name="AudioAnalyser+data"></a>

### audioAnalyser.data : <code>Uint8Array</code>
Holds the analyzed data.

**Kind**: instance property of [<code>AudioAnalyser</code>](#AudioAnalyser)  
<a name="AudioAnalyser+getFrequencyData"></a>

### audioAnalyser.getFrequencyData() ⇒ <code>Uint8Array</code>
Returns an array with frequency data of the audio.

Each item in the array represents the decibel value for a specific frequency.
The frequencies are spread linearly from 0 to 1/2 of the sample rate.
For example, for 48000 sample rate, the last item of the array will represent
the decibel value for 24000 Hz.

**Kind**: instance method of [<code>AudioAnalyser</code>](#AudioAnalyser)  
**Returns**: <code>Uint8Array</code> - The frequency data.  
<a name="AudioAnalyser+getAverageFrequency"></a>

### audioAnalyser.getAverageFrequency() ⇒ <code>number</code>
Returns the average of the frequencies returned by [getFrequencyData](#AudioAnalyser+getFrequencyData).

**Kind**: instance method of [<code>AudioAnalyser</code>](#AudioAnalyser)  
**Returns**: <code>number</code> - The average frequency.  
<a name="AudioContext"></a>

## AudioContext
Manages the global audio context in the engine.

**Kind**: global class  

* [AudioContext](#AudioContext)
    * [.getContext()](#AudioContext.getContext) ⇒ [<code>AudioContext</code>](#AudioContext)
    * [.setContext(value)](#AudioContext.setContext)

<a name="AudioContext.getContext"></a>

### AudioContext.getContext() ⇒ [<code>AudioContext</code>](#AudioContext)
Returns the global native audio context.

**Kind**: static method of [<code>AudioContext</code>](#AudioContext)  
**Returns**: [<code>AudioContext</code>](#AudioContext) - The native audio context.  
<a name="AudioContext.setContext"></a>

### AudioContext.setContext(value)
Allows to set the global native audio context from outside.

**Kind**: static method of [<code>AudioContext</code>](#AudioContext)  

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>AudioContext</code>](#AudioContext) | The native context to set. |

<a name="AudioListener"></a>

## AudioListener ⇐ <code>Object3D</code>
The class represents a virtual listener of the all positional and non-positional audio effects
in the scene. A three.js application usually creates a single listener. It is a mandatory
constructor parameter for audios entities like [Audio](Audio) and [PositionalAudio](PositionalAudio).

In most cases, the listener object is a child of the camera. So the 3D transformation of the
camera represents the 3D transformation of the listener.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [AudioListener](#AudioListener) ⇐ <code>Object3D</code>
    * [new AudioListener()](#new_AudioListener_new)
    * [.context](#AudioListener+context) : <code>AudioContext</code>
    * [.gain](#AudioListener+gain) : <code>GainNode</code>
    * [.filter](#AudioListener+filter) : <code>AudioNode</code>
    * [.timeDelta](#AudioListener+timeDelta) : <code>number</code>
    * [.getInput()](#AudioListener+getInput) ⇒ <code>GainNode</code>
    * [.removeFilter()](#AudioListener+removeFilter) ⇒ [<code>AudioListener</code>](#AudioListener)
    * [.getFilter()](#AudioListener+getFilter) ⇒ <code>AudioNode</code>
    * [.setFilter(value)](#AudioListener+setFilter) ⇒ [<code>AudioListener</code>](#AudioListener)
    * [.getMasterVolume()](#AudioListener+getMasterVolume) ⇒ <code>number</code>
    * [.setMasterVolume(value)](#AudioListener+setMasterVolume) ⇒ [<code>AudioListener</code>](#AudioListener)

<a name="new_AudioListener_new"></a>

### new AudioListener()
Constructs a new audio listener.

<a name="AudioListener+context"></a>

### audioListener.context : <code>AudioContext</code>
The native audio context.

**Kind**: instance property of [<code>AudioListener</code>](#AudioListener)  
**Read only**: true  
<a name="AudioListener+gain"></a>

### audioListener.gain : <code>GainNode</code>
The gain node used for volume control.

**Kind**: instance property of [<code>AudioListener</code>](#AudioListener)  
**Read only**: true  
<a name="AudioListener+filter"></a>

### audioListener.filter : <code>AudioNode</code>
An optional filter.

Defined via [setFilter](#AudioListener+setFilter).

**Kind**: instance property of [<code>AudioListener</code>](#AudioListener)  
**Default**: <code>null</code>  
**Read only**: true  
<a name="AudioListener+timeDelta"></a>

### audioListener.timeDelta : <code>number</code>
Time delta values required for `linearRampToValueAtTime()` usage.

**Kind**: instance property of [<code>AudioListener</code>](#AudioListener)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="AudioListener+getInput"></a>

### audioListener.getInput() ⇒ <code>GainNode</code>
Returns the listener's input node.

This method is used by other audio nodes to connect to this listener.

**Kind**: instance method of [<code>AudioListener</code>](#AudioListener)  
**Returns**: <code>GainNode</code> - The input node.  
<a name="AudioListener+removeFilter"></a>

### audioListener.removeFilter() ⇒ [<code>AudioListener</code>](#AudioListener)
Removes the current filter from this listener.

**Kind**: instance method of [<code>AudioListener</code>](#AudioListener)  
**Returns**: [<code>AudioListener</code>](#AudioListener) - A reference to this listener.  
<a name="AudioListener+getFilter"></a>

### audioListener.getFilter() ⇒ <code>AudioNode</code>
Returns the current set filter.

**Kind**: instance method of [<code>AudioListener</code>](#AudioListener)  
**Returns**: <code>AudioNode</code> - The filter.  
<a name="AudioListener+setFilter"></a>

### audioListener.setFilter(value) ⇒ [<code>AudioListener</code>](#AudioListener)
Sets the given filter to this listener.

**Kind**: instance method of [<code>AudioListener</code>](#AudioListener)  
**Returns**: [<code>AudioListener</code>](#AudioListener) - A reference to this listener.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>AudioNode</code> | The filter to set. |

<a name="AudioListener+getMasterVolume"></a>

### audioListener.getMasterVolume() ⇒ <code>number</code>
Returns the applications master volume.

**Kind**: instance method of [<code>AudioListener</code>](#AudioListener)  
**Returns**: <code>number</code> - The master volume.  
<a name="AudioListener+setMasterVolume"></a>

### audioListener.setMasterVolume(value) ⇒ [<code>AudioListener</code>](#AudioListener)
Sets the applications master volume. This volume setting affects
all audio nodes in the scene.

**Kind**: instance method of [<code>AudioListener</code>](#AudioListener)  
**Returns**: [<code>AudioListener</code>](#AudioListener) - A reference to this listener.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The master volume to set. |

<a name="PositionalAudio"></a>

## PositionalAudio ⇐ <code>Audio</code>
Represents a positional audio object.

```js
// create an AudioListener and add it to the camera
const listener = new THREE.AudioListener();
camera.add( listener );

// create the PositionalAudio object (passing in the listener)
const sound = new THREE.PositionalAudio( listener );

// load a sound and set it as the PositionalAudio object's buffer
const audioLoader = new THREE.AudioLoader();
audioLoader.load( 'sounds/song.ogg', function( buffer ) {
	sound.setBuffer( buffer );
	sound.setRefDistance( 20 );
	sound.play();
});

// create an object for the sound to play from
const sphere = new THREE.SphereGeometry( 20, 32, 16 );
const material = new THREE.MeshPhongMaterial( { color: 0xff2200 } );
const mesh = new THREE.Mesh( sphere, material );
scene.add( mesh );

// finally add the sound to the mesh
mesh.add( sound );

**Kind**: global class  
**Extends**: <code>Audio</code>  

* [PositionalAudio](#PositionalAudio) ⇐ <code>Audio</code>
    * [new PositionalAudio(listener)](#new_PositionalAudio_new)
    * [.panner](#PositionalAudio+panner) : <code>PannerNode</code>
    * [.getRefDistance()](#PositionalAudio+getRefDistance) ⇒ <code>number</code>
    * [.setRefDistance(value)](#PositionalAudio+setRefDistance) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
    * [.getRolloffFactor()](#PositionalAudio+getRolloffFactor) ⇒ <code>number</code>
    * [.setRolloffFactor(value)](#PositionalAudio+setRolloffFactor) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
    * [.getDistanceModel()](#PositionalAudio+getDistanceModel) ⇒ <code>&#x27;linear&#x27;</code> \| <code>&#x27;inverse&#x27;</code> \| <code>&#x27;exponential&#x27;</code>
    * [.setDistanceModel(value)](#PositionalAudio+setDistanceModel) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
    * [.getMaxDistance()](#PositionalAudio+getMaxDistance) ⇒ <code>number</code>
    * [.setMaxDistance(value)](#PositionalAudio+setMaxDistance) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
    * [.setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain)](#PositionalAudio+setDirectionalCone) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)

<a name="new_PositionalAudio_new"></a>

### new PositionalAudio(listener)
Constructs a positional audio.


| Param | Type | Description |
| --- | --- | --- |
| listener | <code>AudioListener</code> | The global audio listener. |

<a name="PositionalAudio+panner"></a>

### positionalAudio.panner : <code>PannerNode</code>
The panner node represents the location, direction, and behavior of an audio
source in 3D space.

**Kind**: instance property of [<code>PositionalAudio</code>](#PositionalAudio)  
**Read only**: true  
<a name="PositionalAudio+getRefDistance"></a>

### positionalAudio.getRefDistance() ⇒ <code>number</code>
Returns the current reference distance.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: <code>number</code> - The reference distance.  
<a name="PositionalAudio+setRefDistance"></a>

### positionalAudio.setRefDistance(value) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
Defines the reference distance for reducing volume as the audio source moves
further from the listener – i.e. the distance at which the volume reduction
starts taking effect.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: [<code>PositionalAudio</code>](#PositionalAudio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The reference distance to set. |

<a name="PositionalAudio+getRolloffFactor"></a>

### positionalAudio.getRolloffFactor() ⇒ <code>number</code>
Returns the current rolloff factor.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: <code>number</code> - The rolloff factor.  
<a name="PositionalAudio+setRolloffFactor"></a>

### positionalAudio.setRolloffFactor(value) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
Defines how quickly the volume is reduced as the source moves away from the listener.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: [<code>PositionalAudio</code>](#PositionalAudio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The rolloff factor. |

<a name="PositionalAudio+getDistanceModel"></a>

### positionalAudio.getDistanceModel() ⇒ <code>&#x27;linear&#x27;</code> \| <code>&#x27;inverse&#x27;</code> \| <code>&#x27;exponential&#x27;</code>
Returns the current distance model.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: <code>&#x27;linear&#x27;</code> \| <code>&#x27;inverse&#x27;</code> \| <code>&#x27;exponential&#x27;</code> - The distance model.  
<a name="PositionalAudio+setDistanceModel"></a>

### positionalAudio.setDistanceModel(value) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
Defines which algorithm to use to reduce the volume of the audio source
as it moves away from the listener.

Read [the spec](https://www.w3.org/TR/webaudio-1.1/#enumdef-distancemodeltype)
for more details.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: [<code>PositionalAudio</code>](#PositionalAudio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>&#x27;linear&#x27;</code> \| <code>&#x27;inverse&#x27;</code> \| <code>&#x27;exponential&#x27;</code> | The distance model to set. |

<a name="PositionalAudio+getMaxDistance"></a>

### positionalAudio.getMaxDistance() ⇒ <code>number</code>
Returns the current max distance.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: <code>number</code> - The max distance.  
<a name="PositionalAudio+setMaxDistance"></a>

### positionalAudio.setMaxDistance(value) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
Defines the maximum distance between the audio source and the listener,
after which the volume is not reduced any further.

This value is used only by the `linear` distance model.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: [<code>PositionalAudio</code>](#PositionalAudio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The max distance. |

<a name="PositionalAudio+setDirectionalCone"></a>

### positionalAudio.setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) ⇒ [<code>PositionalAudio</code>](#PositionalAudio)
Sets the directional cone in which the audio can be listened.

**Kind**: instance method of [<code>PositionalAudio</code>](#PositionalAudio)  
**Returns**: [<code>PositionalAudio</code>](#PositionalAudio) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| coneInnerAngle | <code>number</code> | An angle, in degrees, of a cone inside of which there will be no volume reduction. |
| coneOuterAngle | <code>number</code> | An angle, in degrees, of a cone outside of which the volume will be reduced by a constant value, defined by the `coneOuterGain` parameter. |
| coneOuterGain | <code>number</code> | The amount of volume reduction outside the cone defined by the `coneOuterAngle`. When set to `0`, no sound can be heard. |

<a name="ArrayCamera"></a>

## ArrayCamera ⇐ <code>PerspectiveCamera</code>
This type of camera can be used in order to efficiently render a scene with a
predefined set of cameras. This is an important performance aspect for
rendering VR scenes.

An instance of `ArrayCamera` always has an array of sub cameras. It's mandatory
to define for each sub camera the `viewport` property which determines the
part of the viewport that is rendered with this camera.

**Kind**: global class  
**Extends**: <code>PerspectiveCamera</code>  

* [ArrayCamera](#ArrayCamera) ⇐ <code>PerspectiveCamera</code>
    * [new ArrayCamera([array])](#new_ArrayCamera_new)
    * [.isArrayCamera](#ArrayCamera+isArrayCamera) : <code>boolean</code>
    * [.cameras](#ArrayCamera+cameras) : <code>Array.&lt;PerspectiveCamera&gt;</code>

<a name="new_ArrayCamera_new"></a>

### new ArrayCamera([array])
Constructs a new array camera.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;PerspectiveCamera&gt;</code> | <code>[]</code> | An array of perspective sub cameras. |

<a name="ArrayCamera+isArrayCamera"></a>

### arrayCamera.isArrayCamera : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ArrayCamera</code>](#ArrayCamera)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ArrayCamera+cameras"></a>

### arrayCamera.cameras : <code>Array.&lt;PerspectiveCamera&gt;</code>
An array of perspective sub cameras.

**Kind**: instance property of [<code>ArrayCamera</code>](#ArrayCamera)  
<a name="Camera"></a>

## *Camera ⇐ <code>Object3D</code>*
Abstract base class for cameras. This class should always be inherited
when you build a new camera.

**Kind**: global abstract class  
**Extends**: <code>Object3D</code>  

* *[Camera](#Camera) ⇐ <code>Object3D</code>*
    * *[new Camera()](#new_Camera_new)*
    * *[.isCamera](#Camera+isCamera) : <code>boolean</code>*
    * *[.matrixWorldInverse](#Camera+matrixWorldInverse) : <code>Matrix4</code>*
    * *[.projectionMatrix](#Camera+projectionMatrix) : <code>Matrix4</code>*
    * *[.projectionMatrixInverse](#Camera+projectionMatrixInverse) : <code>Matrix4</code>*
    * *[.coordinateSystem](#Camera+coordinateSystem) : <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code>*
    * *[.getWorldDirection(target)](#Camera+getWorldDirection) ⇒ <code>Vector3</code>*

<a name="new_Camera_new"></a>

### *new Camera()*
Constructs a new camera.

<a name="Camera+isCamera"></a>

### *camera.isCamera : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>Camera</code>](#Camera)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Camera+matrixWorldInverse"></a>

### *camera.matrixWorldInverse : <code>Matrix4</code>*
The inverse of the camera's world matrix.

**Kind**: instance property of [<code>Camera</code>](#Camera)  
<a name="Camera+projectionMatrix"></a>

### *camera.projectionMatrix : <code>Matrix4</code>*
The camera's projection matrix.

**Kind**: instance property of [<code>Camera</code>](#Camera)  
<a name="Camera+projectionMatrixInverse"></a>

### *camera.projectionMatrixInverse : <code>Matrix4</code>*
The inverse of the camera's projection matrix.

**Kind**: instance property of [<code>Camera</code>](#Camera)  
<a name="Camera+coordinateSystem"></a>

### *camera.coordinateSystem : <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code>*
The coordinate system in which the camera is used.

**Kind**: instance property of [<code>Camera</code>](#Camera)  
<a name="Camera+getWorldDirection"></a>

### *camera.getWorldDirection(target) ⇒ <code>Vector3</code>*
Returns a vector representing the ("look") direction of the 3D object in world space.

This method is overwritten since cameras have a different forward vector compared to other
3D objects. A camera looks down its local, negative z-axis by default.

**Kind**: instance method of [<code>Camera</code>](#Camera)  
**Returns**: <code>Vector3</code> - The 3D object's direction in world space.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector the result is stored to. |

<a name="CubeCamera"></a>

## CubeCamera ⇐ <code>Object3D</code>
A special type of camera that is positioned in 3D space to render its surroundings into a
cube render target. The render target can then be used as an environment map for rendering
realtime reflections in your scene.

```js
// Create cube render target
const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );

// Create cube camera
const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
scene.add( cubeCamera );

// Create car
const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );
const car = new THREE.Mesh( carGeometry, chromeMaterial );
scene.add( car );

// Update the render target cube
car.visible = false;
cubeCamera.position.copy( car.position );
cubeCamera.update( renderer, scene );

// Render the scene
car.visible = true;
renderer.render( scene, camera );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [CubeCamera](#CubeCamera) ⇐ <code>Object3D</code>
    * [new CubeCamera(near, far, renderTarget)](#new_CubeCamera_new)
    * [.renderTarget](#CubeCamera+renderTarget) : <code>WebGLCubeRenderTarget</code>
    * [.coordinateSystem](#CubeCamera+coordinateSystem) : <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code>
    * [.activeMipmapLevel](#CubeCamera+activeMipmapLevel) : <code>number</code>
    * [.updateCoordinateSystem()](#CubeCamera+updateCoordinateSystem)
    * [.update(renderer, scene)](#CubeCamera+update)

<a name="new_CubeCamera_new"></a>

### new CubeCamera(near, far, renderTarget)
Constructs a new cube camera.


| Param | Type | Description |
| --- | --- | --- |
| near | <code>number</code> | The camera's near plane. |
| far | <code>number</code> | The camera's far plane. |
| renderTarget | <code>WebGLCubeRenderTarget</code> | The cube render target. |

<a name="CubeCamera+renderTarget"></a>

### cubeCamera.renderTarget : <code>WebGLCubeRenderTarget</code>
A reference to the cube render target.

**Kind**: instance property of [<code>CubeCamera</code>](#CubeCamera)  
<a name="CubeCamera+coordinateSystem"></a>

### cubeCamera.coordinateSystem : <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code>
The current active coordinate system.

**Kind**: instance property of [<code>CubeCamera</code>](#CubeCamera)  
**Default**: <code>null</code>  
<a name="CubeCamera+activeMipmapLevel"></a>

### cubeCamera.activeMipmapLevel : <code>number</code>
The current active mipmap level

**Kind**: instance property of [<code>CubeCamera</code>](#CubeCamera)  
**Default**: <code>0</code>  
<a name="CubeCamera+updateCoordinateSystem"></a>

### cubeCamera.updateCoordinateSystem()
Must be called when the coordinate system of the cube camera is changed.

**Kind**: instance method of [<code>CubeCamera</code>](#CubeCamera)  
<a name="CubeCamera+update"></a>

### cubeCamera.update(renderer, scene)
Calling this method will render the given scene with the given renderer
into the cube render target of the camera.

**Kind**: instance method of [<code>CubeCamera</code>](#CubeCamera)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> \| <code>WebGLRenderer</code> | The renderer. |
| scene | <code>Scene</code> | The scene to render. |

<a name="OrthographicCamera"></a>

## OrthographicCamera ⇐ <code>Camera</code>
Camera that uses [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection).

In this projection mode, an object's size in the rendered image stays
constant regardless of its distance from the camera. This can be useful
for rendering 2D scenes and UI elements, amongst other things.

```js
const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
scene.add( camera );
```

**Kind**: global class  
**Extends**: <code>Camera</code>  

* [OrthographicCamera](#OrthographicCamera) ⇐ <code>Camera</code>
    * [new OrthographicCamera([left], [right], [top], [bottom], [near], [far])](#new_OrthographicCamera_new)
    * [.isOrthographicCamera](#OrthographicCamera+isOrthographicCamera) : <code>boolean</code>
    * [.zoom](#OrthographicCamera+zoom) : <code>number</code>
    * [.view](#OrthographicCamera+view) : <code>Object</code>
    * [.left](#OrthographicCamera+left) : <code>number</code>
    * [.right](#OrthographicCamera+right) : <code>number</code>
    * [.top](#OrthographicCamera+top) : <code>number</code>
    * [.bottom](#OrthographicCamera+bottom) : <code>number</code>
    * [.near](#OrthographicCamera+near) : <code>number</code>
    * [.far](#OrthographicCamera+far) : <code>number</code>
    * [.setViewOffset(fullWidth, fullHeight, x, y, width, height)](#OrthographicCamera+setViewOffset)
    * [.clearViewOffset()](#OrthographicCamera+clearViewOffset)
    * [.updateProjectionMatrix()](#OrthographicCamera+updateProjectionMatrix)

<a name="new_OrthographicCamera_new"></a>

### new OrthographicCamera([left], [right], [top], [bottom], [near], [far])
Constructs a new orthographic camera.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [left] | <code>number</code> | <code>-1</code> | The left plane of the camera's frustum. |
| [right] | <code>number</code> | <code>1</code> | The right plane of the camera's frustum. |
| [top] | <code>number</code> | <code>1</code> | The top plane of the camera's frustum. |
| [bottom] | <code>number</code> | <code>-1</code> | The bottom plane of the camera's frustum. |
| [near] | <code>number</code> | <code>0.1</code> | The camera's near plane. |
| [far] | <code>number</code> | <code>2000</code> | The camera's far plane. |

<a name="OrthographicCamera+isOrthographicCamera"></a>

### orthographicCamera.isOrthographicCamera : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="OrthographicCamera+zoom"></a>

### orthographicCamera.zoom : <code>number</code>
The zoom factor of the camera.

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>1</code>  
<a name="OrthographicCamera+view"></a>

### orthographicCamera.view : <code>Object</code>
Represents the frustum window specification. This property should not be edited
directly but via [PerspectiveCamera#setViewOffset](PerspectiveCamera#setViewOffset) and [PerspectiveCamera#clearViewOffset](PerspectiveCamera#clearViewOffset).

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>null</code>  
<a name="OrthographicCamera+left"></a>

### orthographicCamera.left : <code>number</code>
The left plane of the camera's frustum.

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>-1</code>  
<a name="OrthographicCamera+right"></a>

### orthographicCamera.right : <code>number</code>
The right plane of the camera's frustum.

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>1</code>  
<a name="OrthographicCamera+top"></a>

### orthographicCamera.top : <code>number</code>
The top plane of the camera's frustum.

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>1</code>  
<a name="OrthographicCamera+bottom"></a>

### orthographicCamera.bottom : <code>number</code>
The bottom plane of the camera's frustum.

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>-1</code>  
<a name="OrthographicCamera+near"></a>

### orthographicCamera.near : <code>number</code>
The camera's near plane. The valid range is greater than `0`
and less than the current value of [far](#OrthographicCamera+far).

Note that, unlike for the [PerspectiveCamera](PerspectiveCamera), `0` is a
valid value for an orthographic camera's near plane.

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>0.1</code>  
<a name="OrthographicCamera+far"></a>

### orthographicCamera.far : <code>number</code>
The camera's far plane. Must be greater than the
current value of [near](#OrthographicCamera+near).

**Kind**: instance property of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**Default**: <code>2000</code>  
<a name="OrthographicCamera+setViewOffset"></a>

### orthographicCamera.setViewOffset(fullWidth, fullHeight, x, y, width, height)
Sets an offset in a larger frustum. This is useful for multi-window or
multi-monitor/multi-machine setups.

**Kind**: instance method of [<code>OrthographicCamera</code>](#OrthographicCamera)  
**See**: [PerspectiveCamera#setViewOffset](PerspectiveCamera#setViewOffset)  

| Param | Type | Description |
| --- | --- | --- |
| fullWidth | <code>number</code> | The full width of multiview setup. |
| fullHeight | <code>number</code> | The full height of multiview setup. |
| x | <code>number</code> | The horizontal offset of the subcamera. |
| y | <code>number</code> | The vertical offset of the subcamera. |
| width | <code>number</code> | The width of subcamera. |
| height | <code>number</code> | The height of subcamera. |

<a name="OrthographicCamera+clearViewOffset"></a>

### orthographicCamera.clearViewOffset()
Removes the view offset from the projection matrix.

**Kind**: instance method of [<code>OrthographicCamera</code>](#OrthographicCamera)  
<a name="OrthographicCamera+updateProjectionMatrix"></a>

### orthographicCamera.updateProjectionMatrix()
Updates the camera's projection matrix. Must be called after any change of
camera properties.

**Kind**: instance method of [<code>OrthographicCamera</code>](#OrthographicCamera)  
<a name="PerspectiveCamera"></a>

## PerspectiveCamera ⇐ <code>Camera</code>
Camera that uses [perspective projection](https://en.wikipedia.org/wiki/Perspective_(graphical)).

This projection mode is designed to mimic the way the human eye sees. It
is the most common projection mode used for rendering a 3D scene.

```js
const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
scene.add( camera );
```

**Kind**: global class  
**Extends**: <code>Camera</code>  

* [PerspectiveCamera](#PerspectiveCamera) ⇐ <code>Camera</code>
    * [new PerspectiveCamera([fov], [aspect], [near], [far])](#new_PerspectiveCamera_new)
    * [.isPerspectiveCamera](#PerspectiveCamera+isPerspectiveCamera) : <code>boolean</code>
    * [.fov](#PerspectiveCamera+fov) : <code>number</code>
    * [.zoom](#PerspectiveCamera+zoom) : <code>number</code>
    * [.near](#PerspectiveCamera+near) : <code>number</code>
    * [.far](#PerspectiveCamera+far) : <code>number</code>
    * [.focus](#PerspectiveCamera+focus) : <code>number</code>
    * [.aspect](#PerspectiveCamera+aspect) : <code>number</code>
    * [.view](#PerspectiveCamera+view) : <code>Object</code>
    * [.filmGauge](#PerspectiveCamera+filmGauge) : <code>number</code>
    * [.filmOffset](#PerspectiveCamera+filmOffset) : <code>number</code>
    * [.setFocalLength(focalLength)](#PerspectiveCamera+setFocalLength)
    * [.getFocalLength()](#PerspectiveCamera+getFocalLength) ⇒ <code>number</code>
    * [.getEffectiveFOV()](#PerspectiveCamera+getEffectiveFOV) ⇒ <code>number</code>
    * [.getFilmWidth()](#PerspectiveCamera+getFilmWidth) ⇒ <code>number</code>
    * [.getFilmHeight()](#PerspectiveCamera+getFilmHeight) ⇒ <code>number</code>
    * [.getViewBounds(distance, minTarget, maxTarget)](#PerspectiveCamera+getViewBounds)
    * [.getViewSize(distance, target)](#PerspectiveCamera+getViewSize) ⇒ <code>Vector2</code>
    * [.setViewOffset(fullWidth, fullHeight, x, y, width, height)](#PerspectiveCamera+setViewOffset)
    * [.clearViewOffset()](#PerspectiveCamera+clearViewOffset)
    * [.updateProjectionMatrix()](#PerspectiveCamera+updateProjectionMatrix)

<a name="new_PerspectiveCamera_new"></a>

### new PerspectiveCamera([fov], [aspect], [near], [far])
Constructs a new perspective camera.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [fov] | <code>number</code> | <code>50</code> | The vertical field of view. |
| [aspect] | <code>number</code> | <code>1</code> | The aspect ratio. |
| [near] | <code>number</code> | <code>0.1</code> | The camera's near plane. |
| [far] | <code>number</code> | <code>2000</code> | The camera's far plane. |

<a name="PerspectiveCamera+isPerspectiveCamera"></a>

### perspectiveCamera.isPerspectiveCamera : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PerspectiveCamera+fov"></a>

### perspectiveCamera.fov : <code>number</code>
The vertical field of view, from bottom to top of view,
in degrees.

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>50</code>  
<a name="PerspectiveCamera+zoom"></a>

### perspectiveCamera.zoom : <code>number</code>
The zoom factor of the camera.

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>1</code>  
<a name="PerspectiveCamera+near"></a>

### perspectiveCamera.near : <code>number</code>
The camera's near plane. The valid range is greater than `0`
and less than the current value of [far](#PerspectiveCamera+far).

Note that, unlike for the [OrthographicCamera](OrthographicCamera), `0` is <em>not</em> a
valid value for a perspective camera's near plane.

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>0.1</code>  
<a name="PerspectiveCamera+far"></a>

### perspectiveCamera.far : <code>number</code>
The camera's far plane. Must be greater than the
current value of [near](#PerspectiveCamera+near).

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>2000</code>  
<a name="PerspectiveCamera+focus"></a>

### perspectiveCamera.focus : <code>number</code>
Object distance used for stereoscopy and depth-of-field effects. This
parameter does not influence the projection matrix unless a
[StereoCamera](StereoCamera) is being used.

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>10</code>  
<a name="PerspectiveCamera+aspect"></a>

### perspectiveCamera.aspect : <code>number</code>
The aspect ratio, usually the canvas width / canvas height.

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>1</code>  
<a name="PerspectiveCamera+view"></a>

### perspectiveCamera.view : <code>Object</code>
Represents the frustum window specification. This property should not be edited
directly but via [setViewOffset](#PerspectiveCamera+setViewOffset) and [clearViewOffset](#PerspectiveCamera+clearViewOffset).

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>null</code>  
<a name="PerspectiveCamera+filmGauge"></a>

### perspectiveCamera.filmGauge : <code>number</code>
Film size used for the larger axis. Default is `35` (millimeters). This
parameter does not influence the projection matrix unless [filmOffset](#PerspectiveCamera+filmOffset)
is set to a nonzero value.

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>35</code>  
<a name="PerspectiveCamera+filmOffset"></a>

### perspectiveCamera.filmOffset : <code>number</code>
Horizontal off-center offset in the same unit as [filmGauge](#PerspectiveCamera+filmGauge).

**Kind**: instance property of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Default**: <code>0</code>  
<a name="PerspectiveCamera+setFocalLength"></a>

### perspectiveCamera.setFocalLength(focalLength)
Sets the FOV by focal length in respect to the current [filmGauge](#PerspectiveCamera+filmGauge).

The default film gauge is 35, so that the focal length can be specified for
a 35mm (full frame) camera.

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  

| Param | Type | Description |
| --- | --- | --- |
| focalLength | <code>number</code> | Values for focal length and film gauge must have the same unit. |

<a name="PerspectiveCamera+getFocalLength"></a>

### perspectiveCamera.getFocalLength() ⇒ <code>number</code>
Returns the focal length from the current [fov](#PerspectiveCamera+fov) and
[filmGauge](#PerspectiveCamera+filmGauge).

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Returns**: <code>number</code> - The computed focal length.  
<a name="PerspectiveCamera+getEffectiveFOV"></a>

### perspectiveCamera.getEffectiveFOV() ⇒ <code>number</code>
Returns the current vertical field of view angle in degrees considering [zoom](#PerspectiveCamera+zoom).

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Returns**: <code>number</code> - The effective FOV.  
<a name="PerspectiveCamera+getFilmWidth"></a>

### perspectiveCamera.getFilmWidth() ⇒ <code>number</code>
Returns the width of the image on the film. If [aspect](#PerspectiveCamera+aspect) is greater than or
equal to one (landscape format), the result equals [filmGauge](#PerspectiveCamera+filmGauge).

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Returns**: <code>number</code> - The film width.  
<a name="PerspectiveCamera+getFilmHeight"></a>

### perspectiveCamera.getFilmHeight() ⇒ <code>number</code>
Returns the height of the image on the film. If [aspect](#PerspectiveCamera+aspect) is greater than or
equal to one (landscape format), the result equals [filmGauge](#PerspectiveCamera+filmGauge).

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Returns**: <code>number</code> - The film width.  
<a name="PerspectiveCamera+getViewBounds"></a>

### perspectiveCamera.getViewBounds(distance, minTarget, maxTarget)
Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The viewing distance. |
| minTarget | <code>Vector2</code> | The lower-left corner of the view rectangle is written into this vector. |
| maxTarget | <code>Vector2</code> | The upper-right corner of the view rectangle is written into this vector. |

<a name="PerspectiveCamera+getViewSize"></a>

### perspectiveCamera.getViewSize(distance, target) ⇒ <code>Vector2</code>
Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
**Returns**: <code>Vector2</code> - The view size.  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The viewing distance. |
| target | <code>Vector2</code> | The target vector that is used to store result where x is width and y is height. |

<a name="PerspectiveCamera+setViewOffset"></a>

### perspectiveCamera.setViewOffset(fullWidth, fullHeight, x, y, width, height)
Sets an offset in a larger frustum. This is useful for multi-window or
multi-monitor/multi-machine setups.

For example, if you have 3x2 monitors and each monitor is 1920x1080 and
the monitors are in grid like this
```
  +---+---+---+
  | A | B | C |
  +---+---+---+
  | D | E | F |
  +---+---+---+
```
then for each monitor you would call it like this:
```js
const w = 1920;
const h = 1080;
const fullWidth = w * 3;
const fullHeight = h * 2;

// --A--
camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
// --B--
camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
// --C--
camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
// --D--
camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
// --E--
camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
// --F--
camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
```

Note there is no reason monitors have to be the same size or in a grid.

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  

| Param | Type | Description |
| --- | --- | --- |
| fullWidth | <code>number</code> | The full width of multiview setup. |
| fullHeight | <code>number</code> | The full height of multiview setup. |
| x | <code>number</code> | The horizontal offset of the subcamera. |
| y | <code>number</code> | The vertical offset of the subcamera. |
| width | <code>number</code> | The width of subcamera. |
| height | <code>number</code> | The height of subcamera. |

<a name="PerspectiveCamera+clearViewOffset"></a>

### perspectiveCamera.clearViewOffset()
Removes the view offset from the projection matrix.

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
<a name="PerspectiveCamera+updateProjectionMatrix"></a>

### perspectiveCamera.updateProjectionMatrix()
Updates the camera's projection matrix. Must be called after any change of
camera properties.

**Kind**: instance method of [<code>PerspectiveCamera</code>](#PerspectiveCamera)  
<a name="StereoCamera"></a>

## StereoCamera
A special type of camera that uses two perspective cameras with
stereoscopic projection. Can be used for rendering stereo effects
like [3D Anaglyph](https://en.wikipedia.org/wiki/Anaglyph_3D) or
[Parallax Barrier](https://en.wikipedia.org/wiki/parallax_barrier).

**Kind**: global class  

* [StereoCamera](#StereoCamera)
    * [new StereoCamera()](#new_StereoCamera_new)
    * [.type](#StereoCamera+type) : <code>string</code>
    * [.aspect](#StereoCamera+aspect) : <code>number</code>
    * [.eyeSep](#StereoCamera+eyeSep) : <code>number</code>
    * [.cameraL](#StereoCamera+cameraL) : <code>PerspectiveCamera</code>
    * [.cameraR](#StereoCamera+cameraR) : <code>PerspectiveCamera</code>
    * [.update(camera)](#StereoCamera+update)

<a name="new_StereoCamera_new"></a>

### new StereoCamera()
Constructs a new stereo camera.

<a name="StereoCamera+type"></a>

### stereoCamera.type : <code>string</code>
The type property is used for detecting the object type
in context of serialization/deserialization.

**Kind**: instance property of [<code>StereoCamera</code>](#StereoCamera)  
**Read only**: true  
<a name="StereoCamera+aspect"></a>

### stereoCamera.aspect : <code>number</code>
The aspect.

**Kind**: instance property of [<code>StereoCamera</code>](#StereoCamera)  
**Default**: <code>1</code>  
<a name="StereoCamera+eyeSep"></a>

### stereoCamera.eyeSep : <code>number</code>
The eye separation which represents the distance
between the left and right camera.

**Kind**: instance property of [<code>StereoCamera</code>](#StereoCamera)  
**Default**: <code>0.064</code>  
<a name="StereoCamera+cameraL"></a>

### stereoCamera.cameraL : <code>PerspectiveCamera</code>
The camera representing the left eye. This is added to layer `1` so objects to be
rendered by the left camera must also be added to this layer.

**Kind**: instance property of [<code>StereoCamera</code>](#StereoCamera)  
<a name="StereoCamera+cameraR"></a>

### stereoCamera.cameraR : <code>PerspectiveCamera</code>
The camera representing the right eye. This is added to layer `2` so objects to be
rendered by the right camera must also be added to this layer.

**Kind**: instance property of [<code>StereoCamera</code>](#StereoCamera)  
<a name="StereoCamera+update"></a>

### stereoCamera.update(camera)
Updates the stereo camera based on the given perspective camera.

**Kind**: instance method of [<code>StereoCamera</code>](#StereoCamera)  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>PerspectiveCamera</code> | The perspective camera. |

## Constants

<dl>
<dt><a href="#MOUSE">MOUSE</a> : <code><a href="#ConstantsMouse">ConstantsMouse</a></code></dt>
<dd><p>Represents mouse buttons and interaction types in context of controls.</p>
</dd>
<dt><a href="#TOUCH">TOUCH</a> : <code><a href="#ConstantsTouch">ConstantsTouch</a></code></dt>
<dd><p>Represents touch interaction types in context of controls.</p>
</dd>
<dt><a href="#CullFaceNone">CullFaceNone</a> : <code>number</code></dt>
<dd><p>Disables face culling.</p>
</dd>
<dt><a href="#CullFaceBack">CullFaceBack</a> : <code>number</code></dt>
<dd><p>Culls back faces.</p>
</dd>
<dt><a href="#CullFaceFront">CullFaceFront</a> : <code>number</code></dt>
<dd><p>Culls front faces.</p>
</dd>
<dt><a href="#CullFaceFrontBack">CullFaceFrontBack</a> : <code>number</code></dt>
<dd><p>Culls both front and back faces.</p>
</dd>
<dt><a href="#BasicShadowMap">BasicShadowMap</a> : <code>number</code></dt>
<dd><p>Gives unfiltered shadow maps - fastest, but lowest quality.</p>
</dd>
<dt><a href="#PCFShadowMap">PCFShadowMap</a> : <code>number</code></dt>
<dd><p>Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.</p>
</dd>
<dt><a href="#PCFSoftShadowMap">PCFSoftShadowMap</a> : <code>number</code></dt>
<dd><p>Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with
better soft shadows especially when using low-resolution shadow maps.</p>
</dd>
<dt><a href="#VSMShadowMap">VSMShadowMap</a> : <code>number</code></dt>
<dd><p>Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
When using VSMShadowMap all shadow receivers will also cast shadows.</p>
</dd>
<dt><a href="#FrontSide">FrontSide</a> : <code>number</code></dt>
<dd><p>Only front faces are rendered.</p>
</dd>
<dt><a href="#BackSide">BackSide</a> : <code>number</code></dt>
<dd><p>Only back faces are rendered.</p>
</dd>
<dt><a href="#DoubleSide">DoubleSide</a> : <code>number</code></dt>
<dd><p>Both front and back faces are rendered.</p>
</dd>
<dt><a href="#NoBlending">NoBlending</a> : <code>number</code></dt>
<dd><p>No blending is performed which effectively disables
alpha transparency.</p>
</dd>
<dt><a href="#NormalBlending">NormalBlending</a> : <code>number</code></dt>
<dd><p>The default blending.</p>
</dd>
<dt><a href="#AdditiveBlending">AdditiveBlending</a> : <code>number</code></dt>
<dd><p>Represents additive blending.</p>
</dd>
<dt><a href="#SubtractiveBlending">SubtractiveBlending</a> : <code>number</code></dt>
<dd><p>Represents subtractive blending.</p>
</dd>
<dt><a href="#MultiplyBlending">MultiplyBlending</a> : <code>number</code></dt>
<dd><p>Represents multiply blending.</p>
</dd>
<dt><a href="#CustomBlending">CustomBlending</a> : <code>number</code></dt>
<dd><p>Represents custom blending.</p>
</dd>
<dt><a href="#AddEquation">AddEquation</a> : <code>number</code></dt>
<dd><p>A <code>source + destination</code> blending equation.</p>
</dd>
<dt><a href="#SubtractEquation">SubtractEquation</a> : <code>number</code></dt>
<dd><p>A <code>source - destination</code> blending equation.</p>
</dd>
<dt><a href="#ReverseSubtractEquation">ReverseSubtractEquation</a> : <code>number</code></dt>
<dd><p>A <code>destination - source</code> blending equation.</p>
</dd>
<dt><a href="#MinEquation">MinEquation</a> : <code>number</code></dt>
<dd><p>A blend equation that uses the minimum of source and destination.</p>
</dd>
<dt><a href="#MaxEquation">MaxEquation</a> : <code>number</code></dt>
<dd><p>A blend equation that uses the maximum of source and destination.</p>
</dd>
<dt><a href="#ZeroFactor">ZeroFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by <code>0</code>.</p>
</dd>
<dt><a href="#OneFactor">OneFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by <code>1</code>.</p>
</dd>
<dt><a href="#SrcColorFactor">SrcColorFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by the source colors.</p>
</dd>
<dt><a href="#OneMinusSrcColorFactor">OneMinusSrcColorFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by <code>1</code> minus each source color.</p>
</dd>
<dt><a href="#SrcAlphaFactor">SrcAlphaFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by the source alpha value.</p>
</dd>
<dt><a href="#OneMinusSrcAlphaFactor">OneMinusSrcAlphaFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by 1 minus the source alpha value.</p>
</dd>
<dt><a href="#DstAlphaFactor">DstAlphaFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by the destination alpha value.</p>
</dd>
<dt><a href="#OneMinusDstAlphaFactor">OneMinusDstAlphaFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by <code>1</code> minus the destination alpha value.</p>
</dd>
<dt><a href="#DstColorFactor">DstColorFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by the destination color.</p>
</dd>
<dt><a href="#OneMinusDstColorFactor">OneMinusDstColorFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by <code>1</code> minus each destination color.</p>
</dd>
<dt><a href="#SrcAlphaSaturateFactor">SrcAlphaSaturateFactor</a> : <code>number</code></dt>
<dd><p>Multiplies the RGB colors by the smaller of either the source alpha
value or the value of <code>1</code> minus the destination alpha value. The alpha
value is multiplied by <code>1</code>.</p>
</dd>
<dt><a href="#ConstantColorFactor">ConstantColorFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by a constant color.</p>
</dd>
<dt><a href="#OneMinusConstantColorFactor">OneMinusConstantColorFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by <code>1</code> minus a constant color.</p>
</dd>
<dt><a href="#ConstantAlphaFactor">ConstantAlphaFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by a constant alpha value.</p>
</dd>
<dt><a href="#OneMinusConstantAlphaFactor">OneMinusConstantAlphaFactor</a> : <code>number</code></dt>
<dd><p>Multiplies all colors by 1 minus a constant alpha value.</p>
</dd>
<dt><a href="#NeverDepth">NeverDepth</a> : <code>number</code></dt>
<dd><p>Never pass.</p>
</dd>
<dt><a href="#AlwaysDepth">AlwaysDepth</a> : <code>number</code></dt>
<dd><p>Always pass.</p>
</dd>
<dt><a href="#LessDepth">LessDepth</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is less than the depth buffer value.</p>
</dd>
<dt><a href="#LessEqualDepth">LessEqualDepth</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is less than or equal to the depth buffer value.</p>
</dd>
<dt><a href="#EqualDepth">EqualDepth</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value equals the depth buffer value.</p>
</dd>
<dt><a href="#GreaterEqualDepth">GreaterEqualDepth</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is greater than or equal to the depth buffer value.</p>
</dd>
<dt><a href="#GreaterDepth">GreaterDepth</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is greater than the depth buffer value.</p>
</dd>
<dt><a href="#NotEqualDepth">NotEqualDepth</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is not equal to the depth buffer value.</p>
</dd>
<dt><a href="#MultiplyOperation">MultiplyOperation</a> : <code>number</code></dt>
<dd><p>Multiplies the environment map color with the surface color.</p>
</dd>
<dt><a href="#MixOperation">MixOperation</a> : <code>number</code></dt>
<dd><p>Uses reflectivity to blend between the two colors.</p>
</dd>
<dt><a href="#AddOperation">AddOperation</a> : <code>number</code></dt>
<dd><p>Adds the two colors.</p>
</dd>
<dt><a href="#NoToneMapping">NoToneMapping</a> : <code>number</code></dt>
<dd><p>No tone mapping is applied.</p>
</dd>
<dt><a href="#LinearToneMapping">LinearToneMapping</a> : <code>number</code></dt>
<dd><p>Linear tone mapping.</p>
</dd>
<dt><a href="#ReinhardToneMapping">ReinhardToneMapping</a> : <code>number</code></dt>
<dd><p>Reinhard tone mapping.</p>
</dd>
<dt><a href="#CineonToneMapping">CineonToneMapping</a> : <code>number</code></dt>
<dd><p>Cineon tone mapping.</p>
</dd>
<dt><a href="#ACESFilmicToneMapping">ACESFilmicToneMapping</a> : <code>number</code></dt>
<dd><p>ACES Filmic tone mapping.</p>
</dd>
<dt><a href="#CustomToneMapping">CustomToneMapping</a> : <code>number</code></dt>
<dd><p>Custom tone mapping.</p>
<p>Expects a custom implementation by modifying shader code of the material&#39;s fragment shader.</p>
</dd>
<dt><a href="#AgXToneMapping">AgXToneMapping</a> : <code>number</code></dt>
<dd><p>AgX tone mapping.</p>
</dd>
<dt><a href="#NeutralToneMapping">NeutralToneMapping</a> : <code>number</code></dt>
<dd><p>Neutral tone mapping.</p>
<p>Implementation based on the Khronos 3D Commerce Group standard tone mapping.</p>
</dd>
<dt><a href="#AttachedBindMode">AttachedBindMode</a> : <code>string</code></dt>
<dd><p>The skinned mesh shares the same world space as the skeleton.</p>
</dd>
<dt><a href="#DetachedBindMode">DetachedBindMode</a> : <code>string</code></dt>
<dd><p>The skinned mesh does not share the same world space as the skeleton.
This is useful when a skeleton is shared across multiple skinned meshes.</p>
</dd>
<dt><a href="#UVMapping">UVMapping</a> : <code>number</code></dt>
<dd><p>Maps textures using the geometry&#39;s UV coordinates.</p>
</dd>
<dt><a href="#CubeReflectionMapping">CubeReflectionMapping</a> : <code>number</code></dt>
<dd><p>Reflection mapping for cube textures.</p>
</dd>
<dt><a href="#CubeRefractionMapping">CubeRefractionMapping</a> : <code>number</code></dt>
<dd><p>Refraction mapping for cube textures.</p>
</dd>
<dt><a href="#EquirectangularReflectionMapping">EquirectangularReflectionMapping</a> : <code>number</code></dt>
<dd><p>Reflection mapping for equirectangular textures.</p>
</dd>
<dt><a href="#EquirectangularRefractionMapping">EquirectangularRefractionMapping</a> : <code>number</code></dt>
<dd><p>Refraction mapping for equirectangular textures.</p>
</dd>
<dt><a href="#CubeUVReflectionMapping">CubeUVReflectionMapping</a> : <code>number</code></dt>
<dd><p>Reflection mapping for PMREM textures.</p>
</dd>
<dt><a href="#RepeatWrapping">RepeatWrapping</a> : <code>number</code></dt>
<dd><p>The texture will simply repeat to infinity.</p>
</dd>
<dt><a href="#ClampToEdgeWrapping">ClampToEdgeWrapping</a> : <code>number</code></dt>
<dd><p>The last pixel of the texture stretches to the edge of the mesh.</p>
</dd>
<dt><a href="#MirroredRepeatWrapping">MirroredRepeatWrapping</a> : <code>number</code></dt>
<dd><p>The texture will repeats to infinity, mirroring on each repeat.</p>
</dd>
<dt><a href="#NearestFilter">NearestFilter</a> : <code>number</code></dt>
<dd><p>Returns the value of the texture element that is nearest (in Manhattan distance)
to the specified texture coordinates.</p>
</dd>
<dt><a href="#NearestMipmapNearestFilter">NearestMipmapNearestFilter</a> : <code>number</code></dt>
<dd><p>Chooses the mipmap that most closely matches the size of the pixel being textured
and uses the <code>NearestFilter</code> criterion (the texel nearest to the center of the pixel)
to produce a texture value.</p>
</dd>
<dt><a href="#NearestMipmapLinearFilter">NearestMipmapLinearFilter</a> : <code>number</code></dt>
<dd><p>Chooses the two mipmaps that most closely match the size of the pixel being textured and
uses the <code>NearestFilter</code> criterion to produce a texture value from each mipmap.
The final texture value is a weighted average of those two values.</p>
</dd>
<dt><a href="#LinearFilter">LinearFilter</a> : <code>number</code></dt>
<dd><p>Returns the weighted average of the four texture elements that are closest to the specified
texture coordinates, and can include items wrapped or repeated from other parts of a texture,
depending on the values of <code>wrapS</code> and <code>wrapT</code>, and on the exact mapping.</p>
</dd>
<dt><a href="#LinearMipmapNearestFilter">LinearMipmapNearestFilter</a> : <code>number</code></dt>
<dd><p>Chooses the mipmap that most closely matches the size of the pixel being textured and uses
the <code>LinearFilter</code> criterion (a weighted average of the four texels that are closest to the
center of the pixel) to produce a texture value.</p>
</dd>
<dt><a href="#LinearMipmapLinearFilter">LinearMipmapLinearFilter</a> : <code>number</code></dt>
<dd><p>Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
the <code>LinearFilter</code> criterion to produce a texture value from each mipmap. The final texture value
is a weighted average of those two values.</p>
</dd>
<dt><a href="#UnsignedByteType">UnsignedByteType</a> : <code>number</code></dt>
<dd><p>An unsigned byte data type for textures.</p>
</dd>
<dt><a href="#ByteType">ByteType</a> : <code>number</code></dt>
<dd><p>A byte data type for textures.</p>
</dd>
<dt><a href="#ShortType">ShortType</a> : <code>number</code></dt>
<dd><p>A short data type for textures.</p>
</dd>
<dt><a href="#UnsignedShortType">UnsignedShortType</a> : <code>number</code></dt>
<dd><p>An unsigned short data type for textures.</p>
</dd>
<dt><a href="#IntType">IntType</a> : <code>number</code></dt>
<dd><p>An int data type for textures.</p>
</dd>
<dt><a href="#UnsignedIntType">UnsignedIntType</a> : <code>number</code></dt>
<dd><p>An unsigned int data type for textures.</p>
</dd>
<dt><a href="#FloatType">FloatType</a> : <code>number</code></dt>
<dd><p>A float data type for textures.</p>
</dd>
<dt><a href="#HalfFloatType">HalfFloatType</a> : <code>number</code></dt>
<dd><p>A half float data type for textures.</p>
</dd>
<dt><a href="#UnsignedShort4444Type">UnsignedShort4444Type</a> : <code>number</code></dt>
<dd><p>An unsigned short 4_4_4_4 (packed) data type for textures.</p>
</dd>
<dt><a href="#UnsignedShort5551Type">UnsignedShort5551Type</a> : <code>number</code></dt>
<dd><p>An unsigned short 5_5_5_1 (packed) data type for textures.</p>
</dd>
<dt><a href="#UnsignedInt248Type">UnsignedInt248Type</a> : <code>number</code></dt>
<dd><p>An unsigned int 24_8 data type for textures.</p>
</dd>
<dt><a href="#UnsignedInt5999Type">UnsignedInt5999Type</a> : <code>number</code></dt>
<dd><p>An unsigned int 5_9_9_9 (packed) data type for textures.</p>
</dd>
<dt><a href="#AlphaFormat">AlphaFormat</a> : <code>number</code></dt>
<dd><p>Discards the red, green and blue components and reads just the alpha component.</p>
</dd>
<dt><a href="#RGBFormat">RGBFormat</a> : <code>number</code></dt>
<dd><p>Discards the alpha component and reads the red, green and blue component.</p>
</dd>
<dt><a href="#RGBAFormat">RGBAFormat</a> : <code>number</code></dt>
<dd><p>Reads the red, green, blue and alpha components.</p>
</dd>
<dt><a href="#LuminanceFormat">LuminanceFormat</a> : <code>number</code></dt>
<dd><p>reads each element as a single luminance component. This is then converted to a floating point,
clamped to the range <code>[0,1]</code>, and then assembled into an RGBA element by placing the luminance value
in the red, green and blue channels, and attaching 1.0 to the alpha channel.</p>
</dd>
<dt><a href="#LuminanceAlphaFormat">LuminanceAlphaFormat</a> : <code>number</code></dt>
<dd><p>Reads each element as a luminance/alpha double. The same process occurs as for the <code>LuminanceFormat</code>,
except that the alpha channel may have values other than <code>1.0</code>.</p>
</dd>
<dt><a href="#DepthFormat">DepthFormat</a> : <code>number</code></dt>
<dd><p>Reads each element as a single depth value, converts it to floating point, and clamps to the range <code>[0,1]</code>.</p>
</dd>
<dt><a href="#DepthStencilFormat">DepthStencilFormat</a> : <code>number</code></dt>
<dd><p>Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
in <code>DepthFormat</code>. The stencil component is interpreted based on the depth + stencil internal format.</p>
</dd>
<dt><a href="#RedFormat">RedFormat</a> : <code>number</code></dt>
<dd><p>Discards the green, blue and alpha components and reads just the red component.</p>
</dd>
<dt><a href="#RedIntegerFormat">RedIntegerFormat</a> : <code>number</code></dt>
<dd><p>Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.</p>
</dd>
<dt><a href="#RGFormat">RGFormat</a> : <code>number</code></dt>
<dd><p>Discards the alpha, and blue components and reads the red, and green components.</p>
</dd>
<dt><a href="#RGIntegerFormat">RGIntegerFormat</a> : <code>number</code></dt>
<dd><p>Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.</p>
</dd>
<dt><a href="#RGBIntegerFormat">RGBIntegerFormat</a> : <code>number</code></dt>
<dd><p>Discards the alpha component and reads the red, green and blue component. The texels are read as integers instead of floating point.</p>
</dd>
<dt><a href="#RGBAIntegerFormat">RGBAIntegerFormat</a> : <code>number</code></dt>
<dd><p>Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.</p>
</dd>
<dt><a href="#RGB_S3TC_DXT1_Format">RGB_S3TC_DXT1_Format</a> : <code>number</code></dt>
<dd><p>A DXT1-compressed image in an RGB image format.</p>
</dd>
<dt><a href="#RGBA_S3TC_DXT1_Format">RGBA_S3TC_DXT1_Format</a> : <code>number</code></dt>
<dd><p>A DXT1-compressed image in an RGB image format with a simple on/off alpha value.</p>
</dd>
<dt><a href="#RGBA_S3TC_DXT3_Format">RGBA_S3TC_DXT3_Format</a> : <code>number</code></dt>
<dd><p>A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.</p>
</dd>
<dt><a href="#RGBA_S3TC_DXT5_Format">RGBA_S3TC_DXT5_Format</a> : <code>number</code></dt>
<dd><p>A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
compression in how the alpha compression is done.</p>
</dd>
<dt><a href="#RGB_PVRTC_4BPPV1_Format">RGB_PVRTC_4BPPV1_Format</a> : <code>number</code></dt>
<dd><p>PVRTC RGB compression in 4-bit mode. One block for each 4×4 pixels.</p>
</dd>
<dt><a href="#RGB_PVRTC_2BPPV1_Format">RGB_PVRTC_2BPPV1_Format</a> : <code>number</code></dt>
<dd><p>PVRTC RGB compression in 2-bit mode. One block for each 8×4 pixels.</p>
</dd>
<dt><a href="#RGBA_PVRTC_4BPPV1_Format">RGBA_PVRTC_4BPPV1_Format</a> : <code>number</code></dt>
<dd><p>PVRTC RGBA compression in 4-bit mode. One block for each 4×4 pixels.</p>
</dd>
<dt><a href="#RGBA_PVRTC_2BPPV1_Format">RGBA_PVRTC_2BPPV1_Format</a> : <code>number</code></dt>
<dd><p>PVRTC RGBA compression in 2-bit mode. One block for each 8×4 pixels.</p>
</dd>
<dt><a href="#RGB_ETC1_Format">RGB_ETC1_Format</a> : <code>number</code></dt>
<dd><p>ETC1 RGB format.</p>
</dd>
<dt><a href="#RGB_ETC2_Format">RGB_ETC2_Format</a> : <code>number</code></dt>
<dd><p>ETC2 RGB format.</p>
</dd>
<dt><a href="#RGBA_ETC2_EAC_Format">RGBA_ETC2_EAC_Format</a> : <code>number</code></dt>
<dd><p>ETC2 RGBA format.</p>
</dd>
<dt><a href="#RGBA_ASTC_4x4_Format">RGBA_ASTC_4x4_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 4x4 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_5x4_Format">RGBA_ASTC_5x4_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 5x4 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_5x5_Format">RGBA_ASTC_5x5_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 5x5 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_6x5_Format">RGBA_ASTC_6x5_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 6x5 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_6x6_Format">RGBA_ASTC_6x6_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 6x6 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_8x5_Format">RGBA_ASTC_8x5_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 8x5 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_8x6_Format">RGBA_ASTC_8x6_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 8x6 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_8x8_Format">RGBA_ASTC_8x8_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 8x8 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_10x5_Format">RGBA_ASTC_10x5_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 10x5 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_10x6_Format">RGBA_ASTC_10x6_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 10x6 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_10x8_Format">RGBA_ASTC_10x8_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 10x8 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_10x10_Format">RGBA_ASTC_10x10_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 10x10 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_12x10_Format">RGBA_ASTC_12x10_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 12x10 format.</p>
</dd>
<dt><a href="#RGBA_ASTC_12x12_Format">RGBA_ASTC_12x12_Format</a> : <code>number</code></dt>
<dd><p>ASTC RGBA 12x12 format.</p>
</dd>
<dt><a href="#RGBA_BPTC_Format">RGBA_BPTC_Format</a> : <code>number</code></dt>
<dd><p>BPTC RGBA format.</p>
</dd>
<dt><a href="#RGB_BPTC_SIGNED_Format">RGB_BPTC_SIGNED_Format</a> : <code>number</code></dt>
<dd><p>BPTC Signed RGB format.</p>
</dd>
<dt><a href="#RGB_BPTC_UNSIGNED_Format">RGB_BPTC_UNSIGNED_Format</a> : <code>number</code></dt>
<dd><p>BPTC Unsigned RGB format.</p>
</dd>
<dt><a href="#RED_RGTC1_Format">RED_RGTC1_Format</a> : <code>number</code></dt>
<dd><p>RGTC1 Red format.</p>
</dd>
<dt><a href="#SIGNED_RED_RGTC1_Format">SIGNED_RED_RGTC1_Format</a> : <code>number</code></dt>
<dd><p>RGTC1 Signed Red format.</p>
</dd>
<dt><a href="#RED_GREEN_RGTC2_Format">RED_GREEN_RGTC2_Format</a> : <code>number</code></dt>
<dd><p>RGTC2 Red Green format.</p>
</dd>
<dt><a href="#SIGNED_RED_GREEN_RGTC2_Format">SIGNED_RED_GREEN_RGTC2_Format</a> : <code>number</code></dt>
<dd><p>RGTC2 Signed Red Green format.</p>
</dd>
<dt><a href="#LoopOnce">LoopOnce</a> : <code>number</code></dt>
<dd><p>Animations are played once.</p>
</dd>
<dt><a href="#LoopRepeat">LoopRepeat</a> : <code>number</code></dt>
<dd><p>Animations are played with a chosen number of repetitions, each time jumping from
the end of the clip directly to its beginning.</p>
</dd>
<dt><a href="#LoopPingPong">LoopPingPong</a> : <code>number</code></dt>
<dd><p>Animations are played with a chosen number of repetitions, alternately playing forward
and backward.</p>
</dd>
<dt><a href="#InterpolateDiscrete">InterpolateDiscrete</a> : <code>number</code></dt>
<dd><p>Discrete interpolation mode for keyframe tracks.</p>
</dd>
<dt><a href="#InterpolateLinear">InterpolateLinear</a> : <code>number</code></dt>
<dd><p>Linear interpolation mode for keyframe tracks.</p>
</dd>
<dt><a href="#InterpolateSmooth">InterpolateSmooth</a> : <code>number</code></dt>
<dd><p>Smooth interpolation mode for keyframe tracks.</p>
</dd>
<dt><a href="#ZeroCurvatureEnding">ZeroCurvatureEnding</a> : <code>number</code></dt>
<dd><p>Zero curvature ending for animations.</p>
</dd>
<dt><a href="#ZeroSlopeEnding">ZeroSlopeEnding</a> : <code>number</code></dt>
<dd><p>Zero slope ending for animations.</p>
</dd>
<dt><a href="#WrapAroundEnding">WrapAroundEnding</a> : <code>number</code></dt>
<dd><p>Wrap around ending for animations.</p>
</dd>
<dt><a href="#NormalAnimationBlendMode">NormalAnimationBlendMode</a> : <code>number</code></dt>
<dd><p>Default animation blend mode.</p>
</dd>
<dt><a href="#AdditiveAnimationBlendMode">AdditiveAnimationBlendMode</a> : <code>number</code></dt>
<dd><p>Additive animation blend mode. Can be used to layer motions on top of
each other to build complex performances from smaller re-usable assets.</p>
</dd>
<dt><a href="#TrianglesDrawMode">TrianglesDrawMode</a> : <code>number</code></dt>
<dd><p>For every three vertices draw a single triangle.</p>
</dd>
<dt><a href="#TriangleStripDrawMode">TriangleStripDrawMode</a> : <code>number</code></dt>
<dd><p>For each vertex draw a triangle from the last three vertices.</p>
</dd>
<dt><a href="#TriangleFanDrawMode">TriangleFanDrawMode</a> : <code>number</code></dt>
<dd><p>For each vertex draw a triangle from the first vertex and the last two vertices.</p>
</dd>
<dt><a href="#BasicDepthPacking">BasicDepthPacking</a> : <code>number</code></dt>
<dd><p>Basic depth packing.</p>
</dd>
<dt><a href="#RGBADepthPacking">RGBADepthPacking</a> : <code>number</code></dt>
<dd><p>A depth value is packed into 32 bit RGBA.</p>
</dd>
<dt><a href="#RGBDepthPacking">RGBDepthPacking</a> : <code>number</code></dt>
<dd><p>A depth value is packed into 24 bit RGB.</p>
</dd>
<dt><a href="#RGDepthPacking">RGDepthPacking</a> : <code>number</code></dt>
<dd><p>A depth value is packed into 16 bit RG.</p>
</dd>
<dt><a href="#TangentSpaceNormalMap">TangentSpaceNormalMap</a> : <code>number</code></dt>
<dd><p>Normal information is relative to the underlying surface.</p>
</dd>
<dt><a href="#ObjectSpaceNormalMap">ObjectSpaceNormalMap</a> : <code>number</code></dt>
<dd><p>Normal information is relative to the object orientation.</p>
</dd>
<dt><a href="#NoColorSpace">NoColorSpace</a> : <code>string</code></dt>
<dd><p>No color space.</p>
</dd>
<dt><a href="#SRGBColorSpace">SRGBColorSpace</a> : <code>string</code></dt>
<dd><p>sRGB color space.</p>
</dd>
<dt><a href="#LinearSRGBColorSpace">LinearSRGBColorSpace</a> : <code>string</code></dt>
<dd><p>sRGB-linear color space.</p>
</dd>
<dt><a href="#LinearTransfer">LinearTransfer</a> : <code>string</code></dt>
<dd><p>Linear transfer function.</p>
</dd>
<dt><a href="#SRGBTransfer">SRGBTransfer</a> : <code>string</code></dt>
<dd><p>sRGB transfer function.</p>
</dd>
<dt><a href="#ZeroStencilOp">ZeroStencilOp</a> : <code>number</code></dt>
<dd><p>Sets the stencil buffer value to <code>0</code>.</p>
</dd>
<dt><a href="#KeepStencilOp">KeepStencilOp</a> : <code>number</code></dt>
<dd><p>Keeps the current value.</p>
</dd>
<dt><a href="#ReplaceStencilOp">ReplaceStencilOp</a> : <code>number</code></dt>
<dd><p>Sets the stencil buffer value to the specified reference value.</p>
</dd>
<dt><a href="#IncrementStencilOp">IncrementStencilOp</a> : <code>number</code></dt>
<dd><p>Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.</p>
</dd>
<dt><a href="#DecrementStencilOp">DecrementStencilOp</a> : <code>number</code></dt>
<dd><p>Decrements the current stencil buffer value. Clamps to <code>0</code>.</p>
</dd>
<dt><a href="#IncrementWrapStencilOp">IncrementWrapStencilOp</a> : <code>number</code></dt>
<dd><p>Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing
the maximum representable unsigned value.</p>
</dd>
<dt><a href="#DecrementWrapStencilOp">DecrementWrapStencilOp</a> : <code>number</code></dt>
<dd><p>Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable
unsigned value when decrementing a stencil buffer value of <code>0</code>.</p>
</dd>
<dt><a href="#InvertStencilOp">InvertStencilOp</a> : <code>number</code></dt>
<dd><p>Inverts the current stencil buffer value bitwise.</p>
</dd>
<dt><a href="#NeverStencilFunc">NeverStencilFunc</a> : <code>number</code></dt>
<dd><p>Will never return true.</p>
</dd>
<dt><a href="#LessStencilFunc">LessStencilFunc</a> : <code>number</code></dt>
<dd><p>Will return true if the stencil reference value is less than the current stencil value.</p>
</dd>
<dt><a href="#EqualStencilFunc">EqualStencilFunc</a> : <code>number</code></dt>
<dd><p>Will return true if the stencil reference value is equal to the current stencil value.</p>
</dd>
<dt><a href="#LessEqualStencilFunc">LessEqualStencilFunc</a> : <code>number</code></dt>
<dd><p>Will return true if the stencil reference value is less than or equal to the current stencil value.</p>
</dd>
<dt><a href="#GreaterStencilFunc">GreaterStencilFunc</a> : <code>number</code></dt>
<dd><p>Will return true if the stencil reference value is greater than the current stencil value.</p>
</dd>
<dt><a href="#NotEqualStencilFunc">NotEqualStencilFunc</a> : <code>number</code></dt>
<dd><p>Will return true if the stencil reference value is not equal to the current stencil value.</p>
</dd>
<dt><a href="#GreaterEqualStencilFunc">GreaterEqualStencilFunc</a> : <code>number</code></dt>
<dd><p>Will return true if the stencil reference value is greater than or equal to the current stencil value.</p>
</dd>
<dt><a href="#AlwaysStencilFunc">AlwaysStencilFunc</a> : <code>number</code></dt>
<dd><p>Will always return true.</p>
</dd>
<dt><a href="#NeverCompare">NeverCompare</a> : <code>number</code></dt>
<dd><p>Never pass.</p>
</dd>
<dt><a href="#LessCompare">LessCompare</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is less than the texture value.</p>
</dd>
<dt><a href="#EqualCompare">EqualCompare</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value equals the texture value.</p>
</dd>
<dt><a href="#LessEqualCompare">LessEqualCompare</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is less than or equal to the texture value.</p>
</dd>
<dt><a href="#GreaterCompare">GreaterCompare</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is greater than the texture value.</p>
</dd>
<dt><a href="#NotEqualCompare">NotEqualCompare</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is not equal to the texture value.</p>
</dd>
<dt><a href="#GreaterEqualCompare">GreaterEqualCompare</a> : <code>number</code></dt>
<dd><p>Pass if the incoming value is greater than or equal to the texture value.</p>
</dd>
<dt><a href="#AlwaysCompare">AlwaysCompare</a> : <code>number</code></dt>
<dd><p>Always pass.</p>
</dd>
<dt><a href="#StaticDrawUsage">StaticDrawUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be specified once by the application, and used many
times as the source for drawing and image specification commands.</p>
</dd>
<dt><a href="#DynamicDrawUsage">DynamicDrawUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be respecified repeatedly by the application, and
used many times as the source for drawing and image specification commands.</p>
</dd>
<dt><a href="#StreamDrawUsage">StreamDrawUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be specified once by the application, and used at most
a few times as the source for drawing and image specification commands.</p>
</dd>
<dt><a href="#StaticReadUsage">StaticReadUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be specified once by reading data from the 3D API, and queried
many times by the application.</p>
</dd>
<dt><a href="#DynamicReadUsage">DynamicReadUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be respecified repeatedly by reading data from the 3D API, and queried
many times by the application.</p>
</dd>
<dt><a href="#StreamReadUsage">StreamReadUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be specified once by reading data from the 3D API, and queried at most
a few times by the application</p>
</dd>
<dt><a href="#StaticCopyUsage">StaticCopyUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be specified once by reading data from the 3D API, and used many times as
the source for WebGL drawing and image specification commands.</p>
</dd>
<dt><a href="#DynamicCopyUsage">DynamicCopyUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be respecified repeatedly by reading data from the 3D API, and used many times
as the source for WebGL drawing and image specification commands.</p>
</dd>
<dt><a href="#StreamCopyUsage">StreamCopyUsage</a> : <code>number</code></dt>
<dd><p>The contents are intended to be specified once by reading data from the 3D API, and used at most a few times
as the source for WebGL drawing and image specification commands.</p>
</dd>
<dt><a href="#GLSL1">GLSL1</a> : <code>string</code></dt>
<dd><p>GLSL 1 shader code.</p>
</dd>
<dt><a href="#GLSL3">GLSL3</a> : <code>string</code></dt>
<dd><p>GLSL 3 shader code.</p>
</dd>
<dt><a href="#WebGLCoordinateSystem">WebGLCoordinateSystem</a> : <code>number</code></dt>
<dd><p>WebGL coordinate system.</p>
</dd>
<dt><a href="#WebGPUCoordinateSystem">WebGPUCoordinateSystem</a> : <code>number</code></dt>
<dd><p>WebGPU coordinate system.</p>
</dd>
<dt><a href="#TimestampQuery">TimestampQuery</a> : <code><a href="#ConstantsTimestampQuery">ConstantsTimestampQuery</a></code></dt>
<dd><p>Represents the different timestamp query types.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#ConstantsMouse">ConstantsMouse</a> : <code>Object</code></dt>
<dd><p>This type represents mouse buttons and interaction types in context of controls.</p>
</dd>
<dt><a href="#ConstantsTouch">ConstantsTouch</a> : <code>Object</code></dt>
<dd><p>This type represents touch interaction types in context of controls.</p>
</dd>
<dt><a href="#ConstantsTimestampQuery">ConstantsTimestampQuery</a> : <code>Object</code></dt>
<dd><p>This type represents the different timestamp query types.</p>
</dd>
</dl>

<a name="MOUSE"></a>

## MOUSE : [<code>ConstantsMouse</code>](#ConstantsMouse)
Represents mouse buttons and interaction types in context of controls.

**Kind**: global constant  
<a name="TOUCH"></a>

## TOUCH : [<code>ConstantsTouch</code>](#ConstantsTouch)
Represents touch interaction types in context of controls.

**Kind**: global constant  
<a name="CullFaceNone"></a>

## CullFaceNone : <code>number</code>
Disables face culling.

**Kind**: global constant  
<a name="CullFaceBack"></a>

## CullFaceBack : <code>number</code>
Culls back faces.

**Kind**: global constant  
<a name="CullFaceFront"></a>

## CullFaceFront : <code>number</code>
Culls front faces.

**Kind**: global constant  
<a name="CullFaceFrontBack"></a>

## CullFaceFrontBack : <code>number</code>
Culls both front and back faces.

**Kind**: global constant  
<a name="BasicShadowMap"></a>

## BasicShadowMap : <code>number</code>
Gives unfiltered shadow maps - fastest, but lowest quality.

**Kind**: global constant  
<a name="PCFShadowMap"></a>

## PCFShadowMap : <code>number</code>
Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.

**Kind**: global constant  
<a name="PCFSoftShadowMap"></a>

## PCFSoftShadowMap : <code>number</code>
Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with
better soft shadows especially when using low-resolution shadow maps.

**Kind**: global constant  
<a name="VSMShadowMap"></a>

## VSMShadowMap : <code>number</code>
Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
When using VSMShadowMap all shadow receivers will also cast shadows.

**Kind**: global constant  
<a name="FrontSide"></a>

## FrontSide : <code>number</code>
Only front faces are rendered.

**Kind**: global constant  
<a name="BackSide"></a>

## BackSide : <code>number</code>
Only back faces are rendered.

**Kind**: global constant  
<a name="DoubleSide"></a>

## DoubleSide : <code>number</code>
Both front and back faces are rendered.

**Kind**: global constant  
<a name="NoBlending"></a>

## NoBlending : <code>number</code>
No blending is performed which effectively disables
alpha transparency.

**Kind**: global constant  
<a name="NormalBlending"></a>

## NormalBlending : <code>number</code>
The default blending.

**Kind**: global constant  
<a name="AdditiveBlending"></a>

## AdditiveBlending : <code>number</code>
Represents additive blending.

**Kind**: global constant  
<a name="SubtractiveBlending"></a>

## SubtractiveBlending : <code>number</code>
Represents subtractive blending.

**Kind**: global constant  
<a name="MultiplyBlending"></a>

## MultiplyBlending : <code>number</code>
Represents multiply blending.

**Kind**: global constant  
<a name="CustomBlending"></a>

## CustomBlending : <code>number</code>
Represents custom blending.

**Kind**: global constant  
<a name="AddEquation"></a>

## AddEquation : <code>number</code>
A `source + destination` blending equation.

**Kind**: global constant  
<a name="SubtractEquation"></a>

## SubtractEquation : <code>number</code>
A `source - destination` blending equation.

**Kind**: global constant  
<a name="ReverseSubtractEquation"></a>

## ReverseSubtractEquation : <code>number</code>
A `destination - source` blending equation.

**Kind**: global constant  
<a name="MinEquation"></a>

## MinEquation : <code>number</code>
A blend equation that uses the minimum of source and destination.

**Kind**: global constant  
<a name="MaxEquation"></a>

## MaxEquation : <code>number</code>
A blend equation that uses the maximum of source and destination.

**Kind**: global constant  
<a name="ZeroFactor"></a>

## ZeroFactor : <code>number</code>
Multiplies all colors by `0`.

**Kind**: global constant  
<a name="OneFactor"></a>

## OneFactor : <code>number</code>
Multiplies all colors by `1`.

**Kind**: global constant  
<a name="SrcColorFactor"></a>

## SrcColorFactor : <code>number</code>
Multiplies all colors by the source colors.

**Kind**: global constant  
<a name="OneMinusSrcColorFactor"></a>

## OneMinusSrcColorFactor : <code>number</code>
Multiplies all colors by `1` minus each source color.

**Kind**: global constant  
<a name="SrcAlphaFactor"></a>

## SrcAlphaFactor : <code>number</code>
Multiplies all colors by the source alpha value.

**Kind**: global constant  
<a name="OneMinusSrcAlphaFactor"></a>

## OneMinusSrcAlphaFactor : <code>number</code>
Multiplies all colors by 1 minus the source alpha value.

**Kind**: global constant  
<a name="DstAlphaFactor"></a>

## DstAlphaFactor : <code>number</code>
Multiplies all colors by the destination alpha value.

**Kind**: global constant  
<a name="OneMinusDstAlphaFactor"></a>

## OneMinusDstAlphaFactor : <code>number</code>
Multiplies all colors by `1` minus the destination alpha value.

**Kind**: global constant  
<a name="DstColorFactor"></a>

## DstColorFactor : <code>number</code>
Multiplies all colors by the destination color.

**Kind**: global constant  
<a name="OneMinusDstColorFactor"></a>

## OneMinusDstColorFactor : <code>number</code>
Multiplies all colors by `1` minus each destination color.

**Kind**: global constant  
<a name="SrcAlphaSaturateFactor"></a>

## SrcAlphaSaturateFactor : <code>number</code>
Multiplies the RGB colors by the smaller of either the source alpha
value or the value of `1` minus the destination alpha value. The alpha
value is multiplied by `1`.

**Kind**: global constant  
<a name="ConstantColorFactor"></a>

## ConstantColorFactor : <code>number</code>
Multiplies all colors by a constant color.

**Kind**: global constant  
<a name="OneMinusConstantColorFactor"></a>

## OneMinusConstantColorFactor : <code>number</code>
Multiplies all colors by `1` minus a constant color.

**Kind**: global constant  
<a name="ConstantAlphaFactor"></a>

## ConstantAlphaFactor : <code>number</code>
Multiplies all colors by a constant alpha value.

**Kind**: global constant  
<a name="OneMinusConstantAlphaFactor"></a>

## OneMinusConstantAlphaFactor : <code>number</code>
Multiplies all colors by 1 minus a constant alpha value.

**Kind**: global constant  
<a name="NeverDepth"></a>

## NeverDepth : <code>number</code>
Never pass.

**Kind**: global constant  
<a name="AlwaysDepth"></a>

## AlwaysDepth : <code>number</code>
Always pass.

**Kind**: global constant  
<a name="LessDepth"></a>

## LessDepth : <code>number</code>
Pass if the incoming value is less than the depth buffer value.

**Kind**: global constant  
<a name="LessEqualDepth"></a>

## LessEqualDepth : <code>number</code>
Pass if the incoming value is less than or equal to the depth buffer value.

**Kind**: global constant  
<a name="EqualDepth"></a>

## EqualDepth : <code>number</code>
Pass if the incoming value equals the depth buffer value.

**Kind**: global constant  
<a name="GreaterEqualDepth"></a>

## GreaterEqualDepth : <code>number</code>
Pass if the incoming value is greater than or equal to the depth buffer value.

**Kind**: global constant  
<a name="GreaterDepth"></a>

## GreaterDepth : <code>number</code>
Pass if the incoming value is greater than the depth buffer value.

**Kind**: global constant  
<a name="NotEqualDepth"></a>

## NotEqualDepth : <code>number</code>
Pass if the incoming value is not equal to the depth buffer value.

**Kind**: global constant  
<a name="MultiplyOperation"></a>

## MultiplyOperation : <code>number</code>
Multiplies the environment map color with the surface color.

**Kind**: global constant  
<a name="MixOperation"></a>

## MixOperation : <code>number</code>
Uses reflectivity to blend between the two colors.

**Kind**: global constant  
<a name="AddOperation"></a>

## AddOperation : <code>number</code>
Adds the two colors.

**Kind**: global constant  
<a name="NoToneMapping"></a>

## NoToneMapping : <code>number</code>
No tone mapping is applied.

**Kind**: global constant  
<a name="LinearToneMapping"></a>

## LinearToneMapping : <code>number</code>
Linear tone mapping.

**Kind**: global constant  
<a name="ReinhardToneMapping"></a>

## ReinhardToneMapping : <code>number</code>
Reinhard tone mapping.

**Kind**: global constant  
<a name="CineonToneMapping"></a>

## CineonToneMapping : <code>number</code>
Cineon tone mapping.

**Kind**: global constant  
<a name="ACESFilmicToneMapping"></a>

## ACESFilmicToneMapping : <code>number</code>
ACES Filmic tone mapping.

**Kind**: global constant  
<a name="CustomToneMapping"></a>

## CustomToneMapping : <code>number</code>
Custom tone mapping.

Expects a custom implementation by modifying shader code of the material's fragment shader.

**Kind**: global constant  
<a name="AgXToneMapping"></a>

## AgXToneMapping : <code>number</code>
AgX tone mapping.

**Kind**: global constant  
<a name="NeutralToneMapping"></a>

## NeutralToneMapping : <code>number</code>
Neutral tone mapping.

Implementation based on the Khronos 3D Commerce Group standard tone mapping.

**Kind**: global constant  
<a name="AttachedBindMode"></a>

## AttachedBindMode : <code>string</code>
The skinned mesh shares the same world space as the skeleton.

**Kind**: global constant  
<a name="DetachedBindMode"></a>

## DetachedBindMode : <code>string</code>
The skinned mesh does not share the same world space as the skeleton.
This is useful when a skeleton is shared across multiple skinned meshes.

**Kind**: global constant  
<a name="UVMapping"></a>

## UVMapping : <code>number</code>
Maps textures using the geometry's UV coordinates.

**Kind**: global constant  
<a name="CubeReflectionMapping"></a>

## CubeReflectionMapping : <code>number</code>
Reflection mapping for cube textures.

**Kind**: global constant  
<a name="CubeRefractionMapping"></a>

## CubeRefractionMapping : <code>number</code>
Refraction mapping for cube textures.

**Kind**: global constant  
<a name="EquirectangularReflectionMapping"></a>

## EquirectangularReflectionMapping : <code>number</code>
Reflection mapping for equirectangular textures.

**Kind**: global constant  
<a name="EquirectangularRefractionMapping"></a>

## EquirectangularRefractionMapping : <code>number</code>
Refraction mapping for equirectangular textures.

**Kind**: global constant  
<a name="CubeUVReflectionMapping"></a>

## CubeUVReflectionMapping : <code>number</code>
Reflection mapping for PMREM textures.

**Kind**: global constant  
<a name="RepeatWrapping"></a>

## RepeatWrapping : <code>number</code>
The texture will simply repeat to infinity.

**Kind**: global constant  
<a name="ClampToEdgeWrapping"></a>

## ClampToEdgeWrapping : <code>number</code>
The last pixel of the texture stretches to the edge of the mesh.

**Kind**: global constant  
<a name="MirroredRepeatWrapping"></a>

## MirroredRepeatWrapping : <code>number</code>
The texture will repeats to infinity, mirroring on each repeat.

**Kind**: global constant  
<a name="NearestFilter"></a>

## NearestFilter : <code>number</code>
Returns the value of the texture element that is nearest (in Manhattan distance)
to the specified texture coordinates.

**Kind**: global constant  
<a name="NearestMipmapNearestFilter"></a>

## NearestMipmapNearestFilter : <code>number</code>
Chooses the mipmap that most closely matches the size of the pixel being textured
and uses the `NearestFilter` criterion (the texel nearest to the center of the pixel)
to produce a texture value.

**Kind**: global constant  
<a name="NearestMipmapLinearFilter"></a>

## NearestMipmapLinearFilter : <code>number</code>
Chooses the two mipmaps that most closely match the size of the pixel being textured and
uses the `NearestFilter` criterion to produce a texture value from each mipmap.
The final texture value is a weighted average of those two values.

**Kind**: global constant  
<a name="LinearFilter"></a>

## LinearFilter : <code>number</code>
Returns the weighted average of the four texture elements that are closest to the specified
texture coordinates, and can include items wrapped or repeated from other parts of a texture,
depending on the values of `wrapS` and `wrapT`, and on the exact mapping.

**Kind**: global constant  
<a name="LinearMipmapNearestFilter"></a>

## LinearMipmapNearestFilter : <code>number</code>
Chooses the mipmap that most closely matches the size of the pixel being textured and uses
the `LinearFilter` criterion (a weighted average of the four texels that are closest to the
center of the pixel) to produce a texture value.

**Kind**: global constant  
<a name="LinearMipmapLinearFilter"></a>

## LinearMipmapLinearFilter : <code>number</code>
Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value
is a weighted average of those two values.

**Kind**: global constant  
<a name="UnsignedByteType"></a>

## UnsignedByteType : <code>number</code>
An unsigned byte data type for textures.

**Kind**: global constant  
<a name="ByteType"></a>

## ByteType : <code>number</code>
A byte data type for textures.

**Kind**: global constant  
<a name="ShortType"></a>

## ShortType : <code>number</code>
A short data type for textures.

**Kind**: global constant  
<a name="UnsignedShortType"></a>

## UnsignedShortType : <code>number</code>
An unsigned short data type for textures.

**Kind**: global constant  
<a name="IntType"></a>

## IntType : <code>number</code>
An int data type for textures.

**Kind**: global constant  
<a name="UnsignedIntType"></a>

## UnsignedIntType : <code>number</code>
An unsigned int data type for textures.

**Kind**: global constant  
<a name="FloatType"></a>

## FloatType : <code>number</code>
A float data type for textures.

**Kind**: global constant  
<a name="HalfFloatType"></a>

## HalfFloatType : <code>number</code>
A half float data type for textures.

**Kind**: global constant  
<a name="UnsignedShort4444Type"></a>

## UnsignedShort4444Type : <code>number</code>
An unsigned short 4_4_4_4 (packed) data type for textures.

**Kind**: global constant  
<a name="UnsignedShort5551Type"></a>

## UnsignedShort5551Type : <code>number</code>
An unsigned short 5_5_5_1 (packed) data type for textures.

**Kind**: global constant  
<a name="UnsignedInt248Type"></a>

## UnsignedInt248Type : <code>number</code>
An unsigned int 24_8 data type for textures.

**Kind**: global constant  
<a name="UnsignedInt5999Type"></a>

## UnsignedInt5999Type : <code>number</code>
An unsigned int 5_9_9_9 (packed) data type for textures.

**Kind**: global constant  
<a name="AlphaFormat"></a>

## AlphaFormat : <code>number</code>
Discards the red, green and blue components and reads just the alpha component.

**Kind**: global constant  
<a name="RGBFormat"></a>

## RGBFormat : <code>number</code>
Discards the alpha component and reads the red, green and blue component.

**Kind**: global constant  
<a name="RGBAFormat"></a>

## RGBAFormat : <code>number</code>
Reads the red, green, blue and alpha components.

**Kind**: global constant  
<a name="LuminanceFormat"></a>

## LuminanceFormat : <code>number</code>
reads each element as a single luminance component. This is then converted to a floating point,
clamped to the range `[0,1]`, and then assembled into an RGBA element by placing the luminance value
in the red, green and blue channels, and attaching 1.0 to the alpha channel.

**Kind**: global constant  
<a name="LuminanceAlphaFormat"></a>

## LuminanceAlphaFormat : <code>number</code>
Reads each element as a luminance/alpha double. The same process occurs as for the `LuminanceFormat`,
except that the alpha channel may have values other than `1.0`.

**Kind**: global constant  
<a name="DepthFormat"></a>

## DepthFormat : <code>number</code>
Reads each element as a single depth value, converts it to floating point, and clamps to the range `[0,1]`.

**Kind**: global constant  
<a name="DepthStencilFormat"></a>

## DepthStencilFormat : <code>number</code>
Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
in `DepthFormat`. The stencil component is interpreted based on the depth + stencil internal format.

**Kind**: global constant  
<a name="RedFormat"></a>

## RedFormat : <code>number</code>
Discards the green, blue and alpha components and reads just the red component.

**Kind**: global constant  
<a name="RedIntegerFormat"></a>

## RedIntegerFormat : <code>number</code>
Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.

**Kind**: global constant  
<a name="RGFormat"></a>

## RGFormat : <code>number</code>
Discards the alpha, and blue components and reads the red, and green components.

**Kind**: global constant  
<a name="RGIntegerFormat"></a>

## RGIntegerFormat : <code>number</code>
Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.

**Kind**: global constant  
<a name="RGBIntegerFormat"></a>

## RGBIntegerFormat : <code>number</code>
Discards the alpha component and reads the red, green and blue component. The texels are read as integers instead of floating point.

**Kind**: global constant  
<a name="RGBAIntegerFormat"></a>

## RGBAIntegerFormat : <code>number</code>
Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.

**Kind**: global constant  
<a name="RGB_S3TC_DXT1_Format"></a>

## RGB\_S3TC\_DXT1\_Format : <code>number</code>
A DXT1-compressed image in an RGB image format.

**Kind**: global constant  
<a name="RGBA_S3TC_DXT1_Format"></a>

## RGBA\_S3TC\_DXT1\_Format : <code>number</code>
A DXT1-compressed image in an RGB image format with a simple on/off alpha value.

**Kind**: global constant  
<a name="RGBA_S3TC_DXT3_Format"></a>

## RGBA\_S3TC\_DXT3\_Format : <code>number</code>
A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.

**Kind**: global constant  
<a name="RGBA_S3TC_DXT5_Format"></a>

## RGBA\_S3TC\_DXT5\_Format : <code>number</code>
A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
compression in how the alpha compression is done.

**Kind**: global constant  
<a name="RGB_PVRTC_4BPPV1_Format"></a>

## RGB\_PVRTC\_4BPPV1\_Format : <code>number</code>
PVRTC RGB compression in 4-bit mode. One block for each 4×4 pixels.

**Kind**: global constant  
<a name="RGB_PVRTC_2BPPV1_Format"></a>

## RGB\_PVRTC\_2BPPV1\_Format : <code>number</code>
PVRTC RGB compression in 2-bit mode. One block for each 8×4 pixels.

**Kind**: global constant  
<a name="RGBA_PVRTC_4BPPV1_Format"></a>

## RGBA\_PVRTC\_4BPPV1\_Format : <code>number</code>
PVRTC RGBA compression in 4-bit mode. One block for each 4×4 pixels.

**Kind**: global constant  
<a name="RGBA_PVRTC_2BPPV1_Format"></a>

## RGBA\_PVRTC\_2BPPV1\_Format : <code>number</code>
PVRTC RGBA compression in 2-bit mode. One block for each 8×4 pixels.

**Kind**: global constant  
<a name="RGB_ETC1_Format"></a>

## RGB\_ETC1\_Format : <code>number</code>
ETC1 RGB format.

**Kind**: global constant  
<a name="RGB_ETC2_Format"></a>

## RGB\_ETC2\_Format : <code>number</code>
ETC2 RGB format.

**Kind**: global constant  
<a name="RGBA_ETC2_EAC_Format"></a>

## RGBA\_ETC2\_EAC\_Format : <code>number</code>
ETC2 RGBA format.

**Kind**: global constant  
<a name="RGBA_ASTC_4x4_Format"></a>

## RGBA\_ASTC\_4x4\_Format : <code>number</code>
ASTC RGBA 4x4 format.

**Kind**: global constant  
<a name="RGBA_ASTC_5x4_Format"></a>

## RGBA\_ASTC\_5x4\_Format : <code>number</code>
ASTC RGBA 5x4 format.

**Kind**: global constant  
<a name="RGBA_ASTC_5x5_Format"></a>

## RGBA\_ASTC\_5x5\_Format : <code>number</code>
ASTC RGBA 5x5 format.

**Kind**: global constant  
<a name="RGBA_ASTC_6x5_Format"></a>

## RGBA\_ASTC\_6x5\_Format : <code>number</code>
ASTC RGBA 6x5 format.

**Kind**: global constant  
<a name="RGBA_ASTC_6x6_Format"></a>

## RGBA\_ASTC\_6x6\_Format : <code>number</code>
ASTC RGBA 6x6 format.

**Kind**: global constant  
<a name="RGBA_ASTC_8x5_Format"></a>

## RGBA\_ASTC\_8x5\_Format : <code>number</code>
ASTC RGBA 8x5 format.

**Kind**: global constant  
<a name="RGBA_ASTC_8x6_Format"></a>

## RGBA\_ASTC\_8x6\_Format : <code>number</code>
ASTC RGBA 8x6 format.

**Kind**: global constant  
<a name="RGBA_ASTC_8x8_Format"></a>

## RGBA\_ASTC\_8x8\_Format : <code>number</code>
ASTC RGBA 8x8 format.

**Kind**: global constant  
<a name="RGBA_ASTC_10x5_Format"></a>

## RGBA\_ASTC\_10x5\_Format : <code>number</code>
ASTC RGBA 10x5 format.

**Kind**: global constant  
<a name="RGBA_ASTC_10x6_Format"></a>

## RGBA\_ASTC\_10x6\_Format : <code>number</code>
ASTC RGBA 10x6 format.

**Kind**: global constant  
<a name="RGBA_ASTC_10x8_Format"></a>

## RGBA\_ASTC\_10x8\_Format : <code>number</code>
ASTC RGBA 10x8 format.

**Kind**: global constant  
<a name="RGBA_ASTC_10x10_Format"></a>

## RGBA\_ASTC\_10x10\_Format : <code>number</code>
ASTC RGBA 10x10 format.

**Kind**: global constant  
<a name="RGBA_ASTC_12x10_Format"></a>

## RGBA\_ASTC\_12x10\_Format : <code>number</code>
ASTC RGBA 12x10 format.

**Kind**: global constant  
<a name="RGBA_ASTC_12x12_Format"></a>

## RGBA\_ASTC\_12x12\_Format : <code>number</code>
ASTC RGBA 12x12 format.

**Kind**: global constant  
<a name="RGBA_BPTC_Format"></a>

## RGBA\_BPTC\_Format : <code>number</code>
BPTC RGBA format.

**Kind**: global constant  
<a name="RGB_BPTC_SIGNED_Format"></a>

## RGB\_BPTC\_SIGNED\_Format : <code>number</code>
BPTC Signed RGB format.

**Kind**: global constant  
<a name="RGB_BPTC_UNSIGNED_Format"></a>

## RGB\_BPTC\_UNSIGNED\_Format : <code>number</code>
BPTC Unsigned RGB format.

**Kind**: global constant  
<a name="RED_RGTC1_Format"></a>

## RED\_RGTC1\_Format : <code>number</code>
RGTC1 Red format.

**Kind**: global constant  
<a name="SIGNED_RED_RGTC1_Format"></a>

## SIGNED\_RED\_RGTC1\_Format : <code>number</code>
RGTC1 Signed Red format.

**Kind**: global constant  
<a name="RED_GREEN_RGTC2_Format"></a>

## RED\_GREEN\_RGTC2\_Format : <code>number</code>
RGTC2 Red Green format.

**Kind**: global constant  
<a name="SIGNED_RED_GREEN_RGTC2_Format"></a>

## SIGNED\_RED\_GREEN\_RGTC2\_Format : <code>number</code>
RGTC2 Signed Red Green format.

**Kind**: global constant  
<a name="LoopOnce"></a>

## LoopOnce : <code>number</code>
Animations are played once.

**Kind**: global constant  
<a name="LoopRepeat"></a>

## LoopRepeat : <code>number</code>
Animations are played with a chosen number of repetitions, each time jumping from
the end of the clip directly to its beginning.

**Kind**: global constant  
<a name="LoopPingPong"></a>

## LoopPingPong : <code>number</code>
Animations are played with a chosen number of repetitions, alternately playing forward
and backward.

**Kind**: global constant  
<a name="InterpolateDiscrete"></a>

## InterpolateDiscrete : <code>number</code>
Discrete interpolation mode for keyframe tracks.

**Kind**: global constant  
<a name="InterpolateLinear"></a>

## InterpolateLinear : <code>number</code>
Linear interpolation mode for keyframe tracks.

**Kind**: global constant  
<a name="InterpolateSmooth"></a>

## InterpolateSmooth : <code>number</code>
Smooth interpolation mode for keyframe tracks.

**Kind**: global constant  
<a name="ZeroCurvatureEnding"></a>

## ZeroCurvatureEnding : <code>number</code>
Zero curvature ending for animations.

**Kind**: global constant  
<a name="ZeroSlopeEnding"></a>

## ZeroSlopeEnding : <code>number</code>
Zero slope ending for animations.

**Kind**: global constant  
<a name="WrapAroundEnding"></a>

## WrapAroundEnding : <code>number</code>
Wrap around ending for animations.

**Kind**: global constant  
<a name="NormalAnimationBlendMode"></a>

## NormalAnimationBlendMode : <code>number</code>
Default animation blend mode.

**Kind**: global constant  
<a name="AdditiveAnimationBlendMode"></a>

## AdditiveAnimationBlendMode : <code>number</code>
Additive animation blend mode. Can be used to layer motions on top of
each other to build complex performances from smaller re-usable assets.

**Kind**: global constant  
<a name="TrianglesDrawMode"></a>

## TrianglesDrawMode : <code>number</code>
For every three vertices draw a single triangle.

**Kind**: global constant  
<a name="TriangleStripDrawMode"></a>

## TriangleStripDrawMode : <code>number</code>
For each vertex draw a triangle from the last three vertices.

**Kind**: global constant  
<a name="TriangleFanDrawMode"></a>

## TriangleFanDrawMode : <code>number</code>
For each vertex draw a triangle from the first vertex and the last two vertices.

**Kind**: global constant  
<a name="BasicDepthPacking"></a>

## BasicDepthPacking : <code>number</code>
Basic depth packing.

**Kind**: global constant  
<a name="RGBADepthPacking"></a>

## RGBADepthPacking : <code>number</code>
A depth value is packed into 32 bit RGBA.

**Kind**: global constant  
<a name="RGBDepthPacking"></a>

## RGBDepthPacking : <code>number</code>
A depth value is packed into 24 bit RGB.

**Kind**: global constant  
<a name="RGDepthPacking"></a>

## RGDepthPacking : <code>number</code>
A depth value is packed into 16 bit RG.

**Kind**: global constant  
<a name="TangentSpaceNormalMap"></a>

## TangentSpaceNormalMap : <code>number</code>
Normal information is relative to the underlying surface.

**Kind**: global constant  
<a name="ObjectSpaceNormalMap"></a>

## ObjectSpaceNormalMap : <code>number</code>
Normal information is relative to the object orientation.

**Kind**: global constant  
<a name="NoColorSpace"></a>

## NoColorSpace : <code>string</code>
No color space.

**Kind**: global constant  
<a name="SRGBColorSpace"></a>

## SRGBColorSpace : <code>string</code>
sRGB color space.

**Kind**: global constant  
<a name="LinearSRGBColorSpace"></a>

## LinearSRGBColorSpace : <code>string</code>
sRGB-linear color space.

**Kind**: global constant  
<a name="LinearTransfer"></a>

## LinearTransfer : <code>string</code>
Linear transfer function.

**Kind**: global constant  
<a name="SRGBTransfer"></a>

## SRGBTransfer : <code>string</code>
sRGB transfer function.

**Kind**: global constant  
<a name="ZeroStencilOp"></a>

## ZeroStencilOp : <code>number</code>
Sets the stencil buffer value to `0`.

**Kind**: global constant  
<a name="KeepStencilOp"></a>

## KeepStencilOp : <code>number</code>
Keeps the current value.

**Kind**: global constant  
<a name="ReplaceStencilOp"></a>

## ReplaceStencilOp : <code>number</code>
Sets the stencil buffer value to the specified reference value.

**Kind**: global constant  
<a name="IncrementStencilOp"></a>

## IncrementStencilOp : <code>number</code>
Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.

**Kind**: global constant  
<a name="DecrementStencilOp"></a>

## DecrementStencilOp : <code>number</code>
Decrements the current stencil buffer value. Clamps to `0`.

**Kind**: global constant  
<a name="IncrementWrapStencilOp"></a>

## IncrementWrapStencilOp : <code>number</code>
Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing
the maximum representable unsigned value.

**Kind**: global constant  
<a name="DecrementWrapStencilOp"></a>

## DecrementWrapStencilOp : <code>number</code>
Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable
unsigned value when decrementing a stencil buffer value of `0`.

**Kind**: global constant  
<a name="InvertStencilOp"></a>

## InvertStencilOp : <code>number</code>
Inverts the current stencil buffer value bitwise.

**Kind**: global constant  
<a name="NeverStencilFunc"></a>

## NeverStencilFunc : <code>number</code>
Will never return true.

**Kind**: global constant  
<a name="LessStencilFunc"></a>

## LessStencilFunc : <code>number</code>
Will return true if the stencil reference value is less than the current stencil value.

**Kind**: global constant  
<a name="EqualStencilFunc"></a>

## EqualStencilFunc : <code>number</code>
Will return true if the stencil reference value is equal to the current stencil value.

**Kind**: global constant  
<a name="LessEqualStencilFunc"></a>

## LessEqualStencilFunc : <code>number</code>
Will return true if the stencil reference value is less than or equal to the current stencil value.

**Kind**: global constant  
<a name="GreaterStencilFunc"></a>

## GreaterStencilFunc : <code>number</code>
Will return true if the stencil reference value is greater than the current stencil value.

**Kind**: global constant  
<a name="NotEqualStencilFunc"></a>

## NotEqualStencilFunc : <code>number</code>
Will return true if the stencil reference value is not equal to the current stencil value.

**Kind**: global constant  
<a name="GreaterEqualStencilFunc"></a>

## GreaterEqualStencilFunc : <code>number</code>
Will return true if the stencil reference value is greater than or equal to the current stencil value.

**Kind**: global constant  
<a name="AlwaysStencilFunc"></a>

## AlwaysStencilFunc : <code>number</code>
Will always return true.

**Kind**: global constant  
<a name="NeverCompare"></a>

## NeverCompare : <code>number</code>
Never pass.

**Kind**: global constant  
<a name="LessCompare"></a>

## LessCompare : <code>number</code>
Pass if the incoming value is less than the texture value.

**Kind**: global constant  
<a name="EqualCompare"></a>

## EqualCompare : <code>number</code>
Pass if the incoming value equals the texture value.

**Kind**: global constant  
<a name="LessEqualCompare"></a>

## LessEqualCompare : <code>number</code>
Pass if the incoming value is less than or equal to the texture value.

**Kind**: global constant  
<a name="GreaterCompare"></a>

## GreaterCompare : <code>number</code>
Pass if the incoming value is greater than the texture value.

**Kind**: global constant  
<a name="NotEqualCompare"></a>

## NotEqualCompare : <code>number</code>
Pass if the incoming value is not equal to the texture value.

**Kind**: global constant  
<a name="GreaterEqualCompare"></a>

## GreaterEqualCompare : <code>number</code>
Pass if the incoming value is greater than or equal to the texture value.

**Kind**: global constant  
<a name="AlwaysCompare"></a>

## AlwaysCompare : <code>number</code>
Always pass.

**Kind**: global constant  
<a name="StaticDrawUsage"></a>

## StaticDrawUsage : <code>number</code>
The contents are intended to be specified once by the application, and used many
times as the source for drawing and image specification commands.

**Kind**: global constant  
<a name="DynamicDrawUsage"></a>

## DynamicDrawUsage : <code>number</code>
The contents are intended to be respecified repeatedly by the application, and
used many times as the source for drawing and image specification commands.

**Kind**: global constant  
<a name="StreamDrawUsage"></a>

## StreamDrawUsage : <code>number</code>
The contents are intended to be specified once by the application, and used at most
a few times as the source for drawing and image specification commands.

**Kind**: global constant  
<a name="StaticReadUsage"></a>

## StaticReadUsage : <code>number</code>
The contents are intended to be specified once by reading data from the 3D API, and queried
many times by the application.

**Kind**: global constant  
<a name="DynamicReadUsage"></a>

## DynamicReadUsage : <code>number</code>
The contents are intended to be respecified repeatedly by reading data from the 3D API, and queried
many times by the application.

**Kind**: global constant  
<a name="StreamReadUsage"></a>

## StreamReadUsage : <code>number</code>
The contents are intended to be specified once by reading data from the 3D API, and queried at most
a few times by the application

**Kind**: global constant  
<a name="StaticCopyUsage"></a>

## StaticCopyUsage : <code>number</code>
The contents are intended to be specified once by reading data from the 3D API, and used many times as
the source for WebGL drawing and image specification commands.

**Kind**: global constant  
<a name="DynamicCopyUsage"></a>

## DynamicCopyUsage : <code>number</code>
The contents are intended to be respecified repeatedly by reading data from the 3D API, and used many times
as the source for WebGL drawing and image specification commands.

**Kind**: global constant  
<a name="StreamCopyUsage"></a>

## StreamCopyUsage : <code>number</code>
The contents are intended to be specified once by reading data from the 3D API, and used at most a few times
as the source for WebGL drawing and image specification commands.

**Kind**: global constant  
<a name="GLSL1"></a>

## GLSL1 : <code>string</code>
GLSL 1 shader code.

**Kind**: global constant  
<a name="GLSL3"></a>

## GLSL3 : <code>string</code>
GLSL 3 shader code.

**Kind**: global constant  
<a name="WebGLCoordinateSystem"></a>

## WebGLCoordinateSystem : <code>number</code>
WebGL coordinate system.

**Kind**: global constant  
<a name="WebGPUCoordinateSystem"></a>

## WebGPUCoordinateSystem : <code>number</code>
WebGPU coordinate system.

**Kind**: global constant  
<a name="TimestampQuery"></a>

## TimestampQuery : [<code>ConstantsTimestampQuery</code>](#ConstantsTimestampQuery)
Represents the different timestamp query types.

**Kind**: global constant  
<a name="ConstantsMouse"></a>

## ConstantsMouse : <code>Object</code>
This type represents mouse buttons and interaction types in context of controls.

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| MIDDLE | <code>number</code> | The left mouse button. |
| LEFT | <code>number</code> | The middle mouse button. |
| RIGHT | <code>number</code> | The right mouse button. |
| ROTATE | <code>number</code> | A rotate interaction. |
| DOLLY | <code>number</code> | A dolly interaction. |
| PAN | <code>number</code> | A pan interaction. |

<a name="ConstantsTouch"></a>

## ConstantsTouch : <code>Object</code>
This type represents touch interaction types in context of controls.

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| ROTATE | <code>number</code> | A rotate interaction. |
| PAN | <code>number</code> | A pan interaction. |
| DOLLY_PAN | <code>number</code> | The dolly-pan interaction. |
| DOLLY_ROTATE | <code>number</code> | A dolly-rotate interaction. |

<a name="ConstantsTimestampQuery"></a>

## ConstantsTimestampQuery : <code>Object</code>
This type represents the different timestamp query types.

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| COMPUTE | <code>string</code> | A `compute` timestamp query. |
| RENDER | <code>string</code> | A `render` timestamp query. |

## Classes

<dl>
<dt><a href="#BufferAttribute">BufferAttribute</a></dt>
<dd><p>This class stores data for an attribute (such as vertex positions, face
indices, normals, colors, UVs, and any custom attributes ) associated with
a geometry, which allows for more efficient passing of data to the GPU.</p>
<p>When working with vector-like data, the <code>fromBufferAttribute( attribute, index )</code>
helper methods on vector and color class might be helpful. E.g. <a href="Vector3#fromBufferAttribute">Vector3#fromBufferAttribute</a>.</p>
</dd>
<dt><a href="#Int8BufferAttribute">Int8BufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>Int8</code> buffer attribute with
a plain <code>Array</code> instance.</p>
</dd>
<dt><a href="#Uint8BufferAttribute">Uint8BufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>UInt8</code> buffer attribute with
a plain <code>Array</code> instance.</p>
</dd>
<dt><a href="#Uint8ClampedBufferAttribute">Uint8ClampedBufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>UInt8Clamped</code> buffer attribute with
a plain <code>Array</code> instance.</p>
</dd>
<dt><a href="#Int16BufferAttribute">Int16BufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>Int16</code> buffer attribute with
a plain <code>Array</code> instance.</p>
</dd>
<dt><a href="#Uint16BufferAttribute">Uint16BufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>UInt16</code> buffer attribute with
a plain <code>Array</code> instance.</p>
</dd>
<dt><a href="#Int32BufferAttribute">Int32BufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>Int32</code> buffer attribute with
a plain <code>Array</code> instance.</p>
</dd>
<dt><a href="#Uint32BufferAttribute">Uint32BufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>UInt32</code> buffer attribute with
a plain <code>Array</code> instance.</p>
</dd>
<dt><a href="#Float16BufferAttribute">Float16BufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>Float16</code> buffer attribute with
a plain <code>Array</code> instance.</p>
<p>This class automatically converts to to and from FP16 since <code>Float16Array</code> is not
natively supported in JavaScript.</p>
</dd>
<dt><a href="#Float32BufferAttribute">Float32BufferAttribute</a> ⇐ <code><a href="#BufferAttribute">BufferAttribute</a></code></dt>
<dd><p>Convenient class that can be used when creating a <code>Float32</code> buffer attribute with
a plain <code>Array</code> instance.</p>
</dd>
</dl>

<a name="BufferAttribute"></a>

## BufferAttribute
This class stores data for an attribute (such as vertex positions, face
indices, normals, colors, UVs, and any custom attributes ) associated with
a geometry, which allows for more efficient passing of data to the GPU.

When working with vector-like data, the `fromBufferAttribute( attribute, index )`
helper methods on vector and color class might be helpful. E.g. [Vector3#fromBufferAttribute](Vector3#fromBufferAttribute).

**Kind**: global class  

* [BufferAttribute](#BufferAttribute)
    * [new BufferAttribute(array, itemSize, [normalized])](#new_BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_BufferAttribute_new"></a>

### new BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>TypedArray</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### bufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### bufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### bufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
<a name="BufferAttribute+array"></a>

### bufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
<a name="BufferAttribute+itemSize"></a>

### bufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
<a name="BufferAttribute+count"></a>

### bufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### bufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
<a name="BufferAttribute+usage"></a>

### bufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
<a name="BufferAttribute+updateRanges"></a>

### bufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
<a name="BufferAttribute+gpuType"></a>

### bufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
**Default**: <code>FloatType</code>  
<a name="BufferAttribute+version"></a>

### bufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
<a name="BufferAttribute+needsUpdate"></a>

### bufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>BufferAttribute</code>](#BufferAttribute)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### bufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
<a name="BufferAttribute+setUsage"></a>

### bufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### bufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### bufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
<a name="BufferAttribute+copy"></a>

### bufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### bufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### bufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### bufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### bufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### bufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### bufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### bufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### bufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### bufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### bufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### bufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### bufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### bufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### bufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### bufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### bufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### bufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### bufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### bufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### bufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### bufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### bufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### bufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>BufferAttribute</code>](#BufferAttribute)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Int8BufferAttribute"></a>

## Int8BufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `Int8` buffer attribute with
a plain `Array` instance.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Int8BufferAttribute](#Int8BufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Int8BufferAttribute(array, itemSize, [normalized])](#new_Int8BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Int8BufferAttribute_new"></a>

### new Int8BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Int8Array</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### int8BufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### int8BufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### int8BufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### int8BufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### int8BufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### int8BufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### int8BufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### int8BufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### int8BufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### int8BufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### int8BufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### int8BufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### int8BufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### int8BufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### int8BufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### int8BufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### int8BufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### int8BufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### int8BufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### int8BufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### int8BufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### int8BufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### int8BufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### int8BufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### int8BufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### int8BufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### int8BufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### int8BufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### int8BufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### int8BufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### int8BufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### int8BufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### int8BufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### int8BufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### int8BufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### int8BufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### int8BufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### int8BufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### int8BufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### int8BufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Int8BufferAttribute</code>](#Int8BufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Uint8BufferAttribute"></a>

## Uint8BufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `UInt8` buffer attribute with
a plain `Array` instance.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Uint8BufferAttribute](#Uint8BufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Uint8BufferAttribute(array, itemSize, [normalized])](#new_Uint8BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Uint8BufferAttribute_new"></a>

### new Uint8BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Uint8Array</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### uint8BufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### uint8BufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### uint8BufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### uint8BufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### uint8BufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### uint8BufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### uint8BufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### uint8BufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### uint8BufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### uint8BufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### uint8BufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### uint8BufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### uint8BufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### uint8BufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### uint8BufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### uint8BufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### uint8BufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### uint8BufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### uint8BufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### uint8BufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### uint8BufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### uint8BufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### uint8BufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### uint8BufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### uint8BufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### uint8BufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### uint8BufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### uint8BufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### uint8BufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### uint8BufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### uint8BufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### uint8BufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### uint8BufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### uint8BufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### uint8BufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### uint8BufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### uint8BufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### uint8BufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### uint8BufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### uint8BufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Uint8BufferAttribute</code>](#Uint8BufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Uint8ClampedBufferAttribute"></a>

## Uint8ClampedBufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `UInt8Clamped` buffer attribute with
a plain `Array` instance.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Uint8ClampedBufferAttribute](#Uint8ClampedBufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Uint8ClampedBufferAttribute(array, itemSize, [normalized])](#new_Uint8ClampedBufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Uint8ClampedBufferAttribute_new"></a>

### new Uint8ClampedBufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Uint8ClampedArray</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### uint8ClampedBufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### uint8ClampedBufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### uint8ClampedBufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### uint8ClampedBufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### uint8ClampedBufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### uint8ClampedBufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### uint8ClampedBufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### uint8ClampedBufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### uint8ClampedBufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### uint8ClampedBufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### uint8ClampedBufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### uint8ClampedBufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### uint8ClampedBufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### uint8ClampedBufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### uint8ClampedBufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### uint8ClampedBufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### uint8ClampedBufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### uint8ClampedBufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### uint8ClampedBufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### uint8ClampedBufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### uint8ClampedBufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### uint8ClampedBufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### uint8ClampedBufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### uint8ClampedBufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### uint8ClampedBufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### uint8ClampedBufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### uint8ClampedBufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### uint8ClampedBufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### uint8ClampedBufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### uint8ClampedBufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### uint8ClampedBufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### uint8ClampedBufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### uint8ClampedBufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### uint8ClampedBufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### uint8ClampedBufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### uint8ClampedBufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### uint8ClampedBufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### uint8ClampedBufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### uint8ClampedBufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### uint8ClampedBufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Uint8ClampedBufferAttribute</code>](#Uint8ClampedBufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Int16BufferAttribute"></a>

## Int16BufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `Int16` buffer attribute with
a plain `Array` instance.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Int16BufferAttribute](#Int16BufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Int16BufferAttribute(array, itemSize, [normalized])](#new_Int16BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Int16BufferAttribute_new"></a>

### new Int16BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Int16Array</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### int16BufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### int16BufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### int16BufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### int16BufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### int16BufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### int16BufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### int16BufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### int16BufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### int16BufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### int16BufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### int16BufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### int16BufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### int16BufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### int16BufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### int16BufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### int16BufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### int16BufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### int16BufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### int16BufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### int16BufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### int16BufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### int16BufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### int16BufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### int16BufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### int16BufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### int16BufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### int16BufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### int16BufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### int16BufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### int16BufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### int16BufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### int16BufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### int16BufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### int16BufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### int16BufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### int16BufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### int16BufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### int16BufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### int16BufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### int16BufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Int16BufferAttribute</code>](#Int16BufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Uint16BufferAttribute"></a>

## Uint16BufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `UInt16` buffer attribute with
a plain `Array` instance.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Uint16BufferAttribute](#Uint16BufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Uint16BufferAttribute(array, itemSize, [normalized])](#new_Uint16BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Uint16BufferAttribute_new"></a>

### new Uint16BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Uint16Array</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### uint16BufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### uint16BufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### uint16BufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### uint16BufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### uint16BufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### uint16BufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### uint16BufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### uint16BufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### uint16BufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### uint16BufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### uint16BufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### uint16BufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### uint16BufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### uint16BufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### uint16BufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### uint16BufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### uint16BufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### uint16BufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### uint16BufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### uint16BufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### uint16BufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### uint16BufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### uint16BufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### uint16BufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### uint16BufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### uint16BufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### uint16BufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### uint16BufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### uint16BufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### uint16BufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### uint16BufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### uint16BufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### uint16BufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### uint16BufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### uint16BufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### uint16BufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### uint16BufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### uint16BufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### uint16BufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### uint16BufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Uint16BufferAttribute</code>](#Uint16BufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Int32BufferAttribute"></a>

## Int32BufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `Int32` buffer attribute with
a plain `Array` instance.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Int32BufferAttribute](#Int32BufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Int32BufferAttribute(array, itemSize, [normalized])](#new_Int32BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Int32BufferAttribute_new"></a>

### new Int32BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Int32Array</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### int32BufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### int32BufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### int32BufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### int32BufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### int32BufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### int32BufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### int32BufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### int32BufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### int32BufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### int32BufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### int32BufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### int32BufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### int32BufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### int32BufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### int32BufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### int32BufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### int32BufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### int32BufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### int32BufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### int32BufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### int32BufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### int32BufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### int32BufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### int32BufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### int32BufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### int32BufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### int32BufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### int32BufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### int32BufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### int32BufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### int32BufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### int32BufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### int32BufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### int32BufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### int32BufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### int32BufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### int32BufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### int32BufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### int32BufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### int32BufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Int32BufferAttribute</code>](#Int32BufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Uint32BufferAttribute"></a>

## Uint32BufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `UInt32` buffer attribute with
a plain `Array` instance.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Uint32BufferAttribute](#Uint32BufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Uint32BufferAttribute(array, itemSize, [normalized])](#new_Uint32BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Uint32BufferAttribute_new"></a>

### new Uint32BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Uint32Array</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### uint32BufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### uint32BufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### uint32BufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### uint32BufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### uint32BufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### uint32BufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### uint32BufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### uint32BufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### uint32BufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### uint32BufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### uint32BufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### uint32BufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### uint32BufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### uint32BufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### uint32BufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### uint32BufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### uint32BufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### uint32BufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### uint32BufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### uint32BufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### uint32BufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### uint32BufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### uint32BufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### uint32BufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### uint32BufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### uint32BufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### uint32BufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### uint32BufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### uint32BufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### uint32BufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### uint32BufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### uint32BufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### uint32BufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### uint32BufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### uint32BufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### uint32BufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### uint32BufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### uint32BufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### uint32BufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### uint32BufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Uint32BufferAttribute</code>](#Uint32BufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Float16BufferAttribute"></a>

## Float16BufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `Float16` buffer attribute with
a plain `Array` instance.

This class automatically converts to to and from FP16 since `Float16Array` is not
natively supported in JavaScript.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Float16BufferAttribute](#Float16BufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Float16BufferAttribute(array, itemSize, [normalized])](#new_Float16BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Float16BufferAttribute_new"></a>

### new Float16BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Uint16Array</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### float16BufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### float16BufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### float16BufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### float16BufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### float16BufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### float16BufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### float16BufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### float16BufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### float16BufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### float16BufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### float16BufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### float16BufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### float16BufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### float16BufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### float16BufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### float16BufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### float16BufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### float16BufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### float16BufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### float16BufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### float16BufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### float16BufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### float16BufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### float16BufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### float16BufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### float16BufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### float16BufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### float16BufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### float16BufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### float16BufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### float16BufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### float16BufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### float16BufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### float16BufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### float16BufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### float16BufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### float16BufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### float16BufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### float16BufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### float16BufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Float16BufferAttribute</code>](#Float16BufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="Float32BufferAttribute"></a>

## Float32BufferAttribute ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
Convenient class that can be used when creating a `Float32` buffer attribute with
a plain `Array` instance.

**Kind**: global class  
**Extends**: [<code>BufferAttribute</code>](#BufferAttribute)  

* [Float32BufferAttribute](#Float32BufferAttribute) ⇐ [<code>BufferAttribute</code>](#BufferAttribute)
    * [new Float32BufferAttribute(array, itemSize, [normalized])](#new_Float32BufferAttribute_new)
    * [.isBufferAttribute](#BufferAttribute+isBufferAttribute) : <code>boolean</code>
    * [.id](#BufferAttribute+id) : <code>number</code>
    * [.name](#BufferAttribute+name) : <code>string</code>
    * [.array](#BufferAttribute+array) : <code>TypedArray</code>
    * [.itemSize](#BufferAttribute+itemSize) : <code>number</code>
    * [.count](#BufferAttribute+count) : <code>number</code>
    * [.normalized](#BufferAttribute+normalized) : <code>boolean</code>
    * [.usage](#BufferAttribute+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#BufferAttribute+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.gpuType](#BufferAttribute+gpuType) : <code>FloatType</code> \| <code>IntType</code>
    * [.version](#BufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#BufferAttribute+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#BufferAttribute+onUploadCallback)
    * [.setUsage(value)](#BufferAttribute+setUsage) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.addUpdateRange(start, count)](#BufferAttribute+addUpdateRange)
    * [.clearUpdateRanges()](#BufferAttribute+clearUpdateRanges)
    * [.copy(source)](#BufferAttribute+copy) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyAt(index1, attribute, index2)](#BufferAttribute+copyAt) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.copyArray(array)](#BufferAttribute+copyArray) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix3(m)](#BufferAttribute+applyMatrix3) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyMatrix4(m)](#BufferAttribute+applyMatrix4) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.applyNormalMatrix(m)](#BufferAttribute+applyNormalMatrix) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.transformDirection(m)](#BufferAttribute+transformDirection) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.set(value, [offset])](#BufferAttribute+set) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getComponent(index, component)](#BufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#BufferAttribute+setComponent) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getX(index)](#BufferAttribute+getX) ⇒ <code>number</code>
    * [.setX(index, x)](#BufferAttribute+setX) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getY(index)](#BufferAttribute+getY) ⇒ <code>number</code>
    * [.setY(index, y)](#BufferAttribute+setY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getZ(index)](#BufferAttribute+getZ) ⇒ <code>number</code>
    * [.setZ(index, z)](#BufferAttribute+setZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.getW(index)](#BufferAttribute+getW) ⇒ <code>number</code>
    * [.setW(index, w)](#BufferAttribute+setW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXY(index, x, y)](#BufferAttribute+setXY) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZ(index, x, y, z)](#BufferAttribute+setXYZ) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#BufferAttribute+setXYZW) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.onUpload(callback)](#BufferAttribute+onUpload) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.clone()](#BufferAttribute+clone) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
    * [.toJSON()](#BufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_Float32BufferAttribute_new"></a>

### new Float32BufferAttribute(array, itemSize, [normalized])
Constructs a new buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> \| <code>Float32Array</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="BufferAttribute+isBufferAttribute"></a>

### float32BufferAttribute.isBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Default**: <code>true</code>  
**Overrides**: [<code>isBufferAttribute</code>](#BufferAttribute+isBufferAttribute)  
**Read only**: true  
<a name="BufferAttribute+id"></a>

### float32BufferAttribute.id : <code>number</code>
The ID of the buffer attribute.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>id</code>](#BufferAttribute+id)  
**Read only**: true  
<a name="BufferAttribute+name"></a>

### float32BufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>name</code>](#BufferAttribute+name)  
<a name="BufferAttribute+array"></a>

### float32BufferAttribute.array : <code>TypedArray</code>
The array holding the attribute data. It should have `itemSize * numVertices`
elements, where `numVertices` is the number of vertices in the associated geometry.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>array</code>](#BufferAttribute+array)  
<a name="BufferAttribute+itemSize"></a>

### float32BufferAttribute.itemSize : <code>number</code>
The number of values of the array that should be associated with a particular vertex.
For instance, if this attribute is storing a 3-component vector (such as a position,
normal, or color), then the value should be `3`.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>itemSize</code>](#BufferAttribute+itemSize)  
<a name="BufferAttribute+count"></a>

### float32BufferAttribute.count : <code>number</code>
Represents the number of items this buffer attribute stores. It is internally computed
by dividing the `array` length by the `itemSize`.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>count</code>](#BufferAttribute+count)  
**Read only**: true  
<a name="BufferAttribute+normalized"></a>

### float32BufferAttribute.normalized : <code>boolean</code>
Applies to integer data only. Indicates how the underlying data in the buffer maps to
the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
and `normalized` is `true`, the values `0 -+65535` in the array data will be mapped to
`0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
to floats unmodified, i.e. `65535` becomes `65535.0f`.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>normalized</code>](#BufferAttribute+normalized)  
<a name="BufferAttribute+usage"></a>

### float32BufferAttribute.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Default**: <code>StaticDrawUsage</code>  
**Overrides**: [<code>usage</code>](#BufferAttribute+usage)  
<a name="BufferAttribute+updateRanges"></a>

### float32BufferAttribute.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>updateRanges</code>](#BufferAttribute+updateRanges)  
<a name="BufferAttribute+gpuType"></a>

### float32BufferAttribute.gpuType : <code>FloatType</code> \| <code>IntType</code>
Configures the bound GPU type for use in shaders.

Note: this only has an effect for integer arrays and is not configurable for float arrays.
For lower precision float types, use `Float16BufferAttribute`.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Default**: <code>FloatType</code>  
**Overrides**: [<code>gpuType</code>](#BufferAttribute+gpuType)  
<a name="BufferAttribute+version"></a>

### float32BufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>version</code>](#BufferAttribute+version)  
<a name="BufferAttribute+needsUpdate"></a>

### float32BufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Default**: <code>false</code>  
**Overrides**: [<code>needsUpdate</code>](#BufferAttribute+needsUpdate)  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="BufferAttribute+onUploadCallback"></a>

### float32BufferAttribute.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute
array data to the GPU.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>onUploadCallback</code>](#BufferAttribute+onUploadCallback)  
<a name="BufferAttribute+setUsage"></a>

### float32BufferAttribute.setUsage(value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the usage of this buffer attribute.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setUsage</code>](#BufferAttribute+setUsage)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="BufferAttribute+addUpdateRange"></a>

### float32BufferAttribute.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>addUpdateRange</code>](#BufferAttribute+addUpdateRange)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="BufferAttribute+clearUpdateRanges"></a>

### float32BufferAttribute.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>clearUpdateRanges</code>](#BufferAttribute+clearUpdateRanges)  
<a name="BufferAttribute+copy"></a>

### float32BufferAttribute.copy(source) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the values of the given buffer attribute to this instance.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>copy</code>](#BufferAttribute+copy)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy. |

<a name="BufferAttribute+copyAt"></a>

### float32BufferAttribute.copyAt(index1, attribute, index2) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies a vector from the given buffer attribute to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>copyAt</code>](#BufferAttribute+copyAt)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this buffer attribute. |
| attribute | [<code>BufferAttribute</code>](#BufferAttribute) | The buffer attribute to copy from. |
| index2 | <code>number</code> | The source index into the given buffer attribute. |

<a name="BufferAttribute+copyArray"></a>

### float32BufferAttribute.copyArray(array) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Copies the given array data into this buffer attribute.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>copyArray</code>](#BufferAttribute+copyArray)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> \| <code>Array</code> | The array to copy. |

<a name="BufferAttribute+applyMatrix3"></a>

### float32BufferAttribute.applyMatrix3(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 matrix to the given attribute. Works with
item size `2` and `3`.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>applyMatrix3</code>](#BufferAttribute+applyMatrix3)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="BufferAttribute+applyMatrix4"></a>

### float32BufferAttribute.applyMatrix4(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>applyMatrix4</code>](#BufferAttribute+applyMatrix4)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+applyNormalMatrix"></a>

### float32BufferAttribute.applyNormalMatrix(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>applyNormalMatrix</code>](#BufferAttribute+applyNormalMatrix)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="BufferAttribute+transformDirection"></a>

### float32BufferAttribute.transformDirection(m) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>transformDirection</code>](#BufferAttribute+transformDirection)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferAttribute+set"></a>

### float32BufferAttribute.set(value, [offset]) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given array data in the buffer attribute.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>set</code>](#BufferAttribute+set)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this buffer attribute's array. |

<a name="BufferAttribute+getComponent"></a>

### float32BufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>getComponent</code>](#BufferAttribute+getComponent)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="BufferAttribute+setComponent"></a>

### float32BufferAttribute.setComponent(index, component, value) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setComponent</code>](#BufferAttribute+setComponent)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="BufferAttribute+getX"></a>

### float32BufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>getX</code>](#BufferAttribute+getX)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setX"></a>

### float32BufferAttribute.setX(index, x) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setX</code>](#BufferAttribute+setX)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="BufferAttribute+getY"></a>

### float32BufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>getY</code>](#BufferAttribute+getY)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setY"></a>

### float32BufferAttribute.setY(index, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setY</code>](#BufferAttribute+setY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="BufferAttribute+getZ"></a>

### float32BufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>getZ</code>](#BufferAttribute+getZ)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setZ"></a>

### float32BufferAttribute.setZ(index, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setZ</code>](#BufferAttribute+setZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="BufferAttribute+getW"></a>

### float32BufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>getW</code>](#BufferAttribute+getW)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="BufferAttribute+setW"></a>

### float32BufferAttribute.setW(index, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setW</code>](#BufferAttribute+setW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="BufferAttribute+setXY"></a>

### float32BufferAttribute.setXY(index, x, y) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setXY</code>](#BufferAttribute+setXY)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="BufferAttribute+setXYZ"></a>

### float32BufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setXYZ</code>](#BufferAttribute+setXYZ)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="BufferAttribute+setXYZW"></a>

### float32BufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>setXYZW</code>](#BufferAttribute+setXYZW)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="BufferAttribute+onUpload"></a>

### float32BufferAttribute.onUpload(callback) ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Sets the given callback function that is executed after the Renderer has transferred
the attribute array data to the GPU. Can be used to perform clean-up operations after
the upload when attribute data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>onUpload</code>](#BufferAttribute+onUpload)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="BufferAttribute+clone"></a>

### float32BufferAttribute.clone() ⇒ [<code>BufferAttribute</code>](#BufferAttribute)
Returns a new buffer attribute with copied values from this instance.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>clone</code>](#BufferAttribute+clone)  
**Returns**: [<code>BufferAttribute</code>](#BufferAttribute) - A clone of this instance.  
<a name="BufferAttribute+toJSON"></a>

### float32BufferAttribute.toJSON() ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

**Kind**: instance method of [<code>Float32BufferAttribute</code>](#Float32BufferAttribute)  
**Overrides**: [<code>toJSON</code>](#BufferAttribute+toJSON)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  
<a name="BufferGeometry"></a>

## BufferGeometry ⇐ <code>EventDispatcher</code>
A representation of mesh, line, or point geometry. Includes vertex
positions, face indices, normals, colors, UVs, and custom attributes
within buffers, reducing the cost of passing all this data to the GPU.

```js
const geometry = new THREE.BufferGeometry();
// create a simple square shape. We duplicate the top left and bottom right
// vertices because each vertex needs to appear once per triangle.
const vertices = new Float32Array( [
	-1.0, -1.0,  1.0, // v0
	 1.0, -1.0,  1.0, // v1
	 1.0,  1.0,  1.0, // v2

	 1.0,  1.0,  1.0, // v3
	-1.0,  1.0,  1.0, // v4
	-1.0, -1.0,  1.0  // v5
] );
// itemSize = 3 because there are 3 values (components) per vertex
geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
const mesh = new THREE.Mesh( geometry, material );
```

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [BufferGeometry](#BufferGeometry) ⇐ <code>EventDispatcher</code>
    * [new BufferGeometry()](#new_BufferGeometry_new)
    * [.isBufferGeometry](#BufferGeometry+isBufferGeometry) : <code>boolean</code>
    * [.id](#BufferGeometry+id) : <code>number</code>
    * [.uuid](#BufferGeometry+uuid) : <code>string</code>
    * [.name](#BufferGeometry+name) : <code>string</code>
    * [.index](#BufferGeometry+index) : <code>BufferAttribute</code>
    * [.indirect](#BufferGeometry+indirect) : <code>BufferAttribute</code>
    * [.attributes](#BufferGeometry+attributes) : <code>Object.&lt;string, (BufferAttribute\|InterleavedBufferAttribute)&gt;</code>
    * [.morphAttributes](#BufferGeometry+morphAttributes) : <code>Object</code>
    * [.morphTargetsRelative](#BufferGeometry+morphTargetsRelative) : <code>boolean</code>
    * [.groups](#BufferGeometry+groups) : <code>Array.&lt;Object&gt;</code>
    * [.boundingBox](#BufferGeometry+boundingBox) : <code>Box3</code>
    * [.boundingSphere](#BufferGeometry+boundingSphere) : <code>Sphere</code>
    * [.drawRange](#BufferGeometry+drawRange) : <code>Object</code>
    * [.userData](#BufferGeometry+userData) : <code>Object</code>
    * [.getIndex()](#BufferGeometry+getIndex) ⇒ <code>BufferAttribute</code>
    * [.setIndex(index)](#BufferGeometry+setIndex) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.setIndirect(indirect)](#BufferGeometry+setIndirect) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.getIndirect()](#BufferGeometry+getIndirect) ⇒ <code>BufferAttribute</code>
    * [.getAttribute(name)](#BufferGeometry+getAttribute) ⇒ <code>BufferAttribute</code> \| <code>InterleavedBufferAttribute</code> \| <code>undefined</code>
    * [.setAttribute(name, attribute)](#BufferGeometry+setAttribute) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.deleteAttribute(name)](#BufferGeometry+deleteAttribute) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.hasAttribute(name)](#BufferGeometry+hasAttribute) ⇒ <code>boolean</code>
    * [.addGroup(start, count, [materialIndex])](#BufferGeometry+addGroup)
    * [.clearGroups()](#BufferGeometry+clearGroups)
    * [.setDrawRange(start, count)](#BufferGeometry+setDrawRange)
    * [.applyMatrix4(matrix)](#BufferGeometry+applyMatrix4) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.applyQuaternion(q)](#BufferGeometry+applyQuaternion) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.rotateX(angle)](#BufferGeometry+rotateX) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.rotateY(angle)](#BufferGeometry+rotateY) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.rotateZ(angle)](#BufferGeometry+rotateZ) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.translate(x, y, z)](#BufferGeometry+translate) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.scale(x, y, z)](#BufferGeometry+scale) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.lookAt(vector)](#BufferGeometry+lookAt) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.center()](#BufferGeometry+center) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.setFromPoints(points)](#BufferGeometry+setFromPoints) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.computeBoundingBox()](#BufferGeometry+computeBoundingBox)
    * [.computeBoundingSphere()](#BufferGeometry+computeBoundingSphere)
    * [.computeTangents()](#BufferGeometry+computeTangents)
    * [.computeVertexNormals()](#BufferGeometry+computeVertexNormals)
    * [.normalizeNormals()](#BufferGeometry+normalizeNormals)
    * [.toNonIndexed()](#BufferGeometry+toNonIndexed) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.toJSON()](#BufferGeometry+toJSON) ⇒ <code>Object</code>
    * [.clone()](#BufferGeometry+clone) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.copy(source)](#BufferGeometry+copy) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
    * [.dispose()](#BufferGeometry+dispose)

<a name="new_BufferGeometry_new"></a>

### new BufferGeometry()
Constructs a new geometry.

<a name="BufferGeometry+isBufferGeometry"></a>

### bufferGeometry.isBufferGeometry : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BufferGeometry+id"></a>

### bufferGeometry.id : <code>number</code>
The ID of the geometry.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
**Read only**: true  
<a name="BufferGeometry+uuid"></a>

### bufferGeometry.uuid : <code>string</code>
The UUID of the geometry.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
**Read only**: true  
<a name="BufferGeometry+name"></a>

### bufferGeometry.name : <code>string</code>
The name of the geometry.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+index"></a>

### bufferGeometry.index : <code>BufferAttribute</code>
Allows for vertices to be re-used across multiple triangles; this is
called using "indexed triangles". Each triangle is associated with the
indices of three vertices. This attribute therefore stores the index of
each vertex for each triangular face. If this attribute is not set, the
renderer assumes that each three contiguous positions represent a single triangle.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
**Default**: <code>null</code>  
<a name="BufferGeometry+indirect"></a>

### bufferGeometry.indirect : <code>BufferAttribute</code>
A (storage) buffer attribute which was generated with a compute shader and
now defines indirect draw calls.

Can only be used with [WebGPURenderer](WebGPURenderer) and a WebGPU backend.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
**Default**: <code>null</code>  
<a name="BufferGeometry+attributes"></a>

### bufferGeometry.attributes : <code>Object.&lt;string, (BufferAttribute\|InterleavedBufferAttribute)&gt;</code>
This dictionary has as id the name of the attribute to be set and as value
the buffer attribute to set it to. Rather than accessing this property directly,
use `setAttribute()` and `getAttribute()` to access attributes of this geometry.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+morphAttributes"></a>

### bufferGeometry.morphAttributes : <code>Object</code>
This dictionary holds the morph targets of the geometry.

Note: Once the geometry has been rendered, the morph attribute data cannot
be changed. You will have to call `dispose()?, and create a new geometry instance.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+morphTargetsRelative"></a>

### bufferGeometry.morphTargetsRelative : <code>boolean</code>
Used to control the morph target behavior; when set to `true`, the morph
target data is treated as relative offsets, rather than as absolute
positions/normals.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
**Default**: <code>false</code>  
<a name="BufferGeometry+groups"></a>

### bufferGeometry.groups : <code>Array.&lt;Object&gt;</code>
Split the geometry into groups, each of which will be rendered in a
separate draw call. This allows an array of materials to be used with the geometry.

Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.

Every vertex and index must belong to exactly one group — groups must not share vertices or
indices, and must not leave vertices or indices unused.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+boundingBox"></a>

### bufferGeometry.boundingBox : <code>Box3</code>
Bounding box for the geometry which can be calculated with `computeBoundingBox()`.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
**Default**: <code>null</code>  
<a name="BufferGeometry+boundingSphere"></a>

### bufferGeometry.boundingSphere : <code>Sphere</code>
Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
**Default**: <code>null</code>  
<a name="BufferGeometry+drawRange"></a>

### bufferGeometry.drawRange : <code>Object</code>
Determines the part of the geometry to render. This should not be set directly,
instead use `setDrawRange()`.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+userData"></a>

### bufferGeometry.userData : <code>Object</code>
An object that can be used to store custom data about the geometry.
It should not hold references to functions as these will not be cloned.

**Kind**: instance property of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+getIndex"></a>

### bufferGeometry.getIndex() ⇒ <code>BufferAttribute</code>
Returns the index of this geometry.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: <code>BufferAttribute</code> - The index. Returns `null` if no index is defined.  
<a name="BufferGeometry+setIndex"></a>

### bufferGeometry.setIndex(index) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Sets the given index to this geometry.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>Array.&lt;number&gt;</code> \| <code>BufferAttribute</code> | The index to set. |

<a name="BufferGeometry+setIndirect"></a>

### bufferGeometry.setIndirect(indirect) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Sets the given indirect attribute to this geometry.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| indirect | <code>BufferAttribute</code> | The attribute holding indirect draw calls. |

<a name="BufferGeometry+getIndirect"></a>

### bufferGeometry.getIndirect() ⇒ <code>BufferAttribute</code>
Returns the indirect attribute of this geometry.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: <code>BufferAttribute</code> - The indirect attribute. Returns `null` if no indirect attribute is defined.  
<a name="BufferGeometry+getAttribute"></a>

### bufferGeometry.getAttribute(name) ⇒ <code>BufferAttribute</code> \| <code>InterleavedBufferAttribute</code> \| <code>undefined</code>
Returns the buffer attribute for the given name.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: <code>BufferAttribute</code> \| <code>InterleavedBufferAttribute</code> \| <code>undefined</code> - The buffer attribute.
Returns `undefined` if not attribute has been found.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute name. |

<a name="BufferGeometry+setAttribute"></a>

### bufferGeometry.setAttribute(name, attribute) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Sets the given attribute for the given name.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute name. |
| attribute | <code>BufferAttribute</code> \| <code>InterleavedBufferAttribute</code> | The attribute to set. |

<a name="BufferGeometry+deleteAttribute"></a>

### bufferGeometry.deleteAttribute(name) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Deletes the attribute for the given name.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute name to delete. |

<a name="BufferGeometry+hasAttribute"></a>

### bufferGeometry.hasAttribute(name) ⇒ <code>boolean</code>
Returns `true` if this geometry has an attribute for the given name.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: <code>boolean</code> - Whether this geometry has an attribute for the given name or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute name. |

<a name="BufferGeometry+addGroup"></a>

### bufferGeometry.addGroup(start, count, [materialIndex])
Adds a group to this geometry.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| start | <code>number</code> |  | The first element in this draw call. That is the first vertex for non-indexed geometry, otherwise the first triangle index. |
| count | <code>number</code> |  | Specifies how many vertices (or indices) are part of this group. |
| [materialIndex] | <code>number</code> | <code>0</code> | The material array index to use. |

<a name="BufferGeometry+clearGroups"></a>

### bufferGeometry.clearGroups()
Clears all groups.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+setDrawRange"></a>

### bufferGeometry.setDrawRange(start, count)
Sets the draw range for this geometry.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | The first vertex for non-indexed geometry, otherwise the first triangle index. |
| count | <code>number</code> | For non-indexed BufferGeometry, `count` is the number of vertices to render. For indexed BufferGeometry, `count` is the number of indices to render. |

<a name="BufferGeometry+applyMatrix4"></a>

### bufferGeometry.applyMatrix4(matrix) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Applies the given 4x4 transformation matrix to the geometry.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The matrix to apply. |

<a name="BufferGeometry+applyQuaternion"></a>

### bufferGeometry.applyQuaternion(q) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Applies the rotation represented by the Quaternion to the geometry.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The Quaternion to apply. |

<a name="BufferGeometry+rotateX"></a>

### bufferGeometry.rotateX(angle) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Rotates the geometry about the X axis. This is typically done as a one time
operation, and not during a loop. Use [Object3D#rotation](Object3D#rotation) for typical
real-time mesh rotation.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| angle | <code>number</code> | The angle in radians. |

<a name="BufferGeometry+rotateY"></a>

### bufferGeometry.rotateY(angle) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Rotates the geometry about the Y axis. This is typically done as a one time
operation, and not during a loop. Use [Object3D#rotation](Object3D#rotation) for typical
real-time mesh rotation.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| angle | <code>number</code> | The angle in radians. |

<a name="BufferGeometry+rotateZ"></a>

### bufferGeometry.rotateZ(angle) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Rotates the geometry about the Z axis. This is typically done as a one time
operation, and not during a loop. Use [Object3D#rotation](Object3D#rotation) for typical
real-time mesh rotation.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| angle | <code>number</code> | The angle in radians. |

<a name="BufferGeometry+translate"></a>

### bufferGeometry.translate(x, y, z) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Translates the geometry. This is typically done as a one time
operation, and not during a loop. Use [Object3D#position](Object3D#position) for typical
real-time mesh rotation.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x offset. |
| y | <code>number</code> | The y offset. |
| z | <code>number</code> | The z offset. |

<a name="BufferGeometry+scale"></a>

### bufferGeometry.scale(x, y, z) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Scales the geometry. This is typically done as a one time
operation, and not during a loop. Use [Object3D#scale](Object3D#scale) for typical
real-time mesh rotation.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x scale. |
| y | <code>number</code> | The y scale. |
| z | <code>number</code> | The z scale. |

<a name="BufferGeometry+lookAt"></a>

### bufferGeometry.lookAt(vector) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Rotates the geometry to face a point in 3D space. This is typically done as a one time
operation, and not during a loop. Use [Object3D#lookAt](Object3D#lookAt) for typical
real-time mesh rotation.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| vector | <code>Vector3</code> | The target point. |

<a name="BufferGeometry+center"></a>

### bufferGeometry.center() ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Center the geometry based on its bounding box.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  
<a name="BufferGeometry+setFromPoints"></a>

### bufferGeometry.setFromPoints(points) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Defines a geometry by creating a `position` attribute based on the given array of points. The array
can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
set to `0`.

If the method is used with an existing `position` attribute, the vertex data are overwritten with the
data from the array. The length of the array must match the vertex count.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> \| <code>Array.&lt;Vector3&gt;</code> | The points. |

<a name="BufferGeometry+computeBoundingBox"></a>

### bufferGeometry.computeBoundingBox()
Computes the bounding box of the geometry, and updates the `boundingBox` member.
The bounding box is not computed by the engine; it must be computed by your app.
You may need to recompute the bounding box if the geometry vertices are modified.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+computeBoundingSphere"></a>

### bufferGeometry.computeBoundingSphere()
Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
You may need to recompute the bounding sphere if the geometry vertices are modified.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+computeTangents"></a>

### bufferGeometry.computeTangents()
Calculates and adds a tangent attribute to this geometry.

The computation is only supported for indexed geometries and if position, normal, and uv attributes
are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
[BufferGeometryUtils#computeMikkTSpaceTangents](BufferGeometryUtils#computeMikkTSpaceTangents) instead.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+computeVertexNormals"></a>

### bufferGeometry.computeVertexNormals()
Computes vertex normals for the given vertex data. For indexed geometries, the method sets
each vertex normal to be the average of the face normals of the faces that share that vertex.
For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
to be the same as the face normal.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+normalizeNormals"></a>

### bufferGeometry.normalizeNormals()
Ensures every normal vector in a geometry will have a magnitude of `1`. This will
correct lighting on the geometry surfaces.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
<a name="BufferGeometry+toNonIndexed"></a>

### bufferGeometry.toNonIndexed() ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Return a new non-index version of this indexed geometry. If the geometry
is already non-indexed, the method is a NOOP.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - The non-indexed version of this indexed geometry.  
<a name="BufferGeometry+toJSON"></a>

### bufferGeometry.toJSON() ⇒ <code>Object</code>
Serializes the geometry into JSON.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: <code>Object</code> - A JSON object representing the serialized geometry.  
<a name="BufferGeometry+clone"></a>

### bufferGeometry.clone() ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Returns a new geometry with copied values from this instance.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A clone of this instance.  
<a name="BufferGeometry+copy"></a>

### bufferGeometry.copy(source) ⇒ [<code>BufferGeometry</code>](#BufferGeometry)
Copies the values of the given geometry to this instance.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Returns**: [<code>BufferGeometry</code>](#BufferGeometry) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>BufferGeometry</code>](#BufferGeometry) | The geometry to copy. |

<a name="BufferGeometry+dispose"></a>

### bufferGeometry.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>BufferGeometry</code>](#BufferGeometry)  
**Emits**: <code>BufferGeometry#event:dispose</code>  
<a name="Clock"></a>

## Clock
Class for keeping track of time.

**Kind**: global class  

* [Clock](#Clock)
    * [new Clock([autoStart])](#new_Clock_new)
    * [.autoStart](#Clock+autoStart) : <code>boolean</code>
    * [.startTime](#Clock+startTime) : <code>number</code>
    * [.oldTime](#Clock+oldTime) : <code>number</code>
    * [.elapsedTime](#Clock+elapsedTime) : <code>number</code>
    * [.running](#Clock+running) : <code>boolean</code>
    * [.start()](#Clock+start)
    * [.stop()](#Clock+stop)
    * [.getElapsedTime()](#Clock+getElapsedTime) ⇒ <code>number</code>
    * [.getDelta()](#Clock+getDelta) ⇒ <code>number</code>

<a name="new_Clock_new"></a>

### new Clock([autoStart])
Constructs a new clock.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [autoStart] | <code>boolean</code> | <code>true</code> | Whether to automatically start the clock when `getDelta()` is called for the first time. |

<a name="Clock+autoStart"></a>

### clock.autoStart : <code>boolean</code>
If set to `true`, the clock starts automatically when `getDelta()` is called
for the first time.

**Kind**: instance property of [<code>Clock</code>](#Clock)  
**Default**: <code>true</code>  
<a name="Clock+startTime"></a>

### clock.startTime : <code>number</code>
Holds the time at which the clock's `start()` method was last called.

**Kind**: instance property of [<code>Clock</code>](#Clock)  
**Default**: <code>0</code>  
<a name="Clock+oldTime"></a>

### clock.oldTime : <code>number</code>
Holds the time at which the clock's `start()`, `getElapsedTime()` or
`getDelta()` methods were last called.

**Kind**: instance property of [<code>Clock</code>](#Clock)  
**Default**: <code>0</code>  
<a name="Clock+elapsedTime"></a>

### clock.elapsedTime : <code>number</code>
Keeps track of the total time that the clock has been running.

**Kind**: instance property of [<code>Clock</code>](#Clock)  
**Default**: <code>0</code>  
<a name="Clock+running"></a>

### clock.running : <code>boolean</code>
Whether the clock is running or not.

**Kind**: instance property of [<code>Clock</code>](#Clock)  
**Default**: <code>true</code>  
<a name="Clock+start"></a>

### clock.start()
Starts the clock. When `autoStart` is set to `true`, the method is automatically
called by the class.

**Kind**: instance method of [<code>Clock</code>](#Clock)  
<a name="Clock+stop"></a>

### clock.stop()
Stops the clock.

**Kind**: instance method of [<code>Clock</code>](#Clock)  
<a name="Clock+getElapsedTime"></a>

### clock.getElapsedTime() ⇒ <code>number</code>
Returns the elapsed time in seconds.

**Kind**: instance method of [<code>Clock</code>](#Clock)  
**Returns**: <code>number</code> - The elapsed time.  
<a name="Clock+getDelta"></a>

### clock.getDelta() ⇒ <code>number</code>
Returns the delta time in seconds.

**Kind**: instance method of [<code>Clock</code>](#Clock)  
**Returns**: <code>number</code> - The delta time.  
<a name="EventDispatcher"></a>

## EventDispatcher
This modules allows to dispatch event objects on custom JavaScript objects.

Main repository: [eventdispatcher.js](https://github.com/mrdoob/eventdispatcher.js/)

Code Example:
```js
class Car extends EventDispatcher {
	start() {
		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
	}
};

// Using events with the custom object
const car = new Car();
car.addEventListener( 'start', function ( event ) {
	alert( event.message );
} );

car.start();
```

**Kind**: global class  

* [EventDispatcher](#EventDispatcher)
    * [.addEventListener(type, listener)](#EventDispatcher+addEventListener)
    * [.hasEventListener(type, listener)](#EventDispatcher+hasEventListener) ⇒ <code>boolean</code>
    * [.removeEventListener(type, listener)](#EventDispatcher+removeEventListener)
    * [.dispatchEvent(event)](#EventDispatcher+dispatchEvent)

<a name="EventDispatcher+addEventListener"></a>

### eventDispatcher.addEventListener(type, listener)
Adds the given event listener to the given event type.

**Kind**: instance method of [<code>EventDispatcher</code>](#EventDispatcher)  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type of event to listen to. |
| listener | <code>function</code> | The function that gets called when the event is fired. |

<a name="EventDispatcher+hasEventListener"></a>

### eventDispatcher.hasEventListener(type, listener) ⇒ <code>boolean</code>
Returns `true` if the given event listener has been added to the given event type.

**Kind**: instance method of [<code>EventDispatcher</code>](#EventDispatcher)  
**Returns**: <code>boolean</code> - Whether the given event listener has been added to the given event type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type of event. |
| listener | <code>function</code> | The listener to check. |

<a name="EventDispatcher+removeEventListener"></a>

### eventDispatcher.removeEventListener(type, listener)
Removes the given event listener from the given event type.

**Kind**: instance method of [<code>EventDispatcher</code>](#EventDispatcher)  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type of event. |
| listener | <code>function</code> | The listener to remove. |

<a name="EventDispatcher+dispatchEvent"></a>

### eventDispatcher.dispatchEvent(event)
Dispatches an event object.

**Kind**: instance method of [<code>EventDispatcher</code>](#EventDispatcher)  

| Param | Type | Description |
| --- | --- | --- |
| event | <code>Object</code> | The event that gets fired. |

<a name="GLBufferAttribute"></a>

## GLBufferAttribute
An alternative version of a buffer attribute with more control over the VBO.

The renderer does not construct a VBO for this kind of attribute. Instead, it uses
whatever VBO is passed in constructor and can later be altered via the `buffer` property.

The most common use case for this class is when some kind of GPGPU calculation interferes
or even produces the VBOs in question.

Notice that this class can only be used with [WebGLRenderer](WebGLRenderer).

**Kind**: global class  

* [GLBufferAttribute](#GLBufferAttribute)
    * [new GLBufferAttribute(buffer, type, itemSize, elementSize, count)](#new_GLBufferAttribute_new)
    * [.isGLBufferAttribute](#GLBufferAttribute+isGLBufferAttribute) : <code>boolean</code>
    * [.name](#GLBufferAttribute+name) : <code>string</code>
    * [.buffer](#GLBufferAttribute+buffer) : <code>WebGLBuffer</code>
    * [.type](#GLBufferAttribute+type) : <code>number</code>
    * [.itemSize](#GLBufferAttribute+itemSize) : <code>number</code>
    * [.elementSize](#GLBufferAttribute+elementSize) : <code>number</code>
    * [.count](#GLBufferAttribute+count) : <code>number</code>
    * [.version](#GLBufferAttribute+version) : <code>number</code>
    * [.needsUpdate](#GLBufferAttribute+needsUpdate) : <code>number</code>
    * [.setBuffer(buffer)](#GLBufferAttribute+setBuffer) ⇒ <code>BufferAttribute</code>
    * [.setType(type, elementSize)](#GLBufferAttribute+setType) ⇒ <code>BufferAttribute</code>
    * [.setItemSize(itemSize)](#GLBufferAttribute+setItemSize) ⇒ <code>BufferAttribute</code>
    * [.setCount(count)](#GLBufferAttribute+setCount) ⇒ <code>BufferAttribute</code>

<a name="new_GLBufferAttribute_new"></a>

### new GLBufferAttribute(buffer, type, itemSize, elementSize, count)
Constructs a new GL buffer attribute.


| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>WebGLBuffer</code> | The native WebGL buffer. |
| type | <code>number</code> | The native data type (e.g. `gl.FLOAT`). |
| itemSize | <code>number</code> | The item size. |
| elementSize | <code>number</code> | The corresponding size (in bytes) for the given `type` parameter. |
| count | <code>number</code> | The expected number of vertices in VBO. |

<a name="GLBufferAttribute+isGLBufferAttribute"></a>

### glBufferAttribute.isGLBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="GLBufferAttribute+name"></a>

### glBufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
<a name="GLBufferAttribute+buffer"></a>

### glBufferAttribute.buffer : <code>WebGLBuffer</code>
The native WebGL buffer.

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
<a name="GLBufferAttribute+type"></a>

### glBufferAttribute.type : <code>number</code>
The native data type.

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
<a name="GLBufferAttribute+itemSize"></a>

### glBufferAttribute.itemSize : <code>number</code>
The item size, see [BufferAttribute#itemSize](BufferAttribute#itemSize).

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
<a name="GLBufferAttribute+elementSize"></a>

### glBufferAttribute.elementSize : <code>number</code>
The corresponding size (in bytes) for the given `type` parameter.

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
<a name="GLBufferAttribute+count"></a>

### glBufferAttribute.count : <code>number</code>
The expected number of vertices in VBO.

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
<a name="GLBufferAttribute+version"></a>

### glBufferAttribute.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
<a name="GLBufferAttribute+needsUpdate"></a>

### glBufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="GLBufferAttribute+setBuffer"></a>

### glBufferAttribute.setBuffer(buffer) ⇒ <code>BufferAttribute</code>
Sets the given native WebGL buffer.

**Kind**: instance method of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
**Returns**: <code>BufferAttribute</code> - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>WebGLBuffer</code> | The buffer to set. |

<a name="GLBufferAttribute+setType"></a>

### glBufferAttribute.setType(type, elementSize) ⇒ <code>BufferAttribute</code>
Sets the given native data type and element size.

**Kind**: instance method of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
**Returns**: <code>BufferAttribute</code> - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>number</code> | The native data type (e.g. `gl.FLOAT`). |
| elementSize | <code>number</code> | The corresponding size (in bytes) for the given `type` parameter. |

<a name="GLBufferAttribute+setItemSize"></a>

### glBufferAttribute.setItemSize(itemSize) ⇒ <code>BufferAttribute</code>
Sets the item size.

**Kind**: instance method of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
**Returns**: <code>BufferAttribute</code> - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| itemSize | <code>number</code> | The item size. |

<a name="GLBufferAttribute+setCount"></a>

### glBufferAttribute.setCount(count) ⇒ <code>BufferAttribute</code>
Sets the count (the expected number of vertices in VBO).

**Kind**: instance method of [<code>GLBufferAttribute</code>](#GLBufferAttribute)  
**Returns**: <code>BufferAttribute</code> - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| count | <code>number</code> | The count. |

<a name="InstancedBufferAttribute"></a>

## InstancedBufferAttribute ⇐ <code>BufferAttribute</code>
An instanced version of a buffer attribute.

**Kind**: global class  
**Extends**: <code>BufferAttribute</code>  

* [InstancedBufferAttribute](#InstancedBufferAttribute) ⇐ <code>BufferAttribute</code>
    * [new InstancedBufferAttribute(array, itemSize, [normalized], [meshPerAttribute])](#new_InstancedBufferAttribute_new)
    * [.isInstancedBufferAttribute](#InstancedBufferAttribute+isInstancedBufferAttribute) : <code>boolean</code>
    * [.meshPerAttribute](#InstancedBufferAttribute+meshPerAttribute) : <code>number</code>

<a name="new_InstancedBufferAttribute_new"></a>

### new InstancedBufferAttribute(array, itemSize, [normalized], [meshPerAttribute])
Constructs a new instanced buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>TypedArray</code> |  | The array holding the attribute data. |
| itemSize | <code>number</code> |  | The item size. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |
| [meshPerAttribute] | <code>number</code> | <code>1</code> | How often a value of this buffer attribute should be repeated. |

<a name="InstancedBufferAttribute+isInstancedBufferAttribute"></a>

### instancedBufferAttribute.isInstancedBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InstancedBufferAttribute</code>](#InstancedBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InstancedBufferAttribute+meshPerAttribute"></a>

### instancedBufferAttribute.meshPerAttribute : <code>number</code>
Defines how often a value of this buffer attribute should be repeated. A
value of one means that each value of the instanced attribute is used for
a single instance. A value of two means that each value is used for two
consecutive instances (and so on).

**Kind**: instance property of [<code>InstancedBufferAttribute</code>](#InstancedBufferAttribute)  
**Default**: <code>1</code>  
<a name="InstancedBufferGeometry"></a>

## InstancedBufferGeometry
An instanced version of a geometry.

**Kind**: global class  

* [InstancedBufferGeometry](#InstancedBufferGeometry)
    * [new InstancedBufferGeometry()](#new_InstancedBufferGeometry_new)
    * [.isInstancedBufferGeometry](#InstancedBufferGeometry+isInstancedBufferGeometry) : <code>boolean</code>
    * [.instanceCount](#InstancedBufferGeometry+instanceCount) : <code>number</code>

<a name="new_InstancedBufferGeometry_new"></a>

### new InstancedBufferGeometry()
Constructs a new instanced buffer geometry.

<a name="InstancedBufferGeometry+isInstancedBufferGeometry"></a>

### instancedBufferGeometry.isInstancedBufferGeometry : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InstancedBufferGeometry</code>](#InstancedBufferGeometry)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InstancedBufferGeometry+instanceCount"></a>

### instancedBufferGeometry.instanceCount : <code>number</code>
The instance count.

**Kind**: instance property of [<code>InstancedBufferGeometry</code>](#InstancedBufferGeometry)  
**Default**: <code>Infinity</code>  
<a name="InstancedInterleavedBuffer"></a>

## InstancedInterleavedBuffer ⇐ <code>InterleavedBuffer</code>
An instanced version of an interleaved buffer.

**Kind**: global class  
**Extends**: <code>InterleavedBuffer</code>  

* [InstancedInterleavedBuffer](#InstancedInterleavedBuffer) ⇐ <code>InterleavedBuffer</code>
    * [new InstancedInterleavedBuffer(array, stride, [meshPerAttribute])](#new_InstancedInterleavedBuffer_new)
    * [.isInstancedInterleavedBuffer](#InstancedInterleavedBuffer+isInstancedInterleavedBuffer) : <code>boolean</code>
    * [.meshPerAttribute](#InstancedInterleavedBuffer+meshPerAttribute) : <code>number</code>

<a name="new_InstancedInterleavedBuffer_new"></a>

### new InstancedInterleavedBuffer(array, stride, [meshPerAttribute])
Constructs a new instanced interleaved buffer.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>TypedArray</code> |  | A typed array with a shared buffer storing attribute data. |
| stride | <code>number</code> |  | The number of typed-array elements per vertex. |
| [meshPerAttribute] | <code>number</code> | <code>1</code> | Defines how often a value of this interleaved buffer should be repeated. |

<a name="InstancedInterleavedBuffer+isInstancedInterleavedBuffer"></a>

### instancedInterleavedBuffer.isInstancedInterleavedBuffer : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InstancedInterleavedBuffer</code>](#InstancedInterleavedBuffer)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InstancedInterleavedBuffer+meshPerAttribute"></a>

### instancedInterleavedBuffer.meshPerAttribute : <code>number</code>
Defines how often a value of this buffer attribute should be repeated,
see [InstancedBufferAttribute#meshPerAttribute](InstancedBufferAttribute#meshPerAttribute).

**Kind**: instance property of [<code>InstancedInterleavedBuffer</code>](#InstancedInterleavedBuffer)  
**Default**: <code>1</code>  
<a name="InterleavedBuffer"></a>

## InterleavedBuffer
"Interleaved" means that multiple attributes, possibly of different types,
(e.g., position, normal, uv, color) are packed into a single array buffer.

An introduction into interleaved arrays can be found here: [Interleaved array basics](https://blog.tojicode.com/2011/05/interleaved-array-basics.html)

**Kind**: global class  

* [InterleavedBuffer](#InterleavedBuffer)
    * [new InterleavedBuffer(array, stride)](#new_InterleavedBuffer_new)
    * [.isInterleavedBuffer](#InterleavedBuffer+isInterleavedBuffer) : <code>boolean</code>
    * [.array](#InterleavedBuffer+array) : <code>TypedArray</code>
    * [.stride](#InterleavedBuffer+stride) : <code>number</code>
    * [.count](#InterleavedBuffer+count) : <code>number</code>
    * [.usage](#InterleavedBuffer+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.updateRanges](#InterleavedBuffer+updateRanges) : <code>Array.&lt;Object&gt;</code>
    * [.version](#InterleavedBuffer+version) : <code>number</code>
    * [.uuid](#InterleavedBuffer+uuid) : <code>string</code>
    * [.needsUpdate](#InterleavedBuffer+needsUpdate) : <code>number</code>
    * [.onUploadCallback()](#InterleavedBuffer+onUploadCallback)
    * [.setUsage(value)](#InterleavedBuffer+setUsage) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
    * [.addUpdateRange(start, count)](#InterleavedBuffer+addUpdateRange)
    * [.clearUpdateRanges()](#InterleavedBuffer+clearUpdateRanges)
    * [.copy(source)](#InterleavedBuffer+copy) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
    * [.copyAt(index1, interleavedBuffer, index2)](#InterleavedBuffer+copyAt) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
    * [.set(value, [offset])](#InterleavedBuffer+set) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
    * [.clone([data])](#InterleavedBuffer+clone) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
    * [.onUpload(callback)](#InterleavedBuffer+onUpload) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
    * [.toJSON([data])](#InterleavedBuffer+toJSON) ⇒ <code>Object</code>

<a name="new_InterleavedBuffer_new"></a>

### new InterleavedBuffer(array, stride)
Constructs a new interleaved buffer.


| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> | A typed array with a shared buffer storing attribute data. |
| stride | <code>number</code> | The number of typed-array elements per vertex. |

<a name="InterleavedBuffer+isInterleavedBuffer"></a>

### interleavedBuffer.isInterleavedBuffer : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InterleavedBuffer+array"></a>

### interleavedBuffer.array : <code>TypedArray</code>
A typed array with a shared buffer storing attribute data.

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
<a name="InterleavedBuffer+stride"></a>

### interleavedBuffer.stride : <code>number</code>
The number of typed-array elements per vertex.

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
<a name="InterleavedBuffer+count"></a>

### interleavedBuffer.count : <code>number</code>
The total number of elements in the array

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Read only**: true  
<a name="InterleavedBuffer+usage"></a>

### interleavedBuffer.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
Defines the intended usage pattern of the data store for optimization purposes.

Note: After the initial use of a buffer, its usage cannot be changed. Instead,
instantiate a new one and set the desired usage before the next render.

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Default**: <code>StaticDrawUsage</code>  
<a name="InterleavedBuffer+updateRanges"></a>

### interleavedBuffer.updateRanges : <code>Array.&lt;Object&gt;</code>
This can be used to only update some components of stored vectors (for example, just the
component related to color). Use the `addUpdateRange()` function to add ranges to this array.

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
<a name="InterleavedBuffer+version"></a>

### interleavedBuffer.version : <code>number</code>
A version number, incremented every time the `needsUpdate` is set to `true`.

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
<a name="InterleavedBuffer+uuid"></a>

### interleavedBuffer.uuid : <code>string</code>
The UUID of the interleaved buffer.

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Read only**: true  
<a name="InterleavedBuffer+needsUpdate"></a>

### interleavedBuffer.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="InterleavedBuffer+onUploadCallback"></a>

### interleavedBuffer.onUploadCallback()
A callback function that is executed after the renderer has transferred the attribute array
data to the GPU.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
<a name="InterleavedBuffer+setUsage"></a>

### interleavedBuffer.setUsage(value) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
Sets the usage of this interleaved buffer.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Returns**: [<code>InterleavedBuffer</code>](#InterleavedBuffer) - A reference to this interleaved buffer.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="InterleavedBuffer+addUpdateRange"></a>

### interleavedBuffer.addUpdateRange(start, count)
Adds a range of data in the data array to be updated on the GPU.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>number</code> | Position at which to start update. |
| count | <code>number</code> | The number of components to update. |

<a name="InterleavedBuffer+clearUpdateRanges"></a>

### interleavedBuffer.clearUpdateRanges()
Clears the update ranges.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
<a name="InterleavedBuffer+copy"></a>

### interleavedBuffer.copy(source) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
Copies the values of the given interleaved buffer to this instance.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Returns**: [<code>InterleavedBuffer</code>](#InterleavedBuffer) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>InterleavedBuffer</code>](#InterleavedBuffer) | The interleaved buffer to copy. |

<a name="InterleavedBuffer+copyAt"></a>

### interleavedBuffer.copyAt(index1, interleavedBuffer, index2) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
Copies a vector from the given interleaved buffer to this one. The start
and destination position in the attribute buffers are represented by the
given indices.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Returns**: [<code>InterleavedBuffer</code>](#InterleavedBuffer) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index1 | <code>number</code> | The destination index into this interleaved buffer. |
| interleavedBuffer | [<code>InterleavedBuffer</code>](#InterleavedBuffer) | The interleaved buffer to copy from. |
| index2 | <code>number</code> | The source index into the given interleaved buffer. |

<a name="InterleavedBuffer+set"></a>

### interleavedBuffer.set(value, [offset]) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
Sets the given array data in the interleaved buffer.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Returns**: [<code>InterleavedBuffer</code>](#InterleavedBuffer) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>TypedArray</code> \| <code>Array</code> |  | The array data to set. |
| [offset] | <code>number</code> | <code>0</code> | The offset in this interleaved buffer's array. |

<a name="InterleavedBuffer+clone"></a>

### interleavedBuffer.clone([data]) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
Returns a new interleaved buffer with copied values from this instance.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Returns**: [<code>InterleavedBuffer</code>](#InterleavedBuffer) - A clone of this instance.  

| Param | Type | Description |
| --- | --- | --- |
| [data] | <code>Object</code> | An object with shared array buffers that allows to retain shared structures. |

<a name="InterleavedBuffer+onUpload"></a>

### interleavedBuffer.onUpload(callback) ⇒ [<code>InterleavedBuffer</code>](#InterleavedBuffer)
Sets the given callback function that is executed after the Renderer has transferred
the array data to the GPU. Can be used to perform clean-up operations after
the upload when data are not needed anymore on the CPU side.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Returns**: [<code>InterleavedBuffer</code>](#InterleavedBuffer) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The `onUpload()` callback. |

<a name="InterleavedBuffer+toJSON"></a>

### interleavedBuffer.toJSON([data]) ⇒ <code>Object</code>
Serializes the interleaved buffer into JSON.

**Kind**: instance method of [<code>InterleavedBuffer</code>](#InterleavedBuffer)  
**Returns**: <code>Object</code> - A JSON object representing the serialized interleaved buffer.  

| Param | Type | Description |
| --- | --- | --- |
| [data] | <code>Object</code> | An optional value holding meta information about the serialization. |

<a name="InterleavedBufferAttribute"></a>

## InterleavedBufferAttribute
An alternative version of a buffer attribute with interleaved data. Interleaved
attributes share a common interleaved data storage ([InterleavedBuffer](InterleavedBuffer)) and refer with
different offsets into the buffer.

**Kind**: global class  

* [InterleavedBufferAttribute](#InterleavedBufferAttribute)
    * [new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, [normalized])](#new_InterleavedBufferAttribute_new)
    * [.isInterleavedBufferAttribute](#InterleavedBufferAttribute+isInterleavedBufferAttribute) : <code>boolean</code>
    * [.name](#InterleavedBufferAttribute+name) : <code>string</code>
    * [.data](#InterleavedBufferAttribute+data) : <code>InterleavedBuffer</code>
    * [.itemSize](#InterleavedBufferAttribute+itemSize) : <code>number</code>
    * [.offset](#InterleavedBufferAttribute+offset) : <code>number</code>
    * [.normalized](#InterleavedBufferAttribute+normalized) : <code>InterleavedBuffer</code>
    * [.count](#InterleavedBufferAttribute+count) : <code>number</code>
    * [.array](#InterleavedBufferAttribute+array) : <code>TypedArray</code>
    * [.needsUpdate](#InterleavedBufferAttribute+needsUpdate) : <code>number</code>
    * [.applyMatrix4(m)](#InterleavedBufferAttribute+applyMatrix4) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.applyNormalMatrix(m)](#InterleavedBufferAttribute+applyNormalMatrix) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.transformDirection(m)](#InterleavedBufferAttribute+transformDirection) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.getComponent(index, component)](#InterleavedBufferAttribute+getComponent) ⇒ <code>number</code>
    * [.setComponent(index, component, value)](#InterleavedBufferAttribute+setComponent) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.setX(index, x)](#InterleavedBufferAttribute+setX) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.setY(index, y)](#InterleavedBufferAttribute+setY) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.setZ(index, z)](#InterleavedBufferAttribute+setZ) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.setW(index, w)](#InterleavedBufferAttribute+setW) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.getX(index)](#InterleavedBufferAttribute+getX) ⇒ <code>number</code>
    * [.getY(index)](#InterleavedBufferAttribute+getY) ⇒ <code>number</code>
    * [.getZ(index)](#InterleavedBufferAttribute+getZ) ⇒ <code>number</code>
    * [.getW(index)](#InterleavedBufferAttribute+getW) ⇒ <code>number</code>
    * [.setXY(index, x, y)](#InterleavedBufferAttribute+setXY) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.setXYZ(index, x, y, z)](#InterleavedBufferAttribute+setXYZ) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.setXYZW(index, x, y, z, w)](#InterleavedBufferAttribute+setXYZW) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.clone([data])](#InterleavedBufferAttribute+clone) ⇒ <code>BufferAttribute</code> \| [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
    * [.toJSON([data])](#InterleavedBufferAttribute+toJSON) ⇒ <code>Object</code>

<a name="new_InterleavedBufferAttribute_new"></a>

### new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, [normalized])
Constructs a new interleaved buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| interleavedBuffer | <code>InterleavedBuffer</code> |  | The buffer holding the interleaved data. |
| itemSize | <code>number</code> |  | The item size. |
| offset | <code>number</code> |  | The attribute offset into the buffer. |
| [normalized] | <code>boolean</code> | <code>false</code> | Whether the data are normalized or not. |

<a name="InterleavedBufferAttribute+isInterleavedBufferAttribute"></a>

### interleavedBufferAttribute.isInterleavedBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InterleavedBufferAttribute+name"></a>

### interleavedBufferAttribute.name : <code>string</code>
The name of the buffer attribute.

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
<a name="InterleavedBufferAttribute+data"></a>

### interleavedBufferAttribute.data : <code>InterleavedBuffer</code>
The buffer holding the interleaved data.

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
<a name="InterleavedBufferAttribute+itemSize"></a>

### interleavedBufferAttribute.itemSize : <code>number</code>
The item size, see [BufferAttribute#itemSize](BufferAttribute#itemSize).

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
<a name="InterleavedBufferAttribute+offset"></a>

### interleavedBufferAttribute.offset : <code>number</code>
The attribute offset into the buffer.

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
<a name="InterleavedBufferAttribute+normalized"></a>

### interleavedBufferAttribute.normalized : <code>InterleavedBuffer</code>
Whether the data are normalized or not, see [BufferAttribute#normalized](BufferAttribute#normalized)

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
<a name="InterleavedBufferAttribute+count"></a>

### interleavedBufferAttribute.count : <code>number</code>
The item count of this buffer attribute.

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Read only**: true  
<a name="InterleavedBufferAttribute+array"></a>

### interleavedBufferAttribute.array : <code>TypedArray</code>
The array holding the interleaved buffer attribute data.

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
<a name="InterleavedBufferAttribute+needsUpdate"></a>

### interleavedBufferAttribute.needsUpdate : <code>number</code>
Flag to indicate that this attribute has changed and should be re-sent to
the GPU. Set this to `true` when you modify the value of the array.

**Kind**: instance property of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="InterleavedBufferAttribute+applyMatrix4"></a>

### interleavedBufferAttribute.applyMatrix4(m) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="InterleavedBufferAttribute+applyNormalMatrix"></a>

### interleavedBufferAttribute.applyNormalMatrix(m) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Applies the given 3x3 normal matrix to the given attribute. Only works with
item size `3`.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix to apply. |

<a name="InterleavedBufferAttribute+transformDirection"></a>

### interleavedBufferAttribute.transformDirection(m) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Applies the given 4x4 matrix to the given attribute. Only works with
item size `3` and with direction vectors.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="InterleavedBufferAttribute+getComponent"></a>

### interleavedBufferAttribute.getComponent(index, component) ⇒ <code>number</code>
Returns the given component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: <code>number</code> - The returned value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |

<a name="InterleavedBufferAttribute+setComponent"></a>

### interleavedBufferAttribute.setComponent(index, component, value) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Sets the given value to the given component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| component | <code>number</code> | The component index. |
| value | <code>number</code> | The value to set. |

<a name="InterleavedBufferAttribute+setX"></a>

### interleavedBufferAttribute.setX(index, x) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Sets the x component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value to set. |

<a name="InterleavedBufferAttribute+setY"></a>

### interleavedBufferAttribute.setY(index, y) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Sets the y component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| y | <code>number</code> | The value to set. |

<a name="InterleavedBufferAttribute+setZ"></a>

### interleavedBufferAttribute.setZ(index, z) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Sets the z component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| z | <code>number</code> | The value to set. |

<a name="InterleavedBufferAttribute+setW"></a>

### interleavedBufferAttribute.setW(index, w) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Sets the w component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| w | <code>number</code> | The value to set. |

<a name="InterleavedBufferAttribute+getX"></a>

### interleavedBufferAttribute.getX(index) ⇒ <code>number</code>
Returns the x component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: <code>number</code> - The x component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="InterleavedBufferAttribute+getY"></a>

### interleavedBufferAttribute.getY(index) ⇒ <code>number</code>
Returns the y component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: <code>number</code> - The y component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="InterleavedBufferAttribute+getZ"></a>

### interleavedBufferAttribute.getZ(index) ⇒ <code>number</code>
Returns the z component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: <code>number</code> - The z component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="InterleavedBufferAttribute+getW"></a>

### interleavedBufferAttribute.getW(index) ⇒ <code>number</code>
Returns the w component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: <code>number</code> - The w component.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |

<a name="InterleavedBufferAttribute+setXY"></a>

### interleavedBufferAttribute.setXY(index, x, y) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Sets the x and y component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |

<a name="InterleavedBufferAttribute+setXYZ"></a>

### interleavedBufferAttribute.setXYZ(index, x, y, z) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Sets the x, y and z component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |

<a name="InterleavedBufferAttribute+setXYZW"></a>

### interleavedBufferAttribute.setXYZW(index, x, y, z, w) ⇒ [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Sets the x, y, z and w component of the vector at the given index.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index into the buffer attribute. |
| x | <code>number</code> | The value for the x component to set. |
| y | <code>number</code> | The value for the y component to set. |
| z | <code>number</code> | The value for the z component to set. |
| w | <code>number</code> | The value for the w component to set. |

<a name="InterleavedBufferAttribute+clone"></a>

### interleavedBufferAttribute.clone([data]) ⇒ <code>BufferAttribute</code> \| [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)
Returns a new buffer attribute with copied values from this instance.

If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: <code>BufferAttribute</code> \| [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute) - A clone of this instance.  

| Param | Type | Description |
| --- | --- | --- |
| [data] | <code>Object</code> | An object with interleaved buffers that allows to retain the interleaved property. |

<a name="InterleavedBufferAttribute+toJSON"></a>

### interleavedBufferAttribute.toJSON([data]) ⇒ <code>Object</code>
Serializes the buffer attribute into JSON.

If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.

**Kind**: instance method of [<code>InterleavedBufferAttribute</code>](#InterleavedBufferAttribute)  
**Returns**: <code>Object</code> - A JSON object representing the serialized buffer attribute.  

| Param | Type | Description |
| --- | --- | --- |
| [data] | <code>Object</code> | An optional value holding meta information about the serialization. |

<a name="Layers"></a>

## Layers
A layers object assigns an 3D object to 1 or more of 32
layers numbered `0` to `31` - internally the layers are stored as a
bit mask], and by default all 3D objects are a member of layer `0`.

This can be used to control visibility - an object must share a layer with
a camera to be visible when that camera's view is
rendered.

All classes that inherit from [Object3D](Object3D) have an `layers` property which
is an instance of this class.

**Kind**: global class  

* [Layers](#Layers)
    * [new Layers()](#new_Layers_new)
    * [.mask](#Layers+mask) : <code>number</code>
    * [.set(layer)](#Layers+set)
    * [.enable(layer)](#Layers+enable)
    * [.enableAll()](#Layers+enableAll)
    * [.toggle(layer)](#Layers+toggle)
    * [.disable(layer)](#Layers+disable)
    * [.disableAll()](#Layers+disableAll)
    * [.test(layers)](#Layers+test) ⇒ <code>boolean</code>
    * [.isEnabled(layer)](#Layers+isEnabled) ⇒ <code>boolean</code>

<a name="new_Layers_new"></a>

### new Layers()
Constructs a new layers instance, with membership
initially set to layer `0`.

<a name="Layers+mask"></a>

### layers.mask : <code>number</code>
A bit mask storing which of the 32 layers this layers object is currently
a member of.

**Kind**: instance property of [<code>Layers</code>](#Layers)  
<a name="Layers+set"></a>

### layers.set(layer)
Sets membership to the given layer, and remove membership all other layers.

**Kind**: instance method of [<code>Layers</code>](#Layers)  

| Param | Type | Description |
| --- | --- | --- |
| layer | <code>number</code> | The layer to set. |

<a name="Layers+enable"></a>

### layers.enable(layer)
Adds membership of the given layer.

**Kind**: instance method of [<code>Layers</code>](#Layers)  

| Param | Type | Description |
| --- | --- | --- |
| layer | <code>number</code> | The layer to enable. |

<a name="Layers+enableAll"></a>

### layers.enableAll()
Adds membership to all layers.

**Kind**: instance method of [<code>Layers</code>](#Layers)  
<a name="Layers+toggle"></a>

### layers.toggle(layer)
Toggles the membership of the given layer.

**Kind**: instance method of [<code>Layers</code>](#Layers)  

| Param | Type | Description |
| --- | --- | --- |
| layer | <code>number</code> | The layer to toggle. |

<a name="Layers+disable"></a>

### layers.disable(layer)
Removes membership of the given layer.

**Kind**: instance method of [<code>Layers</code>](#Layers)  

| Param | Type | Description |
| --- | --- | --- |
| layer | <code>number</code> | The layer to enable. |

<a name="Layers+disableAll"></a>

### layers.disableAll()
Removes the membership from all layers.

**Kind**: instance method of [<code>Layers</code>](#Layers)  
<a name="Layers+test"></a>

### layers.test(layers) ⇒ <code>boolean</code>
Returns `true` if this and the given layers object have at least one
layer in common.

**Kind**: instance method of [<code>Layers</code>](#Layers)  
**Returns**: <code>boolean</code> - Whether this and the given layers object have at least one layer in common or not.  

| Param | Type | Description |
| --- | --- | --- |
| layers | [<code>Layers</code>](#Layers) | The layers to test. |

<a name="Layers+isEnabled"></a>

### layers.isEnabled(layer) ⇒ <code>boolean</code>
Returns `true` if the given layer is enabled.

**Kind**: instance method of [<code>Layers</code>](#Layers)  
**Returns**: <code>boolean</code> - Whether the given layer is enabled or not.  

| Param | Type | Description |
| --- | --- | --- |
| layer | <code>number</code> | The layer to test. |

<a name="Object3D"></a>

## Object3D ⇐ <code>EventDispatcher</code>
This is the base class for most objects in three.js and provides a set of
properties and methods for manipulating objects in 3D space.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [Object3D](#Object3D) ⇐ <code>EventDispatcher</code>
    * [new Object3D()](#new_Object3D_new)
    * _instance_
        * [.isObject3D](#Object3D+isObject3D) : <code>boolean</code>
        * [.id](#Object3D+id) : <code>number</code>
        * [.uuid](#Object3D+uuid) : <code>string</code>
        * [.name](#Object3D+name) : <code>string</code>
        * [.type](#Object3D+type) : <code>string</code>
        * [.parent](#Object3D+parent) : [<code>Object3D</code>](#Object3D)
        * [.children](#Object3D+children) : [<code>Array.&lt;Object3D&gt;</code>](#Object3D)
        * [.up](#Object3D+up) : <code>Vector3</code>
        * [.position](#Object3D+position) : <code>Vector3</code>
        * [.rotation](#Object3D+rotation) : <code>Euler</code>
        * [.quaternion](#Object3D+quaternion) : <code>Quaternion</code>
        * [.scale](#Object3D+scale) : <code>Vector3</code>
        * [.modelViewMatrix](#Object3D+modelViewMatrix) : <code>Matrix4</code>
        * [.normalMatrix](#Object3D+normalMatrix) : <code>Matrix3</code>
        * [.matrix](#Object3D+matrix) : <code>Matrix4</code>
        * [.matrixWorld](#Object3D+matrixWorld) : <code>Matrix4</code>
        * [.matrixAutoUpdate](#Object3D+matrixAutoUpdate) : <code>boolean</code>
        * [.matrixWorldAutoUpdate](#Object3D+matrixWorldAutoUpdate) : <code>boolean</code>
        * [.matrixWorldNeedsUpdate](#Object3D+matrixWorldNeedsUpdate) : <code>boolean</code>
        * [.layers](#Object3D+layers) : <code>Layers</code>
        * [.visible](#Object3D+visible) : <code>boolean</code>
        * [.castShadow](#Object3D+castShadow) : <code>boolean</code>
        * [.receiveShadow](#Object3D+receiveShadow) : <code>boolean</code>
        * [.frustumCulled](#Object3D+frustumCulled) : <code>boolean</code>
        * [.renderOrder](#Object3D+renderOrder) : <code>number</code>
        * [.animations](#Object3D+animations) : <code>Array.&lt;AnimationClip&gt;</code>
        * [.customDepthMaterial](#Object3D+customDepthMaterial) : <code>Material</code> \| <code>undefined</code>
        * [.customDistanceMaterial](#Object3D+customDistanceMaterial) : <code>Material</code> \| <code>undefined</code>
        * [.userData](#Object3D+userData) : <code>Object</code>
        * [.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group)](#Object3D+onBeforeShadow)
        * [.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group)](#Object3D+onAfterShadow)
        * [.onBeforeRender(renderer, object, camera, geometry, material, group)](#Object3D+onBeforeRender)
        * [.onAfterRender(renderer, object, camera, geometry, material, group)](#Object3D+onAfterRender)
        * [.applyMatrix4(matrix)](#Object3D+applyMatrix4)
        * [.applyQuaternion(q)](#Object3D+applyQuaternion) ⇒ [<code>Object3D</code>](#Object3D)
        * [.setRotationFromAxisAngle(axis, angle)](#Object3D+setRotationFromAxisAngle)
        * [.setRotationFromEuler(euler)](#Object3D+setRotationFromEuler)
        * [.setRotationFromMatrix(m)](#Object3D+setRotationFromMatrix)
        * [.setRotationFromQuaternion(q)](#Object3D+setRotationFromQuaternion)
        * [.rotateOnAxis(axis, angle)](#Object3D+rotateOnAxis) ⇒ [<code>Object3D</code>](#Object3D)
        * [.rotateOnWorldAxis(axis, angle)](#Object3D+rotateOnWorldAxis) ⇒ [<code>Object3D</code>](#Object3D)
        * [.rotateX(angle)](#Object3D+rotateX) ⇒ [<code>Object3D</code>](#Object3D)
        * [.rotateY(angle)](#Object3D+rotateY) ⇒ [<code>Object3D</code>](#Object3D)
        * [.rotateZ(angle)](#Object3D+rotateZ) ⇒ [<code>Object3D</code>](#Object3D)
        * [.translateOnAxis(axis, distance)](#Object3D+translateOnAxis) ⇒ [<code>Object3D</code>](#Object3D)
        * [.translateX(distance)](#Object3D+translateX) ⇒ [<code>Object3D</code>](#Object3D)
        * [.translateY(distance)](#Object3D+translateY) ⇒ [<code>Object3D</code>](#Object3D)
        * [.translateZ(distance)](#Object3D+translateZ) ⇒ [<code>Object3D</code>](#Object3D)
        * [.localToWorld(vector)](#Object3D+localToWorld) ⇒ <code>Vector3</code>
        * [.worldToLocal(vector)](#Object3D+worldToLocal) ⇒ <code>Vector3</code>
        * [.lookAt(x, [y], [z])](#Object3D+lookAt)
        * [.add(object)](#Object3D+add) ⇒ [<code>Object3D</code>](#Object3D)
        * [.remove(object)](#Object3D+remove) ⇒ [<code>Object3D</code>](#Object3D)
        * [.removeFromParent()](#Object3D+removeFromParent) ⇒ [<code>Object3D</code>](#Object3D)
        * [.clear()](#Object3D+clear) ⇒ [<code>Object3D</code>](#Object3D)
        * [.attach(object)](#Object3D+attach) ⇒ [<code>Object3D</code>](#Object3D)
        * [.getObjectById(id)](#Object3D+getObjectById) ⇒ [<code>Object3D</code>](#Object3D) \| <code>undefined</code>
        * [.getObjectByName(name)](#Object3D+getObjectByName) ⇒ [<code>Object3D</code>](#Object3D) \| <code>undefined</code>
        * [.getObjectByProperty(name, value)](#Object3D+getObjectByProperty) ⇒ [<code>Object3D</code>](#Object3D) \| <code>undefined</code>
        * [.getObjectsByProperty(name, value, result)](#Object3D+getObjectsByProperty) ⇒ [<code>Array.&lt;Object3D&gt;</code>](#Object3D)
        * [.getWorldPosition(target)](#Object3D+getWorldPosition) ⇒ <code>Vector3</code>
        * [.getWorldQuaternion(target)](#Object3D+getWorldQuaternion) ⇒ <code>Quaternion</code>
        * [.getWorldScale(target)](#Object3D+getWorldScale) ⇒ <code>Vector3</code>
        * [.getWorldDirection(target)](#Object3D+getWorldDirection) ⇒ <code>Vector3</code>
        * *[.raycast(raycaster, intersects)](#Object3D+raycast)*
        * [.traverse(callback)](#Object3D+traverse)
        * [.traverseVisible(callback)](#Object3D+traverseVisible)
        * [.traverseAncestors(callback)](#Object3D+traverseAncestors)
        * [.updateMatrix()](#Object3D+updateMatrix)
        * [.updateMatrixWorld([force])](#Object3D+updateMatrixWorld)
        * [.updateWorldMatrix([updateParents], [updateChildren])](#Object3D+updateWorldMatrix)
        * [.toJSON(meta)](#Object3D+toJSON) ⇒ <code>Object</code>
        * [.clone([recursive])](#Object3D+clone) ⇒ [<code>Object3D</code>](#Object3D)
        * [.copy(source, [recursive])](#Object3D+copy) ⇒ [<code>Object3D</code>](#Object3D)
        * ["added"](#Object3D+event_added)
        * ["removed"](#Object3D+event_removed)
        * ["childadded"](#Object3D+event_childadded)
        * ["childremoved"](#Object3D+event_childremoved)
    * _static_
        * [.DEFAULT_UP](#Object3D.DEFAULT_UP) : <code>Vector3</code>
        * [.DEFAULT_MATRIX_AUTO_UPDATE](#Object3D.DEFAULT_MATRIX_AUTO_UPDATE) : <code>boolean</code>
        * [.DEFAULT_MATRIX_WORLD_AUTO_UPDATE](#Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE) : <code>boolean</code>

<a name="new_Object3D_new"></a>

### new Object3D()
Constructs a new 3D object.

<a name="Object3D+isObject3D"></a>

### object3D.isObject3D : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Object3D+id"></a>

### object3D.id : <code>number</code>
The ID of the 3D object.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Read only**: true  
<a name="Object3D+uuid"></a>

### object3D.uuid : <code>string</code>
The UUID of the 3D object.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Read only**: true  
<a name="Object3D+name"></a>

### object3D.name : <code>string</code>
The name of the 3D object.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+type"></a>

### object3D.type : <code>string</code>
The type property is used for detecting the object type
in context of serialization/deserialization.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Read only**: true  
<a name="Object3D+parent"></a>

### object3D.parent : [<code>Object3D</code>](#Object3D)
A reference to the parent object.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>null</code>  
<a name="Object3D+children"></a>

### object3D.children : [<code>Array.&lt;Object3D&gt;</code>](#Object3D)
An array holding the child 3D objects of this instance.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+up"></a>

### object3D.up : <code>Vector3</code>
Defines the `up` direction of the 3D object which influences
the orientation via methods like [lookAt](#Object3D+lookAt).

The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+position"></a>

### object3D.position : <code>Vector3</code>
Represents the object's local position.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>(0,0,0)</code>  
<a name="Object3D+rotation"></a>

### object3D.rotation : <code>Euler</code>
Represents the object's local rotation as Euler angles, in radians.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>(0,0,0)</code>  
<a name="Object3D+quaternion"></a>

### object3D.quaternion : <code>Quaternion</code>
Represents the object's local rotation as Quaternions.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+scale"></a>

### object3D.scale : <code>Vector3</code>
Represents the object's local scale.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>(1,1,1)</code>  
<a name="Object3D+modelViewMatrix"></a>

### object3D.modelViewMatrix : <code>Matrix4</code>
Represents the object's model-view matrix.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+normalMatrix"></a>

### object3D.normalMatrix : <code>Matrix3</code>
Represents the object's normal matrix.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+matrix"></a>

### object3D.matrix : <code>Matrix4</code>
Represents the object's transformation matrix in local space.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+matrixWorld"></a>

### object3D.matrixWorld : <code>Matrix4</code>
Represents the object's transformation matrix in world space.
If the 3D object has no parent, then it's identical to the local transformation matrix

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+matrixAutoUpdate"></a>

### object3D.matrixAutoUpdate : <code>boolean</code>
When set to `true`, the engine automatically computes the local matrix from position,
rotation and scale every frame.

The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>true</code>  
<a name="Object3D+matrixWorldAutoUpdate"></a>

### object3D.matrixWorldAutoUpdate : <code>boolean</code>
When set to `true`, the engine automatically computes the world matrix from the current local
matrix and the object's transformation hierarchy.

The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>true</code>  
<a name="Object3D+matrixWorldNeedsUpdate"></a>

### object3D.matrixWorldNeedsUpdate : <code>boolean</code>
When set to `true`, it calculates the world matrix in that frame and resets this property
to `false`.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>false</code>  
<a name="Object3D+layers"></a>

### object3D.layers : <code>Layers</code>
The layer membership of the 3D object. The 3D object is only visible if it has
at least one layer in common with the camera in use. This property can also be
used to filter out unwanted objects in ray-intersection tests when using [Raycaster](Raycaster).

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+visible"></a>

### object3D.visible : <code>boolean</code>
When set to `true`, the 3D object gets rendered.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>true</code>  
<a name="Object3D+castShadow"></a>

### object3D.castShadow : <code>boolean</code>
When set to `true`, the 3D object gets rendered into shadow maps.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>false</code>  
<a name="Object3D+receiveShadow"></a>

### object3D.receiveShadow : <code>boolean</code>
When set to `true`, the 3D object is affected by shadows in the scene.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>false</code>  
<a name="Object3D+frustumCulled"></a>

### object3D.frustumCulled : <code>boolean</code>
When set to `true`, the 3D object is honored by view frustum culling.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>true</code>  
<a name="Object3D+renderOrder"></a>

### object3D.renderOrder : <code>number</code>
This value allows the default rendering order of scene graph objects to be
overridden although opaque and transparent objects remain sorted independently.
When this property is set for an instance of [Group](Group),all descendants
objects will be sorted and rendered together. Sorting is from lowest to highest
render order.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>0</code>  
<a name="Object3D+animations"></a>

### object3D.animations : <code>Array.&lt;AnimationClip&gt;</code>
An array holding the animation clips of the 3D object.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+customDepthMaterial"></a>

### object3D.customDepthMaterial : <code>Material</code> \| <code>undefined</code>
Custom depth material to be used when rendering to the depth map. Can only be used
in context of meshes. When shadow-casting with a [DirectionalLight](DirectionalLight) or [SpotLight](SpotLight),
if you are modifying vertex positions in the vertex shader you must specify a custom depth
material for proper shadows.

Only relevant in context of [WebGLRenderer](WebGLRenderer).

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>undefined</code>  
<a name="Object3D+customDistanceMaterial"></a>

### object3D.customDistanceMaterial : <code>Material</code> \| <code>undefined</code>
Same as [customDepthMaterial](#Object3D+customDepthMaterial), but used with [PointLight](PointLight).

Only relevant in context of [WebGLRenderer](WebGLRenderer).

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>undefined</code>  
<a name="Object3D+userData"></a>

### object3D.userData : <code>Object</code>
An object that can be used to store custom data about the 3D object. It
should not hold references to functions as these will not be cloned.

**Kind**: instance property of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+onBeforeShadow"></a>

### object3D.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group)
A callback that is executed immediately before a 3D object is rendered to a shadow map.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> \| <code>WebGLRenderer</code> | The renderer. |
| object | [<code>Object3D</code>](#Object3D) | The 3D object. |
| camera | <code>Camera</code> | The camera that is used to render the scene. |
| shadowCamera | <code>Camera</code> | The shadow camera. |
| geometry | <code>BufferGeometry</code> | The 3D object's geometry. |
| depthMaterial | <code>Material</code> | The depth material. |
| group | <code>Object</code> | The geometry group data. |

<a name="Object3D+onAfterShadow"></a>

### object3D.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group)
A callback that is executed immediately after a 3D object is rendered to a shadow map.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> \| <code>WebGLRenderer</code> | The renderer. |
| object | [<code>Object3D</code>](#Object3D) | The 3D object. |
| camera | <code>Camera</code> | The camera that is used to render the scene. |
| shadowCamera | <code>Camera</code> | The shadow camera. |
| geometry | <code>BufferGeometry</code> | The 3D object's geometry. |
| depthMaterial | <code>Material</code> | The depth material. |
| group | <code>Object</code> | The geometry group data. |

<a name="Object3D+onBeforeRender"></a>

### object3D.onBeforeRender(renderer, object, camera, geometry, material, group)
A callback that is executed immediately before a 3D object is rendered.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> \| <code>WebGLRenderer</code> | The renderer. |
| object | [<code>Object3D</code>](#Object3D) | The 3D object. |
| camera | <code>Camera</code> | The camera that is used to render the scene. |
| geometry | <code>BufferGeometry</code> | The 3D object's geometry. |
| material | <code>Material</code> | The 3D object's material. |
| group | <code>Object</code> | The geometry group data. |

<a name="Object3D+onAfterRender"></a>

### object3D.onAfterRender(renderer, object, camera, geometry, material, group)
A callback that is executed immediately after a 3D object is rendered.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> \| <code>WebGLRenderer</code> | The renderer. |
| object | [<code>Object3D</code>](#Object3D) | The 3D object. |
| camera | <code>Camera</code> | The camera that is used to render the scene. |
| geometry | <code>BufferGeometry</code> | The 3D object's geometry. |
| material | <code>Material</code> | The 3D object's material. |
| group | <code>Object</code> | The geometry group data. |

<a name="Object3D+applyMatrix4"></a>

### object3D.applyMatrix4(matrix)
Applies the given transformation matrix to the object and updates the object's position,
rotation and scale.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |

<a name="Object3D+applyQuaternion"></a>

### object3D.applyQuaternion(q) ⇒ [<code>Object3D</code>](#Object3D)
Applies a rotation represented by given the quaternion to the 3D object.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The quaternion. |

<a name="Object3D+setRotationFromAxisAngle"></a>

### object3D.setRotationFromAxisAngle(axis, angle)
Sets the given rotation represented as an axis/angle couple to the 3D object.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>Vector3</code> | The (normalized) axis vector. |
| angle | <code>number</code> | The angle in radians. |

<a name="Object3D+setRotationFromEuler"></a>

### object3D.setRotationFromEuler(euler)
Sets the given rotation represented as Euler angles to the 3D object.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| euler | <code>Euler</code> | The Euler angles. |

<a name="Object3D+setRotationFromMatrix"></a>

### object3D.setRotationFromMatrix(m)
Sets the given rotation represented as rotation matrix to the 3D object.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | Although a 4x4 matrix is expected, the upper 3x3 portion must be a pure rotation matrix (i.e, unscaled). |

<a name="Object3D+setRotationFromQuaternion"></a>

### object3D.setRotationFromQuaternion(q)
Sets the given rotation represented as a Quaternion to the 3D object.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The Quaternion |

<a name="Object3D+rotateOnAxis"></a>

### object3D.rotateOnAxis(axis, angle) ⇒ [<code>Object3D</code>](#Object3D)
Rotates the 3D object along an axis in local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>Vector3</code> | The (normalized) axis vector. |
| angle | <code>number</code> | The angle in radians. |

<a name="Object3D+rotateOnWorldAxis"></a>

### object3D.rotateOnWorldAxis(axis, angle) ⇒ [<code>Object3D</code>](#Object3D)
Rotates the 3D object along an axis in world space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>Vector3</code> | The (normalized) axis vector. |
| angle | <code>number</code> | The angle in radians. |

<a name="Object3D+rotateX"></a>

### object3D.rotateX(angle) ⇒ [<code>Object3D</code>](#Object3D)
Rotates the 3D object around its X axis in local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| angle | <code>number</code> | The angle in radians. |

<a name="Object3D+rotateY"></a>

### object3D.rotateY(angle) ⇒ [<code>Object3D</code>](#Object3D)
Rotates the 3D object around its Y axis in local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| angle | <code>number</code> | The angle in radians. |

<a name="Object3D+rotateZ"></a>

### object3D.rotateZ(angle) ⇒ [<code>Object3D</code>](#Object3D)
Rotates the 3D object around its Z axis in local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| angle | <code>number</code> | The angle in radians. |

<a name="Object3D+translateOnAxis"></a>

### object3D.translateOnAxis(axis, distance) ⇒ [<code>Object3D</code>](#Object3D)
Translate the 3D object by a distance along the given axis in local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>Vector3</code> | The (normalized) axis vector. |
| distance | <code>number</code> | The distance in world units. |

<a name="Object3D+translateX"></a>

### object3D.translateX(distance) ⇒ [<code>Object3D</code>](#Object3D)
Translate the 3D object by a distance along its X-axis in local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The distance in world units. |

<a name="Object3D+translateY"></a>

### object3D.translateY(distance) ⇒ [<code>Object3D</code>](#Object3D)
Translate the 3D object by a distance along its Y-axis in local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The distance in world units. |

<a name="Object3D+translateZ"></a>

### object3D.translateZ(distance) ⇒ [<code>Object3D</code>](#Object3D)
Translate the 3D object by a distance along its Z-axis in local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The distance in world units. |

<a name="Object3D+localToWorld"></a>

### object3D.localToWorld(vector) ⇒ <code>Vector3</code>
Converts the given vector from this 3D object's local space to world space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: <code>Vector3</code> - The converted vector.  

| Param | Type | Description |
| --- | --- | --- |
| vector | <code>Vector3</code> | The vector to convert. |

<a name="Object3D+worldToLocal"></a>

### object3D.worldToLocal(vector) ⇒ <code>Vector3</code>
Converts the given vector from this 3D object's word space to local space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: <code>Vector3</code> - The converted vector.  

| Param | Type | Description |
| --- | --- | --- |
| vector | <code>Vector3</code> | The vector to convert. |

<a name="Object3D+lookAt"></a>

### object3D.lookAt(x, [y], [z])
Rotates the object to face a point in world space.

This method does not support objects having non-uniformly-scaled parent(s).

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector3</code> | The x coordinate in world space. Alternatively, a vector representing a position in world space |
| [y] | <code>number</code> | The y coordinate in world space. |
| [z] | <code>number</code> | The z coordinate in world space. |

<a name="Object3D+add"></a>

### object3D.add(object) ⇒ [<code>Object3D</code>](#Object3D)
Adds the given 3D object as a child to this 3D object. An arbitrary number of
objects may be added. Any current parent on an object passed in here will be
removed, since an object can have at most one parent.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  
**Emits**: [<code>added</code>](#Object3D+event_added), [<code>childadded</code>](#Object3D+event_childadded)  

| Param | Type | Description |
| --- | --- | --- |
| object | [<code>Object3D</code>](#Object3D) | The 3D object to add. |

<a name="Object3D+remove"></a>

### object3D.remove(object) ⇒ [<code>Object3D</code>](#Object3D)
Removes the given 3D object as child from this 3D object.
An arbitrary number of objects may be removed.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  
**Emits**: [<code>removed</code>](#Object3D+event_removed), [<code>childremoved</code>](#Object3D+event_childremoved)  

| Param | Type | Description |
| --- | --- | --- |
| object | [<code>Object3D</code>](#Object3D) | The 3D object to remove. |

<a name="Object3D+removeFromParent"></a>

### object3D.removeFromParent() ⇒ [<code>Object3D</code>](#Object3D)
Removes this 3D object from its current parent.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  
**Emits**: [<code>removed</code>](#Object3D+event_removed), [<code>childremoved</code>](#Object3D+event_childremoved)  
<a name="Object3D+clear"></a>

### object3D.clear() ⇒ [<code>Object3D</code>](#Object3D)
Removes all child objects.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  
**Emits**: [<code>removed</code>](#Object3D+event_removed), [<code>childremoved</code>](#Object3D+event_childremoved)  
<a name="Object3D+attach"></a>

### object3D.attach(object) ⇒ [<code>Object3D</code>](#Object3D)
Adds the given 3D object as a child of this 3D object, while maintaining the object's world
transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  
**Emits**: [<code>added</code>](#Object3D+event_added), [<code>childadded</code>](#Object3D+event_childadded)  

| Param | Type | Description |
| --- | --- | --- |
| object | [<code>Object3D</code>](#Object3D) | The 3D object to attach. |

<a name="Object3D+getObjectById"></a>

### object3D.getObjectById(id) ⇒ [<code>Object3D</code>](#Object3D) \| <code>undefined</code>
Searches through the 3D object and its children, starting with the 3D object
itself, and returns the first with a matching ID.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) \| <code>undefined</code> - The found 3D object. Returns `undefined` if no 3D object has been found.  

| Param | Type | Description |
| --- | --- | --- |
| id | <code>number</code> | The id. |

<a name="Object3D+getObjectByName"></a>

### object3D.getObjectByName(name) ⇒ [<code>Object3D</code>](#Object3D) \| <code>undefined</code>
Searches through the 3D object and its children, starting with the 3D object
itself, and returns the first with a matching name.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) \| <code>undefined</code> - The found 3D object. Returns `undefined` if no 3D object has been found.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name. |

<a name="Object3D+getObjectByProperty"></a>

### object3D.getObjectByProperty(name, value) ⇒ [<code>Object3D</code>](#Object3D) \| <code>undefined</code>
Searches through the 3D object and its children, starting with the 3D object
itself, and returns the first with a matching property value.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) \| <code>undefined</code> - The found 3D object. Returns `undefined` if no 3D object has been found.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property. |
| value | <code>any</code> | The value. |

<a name="Object3D+getObjectsByProperty"></a>

### object3D.getObjectsByProperty(name, value, result) ⇒ [<code>Array.&lt;Object3D&gt;</code>](#Object3D)
Searches through the 3D object and its children, starting with the 3D object
itself, and returns all 3D objects with a matching property value.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Array.&lt;Object3D&gt;</code>](#Object3D) - The found 3D objects.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property. |
| value | <code>any</code> | The value. |
| result | [<code>Array.&lt;Object3D&gt;</code>](#Object3D) | The method stores the result in this array. |

<a name="Object3D+getWorldPosition"></a>

### object3D.getWorldPosition(target) ⇒ <code>Vector3</code>
Returns a vector representing the position of the 3D object in world space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: <code>Vector3</code> - The 3D object's position in world space.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector the result is stored to. |

<a name="Object3D+getWorldQuaternion"></a>

### object3D.getWorldQuaternion(target) ⇒ <code>Quaternion</code>
Returns a Quaternion representing the position of the 3D object in world space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: <code>Quaternion</code> - The 3D object's rotation in world space.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Quaternion</code> | The target Quaternion the result is stored to. |

<a name="Object3D+getWorldScale"></a>

### object3D.getWorldScale(target) ⇒ <code>Vector3</code>
Returns a vector representing the scale of the 3D object in world space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: <code>Vector3</code> - The 3D object's scale in world space.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector the result is stored to. |

<a name="Object3D+getWorldDirection"></a>

### object3D.getWorldDirection(target) ⇒ <code>Vector3</code>
Returns a vector representing the ("look") direction of the 3D object in world space.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: <code>Vector3</code> - The 3D object's direction in world space.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector the result is stored to. |

<a name="Object3D+raycast"></a>

### *object3D.raycast(raycaster, intersects)*
Abstract method to get intersections between a casted ray and this
3D object. Renderable 3D objects such as [Mesh](Mesh), [Line](Line) or [Points](Points)
implement this method in order to use raycasting.

**Kind**: instance abstract method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | An array holding the result of the method. |

<a name="Object3D+traverse"></a>

### object3D.traverse(callback)
Executes the callback on this 3D object and all descendants.

Note: Modifying the scene graph inside the callback is discouraged.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | A callback function that allows to process the current 3D object. |

<a name="Object3D+traverseVisible"></a>

### object3D.traverseVisible(callback)
Like [traverse](#Object3D+traverse), but the callback will only be executed for visible 3D objects.
Descendants of invisible 3D objects are not traversed.

Note: Modifying the scene graph inside the callback is discouraged.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | A callback function that allows to process the current 3D object. |

<a name="Object3D+traverseAncestors"></a>

### object3D.traverseAncestors(callback)
Like [traverse](#Object3D+traverse), but the callback will only be executed for all ancestors.

Note: Modifying the scene graph inside the callback is discouraged.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | A callback function that allows to process the current 3D object. |

<a name="Object3D+updateMatrix"></a>

### object3D.updateMatrix()
Updates the transformation matrix in local space by computing it from the current
position, rotation and scale values.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
<a name="Object3D+updateMatrixWorld"></a>

### object3D.updateMatrixWorld([force])
Updates the transformation matrix in world space of this 3D objects and its descendants.

To ensure correct results, this method also recomputes the 3D object's transformation matrix in
local space. The computation of the local and world matrix can be controlled with the
[matrixAutoUpdate](#Object3D+matrixAutoUpdate) and [matrixWorldAutoUpdate](#Object3D+matrixWorldAutoUpdate) flags which are both
`true` by default.  Set these flags to `false` if you need more control over the update matrix process.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [matrixWorldAutoUpdate](#Object3D+matrixWorldAutoUpdate) is set to `false`. |

<a name="Object3D+updateWorldMatrix"></a>

### object3D.updateWorldMatrix([updateParents], [updateChildren])
An alternative version of [updateMatrixWorld](#Object3D+updateMatrixWorld) with more control over the
update of ancestor and descendant nodes.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [updateParents] | <code>boolean</code> | <code>false</code> | Whether ancestor nodes should be updated or not. |
| [updateChildren] | <code>boolean</code> | <code>false</code> | Whether descendant nodes should be updated or not. |

<a name="Object3D+toJSON"></a>

### object3D.toJSON(meta) ⇒ <code>Object</code>
Serializes the 3D object into JSON.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: <code>Object</code> - A JSON object representing the serialized 3D object.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Object3D+clone"></a>

### object3D.clone([recursive]) ⇒ [<code>Object3D</code>](#Object3D)
Returns a new 3D object with copied values from this instance.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A clone of this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [recursive] | <code>boolean</code> | <code>true</code> | When set to `true`, descendants of the 3D object are also cloned. |

<a name="Object3D+copy"></a>

### object3D.copy(source, [recursive]) ⇒ [<code>Object3D</code>](#Object3D)
Copies the values of the given 3D object to this instance.

**Kind**: instance method of [<code>Object3D</code>](#Object3D)  
**Returns**: [<code>Object3D</code>](#Object3D) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| source | [<code>Object3D</code>](#Object3D) |  | The 3D object to copy. |
| [recursive] | <code>boolean</code> | <code>true</code> | When set to `true`, descendants of the 3D object are cloned. |

<a name="Object3D+event_added"></a>

### "added"
Fires when the object has been added to its parent object.

**Kind**: event emitted by [<code>Object3D</code>](#Object3D)  
<a name="Object3D+event_removed"></a>

### "removed"
Fires when the object has been removed from its parent object.

**Kind**: event emitted by [<code>Object3D</code>](#Object3D)  
<a name="Object3D+event_childadded"></a>

### "childadded"
Fires when a new child object has been added.

**Kind**: event emitted by [<code>Object3D</code>](#Object3D)  
<a name="Object3D+event_childremoved"></a>

### "childremoved"
Fires when a new child object has been added.

**Kind**: event emitted by [<code>Object3D</code>](#Object3D)  
<a name="Object3D.DEFAULT_UP"></a>

### Object3D.DEFAULT\_UP : <code>Vector3</code>
The default up direction for objects, also used as the default
position for [DirectionalLight](DirectionalLight) and [HemisphereLight](HemisphereLight).

**Kind**: static property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>(0,1,0)</code>  
<a name="Object3D.DEFAULT_MATRIX_AUTO_UPDATE"></a>

### Object3D.DEFAULT\_MATRIX\_AUTO\_UPDATE : <code>boolean</code>
The default setting for [matrixAutoUpdate](#Object3D+matrixAutoUpdate) for
newly created 3D objects.

**Kind**: static property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>true</code>  
<a name="Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE"></a>

### Object3D.DEFAULT\_MATRIX\_WORLD\_AUTO\_UPDATE : <code>boolean</code>
The default setting for [matrixWorldAutoUpdate](#Object3D+matrixWorldAutoUpdate) for
newly created 3D objects.

**Kind**: static property of [<code>Object3D</code>](#Object3D)  
**Default**: <code>true</code>  
<a name="Raycaster"></a>

## Raycaster
This class is designed to assist with raycasting. Raycasting is used for
mouse picking (working out what objects in the 3d space the mouse is over)
amongst other things.

**Kind**: global class  

* [Raycaster](#Raycaster)
    * [new Raycaster(origin, direction, [near], [far])](#new_Raycaster_new)
    * _instance_
        * [.ray](#Raycaster+ray) : <code>Ray</code>
        * [.near](#Raycaster+near) : <code>number</code>
        * [.far](#Raycaster+far) : <code>number</code>
        * [.camera](#Raycaster+camera) : <code>Camera</code>
        * [.layers](#Raycaster+layers) : <code>Layers</code>
        * [.params](#Raycaster+params) : <code>Object</code>
        * [.set(origin, direction)](#Raycaster+set)
        * [.setFromCamera(coords, camera)](#Raycaster+setFromCamera)
        * [.setFromXRController(controller)](#Raycaster+setFromXRController) ⇒ [<code>Raycaster</code>](#Raycaster)
        * [.intersectObject(object, [recursive], [intersects])](#Raycaster+intersectObject) ⇒ [<code>Array.&lt;Intersection&gt;</code>](#Raycaster..Intersection)
        * [.intersectObjects(objects, [recursive], [intersects])](#Raycaster+intersectObjects) ⇒ [<code>Array.&lt;Intersection&gt;</code>](#Raycaster..Intersection)
    * _inner_
        * [~Intersection](#Raycaster..Intersection) : <code>Object</code>

<a name="new_Raycaster_new"></a>

### new Raycaster(origin, direction, [near], [far])
Constructs a new raycaster.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| origin | <code>Vector3</code> |  | The origin vector where the ray casts from. |
| direction | <code>Vector3</code> |  | The (normalized) direction vector that gives direction to the ray. |
| [near] | <code>number</code> | <code>0</code> | All results returned are further away than near. Near can't be negative. |
| [far] | <code>number</code> | <code>Infinity</code> | All results returned are closer than far. Far can't be lower than near. |

<a name="Raycaster+ray"></a>

### raycaster.ray : <code>Ray</code>
The ray used for raycasting.

**Kind**: instance property of [<code>Raycaster</code>](#Raycaster)  
<a name="Raycaster+near"></a>

### raycaster.near : <code>number</code>
All results returned are further away than near. Near can't be negative.

**Kind**: instance property of [<code>Raycaster</code>](#Raycaster)  
**Default**: <code>0</code>  
<a name="Raycaster+far"></a>

### raycaster.far : <code>number</code>
All results returned are further away than near. Near can't be negative.

**Kind**: instance property of [<code>Raycaster</code>](#Raycaster)  
**Default**: <code>Infinity</code>  
<a name="Raycaster+camera"></a>

### raycaster.camera : <code>Camera</code>
The camera to use when raycasting against view-dependent objects such as
billboarded objects like sprites. This field can be set manually or
is set when calling `setFromCamera()`.

**Kind**: instance property of [<code>Raycaster</code>](#Raycaster)  
**Default**: <code>null</code>  
<a name="Raycaster+layers"></a>

### raycaster.layers : <code>Layers</code>
Allows to selectively ignore 3D objects when performing intersection tests.
The following code example ensures that only 3D objects on layer `1` will be
honored by raycaster.
```js
raycaster.layers.set( 1 );
object.layers.enable( 1 );
```

**Kind**: instance property of [<code>Raycaster</code>](#Raycaster)  
<a name="Raycaster+params"></a>

### raycaster.params : <code>Object</code>
A parameter object that configures the raycasting. It has the structure:

```
{
	Mesh: {},
	Line: { threshold: 1 },
	LOD: {},
	Points: { threshold: 1 },
	Sprite: {}
}
```
Where `threshold` is the precision of the raycaster when intersecting objects, in world units.

**Kind**: instance property of [<code>Raycaster</code>](#Raycaster)  
<a name="Raycaster+set"></a>

### raycaster.set(origin, direction)
Updates the ray with a new origin and direction by copying the values from the arguments.

**Kind**: instance method of [<code>Raycaster</code>](#Raycaster)  

| Param | Type | Description |
| --- | --- | --- |
| origin | <code>Vector3</code> | The origin vector where the ray casts from. |
| direction | <code>Vector3</code> | The (normalized) direction vector that gives direction to the ray. |

<a name="Raycaster+setFromCamera"></a>

### raycaster.setFromCamera(coords, camera)
Uses the given coordinates and camera to compute a new origin and direction for the internal ray.

**Kind**: instance method of [<code>Raycaster</code>](#Raycaster)  

| Param | Type | Description |
| --- | --- | --- |
| coords | <code>Vector2</code> | 2D coordinates of the mouse, in normalized device coordinates (NDC). X and Y components should be between `-1` and `1`. |
| camera | <code>Camera</code> | The camera from which the ray should originate. |

<a name="Raycaster+setFromXRController"></a>

### raycaster.setFromXRController(controller) ⇒ [<code>Raycaster</code>](#Raycaster)
Uses the given WebXR controller to compute a new origin and direction for the internal ray.

**Kind**: instance method of [<code>Raycaster</code>](#Raycaster)  
**Returns**: [<code>Raycaster</code>](#Raycaster) - A reference to this raycaster.  

| Param | Type | Description |
| --- | --- | --- |
| controller | <code>WebXRController</code> | The controller to copy the position and direction from. |

<a name="Raycaster+intersectObject"></a>

### raycaster.intersectObject(object, [recursive], [intersects]) ⇒ [<code>Array.&lt;Intersection&gt;</code>](#Raycaster..Intersection)
Checks all intersection between the ray and the object with or without the
descendants. Intersections are returned sorted by distance, closest first.

`Raycaster` delegates to the `raycast()` method of the passed 3D object, when
evaluating whether the ray intersects the object or not. This allows meshes to respond
differently to ray casting than lines or points.

Note that for meshes, faces must be pointed towards the origin of the ray in order
to be detected; intersections of the ray passing through the back of a face will not
be detected. To raycast against both faces of an object, you'll want to set  [Material#side](Material#side)
to `THREE.DoubleSide`.

**Kind**: instance method of [<code>Raycaster</code>](#Raycaster)  
**Returns**: [<code>Array.&lt;Intersection&gt;</code>](#Raycaster..Intersection) - An array holding the intersection points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object to check for intersection with the ray. |
| [recursive] | <code>boolean</code> | <code>true</code> | If set to `true`, it also checks all descendants. Otherwise it only checks intersection with the object. |
| [intersects] | [<code>Array.&lt;Intersection&gt;</code>](#Raycaster..Intersection) | <code>[]</code> | The target array that holds the result of the method. |

<a name="Raycaster+intersectObjects"></a>

### raycaster.intersectObjects(objects, [recursive], [intersects]) ⇒ [<code>Array.&lt;Intersection&gt;</code>](#Raycaster..Intersection)
Checks all intersection between the ray and the objects with or without
the descendants. Intersections are returned sorted by distance, closest first.

**Kind**: instance method of [<code>Raycaster</code>](#Raycaster)  
**Returns**: [<code>Array.&lt;Intersection&gt;</code>](#Raycaster..Intersection) - An array holding the intersection points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| objects | <code>Array.&lt;Object3D&gt;</code> |  | The 3D objects to check for intersection with the ray. |
| [recursive] | <code>boolean</code> | <code>true</code> | If set to `true`, it also checks all descendants. Otherwise it only checks intersection with the object. |
| [intersects] | [<code>Array.&lt;Intersection&gt;</code>](#Raycaster..Intersection) | <code>[]</code> | The target array that holds the result of the method. |

<a name="Raycaster..Intersection"></a>

### Raycaster~Intersection : <code>Object</code>
The intersection point of a raycaster intersection test.

**Kind**: inner typedef of [<code>Raycaster</code>](#Raycaster)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The distance from the ray's origin to the intersection point. |
| distanceToRay | <code>number</code> | Some 3D objects e.g. [Points](Points) provide the distance of the intersection to the nearest point on the ray. For other objects it will be `undefined`. |
| point | <code>Vector3</code> | The intersection point, in world coordinates. |
| face | <code>Object</code> | The face that has been intersected. |
| faceIndex | <code>number</code> | The face index. |
| object | <code>Object3D</code> | The 3D object that has been intersected. |
| uv | <code>Vector2</code> | U,V coordinates at point of intersection. |
| uv1 | <code>Vector2</code> | Second set of U,V coordinates at point of intersection. |
| uv1 | <code>Vector3</code> | Interpolated normal vector at point of intersection. |
| instanceId | <code>number</code> | The index number of the instance where the ray intersects the [InstancedMesh](InstancedMesh). |

<a name="RenderTarget"></a>

## RenderTarget ⇐ <code>EventDispatcher</code>
A render target is a buffer where the video card draws pixels for a scene
that is being rendered in the background. It is used in different effects,
such as applying postprocessing to a rendered image before displaying it
on the screen.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [RenderTarget](#RenderTarget) ⇐ <code>EventDispatcher</code>
    * [new RenderTarget([width], [height], [options])](#new_RenderTarget_new)
    * _instance_
        * [.isRenderTarget](#RenderTarget+isRenderTarget) : <code>boolean</code>
        * [.width](#RenderTarget+width) : <code>number</code>
        * [.height](#RenderTarget+height) : <code>number</code>
        * [.depth](#RenderTarget+depth) : <code>number</code>
        * [.scissor](#RenderTarget+scissor) : <code>Vector4</code>
        * [.scissorTest](#RenderTarget+scissorTest) : <code>boolean</code>
        * [.viewport](#RenderTarget+viewport) : <code>Vector4</code>
        * [.textures](#RenderTarget+textures) : <code>Array.&lt;Texture&gt;</code>
        * [.depthBuffer](#RenderTarget+depthBuffer) : <code>boolean</code>
        * [.stencilBuffer](#RenderTarget+stencilBuffer) : <code>boolean</code>
        * [.resolveDepthBuffer](#RenderTarget+resolveDepthBuffer) : <code>boolean</code>
        * [.resolveStencilBuffer](#RenderTarget+resolveStencilBuffer) : <code>boolean</code>
        * [.samples](#RenderTarget+samples) : <code>number</code>
        * [.texture](#RenderTarget+texture) : <code>Texture</code>
        * [.depthTexture](#RenderTarget+depthTexture) : <code>DepthTexture</code>
        * [.setSize(width, height, [depth])](#RenderTarget+setSize)
        * [.clone()](#RenderTarget+clone) ⇒ [<code>RenderTarget</code>](#RenderTarget)
        * [.copy(source)](#RenderTarget+copy) ⇒ [<code>RenderTarget</code>](#RenderTarget)
        * [.dispose()](#RenderTarget+dispose)
    * _inner_
        * [~Options](#RenderTarget..Options) : <code>Object</code>

<a name="new_RenderTarget_new"></a>

### new RenderTarget([width], [height], [options])
Constructs a new render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | [<code>Options</code>](#RenderTarget..Options) |  | The configuration object. |

<a name="RenderTarget+isRenderTarget"></a>

### renderTarget.isRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="RenderTarget+width"></a>

### renderTarget.width : <code>number</code>
The width of the render target.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>1</code>  
<a name="RenderTarget+height"></a>

### renderTarget.height : <code>number</code>
The height of the render target.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>1</code>  
<a name="RenderTarget+depth"></a>

### renderTarget.depth : <code>number</code>
The depth of the render target.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>1</code>  
<a name="RenderTarget+scissor"></a>

### renderTarget.scissor : <code>Vector4</code>
A rectangular area inside the render target's viewport. Fragments that are
outside the area will be discarded.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>(0,0,width,height)</code>  
<a name="RenderTarget+scissorTest"></a>

### renderTarget.scissorTest : <code>boolean</code>
Indicates whether the scissor test should be enabled when rendering into
this render target or not.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>false</code>  
<a name="RenderTarget+viewport"></a>

### renderTarget.viewport : <code>Vector4</code>
A rectangular area representing the render target's viewport.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>(0,0,width,height)</code>  
<a name="RenderTarget+textures"></a>

### renderTarget.textures : <code>Array.&lt;Texture&gt;</code>
An array of textures. Each color attachment is represented as a separate texture.
Has at least a single entry for the default color attachment.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
<a name="RenderTarget+depthBuffer"></a>

### renderTarget.depthBuffer : <code>boolean</code>
Whether to allocate a depth buffer or not.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>true</code>  
<a name="RenderTarget+stencilBuffer"></a>

### renderTarget.stencilBuffer : <code>boolean</code>
Whether to allocate a stencil buffer or not.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>false</code>  
<a name="RenderTarget+resolveDepthBuffer"></a>

### renderTarget.resolveDepthBuffer : <code>boolean</code>
Whether to resolve the depth buffer or not.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>true</code>  
<a name="RenderTarget+resolveStencilBuffer"></a>

### renderTarget.resolveStencilBuffer : <code>boolean</code>
Whether to resolve the stencil buffer or not.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>true</code>  
<a name="RenderTarget+samples"></a>

### renderTarget.samples : <code>number</code>
The number of MSAA samples.

A value of `0` disables MSAA.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>0</code>  
<a name="RenderTarget+texture"></a>

### renderTarget.texture : <code>Texture</code>
The texture representing the default color attachment.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
<a name="RenderTarget+depthTexture"></a>

### renderTarget.depthTexture : <code>DepthTexture</code>
Instead of saving the depth in a renderbuffer, a texture
can be used instead which is useful for further processing
e.g. in context of post-processing.

**Kind**: instance property of [<code>RenderTarget</code>](#RenderTarget)  
**Default**: <code>null</code>  
<a name="RenderTarget+setSize"></a>

### renderTarget.setSize(width, height, [depth])
Sets the size of this render target.

**Kind**: instance method of [<code>RenderTarget</code>](#RenderTarget)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| width | <code>number</code> |  | The width. |
| height | <code>number</code> |  | The height. |
| [depth] | <code>number</code> | <code>1</code> | The depth. |

<a name="RenderTarget+clone"></a>

### renderTarget.clone() ⇒ [<code>RenderTarget</code>](#RenderTarget)
Returns a new render target with copied values from this instance.

**Kind**: instance method of [<code>RenderTarget</code>](#RenderTarget)  
**Returns**: [<code>RenderTarget</code>](#RenderTarget) - A clone of this instance.  
<a name="RenderTarget+copy"></a>

### renderTarget.copy(source) ⇒ [<code>RenderTarget</code>](#RenderTarget)
Copies the settings of the given render target. This is a structural copy so
no resources are shared between render targets after the copy. That includes
all MRT textures and the depth texture.

**Kind**: instance method of [<code>RenderTarget</code>](#RenderTarget)  
**Returns**: [<code>RenderTarget</code>](#RenderTarget) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>RenderTarget</code>](#RenderTarget) | The render target to copy. |

<a name="RenderTarget+dispose"></a>

### renderTarget.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>RenderTarget</code>](#RenderTarget)  
**Emits**: <code>RenderTarget#event:dispose</code>  
<a name="RenderTarget..Options"></a>

### RenderTarget~Options : <code>Object</code>
Render target options.

**Kind**: inner typedef of [<code>RenderTarget</code>](#RenderTarget)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [generateMipmaps] | <code>boolean</code> | <code>false</code> | Whether to generate mipmaps or not. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter. |
| [minFilter] | <code>number</code> | <code>LinearFilter</code> | The min filter. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [internalFormat] | <code>string</code> | <code>null</code> | The texture's internal format. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The texture's uv wrapping mode. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The texture's uv wrapping mode. |
| [anisotropy] | <code>number</code> | <code>1</code> | The texture's anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The texture's color space. |
| [depthBuffer] | <code>boolean</code> | <code>true</code> | Whether to allocate a depth buffer or not. |
| [stencilBuffer] | <code>boolean</code> | <code>false</code> | Whether to allocate a stencil buffer or not. |
| [resolveDepthBuffer] | <code>boolean</code> | <code>true</code> | Whether to resolve the depth buffer or not. |
| [resolveStencilBuffer] | <code>boolean</code> | <code>true</code> | Whether  to resolve the stencil buffer or not. |
| [depthTexture] | <code>Texture</code> | <code></code> | Reference to a depth texture. |
| [samples] | <code>number</code> | <code>0</code> | The MSAA samples count. |
| [count] | <code>number</code> | <code>1</code> | Defines the number of color attachments . Must be at least `1`. |

<a name="RenderTarget3D"></a>

## RenderTarget3D ⇐ <code>RenderTarget</code>
Represents a 3D render target.

**Kind**: global class  
**Extends**: <code>RenderTarget</code>  

* [RenderTarget3D](#RenderTarget3D) ⇐ <code>RenderTarget</code>
    * [new RenderTarget3D([width], [height], [depth], [options])](#new_RenderTarget3D_new)
    * [.isRenderTarget3D](#RenderTarget3D+isRenderTarget3D) : <code>boolean</code>
    * [.texture](#RenderTarget3D+texture) : <code>Data3DTexture</code>

<a name="new_RenderTarget3D_new"></a>

### new RenderTarget3D([width], [height], [depth], [options])
Constructs a new 3D render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [depth] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="RenderTarget3D+isRenderTarget3D"></a>

### renderTarget3D.isRenderTarget3D : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>RenderTarget3D</code>](#RenderTarget3D)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="RenderTarget3D+texture"></a>

### renderTarget3D.texture : <code>Data3DTexture</code>
Overwritten with a different texture type.

**Kind**: instance property of [<code>RenderTarget3D</code>](#RenderTarget3D)  
<a name="RenderTargetArray"></a>

## RenderTargetArray ⇐ <code>RenderTarget</code>
Represents an array render target.

**Kind**: global class  
**Extends**: <code>RenderTarget</code>  

* [RenderTargetArray](#RenderTargetArray) ⇐ <code>RenderTarget</code>
    * [new RenderTargetArray([width], [height], [depth], [options])](#new_RenderTargetArray_new)
    * [.texture](#RenderTargetArray+texture) : <code>DataArrayTexture</code>

<a name="new_RenderTargetArray_new"></a>

### new RenderTargetArray([width], [height], [depth], [options])
Constructs a new 3D render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [depth] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="RenderTargetArray+texture"></a>

### renderTargetArray.texture : <code>DataArrayTexture</code>
Overwritten with a different texture type.

**Kind**: instance property of [<code>RenderTargetArray</code>](#RenderTargetArray)  
<a name="Uniform"></a>

## Uniform
Represents a uniform which is a global shader variable. They are passed to shader programs.

When declaring a uniform of a [ShaderMaterial](ShaderMaterial), it is declared by value or by object.
```js
uniforms: {
	time: { value: 1.0 },
	resolution: new Uniform( new Vector2() )
};
```
Since this class can only be used in context of [ShaderMaterial](ShaderMaterial), it is only supported
in [WebGLRenderer](WebGLRenderer).

**Kind**: global class  

* [Uniform](#Uniform)
    * [new Uniform(value)](#new_Uniform_new)
    * [.value](#Uniform+value) : <code>any</code>
    * [.clone()](#Uniform+clone) ⇒ [<code>Uniform</code>](#Uniform)

<a name="new_Uniform_new"></a>

### new Uniform(value)
Constructs a new uniform.


| Param | Type | Description |
| --- | --- | --- |
| value | <code>any</code> | The uniform value. |

<a name="Uniform+value"></a>

### uniform.value : <code>any</code>
The uniform value.

**Kind**: instance property of [<code>Uniform</code>](#Uniform)  
<a name="Uniform+clone"></a>

### uniform.clone() ⇒ [<code>Uniform</code>](#Uniform)
Returns a new uniform with copied values from this instance.
If the value has a `clone()` method, the value is cloned as well.

**Kind**: instance method of [<code>Uniform</code>](#Uniform)  
**Returns**: [<code>Uniform</code>](#Uniform) - A clone of this instance.  
<a name="UniformsGroup"></a>

## UniformsGroup ⇐ <code>EventDispatcher</code>
A class for managing multiple uniforms in a single group. The renderer will process
such a definition as a single UBO.

Since this class can only be used in context of [ShaderMaterial](ShaderMaterial), it is only supported
in [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [UniformsGroup](#UniformsGroup) ⇐ <code>EventDispatcher</code>
    * [new UniformsGroup()](#new_UniformsGroup_new)
    * [.isUniformsGroup](#UniformsGroup+isUniformsGroup) : <code>boolean</code>
    * [.id](#UniformsGroup+id) : <code>number</code>
    * [.name](#UniformsGroup+name) : <code>string</code>
    * [.usage](#UniformsGroup+usage) : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
    * [.uniforms](#UniformsGroup+uniforms) : <code>Array.&lt;Uniform&gt;</code>
    * [.add(uniform)](#UniformsGroup+add) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
    * [.remove(uniform)](#UniformsGroup+remove) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
    * [.setName(name)](#UniformsGroup+setName) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
    * [.setUsage(value)](#UniformsGroup+setUsage) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
    * [.dispose()](#UniformsGroup+dispose)
    * [.copy(source)](#UniformsGroup+copy) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
    * [.clone()](#UniformsGroup+clone) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)

<a name="new_UniformsGroup_new"></a>

### new UniformsGroup()
Constructs a new uniforms group.

<a name="UniformsGroup+isUniformsGroup"></a>

### uniformsGroup.isUniformsGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformsGroup</code>](#UniformsGroup)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="UniformsGroup+id"></a>

### uniformsGroup.id : <code>number</code>
The ID of the 3D object.

**Kind**: instance property of [<code>UniformsGroup</code>](#UniformsGroup)  
**Read only**: true  
<a name="UniformsGroup+name"></a>

### uniformsGroup.name : <code>string</code>
The name of the uniforms group.

**Kind**: instance property of [<code>UniformsGroup</code>](#UniformsGroup)  
<a name="UniformsGroup+usage"></a>

### uniformsGroup.usage : <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code>
The buffer usage.

**Kind**: instance property of [<code>UniformsGroup</code>](#UniformsGroup)  
**Default**: <code>StaticDrawUsage</code>  
<a name="UniformsGroup+uniforms"></a>

### uniformsGroup.uniforms : <code>Array.&lt;Uniform&gt;</code>
An array holding the uniforms.

**Kind**: instance property of [<code>UniformsGroup</code>](#UniformsGroup)  
<a name="UniformsGroup+add"></a>

### uniformsGroup.add(uniform) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
Adds the given uniform to this uniforms group.

**Kind**: instance method of [<code>UniformsGroup</code>](#UniformsGroup)  
**Returns**: [<code>UniformsGroup</code>](#UniformsGroup) - A reference to this uniforms group.  

| Param | Type | Description |
| --- | --- | --- |
| uniform | <code>Uniform</code> | The uniform to add. |

<a name="UniformsGroup+remove"></a>

### uniformsGroup.remove(uniform) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
Removes the given uniform from this uniforms group.

**Kind**: instance method of [<code>UniformsGroup</code>](#UniformsGroup)  
**Returns**: [<code>UniformsGroup</code>](#UniformsGroup) - A reference to this uniforms group.  

| Param | Type | Description |
| --- | --- | --- |
| uniform | <code>Uniform</code> | The uniform to remove. |

<a name="UniformsGroup+setName"></a>

### uniformsGroup.setName(name) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
Sets the name of this uniforms group.

**Kind**: instance method of [<code>UniformsGroup</code>](#UniformsGroup)  
**Returns**: [<code>UniformsGroup</code>](#UniformsGroup) - A reference to this uniforms group.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name to set. |

<a name="UniformsGroup+setUsage"></a>

### uniformsGroup.setUsage(value) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
Sets the usage of this uniforms group.

**Kind**: instance method of [<code>UniformsGroup</code>](#UniformsGroup)  
**Returns**: [<code>UniformsGroup</code>](#UniformsGroup) - A reference to this uniforms group.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StaticDrawUsage</code> \| <code>DynamicDrawUsage</code> \| <code>StreamDrawUsage</code> \| <code>StaticReadUsage</code> \| <code>DynamicReadUsage</code> \| <code>StreamReadUsage</code> \| <code>StaticCopyUsage</code> \| <code>DynamicCopyUsage</code> \| <code>StreamCopyUsage</code> | The usage to set. |

<a name="UniformsGroup+dispose"></a>

### uniformsGroup.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>UniformsGroup</code>](#UniformsGroup)  
**Emits**: <code>Texture#event:dispose</code>  
<a name="UniformsGroup+copy"></a>

### uniformsGroup.copy(source) ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
Copies the values of the given uniforms group to this instance.

**Kind**: instance method of [<code>UniformsGroup</code>](#UniformsGroup)  
**Returns**: [<code>UniformsGroup</code>](#UniformsGroup) - A reference to this uniforms group.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>UniformsGroup</code>](#UniformsGroup) | The uniforms group to copy. |

<a name="UniformsGroup+clone"></a>

### uniformsGroup.clone() ⇒ [<code>UniformsGroup</code>](#UniformsGroup)
Returns a new uniforms group with copied values from this instance.

**Kind**: instance method of [<code>UniformsGroup</code>](#UniformsGroup)  
**Returns**: [<code>UniformsGroup</code>](#UniformsGroup) - A clone of this instance.  
<a name="Controls"></a>

## *Controls ⇐ <code>EventDispatcher</code>*
Abstract base class for controls.

**Kind**: global abstract class  
**Extends**: <code>EventDispatcher</code>  

* *[Controls](#Controls) ⇐ <code>EventDispatcher</code>*
    * *[new Controls(object, domElement)](#new_Controls_new)*
    * *[.object](#Controls+object) : <code>Object3D</code>*
    * *[.domElement](#Controls+domElement) : <code>HTMLDOMElement</code>*
    * *[.enabled](#Controls+enabled) : <code>boolean</code>*
    * *[.state](#Controls+state) : <code>number</code>*
    * *[.keys](#Controls+keys) : <code>Object</code>*
    * *[.mouseButtons](#Controls+mouseButtons) : <code>Object</code>*
    * *[.touches](#Controls+touches) : <code>Object</code>*
    * *[.connect(element)](#Controls+connect)*
    * *[.disconnect()](#Controls+disconnect)*
    * *[.dispose()](#Controls+dispose)*
    * *[.update([delta])](#Controls+update)*

<a name="new_Controls_new"></a>

### *new Controls(object, domElement)*
Constructs a new controls instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The object that is managed by the controls. |
| domElement | <code>HTMLDOMElement</code> | <code></code> | The HTML element used for event listeners. |

<a name="Controls+object"></a>

### *controls.object : <code>Object3D</code>*
The object that is managed by the controls.

**Kind**: instance property of [<code>Controls</code>](#Controls)  
<a name="Controls+domElement"></a>

### *controls.domElement : <code>HTMLDOMElement</code>*
The HTML element used for event listeners.

**Kind**: instance property of [<code>Controls</code>](#Controls)  
**Default**: <code>null</code>  
<a name="Controls+enabled"></a>

### *controls.enabled : <code>boolean</code>*
Whether the controls responds to user input or not.

**Kind**: instance property of [<code>Controls</code>](#Controls)  
**Default**: <code>true</code>  
<a name="Controls+state"></a>

### *controls.state : <code>number</code>*
The internal state of the controls.

**Kind**: instance property of [<code>Controls</code>](#Controls)  
**Default**: <code>-1</code>  
<a name="Controls+keys"></a>

### *controls.keys : <code>Object</code>*
This object defines the keyboard input of the controls.

**Kind**: instance property of [<code>Controls</code>](#Controls)  
<a name="Controls+mouseButtons"></a>

### *controls.mouseButtons : <code>Object</code>*
This object defines what type of actions are assigned to the available mouse buttons.
It depends on the control implementation what kind of mouse buttons and actions are supported.

**Kind**: instance property of [<code>Controls</code>](#Controls)  
<a name="Controls+touches"></a>

### *controls.touches : <code>Object</code>*
This object defines what type of actions are assigned to what kind of touch interaction.
It depends on the control implementation what kind of touch interaction and actions are supported.

**Kind**: instance property of [<code>Controls</code>](#Controls)  
<a name="Controls+connect"></a>

### *controls.connect(element)*
Connects the controls to the DOM. This method has so called "side effects" since
it adds the module's event listeners to the DOM.

**Kind**: instance method of [<code>Controls</code>](#Controls)  

| Param | Type | Description |
| --- | --- | --- |
| element | <code>HTMLDOMElement</code> | The DOM element to connect to. |

<a name="Controls+disconnect"></a>

### *controls.disconnect()*
Disconnects the controls from the DOM.

**Kind**: instance method of [<code>Controls</code>](#Controls)  
<a name="Controls+dispose"></a>

### *controls.dispose()*
Call this method if you no longer want use to the controls. It frees all internal
resources and removes all event listeners.

**Kind**: instance method of [<code>Controls</code>](#Controls)  
<a name="Controls+update"></a>

### *controls.update([delta])*
Controls should implement this method if they have to update their internal state
per simulation step.

**Kind**: instance method of [<code>Controls</code>](#Controls)  

| Param | Type | Description |
| --- | --- | --- |
| [delta] | <code>number</code> | The time delta in seconds. |

## Classes

<dl>
<dt><a href="#DataUtils">DataUtils</a></dt>
<dd><p>A class containing utility functions for data.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#toHalfFloat">toHalfFloat(val)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a half precision floating point value (FP16) from the given single
precision floating point value (FP32).</p>
</dd>
<dt><a href="#fromHalfFloat">fromHalfFloat(val)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a single precision floating point value (FP32) from the given half
precision floating point value (FP16).</p>
</dd>
</dl>

<a name="DataUtils"></a>

## DataUtils
A class containing utility functions for data.

**Kind**: global class  

* [DataUtils](#DataUtils)
    * [.toHalfFloat(val)](#DataUtils.toHalfFloat) ⇒ <code>number</code>
    * [.fromHalfFloat(val)](#DataUtils.fromHalfFloat) ⇒ <code>number</code>

<a name="DataUtils.toHalfFloat"></a>

### DataUtils.toHalfFloat(val) ⇒ <code>number</code>
Returns a half precision floating point value (FP16) from the given single
precision floating point value (FP32).

**Kind**: static method of [<code>DataUtils</code>](#DataUtils)  
**Returns**: <code>number</code> - The FP16 value.  

| Param | Type | Description |
| --- | --- | --- |
| val | <code>number</code> | A single precision floating point value. |

<a name="DataUtils.fromHalfFloat"></a>

### DataUtils.fromHalfFloat(val) ⇒ <code>number</code>
Returns a single precision floating point value (FP32) from the given half
precision floating point value (FP16).

**Kind**: static method of [<code>DataUtils</code>](#DataUtils)  
**Returns**: <code>number</code> - The FP32 value.  

| Param | Type | Description |
| --- | --- | --- |
| val | <code>number</code> | A half precision floating point value. |

<a name="toHalfFloat"></a>

## toHalfFloat(val) ⇒ <code>number</code>
Returns a half precision floating point value (FP16) from the given single
precision floating point value (FP32).

**Kind**: global function  
**Returns**: <code>number</code> - The FP16 value.  

| Param | Type | Description |
| --- | --- | --- |
| val | <code>number</code> | A single precision floating point value. |

<a name="fromHalfFloat"></a>

## fromHalfFloat(val) ⇒ <code>number</code>
Returns a single precision floating point value (FP32) from the given half
precision floating point value (FP16).

**Kind**: global function  
**Returns**: <code>number</code> - The FP32 value.  

| Param | Type | Description |
| --- | --- | --- |
| val | <code>number</code> | A half precision floating point value. |

<a name="ImageUtils"></a>

## ImageUtils
A class containing utility functions for images.

**Kind**: global class  

* [ImageUtils](#ImageUtils)
    * [.getDataURL(image, [type])](#ImageUtils.getDataURL) ⇒ <code>string</code>
    * [.sRGBToLinear(image)](#ImageUtils.sRGBToLinear) ⇒ <code>HTMLCanvasElement</code> \| <code>Object</code>

<a name="ImageUtils.getDataURL"></a>

### ImageUtils.getDataURL(image, [type]) ⇒ <code>string</code>
Returns a data URI containing a representation of the given image.

**Kind**: static method of [<code>ImageUtils</code>](#ImageUtils)  
**Returns**: <code>string</code> - The data URI.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| image | <code>HTMLImageElement</code> \| <code>HTMLCanvasElement</code> |  | The image object. |
| [type] | <code>string</code> | <code>&quot;&#x27;image/png&#x27;&quot;</code> | Indicates the image format. |

<a name="ImageUtils.sRGBToLinear"></a>

### ImageUtils.sRGBToLinear(image) ⇒ <code>HTMLCanvasElement</code> \| <code>Object</code>
Converts the given sRGB image data to linear color space.

**Kind**: static method of [<code>ImageUtils</code>](#ImageUtils)  
**Returns**: <code>HTMLCanvasElement</code> \| <code>Object</code> - The converted image.  

| Param | Type | Description |
| --- | --- | --- |
| image | <code>HTMLImageElement</code> \| <code>HTMLCanvasElement</code> \| <code>ImageBitmap</code> \| <code>Object</code> | The image object. |

<a name="PMREMGenerator"></a>

## PMREMGenerator
This class generates a Prefiltered, Mipmapped Radiance Environment Map
(PMREM) from a cubeMap environment texture. This allows different levels of
blur to be quickly accessed based on material roughness. It is packed into a
special CubeUV format that allows us to perform custom interpolation so that
we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
chain, it only goes down to the LOD_MIN level (above), and then creates extra
even more filtered 'mips' at the same LOD_MIN resolution, associated with
higher roughness levels. In this way we maintain resolution to smoothly
interpolate diffuse lighting while limiting sampling computation.

Paper: Fast, Accurate Image-Based Lighting:
[https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view](https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view)

**Kind**: global class  

* [PMREMGenerator](#PMREMGenerator)
    * [new PMREMGenerator(renderer)](#new_PMREMGenerator_new)
    * [.fromScene(scene, [sigma], [near], [far], [options])](#PMREMGenerator+fromScene) ⇒ <code>WebGLRenderTarget</code>
    * [.fromEquirectangular(equirectangular, [renderTarget])](#PMREMGenerator+fromEquirectangular) ⇒ <code>WebGLRenderTarget</code>
    * [.fromCubemap(cubemap, [renderTarget])](#PMREMGenerator+fromCubemap) ⇒ <code>WebGLRenderTarget</code>
    * [.compileCubemapShader()](#PMREMGenerator+compileCubemapShader)
    * [.compileEquirectangularShader()](#PMREMGenerator+compileEquirectangularShader)
    * [.dispose()](#PMREMGenerator+dispose)

<a name="new_PMREMGenerator_new"></a>

### new PMREMGenerator(renderer)
Constructs a new PMREM generator.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="PMREMGenerator+fromScene"></a>

### pmremGenerator.fromScene(scene, [sigma], [near], [far], [options]) ⇒ <code>WebGLRenderTarget</code>
Generates a PMREM from a supplied Scene, which can be faster than using an
image if networking bandwidth is low. Optional sigma specifies a blur radius
in radians to be applied to the scene before PMREM generation. Optional near
and far planes ensure the scene is rendered in its entirety.

**Kind**: instance method of [<code>PMREMGenerator</code>](#PMREMGenerator)  
**Returns**: <code>WebGLRenderTarget</code> - The resulting PMREM.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to be captured. |
| [sigma] | <code>number</code> | <code>0</code> | The blur radius in radians. |
| [near] | <code>number</code> | <code>0.1</code> | The near plane distance. |
| [far] | <code>number</code> | <code>100</code> | The far plane distance. |
| [options] | <code>Object</code> | <code>{}</code> | The configuration options. |
| [options.size] | <code>number</code> | <code>256</code> | The texture size of the PMREM. |
| [options.renderTarget] | <code>Vector3</code> | <code>origin</code> | The position of the internal cube camera that renders the scene. |

<a name="PMREMGenerator+fromEquirectangular"></a>

### pmremGenerator.fromEquirectangular(equirectangular, [renderTarget]) ⇒ <code>WebGLRenderTarget</code>
Generates a PMREM from an equirectangular texture, which can be either LDR
or HDR. The ideal input image size is 1k (1024 x 512),
as this matches best with the 256 x 256 cubemap output.

**Kind**: instance method of [<code>PMREMGenerator</code>](#PMREMGenerator)  
**Returns**: <code>WebGLRenderTarget</code> - The resulting PMREM.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| equirectangular | <code>Texture</code> |  | The equirectangular texture to be converted. |
| [renderTarget] | <code>WebGLRenderTarget</code> | <code></code> | The render target to use. |

<a name="PMREMGenerator+fromCubemap"></a>

### pmremGenerator.fromCubemap(cubemap, [renderTarget]) ⇒ <code>WebGLRenderTarget</code>
Generates a PMREM from an cubemap texture, which can be either LDR
or HDR. The ideal input cube size is 256 x 256,
as this matches best with the 256 x 256 cubemap output.

**Kind**: instance method of [<code>PMREMGenerator</code>](#PMREMGenerator)  
**Returns**: <code>WebGLRenderTarget</code> - The resulting PMREM.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| cubemap | <code>Texture</code> |  | The cubemap texture to be converted. |
| [renderTarget] | <code>WebGLRenderTarget</code> | <code></code> | The render target to use. |

<a name="PMREMGenerator+compileCubemapShader"></a>

### pmremGenerator.compileCubemapShader()
Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
your texture's network fetch for increased concurrency.

**Kind**: instance method of [<code>PMREMGenerator</code>](#PMREMGenerator)  
<a name="PMREMGenerator+compileEquirectangularShader"></a>

### pmremGenerator.compileEquirectangularShader()
Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
your texture's network fetch for increased concurrency.

**Kind**: instance method of [<code>PMREMGenerator</code>](#PMREMGenerator)  
<a name="PMREMGenerator+dispose"></a>

### pmremGenerator.dispose()
Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
one of them will cause any others to also become unusable.

**Kind**: instance method of [<code>PMREMGenerator</code>](#PMREMGenerator)  
<a name="ShapeUtils"></a>

## ShapeUtils
A class containing utility functions for shapes.

**Kind**: global class  

* [ShapeUtils](#ShapeUtils)
    * [.area(contour)](#ShapeUtils.area) ⇒ <code>number</code>
    * [.isClockWise(pts)](#ShapeUtils.isClockWise) ⇒ <code>boolean</code>
    * [.triangulateShape(contour, holes)](#ShapeUtils.triangulateShape) ⇒ <code>Array.&lt;Array.&lt;number&gt;&gt;</code>

<a name="ShapeUtils.area"></a>

### ShapeUtils.area(contour) ⇒ <code>number</code>
Calculate area of a ( 2D ) contour polygon.

**Kind**: static method of [<code>ShapeUtils</code>](#ShapeUtils)  
**Returns**: <code>number</code> - The area.  

| Param | Type | Description |
| --- | --- | --- |
| contour | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points. |

<a name="ShapeUtils.isClockWise"></a>

### ShapeUtils.isClockWise(pts) ⇒ <code>boolean</code>
Returns `true` if the given contour uses a clockwise winding order.

**Kind**: static method of [<code>ShapeUtils</code>](#ShapeUtils)  
**Returns**: <code>boolean</code> - Whether the given contour uses a clockwise winding order or not.  

| Param | Type | Description |
| --- | --- | --- |
| pts | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points defining a polygon. |

<a name="ShapeUtils.triangulateShape"></a>

### ShapeUtils.triangulateShape(contour, holes) ⇒ <code>Array.&lt;Array.&lt;number&gt;&gt;</code>
Triangulates the given shape definition.

**Kind**: static method of [<code>ShapeUtils</code>](#ShapeUtils)  
**Returns**: <code>Array.&lt;Array.&lt;number&gt;&gt;</code> - An array that holds for each face definition an array with three indices.  

| Param | Type | Description |
| --- | --- | --- |
| contour | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points defining the contour. |
| holes | <code>Array.&lt;Array.&lt;Vector2&gt;&gt;</code> | An array that holds arrays of 2D points defining the holes. |

## Classes

<dl>
<dt><a href="#TextureUtils">TextureUtils</a></dt>
<dd><p>A class containing utility functions for textures.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#contain">contain(texture, aspect)</a> ⇒ <code>Texture</code></dt>
<dd><p>Scales the texture as large as possible within its surface without cropping
or stretching the texture. The method preserves the original aspect ratio of
the texture. Akin to CSS <code>object-fit: contain</code></p>
</dd>
<dt><a href="#cover">cover(texture, aspect)</a> ⇒ <code>Texture</code></dt>
<dd><p>Scales the texture to the smallest possible size to fill the surface, leaving
no empty space. The method preserves the original aspect ratio of the texture.
Akin to CSS <code>object-fit: cover</code>.</p>
</dd>
<dt><a href="#fill">fill(texture)</a> ⇒ <code>Texture</code></dt>
<dd><p>Configures the texture to the default transformation. Akin to CSS <code>object-fit: fill</code>.</p>
</dd>
<dt><a href="#getByteLength">getByteLength(width, height, format, type)</a> ⇒ <code>number</code></dt>
<dd><p>Determines how many bytes must be used to represent the texture.</p>
</dd>
</dl>

<a name="TextureUtils"></a>

## TextureUtils
A class containing utility functions for textures.

**Kind**: global class  

* [TextureUtils](#TextureUtils)
    * [.contain(texture, aspect)](#TextureUtils.contain) ⇒ <code>Texture</code>
    * [.cover(texture, aspect)](#TextureUtils.cover) ⇒ <code>Texture</code>
    * [.fill(texture)](#TextureUtils.fill) ⇒ <code>Texture</code>
    * [.getByteLength(width, height, format, type)](#TextureUtils.getByteLength) ⇒ <code>number</code>

<a name="TextureUtils.contain"></a>

### TextureUtils.contain(texture, aspect) ⇒ <code>Texture</code>
Scales the texture as large as possible within its surface without cropping
or stretching the texture. The method preserves the original aspect ratio of
the texture. Akin to CSS `object-fit: contain`

**Kind**: static method of [<code>TextureUtils</code>](#TextureUtils)  
**Returns**: <code>Texture</code> - The updated texture.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| aspect | <code>number</code> | The texture's aspect ratio. |

<a name="TextureUtils.cover"></a>

### TextureUtils.cover(texture, aspect) ⇒ <code>Texture</code>
Scales the texture to the smallest possible size to fill the surface, leaving
no empty space. The method preserves the original aspect ratio of the texture.
Akin to CSS `object-fit: cover`.

**Kind**: static method of [<code>TextureUtils</code>](#TextureUtils)  
**Returns**: <code>Texture</code> - The updated texture.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| aspect | <code>number</code> | The texture's aspect ratio. |

<a name="TextureUtils.fill"></a>

### TextureUtils.fill(texture) ⇒ <code>Texture</code>
Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.

**Kind**: static method of [<code>TextureUtils</code>](#TextureUtils)  
**Returns**: <code>Texture</code> - The updated texture.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="TextureUtils.getByteLength"></a>

### TextureUtils.getByteLength(width, height, format, type) ⇒ <code>number</code>
Determines how many bytes must be used to represent the texture.

**Kind**: static method of [<code>TextureUtils</code>](#TextureUtils)  
**Returns**: <code>number</code> - The byte length.  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the texture. |
| height | <code>number</code> | The height of the texture. |
| format | <code>number</code> | The texture's format. |
| type | <code>number</code> | The texture's type. |

<a name="contain"></a>

## contain(texture, aspect) ⇒ <code>Texture</code>
Scales the texture as large as possible within its surface without cropping
or stretching the texture. The method preserves the original aspect ratio of
the texture. Akin to CSS `object-fit: contain`

**Kind**: global function  
**Returns**: <code>Texture</code> - The updated texture.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| aspect | <code>number</code> | The texture's aspect ratio. |

<a name="cover"></a>

## cover(texture, aspect) ⇒ <code>Texture</code>
Scales the texture to the smallest possible size to fill the surface, leaving
no empty space. The method preserves the original aspect ratio of the texture.
Akin to CSS `object-fit: cover`.

**Kind**: global function  
**Returns**: <code>Texture</code> - The updated texture.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| aspect | <code>number</code> | The texture's aspect ratio. |

<a name="fill"></a>

## fill(texture) ⇒ <code>Texture</code>
Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.

**Kind**: global function  
**Returns**: <code>Texture</code> - The updated texture.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="getByteLength"></a>

## getByteLength(width, height, format, type) ⇒ <code>number</code>
Determines how many bytes must be used to represent the texture.

**Kind**: global function  
**Returns**: <code>number</code> - The byte length.  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the texture. |
| height | <code>number</code> | The height of the texture. |
| format | <code>number</code> | The texture's format. |
| type | <code>number</code> | The texture's type. |

<a name="Curve"></a>

## *Curve*
An abstract base class for creating an analytic curve object that contains methods
for interpolation.

**Kind**: global abstract class  

* *[Curve](#Curve)*
    * *[new Curve()](#new_Curve_new)*
    * *[.type](#Curve+type) : <code>string</code>*
    * *[.arcLengthDivisions](#Curve+arcLengthDivisions) : <code>number</code>*
    * *[.needsUpdate](#Curve+needsUpdate) : <code>boolean</code>*
    * **[.getPoint(t, [optionalTarget])](#Curve+getPoint) ⇒ <code>Vector2</code> \| <code>Vector3</code>**
    * *[.getPointAt(u, [optionalTarget])](#Curve+getPointAt) ⇒ <code>Vector2</code> \| <code>Vector3</code>*
    * *[.getPoints([divisions])](#Curve+getPoints) ⇒ <code>Array.&lt;(Vector2\|Vector3)&gt;</code>*
    * *[.getSpacedPoints([divisions])](#Curve+getSpacedPoints) ⇒ <code>Array.&lt;(Vector2\|Vector3)&gt;</code>*
    * *[.getLength()](#Curve+getLength) ⇒ <code>number</code>*
    * *[.getLengths([divisions])](#Curve+getLengths) ⇒ <code>Array.&lt;number&gt;</code>*
    * *[.updateArcLengths()](#Curve+updateArcLengths)*
    * *[.getUtoTmapping(u, distance)](#Curve+getUtoTmapping) ⇒ <code>number</code>*
    * *[.getTangent(t, [optionalTarget])](#Curve+getTangent) ⇒ <code>Vector2</code> \| <code>Vector3</code>*
    * *[.getTangentAt(u, [optionalTarget])](#Curve+getTangentAt) ⇒ <code>Vector2</code> \| <code>Vector3</code>*
    * *[.computeFrenetFrames(segments, [closed])](#Curve+computeFrenetFrames) ⇒ <code>Object</code>*
    * *[.clone()](#Curve+clone) ⇒ [<code>Curve</code>](#Curve)*
    * *[.copy(source)](#Curve+copy) ⇒ [<code>Curve</code>](#Curve)*
    * *[.toJSON()](#Curve+toJSON) ⇒ <code>Object</code>*
    * *[.fromJSON(json)](#Curve+fromJSON) ⇒ [<code>Curve</code>](#Curve)*

<a name="new_Curve_new"></a>

### *new Curve()*
Constructs a new curve.

<a name="Curve+type"></a>

### *curve.type : <code>string</code>*
The type property is used for detecting the object type
in context of serialization/deserialization.

**Kind**: instance property of [<code>Curve</code>](#Curve)  
**Read only**: true  
<a name="Curve+arcLengthDivisions"></a>

### *curve.arcLengthDivisions : <code>number</code>*
This value determines the amount of divisions when calculating the
cumulative segment lengths of a curve via [getLengths](#Curve+getLengths). To ensure
precision when using methods like [getSpacedPoints](#Curve+getSpacedPoints), it is
recommended to increase the value of this property if the curve is very large.

**Kind**: instance property of [<code>Curve</code>](#Curve)  
**Default**: <code>200</code>  
<a name="Curve+needsUpdate"></a>

### *curve.needsUpdate : <code>boolean</code>*
Must be set to `true` if the curve parameters have changed.

**Kind**: instance property of [<code>Curve</code>](#Curve)  
**Default**: <code>false</code>  
<a name="Curve+getPoint"></a>

### **curve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code> \| <code>Vector3</code>**
This method returns a vector in 2D or 3D space (depending on the curve definition)
for the given interpolation factor.

**Kind**: instance abstract method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Vector2</code> \| <code>Vector3</code> - The position on the curve. It can be a 2D or 3D vector depending on the curve definition.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> \| <code>Vector3</code> | The optional target vector the result is written to. |

<a name="Curve+getPointAt"></a>

### *curve.getPointAt(u, [optionalTarget]) ⇒ <code>Vector2</code> \| <code>Vector3</code>*
This method returns a vector in 2D or 3D space (depending on the curve definition)
for the given interpolation factor. Unlike [getPoint](#Curve+getPoint), this method honors the length
of the curve which equidistant samples.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Vector2</code> \| <code>Vector3</code> - The position on the curve. It can be a 2D or 3D vector depending on the curve definition.  

| Param | Type | Description |
| --- | --- | --- |
| u | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> \| <code>Vector3</code> | The optional target vector the result is written to. |

<a name="Curve+getPoints"></a>

### *curve.getPoints([divisions]) ⇒ <code>Array.&lt;(Vector2\|Vector3)&gt;</code>*
This method samples the curve via [getPoint](#Curve+getPoint) and returns an array of points representing
the curve shape.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Array.&lt;(Vector2\|Vector3)&gt;</code> - An array holding the sampled curve values. The number of points is `divisions + 1`.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [divisions] | <code>number</code> | <code>5</code> | The number of divisions. |

<a name="Curve+getSpacedPoints"></a>

### *curve.getSpacedPoints([divisions]) ⇒ <code>Array.&lt;(Vector2\|Vector3)&gt;</code>*
This method samples the curve via [getPointAt](#Curve+getPointAt) and returns an array of points representing
the curve shape. Unlike [getPoints](#Curve+getPoints), this method returns equi-spaced points across the entire
curve.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Array.&lt;(Vector2\|Vector3)&gt;</code> - An array holding the sampled curve values. The number of points is `divisions + 1`.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [divisions] | <code>number</code> | <code>5</code> | The number of divisions. |

<a name="Curve+getLength"></a>

### *curve.getLength() ⇒ <code>number</code>*
Returns the total arc length of the curve.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>number</code> - The length of the curve.  
<a name="Curve+getLengths"></a>

### *curve.getLengths([divisions]) ⇒ <code>Array.&lt;number&gt;</code>*
Returns an array of cumulative segment lengths of the curve.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Array.&lt;number&gt;</code> - An array holding the cumulative segment lengths.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [divisions] | <code>number</code> | <code>this.arcLengthDivisions</code> | The number of divisions. |

<a name="Curve+updateArcLengths"></a>

### *curve.updateArcLengths()*
Update the cumulative segment distance cache. The method must be called
every time curve parameters are changed. If an updated curve is part of a
composed curve like [CurvePath](CurvePath), this method must be called on the
composed curve, too.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
<a name="Curve+getUtoTmapping"></a>

### *curve.getUtoTmapping(u, distance) ⇒ <code>number</code>*
Given an interpolation factor in the range `[0,1]`, this method returns an updated
interpolation factor in the same range that can be ued to sample equidistant points
from a curve.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>number</code> - The updated interpolation factor.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| u | <code>number</code> |  | The interpolation factor. |
| distance | <code>number</code> | <code></code> | An optional distance on the curve. |

<a name="Curve+getTangent"></a>

### *curve.getTangent(t, [optionalTarget]) ⇒ <code>Vector2</code> \| <code>Vector3</code>*
Returns a unit vector tangent for the given interpolation factor.
If the derived curve does not implement its tangent derivation,
two points a small delta apart will be used to find its gradient
which seems to give a reasonable approximation.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Vector2</code> \| <code>Vector3</code> - The tangent vector.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |
| [optionalTarget] | <code>Vector2</code> \| <code>Vector3</code> | The optional target vector the result is written to. |

<a name="Curve+getTangentAt"></a>

### *curve.getTangentAt(u, [optionalTarget]) ⇒ <code>Vector2</code> \| <code>Vector3</code>*
Same as [getTangent](#Curve+getTangent) but with equidistant samples.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Vector2</code> \| <code>Vector3</code> - The tangent vector.  
**See**: [getPointAt](#Curve+getPointAt)  

| Param | Type | Description |
| --- | --- | --- |
| u | <code>number</code> | The interpolation factor. |
| [optionalTarget] | <code>Vector2</code> \| <code>Vector3</code> | The optional target vector the result is written to. |

<a name="Curve+computeFrenetFrames"></a>

### *curve.computeFrenetFrames(segments, [closed]) ⇒ <code>Object</code>*
Generates the Frenet Frames. Requires a curve definition in 3D space. Used
in geometries like [TubeGeometry](TubeGeometry) or [ExtrudeGeometry](ExtrudeGeometry).

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Object</code> - The Frenet Frames.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| segments | <code>number</code> |  | The number of segments. |
| [closed] | <code>boolean</code> | <code>false</code> | Whether the curve is closed or not. |

<a name="Curve+clone"></a>

### *curve.clone() ⇒ [<code>Curve</code>](#Curve)*
Returns a new curve with copied values from this instance.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: [<code>Curve</code>](#Curve) - A clone of this instance.  
<a name="Curve+copy"></a>

### *curve.copy(source) ⇒ [<code>Curve</code>](#Curve)*
Copies the values of the given curve to this instance.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: [<code>Curve</code>](#Curve) - A reference to this curve.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>Curve</code>](#Curve) | The curve to copy. |

<a name="Curve+toJSON"></a>

### *curve.toJSON() ⇒ <code>Object</code>*
Serializes the curve into JSON.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: <code>Object</code> - A JSON object representing the serialized curve.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  
<a name="Curve+fromJSON"></a>

### *curve.fromJSON(json) ⇒ [<code>Curve</code>](#Curve)*
Deserializes the curve from the given JSON.

**Kind**: instance method of [<code>Curve</code>](#Curve)  
**Returns**: [<code>Curve</code>](#Curve) - A reference to this curve.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON holding the serialized curve. |

<a name="CurvePath"></a>

## CurvePath ⇐ <code>Curve</code>
A base class extending [Curve](Curve). `CurvePath` is simply an
array of connected curves, but retains the API of a curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [CurvePath](#CurvePath) ⇐ <code>Curve</code>
    * [new CurvePath()](#new_CurvePath_new)
    * [.curves](#CurvePath+curves) : <code>Array.&lt;Curve&gt;</code>
    * [.autoClose](#CurvePath+autoClose) : <code>boolean</code>
    * [.add(curve)](#CurvePath+add)
    * [.closePath()](#CurvePath+closePath) ⇒ [<code>CurvePath</code>](#CurvePath)
    * [.getPoint(t, [optionalTarget])](#CurvePath+getPoint) ⇒ <code>Vector2</code> \| <code>Vector3</code>
    * [.getCurveLengths()](#CurvePath+getCurveLengths) ⇒ <code>Array.&lt;number&gt;</code>

<a name="new_CurvePath_new"></a>

### new CurvePath()
Constructs a new curve path.

<a name="CurvePath+curves"></a>

### curvePath.curves : <code>Array.&lt;Curve&gt;</code>
An array of curves defining the
path.

**Kind**: instance property of [<code>CurvePath</code>](#CurvePath)  
<a name="CurvePath+autoClose"></a>

### curvePath.autoClose : <code>boolean</code>
Whether the path should automatically be closed
by a line curve.

**Kind**: instance property of [<code>CurvePath</code>](#CurvePath)  
**Default**: <code>false</code>  
<a name="CurvePath+add"></a>

### curvePath.add(curve)
Adds a curve to this curve path.

**Kind**: instance method of [<code>CurvePath</code>](#CurvePath)  

| Param | Type | Description |
| --- | --- | --- |
| curve | <code>Curve</code> | The curve to add. |

<a name="CurvePath+closePath"></a>

### curvePath.closePath() ⇒ [<code>CurvePath</code>](#CurvePath)
Adds a line curve to close the path.

**Kind**: instance method of [<code>CurvePath</code>](#CurvePath)  
**Returns**: [<code>CurvePath</code>](#CurvePath) - A reference to this curve path.  
<a name="CurvePath+getPoint"></a>

### curvePath.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code> \| <code>Vector3</code>
This method returns a vector in 2D or 3D space (depending on the curve definitions)
for the given interpolation factor.

**Kind**: instance method of [<code>CurvePath</code>](#CurvePath)  
**Returns**: <code>Vector2</code> \| <code>Vector3</code> - The position on the curve. It can be a 2D or 3D vector depending on the curve definition.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> \| <code>Vector3</code> | The optional target vector the result is written to. |

<a name="CurvePath+getCurveLengths"></a>

### curvePath.getCurveLengths() ⇒ <code>Array.&lt;number&gt;</code>
Returns list of cumulative curve lengths of the defined curves.

**Kind**: instance method of [<code>CurvePath</code>](#CurvePath)  
**Returns**: <code>Array.&lt;number&gt;</code> - The curve lengths.  
## Functions

<dl>
<dt><a href="#CatmullRom">CatmullRom(t, p0, p1, p2, p3)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a point on a Catmull-Rom spline.</p>
</dd>
<dt><a href="#QuadraticBezier">QuadraticBezier(t, p0, p1, p2)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a point on a Quadratic Bezier curve.</p>
</dd>
<dt><a href="#CubicBezier">CubicBezier(t, p0, p1, p2, p3)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a point on a Cubic Bezier curve.</p>
</dd>
</dl>

<a name="CatmullRom"></a>

## CatmullRom(t, p0, p1, p2, p3) ⇒ <code>number</code>
Computes a point on a Catmull-Rom spline.

**Kind**: global function  
**Returns**: <code>number</code> - The calculated point on a Catmull-Rom spline.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |
| p0 | <code>number</code> | The first control point. |
| p1 | <code>number</code> | The second control point. |
| p2 | <code>number</code> | The third control point. |
| p3 | <code>number</code> | The fourth control point. |

<a name="QuadraticBezier"></a>

## QuadraticBezier(t, p0, p1, p2) ⇒ <code>number</code>
Computes a point on a Quadratic Bezier curve.

**Kind**: global function  
**Returns**: <code>number</code> - The calculated point on a Quadratic Bezier curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |
| p0 | <code>number</code> | The first control point. |
| p1 | <code>number</code> | The second control point. |
| p2 | <code>number</code> | The third control point. |

<a name="CubicBezier"></a>

## CubicBezier(t, p0, p1, p2, p3) ⇒ <code>number</code>
Computes a point on a Cubic Bezier curve.

**Kind**: global function  
**Returns**: <code>number</code> - The calculated point on a Cubic Bezier curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |
| p0 | <code>number</code> | The first control point. |
| p1 | <code>number</code> | The second control point. |
| p2 | <code>number</code> | The third control point. |
| p3 | <code>number</code> | The fourth control point. |

<a name="Path"></a>

## Path ⇐ <code>CurvePath</code>
A 2D path representation. The class provides methods for creating paths
and contours of 2D shapes similar to the 2D Canvas API.

```js
const path = new THREE.Path();

path.lineTo( 0, 0.8 );
path.quadraticCurveTo( 0, 1, 0.2, 1 );
path.lineTo( 1, 1 );

const points = path.getPoints();

const geometry = new THREE.BufferGeometry().setFromPoints( points );
const material = new THREE.LineBasicMaterial( { color: 0xffffff } );

const line = new THREE.Line( geometry, material );
scene.add( line );
```

**Kind**: global class  
**Extends**: <code>CurvePath</code>  

* [Path](#Path) ⇐ <code>CurvePath</code>
    * [new Path([points])](#new_Path_new)
    * [.currentPoint](#Path+currentPoint) : <code>Vector2</code>
    * [.setFromPoints(points)](#Path+setFromPoints) ⇒ [<code>Path</code>](#Path)
    * [.moveTo(x, y)](#Path+moveTo) ⇒ [<code>Path</code>](#Path)
    * [.lineTo(x, y)](#Path+lineTo) ⇒ [<code>Path</code>](#Path)
    * [.quadraticCurveTo(aCPx, aCPy, aX, aY)](#Path+quadraticCurveTo) ⇒ [<code>Path</code>](#Path)
    * [.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY)](#Path+bezierCurveTo) ⇒ [<code>Path</code>](#Path)
    * [.splineThru(pts)](#Path+splineThru) ⇒ [<code>Path</code>](#Path)
    * [.arc(aX, aY, aRadius, aStartAngle, aEndAngle, [aClockwise])](#Path+arc) ⇒ [<code>Path</code>](#Path)
    * [.absarc(aX, aY, aRadius, aStartAngle, aEndAngle, [aClockwise])](#Path+absarc) ⇒ [<code>Path</code>](#Path)
    * [.ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, [aClockwise], [aRotation])](#Path+ellipse) ⇒ [<code>Path</code>](#Path)
    * [.absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, [aClockwise], [aRotation])](#Path+absellipse) ⇒ [<code>Path</code>](#Path)

<a name="new_Path_new"></a>

### new Path([points])
Constructs a new path.


| Param | Type | Description |
| --- | --- | --- |
| [points] | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points defining the path. |

<a name="Path+currentPoint"></a>

### path.currentPoint : <code>Vector2</code>
The current offset of the path. Any new curve added will start here.

**Kind**: instance property of [<code>Path</code>](#Path)  
<a name="Path+setFromPoints"></a>

### path.setFromPoints(points) ⇒ [<code>Path</code>](#Path)
Creates a path from the given list of points. The points are added
to the path as instances of [LineCurve](LineCurve).

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points. |

<a name="Path+moveTo"></a>

### path.moveTo(x, y) ⇒ [<code>Path</code>](#Path)
Moves [currentPoint](#Path+currentPoint) to the given point.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate. |
| y | <code>number</code> | The y coordinate. |

<a name="Path+lineTo"></a>

### path.lineTo(x, y) ⇒ [<code>Path</code>](#Path)
Adds an instance of [LineCurve](LineCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate of the end point. |
| y | <code>number</code> | The y coordinate of the end point. |

<a name="Path+quadraticCurveTo"></a>

### path.quadraticCurveTo(aCPx, aCPy, aX, aY) ⇒ [<code>Path</code>](#Path)
Adds an instance of [QuadraticBezierCurve](QuadraticBezierCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| aCPx | <code>number</code> | The x coordinate of the control point. |
| aCPy | <code>number</code> | The y coordinate of the control point. |
| aX | <code>number</code> | The x coordinate of the end point. |
| aY | <code>number</code> | The y coordinate of the end point. |

<a name="Path+bezierCurveTo"></a>

### path.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) ⇒ [<code>Path</code>](#Path)
Adds an instance of [CubicBezierCurve](CubicBezierCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| aCP1x | <code>number</code> | The x coordinate of the first control point. |
| aCP1y | <code>number</code> | The y coordinate of the first control point. |
| aCP2x | <code>number</code> | The x coordinate of the second control point. |
| aCP2y | <code>number</code> | The y coordinate of the second control point. |
| aX | <code>number</code> | The x coordinate of the end point. |
| aY | <code>number</code> | The y coordinate of the end point. |

<a name="Path+splineThru"></a>

### path.splineThru(pts) ⇒ [<code>Path</code>](#Path)
Adds an instance of [SplineCurve](SplineCurve) to the path by connecting
the current point with the given list of points.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| pts | <code>Array.&lt;Vector2&gt;</code> | An array of points in 2D space. |

<a name="Path+arc"></a>

### path.arc(aX, aY, aRadius, aStartAngle, aEndAngle, [aClockwise]) ⇒ [<code>Path</code>](#Path)
Adds an arc as an instance of [EllipseCurve](EllipseCurve) to the path, positioned relative
to the current point.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| aX | <code>number</code> |  | The x coordinate of the center of the arc offsetted from the previous curve. |
| aY | <code>number</code> |  | The y coordinate of the center of the arc offsetted from the previous curve. |
| aRadius | <code>number</code> |  | The radius of the arc. |
| aStartAngle | <code>number</code> |  | The start angle in radians. |
| aEndAngle | <code>number</code> |  | The end angle in radians. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether to sweep the arc clockwise or not. |

<a name="Path+absarc"></a>

### path.absarc(aX, aY, aRadius, aStartAngle, aEndAngle, [aClockwise]) ⇒ [<code>Path</code>](#Path)
Adds an absolutely positioned arc as an instance of [EllipseCurve](EllipseCurve) to the path.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| aX | <code>number</code> |  | The x coordinate of the center of the arc. |
| aY | <code>number</code> |  | The y coordinate of the center of the arc. |
| aRadius | <code>number</code> |  | The radius of the arc. |
| aStartAngle | <code>number</code> |  | The start angle in radians. |
| aEndAngle | <code>number</code> |  | The end angle in radians. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether to sweep the arc clockwise or not. |

<a name="Path+ellipse"></a>

### path.ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, [aClockwise], [aRotation]) ⇒ [<code>Path</code>](#Path)
Adds an ellipse as an instance of [EllipseCurve](EllipseCurve) to the path, positioned relative
to the current point

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| aX | <code>number</code> |  | The x coordinate of the center of the ellipse offsetted from the previous curve. |
| aY | <code>number</code> |  | The y coordinate of the center of the ellipse offsetted from the previous curve. |
| xRadius | <code>number</code> |  | The radius of the ellipse in the x axis. |
| yRadius | <code>number</code> |  | The radius of the ellipse in the y axis. |
| aStartAngle | <code>number</code> |  | The start angle in radians. |
| aEndAngle | <code>number</code> |  | The end angle in radians. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether to sweep the ellipse clockwise or not. |
| [aRotation] | <code>number</code> | <code>0</code> | The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. |

<a name="Path+absellipse"></a>

### path.absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, [aClockwise], [aRotation]) ⇒ [<code>Path</code>](#Path)
Adds an absolutely positioned ellipse as an instance of [EllipseCurve](EllipseCurve) to the path.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| aX | <code>number</code> |  | The x coordinate of the absolute center of the ellipse. |
| aY | <code>number</code> |  | The y coordinate of the absolute center of the ellipse. |
| xRadius | <code>number</code> |  | The radius of the ellipse in the x axis. |
| yRadius | <code>number</code> |  | The radius of the ellipse in the y axis. |
| aStartAngle | <code>number</code> |  | The start angle in radians. |
| aEndAngle | <code>number</code> |  | The end angle in radians. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether to sweep the ellipse clockwise or not. |
| [aRotation] | <code>number</code> | <code>0</code> | The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. |

<a name="Shape"></a>

## Shape ⇐ <code>Path</code>
Defines an arbitrary 2d shape plane using paths with optional holes. It
can be used with [ExtrudeGeometry](ExtrudeGeometry), [ShapeGeometry](ShapeGeometry), to get
points, or to get triangulated faces.

```js
const heartShape = new THREE.Shape();

heartShape.moveTo( 25, 25 );
heartShape.bezierCurveTo( 25, 25, 20, 0, 0, 0 );
heartShape.bezierCurveTo( - 30, 0, - 30, 35, - 30, 35 );
heartShape.bezierCurveTo( - 30, 55, - 10, 77, 25, 95 );
heartShape.bezierCurveTo( 60, 77, 80, 55, 80, 35 );
heartShape.bezierCurveTo( 80, 35, 80, 0, 50, 0 );
heartShape.bezierCurveTo( 35, 0, 25, 25, 25, 25 );

const extrudeSettings = {
	depth: 8,
	bevelEnabled: true,
	bevelSegments: 2,
	steps: 2,
	bevelSize: 1,
	bevelThickness: 1
};

const geometry = new THREE.ExtrudeGeometry( heartShape, extrudeSettings );
const mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial() );
```

**Kind**: global class  
**Extends**: <code>Path</code>  

* [Shape](#Shape) ⇐ <code>Path</code>
    * [new Shape([points])](#new_Shape_new)
    * [.uuid](#Shape+uuid) : <code>string</code>
    * [.holes](#Shape+holes) : <code>Array.&lt;Path&gt;</code>
    * [.getPointsHoles(divisions)](#Shape+getPointsHoles) ⇒ <code>Array.&lt;Array.&lt;Vector2&gt;&gt;</code>
    * [.extractPoints(divisions)](#Shape+extractPoints) ⇒ <code>Object</code>

<a name="new_Shape_new"></a>

### new Shape([points])
Constructs a new shape.


| Param | Type | Description |
| --- | --- | --- |
| [points] | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points defining the shape. |

<a name="Shape+uuid"></a>

### shape.uuid : <code>string</code>
The UUID of the shape.

**Kind**: instance property of [<code>Shape</code>](#Shape)  
**Read only**: true  
<a name="Shape+holes"></a>

### shape.holes : <code>Array.&lt;Path&gt;</code>
Defines the holes in the shape. Hole definitions must use the
opposite winding order (CW/CCW) than the outer shape.

**Kind**: instance property of [<code>Shape</code>](#Shape)  
**Read only**: true  
<a name="Shape+getPointsHoles"></a>

### shape.getPointsHoles(divisions) ⇒ <code>Array.&lt;Array.&lt;Vector2&gt;&gt;</code>
Returns an array representing each contour of the holes
as a list of 2D points.

**Kind**: instance method of [<code>Shape</code>](#Shape)  
**Returns**: <code>Array.&lt;Array.&lt;Vector2&gt;&gt;</code> - The holes as a series of 2D points.  

| Param | Type | Description |
| --- | --- | --- |
| divisions | <code>number</code> | The fineness of the result. |

<a name="Shape+extractPoints"></a>

### shape.extractPoints(divisions) ⇒ <code>Object</code>
Returns an object that holds contour data for the shape and its holes as
arrays of 2D points.

**Kind**: instance method of [<code>Shape</code>](#Shape)  
**Returns**: <code>Object</code> - An object with contour data.  

| Param | Type | Description |
| --- | --- | --- |
| divisions | <code>number</code> | The fineness of the result. |

<a name="ShapePath"></a>

## ShapePath
This class is used to convert a series of paths to an array of
shapes. It is specifically used in context of fonts and SVG.

**Kind**: global class  

* [ShapePath](#ShapePath)
    * [new ShapePath()](#new_ShapePath_new)
    * [.color](#ShapePath+color) : <code>Color</code>
    * [.subPaths](#ShapePath+subPaths) : <code>Array.&lt;Path&gt;</code>
    * [.currentPath](#ShapePath+currentPath) : <code>Path</code>
    * [.moveTo(x, y)](#ShapePath+moveTo) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.lineTo(x, y)](#ShapePath+lineTo) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.quadraticCurveTo(aCPx, aCPy, aX, aY)](#ShapePath+quadraticCurveTo) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY)](#ShapePath+bezierCurveTo) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.splineThru(pts)](#ShapePath+splineThru) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.toShapes(isCCW)](#ShapePath+toShapes) ⇒ <code>Array.&lt;Shape&gt;</code>

<a name="new_ShapePath_new"></a>

### new ShapePath()
Constructs a new shape path.

<a name="ShapePath+color"></a>

### shapePath.color : <code>Color</code>
The color of the shape.

**Kind**: instance property of [<code>ShapePath</code>](#ShapePath)  
<a name="ShapePath+subPaths"></a>

### shapePath.subPaths : <code>Array.&lt;Path&gt;</code>
The paths that have been generated for this shape.

**Kind**: instance property of [<code>ShapePath</code>](#ShapePath)  
**Default**: <code>null</code>  
<a name="ShapePath+currentPath"></a>

### shapePath.currentPath : <code>Path</code>
The current path that is being generated.

**Kind**: instance property of [<code>ShapePath</code>](#ShapePath)  
**Default**: <code>null</code>  
<a name="ShapePath+moveTo"></a>

### shapePath.moveTo(x, y) ⇒ [<code>ShapePath</code>](#ShapePath)
Creates a new path and moves it current point to the given one.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate. |
| y | <code>number</code> | The y coordinate. |

<a name="ShapePath+lineTo"></a>

### shapePath.lineTo(x, y) ⇒ [<code>ShapePath</code>](#ShapePath)
Adds an instance of [LineCurve](LineCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate of the end point. |
| y | <code>number</code> | The y coordinate of the end point. |

<a name="ShapePath+quadraticCurveTo"></a>

### shapePath.quadraticCurveTo(aCPx, aCPy, aX, aY) ⇒ [<code>ShapePath</code>](#ShapePath)
Adds an instance of [QuadraticBezierCurve](QuadraticBezierCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| aCPx | <code>number</code> | The x coordinate of the control point. |
| aCPy | <code>number</code> | The y coordinate of the control point. |
| aX | <code>number</code> | The x coordinate of the end point. |
| aY | <code>number</code> | The y coordinate of the end point. |

<a name="ShapePath+bezierCurveTo"></a>

### shapePath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) ⇒ [<code>ShapePath</code>](#ShapePath)
Adds an instance of [CubicBezierCurve](CubicBezierCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| aCP1x | <code>number</code> | The x coordinate of the first control point. |
| aCP1y | <code>number</code> | The y coordinate of the first control point. |
| aCP2x | <code>number</code> | The x coordinate of the second control point. |
| aCP2y | <code>number</code> | The y coordinate of the second control point. |
| aX | <code>number</code> | The x coordinate of the end point. |
| aY | <code>number</code> | The y coordinate of the end point. |

<a name="ShapePath+splineThru"></a>

### shapePath.splineThru(pts) ⇒ [<code>ShapePath</code>](#ShapePath)
Adds an instance of [SplineCurve](SplineCurve) to the path by connecting
the current point with the given list of points.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| pts | <code>Array.&lt;Vector2&gt;</code> | An array of points in 2D space. |

<a name="ShapePath+toShapes"></a>

### shapePath.toShapes(isCCW) ⇒ <code>Array.&lt;Shape&gt;</code>
Converts the paths into an array of shapes.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: <code>Array.&lt;Shape&gt;</code> - An array of shapes.  

| Param | Type | Description |
| --- | --- | --- |
| isCCW | <code>boolean</code> | By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW). If this flag is set to `true`, then those are flipped. |

<a name="ArcCurve"></a>

## ArcCurve ⇐ <code>EllipseCurve</code>
A curve representing an arc.

**Kind**: global class  
**Extends**: <code>EllipseCurve</code>  

* [ArcCurve](#ArcCurve) ⇐ <code>EllipseCurve</code>
    * [new ArcCurve([aX], [aY], [aRadius], [aStartAngle], [aEndAngle], [aClockwise])](#new_ArcCurve_new)
    * [.isArcCurve](#ArcCurve+isArcCurve) : <code>boolean</code>

<a name="new_ArcCurve_new"></a>

### new ArcCurve([aX], [aY], [aRadius], [aStartAngle], [aEndAngle], [aClockwise])
Constructs a new arc curve.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [aX] | <code>number</code> | <code>0</code> | The X center of the ellipse. |
| [aY] | <code>number</code> | <code>0</code> | The Y center of the ellipse. |
| [aRadius] | <code>number</code> | <code>1</code> | The radius of the ellipse in the x direction. |
| [aStartAngle] | <code>number</code> | <code>0</code> | The start angle of the curve in radians starting from the positive X axis. |
| [aEndAngle] | <code>number</code> | <code>Math.PI*2</code> | The end angle of the curve in radians starting from the positive X axis. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether the ellipse is drawn clockwise or not. |

<a name="ArcCurve+isArcCurve"></a>

### arcCurve.isArcCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ArcCurve</code>](#ArcCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CatmullRomCurve3"></a>

## CatmullRomCurve3 ⇐ <code>Curve</code>
A curve representing a Catmull-Rom spline.

```js
//Create a closed wavey loop
const curve = new THREE.CatmullRomCurve3( [
	new THREE.Vector3( -10, 0, 10 ),
	new THREE.Vector3( -5, 5, 5 ),
	new THREE.Vector3( 0, 0, 0 ),
	new THREE.Vector3( 5, -5, 5 ),
	new THREE.Vector3( 10, 0, 10 )
] );

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const curveObject = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [CatmullRomCurve3](#CatmullRomCurve3) ⇐ <code>Curve</code>
    * [new CatmullRomCurve3([points], [closed], [curveType], [tension])](#new_CatmullRomCurve3_new)
    * [.isCatmullRomCurve3](#CatmullRomCurve3+isCatmullRomCurve3) : <code>boolean</code>
    * [.points](#CatmullRomCurve3+points) : <code>Array.&lt;Vector3&gt;</code>
    * [.closed](#CatmullRomCurve3+closed) : <code>boolean</code>
    * [.curveType](#CatmullRomCurve3+curveType) : <code>&#x27;centripetal&#x27;</code> \| <code>&#x27;chordal&#x27;</code> \| <code>&#x27;catmullrom&#x27;</code>
    * [.tension](#CatmullRomCurve3+tension) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#CatmullRomCurve3+getPoint) ⇒ <code>Vector3</code>

<a name="new_CatmullRomCurve3_new"></a>

### new CatmullRomCurve3([points], [closed], [curveType], [tension])
Constructs a new Catmull-Rom curve.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [points] | <code>Array.&lt;Vector3&gt;</code> |  | An array of 3D points defining the curve. |
| [closed] | <code>boolean</code> | <code>false</code> | Whether the curve is closed or not. |
| [curveType] | <code>&#x27;centripetal&#x27;</code> \| <code>&#x27;chordal&#x27;</code> \| <code>&#x27;catmullrom&#x27;</code> | <code>&#x27;centripetal&#x27;</code> | The curve type. |
| [tension] | <code>number</code> | <code>0.5</code> | Tension of the curve. |

<a name="CatmullRomCurve3+isCatmullRomCurve3"></a>

### catmullRomCurve3.isCatmullRomCurve3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CatmullRomCurve3+points"></a>

### catmullRomCurve3.points : <code>Array.&lt;Vector3&gt;</code>
An array of 3D points defining the curve.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
<a name="CatmullRomCurve3+closed"></a>

### catmullRomCurve3.closed : <code>boolean</code>
Whether the curve is closed or not.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Default**: <code>false</code>  
<a name="CatmullRomCurve3+curveType"></a>

### catmullRomCurve3.curveType : <code>&#x27;centripetal&#x27;</code> \| <code>&#x27;chordal&#x27;</code> \| <code>&#x27;catmullrom&#x27;</code>
The curve type.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Default**: <code>&#x27;centripetal&#x27;</code>  
<a name="CatmullRomCurve3+tension"></a>

### catmullRomCurve3.tension : <code>number</code>
Tension of the curve.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Default**: <code>0.5</code>  
<a name="CatmullRomCurve3+getPoint"></a>

### catmullRomCurve3.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a point on the curve.

**Kind**: instance method of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="CubicBezierCurve"></a>

## CubicBezierCurve ⇐ <code>Curve</code>
A curve representing a 2D Cubic Bezier curve.

```js
const curve = new THREE.CubicBezierCurve(
	new THREE.Vector2( - 0, 0 ),
	new THREE.Vector2( - 5, 15 ),
	new THREE.Vector2( 20, 15 ),
	new THREE.Vector2( 10, 0 )
);

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const curveObject = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [CubicBezierCurve](#CubicBezierCurve) ⇐ <code>Curve</code>
    * [new CubicBezierCurve([v0], [v1], [v2], [v3])](#new_CubicBezierCurve_new)
    * [.isCubicBezierCurve](#CubicBezierCurve+isCubicBezierCurve) : <code>boolean</code>
    * [.v0](#CubicBezierCurve+v0) : <code>Vector2</code>
    * [.v1](#CubicBezierCurve+v1) : <code>Vector2</code>
    * [.v2](#CubicBezierCurve+v2) : <code>Vector2</code>
    * [.v3](#CubicBezierCurve+v3) : <code>Vector2</code>
    * [.getPoint(t, [optionalTarget])](#CubicBezierCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_CubicBezierCurve_new"></a>

### new CubicBezierCurve([v0], [v1], [v2], [v3])
Constructs a new Cubic Bezier curve.


| Param | Type | Description |
| --- | --- | --- |
| [v0] | <code>Vector2</code> | The start point. |
| [v1] | <code>Vector2</code> | The first control point. |
| [v2] | <code>Vector2</code> | The second control point. |
| [v3] | <code>Vector2</code> | The end point. |

<a name="CubicBezierCurve+isCubicBezierCurve"></a>

### cubicBezierCurve.isCubicBezierCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubicBezierCurve+v0"></a>

### cubicBezierCurve.v0 : <code>Vector2</code>
The start point.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
<a name="CubicBezierCurve+v1"></a>

### cubicBezierCurve.v1 : <code>Vector2</code>
The first control point.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
<a name="CubicBezierCurve+v2"></a>

### cubicBezierCurve.v2 : <code>Vector2</code>
The second control point.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
<a name="CubicBezierCurve+v3"></a>

### cubicBezierCurve.v3 : <code>Vector2</code>
The end point.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
<a name="CubicBezierCurve+getPoint"></a>

### cubicBezierCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the curve.

**Kind**: instance method of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
**Returns**: <code>Vector2</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="CubicBezierCurve3"></a>

## CubicBezierCurve3 ⇐ <code>Curve</code>
A curve representing a 3D Cubic Bezier curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [CubicBezierCurve3](#CubicBezierCurve3) ⇐ <code>Curve</code>
    * [new CubicBezierCurve3([v0], [v1], [v2], [v3])](#new_CubicBezierCurve3_new)
    * [.isCubicBezierCurve3](#CubicBezierCurve3+isCubicBezierCurve3) : <code>boolean</code>
    * [.v0](#CubicBezierCurve3+v0) : <code>Vector3</code>
    * [.v1](#CubicBezierCurve3+v1) : <code>Vector3</code>
    * [.v2](#CubicBezierCurve3+v2) : <code>Vector3</code>
    * [.v3](#CubicBezierCurve3+v3) : <code>Vector3</code>
    * [.getPoint(t, [optionalTarget])](#CubicBezierCurve3+getPoint) ⇒ <code>Vector3</code>

<a name="new_CubicBezierCurve3_new"></a>

### new CubicBezierCurve3([v0], [v1], [v2], [v3])
Constructs a new Cubic Bezier curve.


| Param | Type | Description |
| --- | --- | --- |
| [v0] | <code>Vector3</code> | The start point. |
| [v1] | <code>Vector3</code> | The first control point. |
| [v2] | <code>Vector3</code> | The second control point. |
| [v3] | <code>Vector3</code> | The end point. |

<a name="CubicBezierCurve3+isCubicBezierCurve3"></a>

### cubicBezierCurve3.isCubicBezierCurve3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubicBezierCurve3+v0"></a>

### cubicBezierCurve3.v0 : <code>Vector3</code>
The start point.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
<a name="CubicBezierCurve3+v1"></a>

### cubicBezierCurve3.v1 : <code>Vector3</code>
The first control point.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
<a name="CubicBezierCurve3+v2"></a>

### cubicBezierCurve3.v2 : <code>Vector3</code>
The second control point.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
<a name="CubicBezierCurve3+v3"></a>

### cubicBezierCurve3.v3 : <code>Vector3</code>
The end point.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
<a name="CubicBezierCurve3+getPoint"></a>

### cubicBezierCurve3.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a point on the curve.

**Kind**: instance method of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="EllipseCurve"></a>

## EllipseCurve ⇐ <code>Curve</code>
A curve representing an ellipse.

```js
const curve = new THREE.EllipseCurve(
	0, 0,
	10, 10,
	0, 2 * Math.PI,
	false,
	0
);

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const ellipse = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [EllipseCurve](#EllipseCurve) ⇐ <code>Curve</code>
    * [new EllipseCurve([aX], [aY], [xRadius], [yRadius], [aStartAngle], [aEndAngle], [aClockwise], [aRotation])](#new_EllipseCurve_new)
    * [.isEllipseCurve](#EllipseCurve+isEllipseCurve) : <code>boolean</code>
    * [.aX](#EllipseCurve+aX) : <code>number</code>
    * [.aY](#EllipseCurve+aY) : <code>number</code>
    * [.xRadius](#EllipseCurve+xRadius) : <code>number</code>
    * [.yRadius](#EllipseCurve+yRadius) : <code>number</code>
    * [.aStartAngle](#EllipseCurve+aStartAngle) : <code>number</code>
    * [.aEndAngle](#EllipseCurve+aEndAngle) : <code>number</code>
    * [.aClockwise](#EllipseCurve+aClockwise) : <code>boolean</code>
    * [.aRotation](#EllipseCurve+aRotation) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#EllipseCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_EllipseCurve_new"></a>

### new EllipseCurve([aX], [aY], [xRadius], [yRadius], [aStartAngle], [aEndAngle], [aClockwise], [aRotation])
Constructs a new ellipse curve.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [aX] | <code>number</code> | <code>0</code> | The X center of the ellipse. |
| [aY] | <code>number</code> | <code>0</code> | The Y center of the ellipse. |
| [xRadius] | <code>number</code> | <code>1</code> | The radius of the ellipse in the x direction. |
| [yRadius] | <code>number</code> | <code>1</code> | The radius of the ellipse in the y direction. |
| [aStartAngle] | <code>number</code> | <code>0</code> | The start angle of the curve in radians starting from the positive X axis. |
| [aEndAngle] | <code>number</code> | <code>Math.PI*2</code> | The end angle of the curve in radians starting from the positive X axis. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether the ellipse is drawn clockwise or not. |
| [aRotation] | <code>number</code> | <code>0</code> | The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. |

<a name="EllipseCurve+isEllipseCurve"></a>

### ellipseCurve.isEllipseCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="EllipseCurve+aX"></a>

### ellipseCurve.aX : <code>number</code>
The X center of the ellipse.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>0</code>  
<a name="EllipseCurve+aY"></a>

### ellipseCurve.aY : <code>number</code>
The Y center of the ellipse.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>0</code>  
<a name="EllipseCurve+xRadius"></a>

### ellipseCurve.xRadius : <code>number</code>
The radius of the ellipse in the x direction.
Setting the this value equal to the [yRadius](#EllipseCurve+yRadius) will result in a circle.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>1</code>  
<a name="EllipseCurve+yRadius"></a>

### ellipseCurve.yRadius : <code>number</code>
The radius of the ellipse in the y direction.
Setting the this value equal to the [xRadius](#EllipseCurve+xRadius) will result in a circle.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>1</code>  
<a name="EllipseCurve+aStartAngle"></a>

### ellipseCurve.aStartAngle : <code>number</code>
The start angle of the curve in radians starting from the positive X axis.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>0</code>  
<a name="EllipseCurve+aEndAngle"></a>

### ellipseCurve.aEndAngle : <code>number</code>
The end angle of the curve in radians starting from the positive X axis.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>Math.PI*2</code>  
<a name="EllipseCurve+aClockwise"></a>

### ellipseCurve.aClockwise : <code>boolean</code>
Whether the ellipse is drawn clockwise or not.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>false</code>  
<a name="EllipseCurve+aRotation"></a>

### ellipseCurve.aRotation : <code>number</code>
The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>0</code>  
<a name="EllipseCurve+getPoint"></a>

### ellipseCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the curve.

**Kind**: instance method of [<code>EllipseCurve</code>](#EllipseCurve)  
**Returns**: <code>Vector2</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="LineCurve"></a>

## LineCurve ⇐ <code>Curve</code>
A curve representing a 2D line segment.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [LineCurve](#LineCurve) ⇐ <code>Curve</code>
    * [new LineCurve([v1], [v2])](#new_LineCurve_new)
    * [.isLineCurve](#LineCurve+isLineCurve) : <code>boolean</code>
    * [.v1](#LineCurve+v1) : <code>Vector2</code>
    * [.v2](#LineCurve+v2) : <code>Vector2</code>
    * [.getPoint(t, [optionalTarget])](#LineCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_LineCurve_new"></a>

### new LineCurve([v1], [v2])
Constructs a new line curve.


| Param | Type | Description |
| --- | --- | --- |
| [v1] | <code>Vector2</code> | The start point. |
| [v2] | <code>Vector2</code> | The end point. |

<a name="LineCurve+isLineCurve"></a>

### lineCurve.isLineCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineCurve</code>](#LineCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineCurve+v1"></a>

### lineCurve.v1 : <code>Vector2</code>
The start point.

**Kind**: instance property of [<code>LineCurve</code>](#LineCurve)  
<a name="LineCurve+v2"></a>

### lineCurve.v2 : <code>Vector2</code>
The end point.

**Kind**: instance property of [<code>LineCurve</code>](#LineCurve)  
<a name="LineCurve+getPoint"></a>

### lineCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the line.

**Kind**: instance method of [<code>LineCurve</code>](#LineCurve)  
**Returns**: <code>Vector2</code> - The position on the line.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the line. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="LineCurve3"></a>

## LineCurve3 ⇐ <code>Curve</code>
A curve representing a 3D line segment.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [LineCurve3](#LineCurve3) ⇐ <code>Curve</code>
    * [new LineCurve3([v1], [v2])](#new_LineCurve3_new)
    * [.isLineCurve3](#LineCurve3+isLineCurve3) : <code>boolean</code>
    * [.v1](#LineCurve3+v1) : <code>Vector3</code>
    * [.v2](#LineCurve3+v2) : <code>Vector2</code>
    * [.getPoint(t, [optionalTarget])](#LineCurve3+getPoint) ⇒ <code>Vector3</code>

<a name="new_LineCurve3_new"></a>

### new LineCurve3([v1], [v2])
Constructs a new line curve.


| Param | Type | Description |
| --- | --- | --- |
| [v1] | <code>Vector3</code> | The start point. |
| [v2] | <code>Vector3</code> | The end point. |

<a name="LineCurve3+isLineCurve3"></a>

### lineCurve3.isLineCurve3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineCurve3</code>](#LineCurve3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineCurve3+v1"></a>

### lineCurve3.v1 : <code>Vector3</code>
The start point.

**Kind**: instance property of [<code>LineCurve3</code>](#LineCurve3)  
<a name="LineCurve3+v2"></a>

### lineCurve3.v2 : <code>Vector2</code>
The end point.

**Kind**: instance property of [<code>LineCurve3</code>](#LineCurve3)  
<a name="LineCurve3+getPoint"></a>

### lineCurve3.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a point on the line.

**Kind**: instance method of [<code>LineCurve3</code>](#LineCurve3)  
**Returns**: <code>Vector3</code> - The position on the line.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the line. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="QuadraticBezierCurve"></a>

## QuadraticBezierCurve ⇐ <code>Curve</code>
A curve representing a 2D Quadratic Bezier curve.

```js
const curve = new THREE.QuadraticBezierCurve(
	new THREE.Vector2( - 10, 0 ),
	new THREE.Vector2( 20, 15 ),
	new THREE.Vector2( 10, 0 )
)

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const curveObject = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [QuadraticBezierCurve](#QuadraticBezierCurve) ⇐ <code>Curve</code>
    * [new QuadraticBezierCurve([v0], [v1], [v2])](#new_QuadraticBezierCurve_new)
    * [.isQuadraticBezierCurve](#QuadraticBezierCurve+isQuadraticBezierCurve) : <code>boolean</code>
    * [.v0](#QuadraticBezierCurve+v0) : <code>Vector2</code>
    * [.v1](#QuadraticBezierCurve+v1) : <code>Vector2</code>
    * [.v2](#QuadraticBezierCurve+v2) : <code>Vector2</code>
    * [.getPoint(t, [optionalTarget])](#QuadraticBezierCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_QuadraticBezierCurve_new"></a>

### new QuadraticBezierCurve([v0], [v1], [v2])
Constructs a new Quadratic Bezier curve.


| Param | Type | Description |
| --- | --- | --- |
| [v0] | <code>Vector2</code> | The start point. |
| [v1] | <code>Vector2</code> | The control point. |
| [v2] | <code>Vector2</code> | The end point. |

<a name="QuadraticBezierCurve+isQuadraticBezierCurve"></a>

### quadraticBezierCurve.isQuadraticBezierCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="QuadraticBezierCurve+v0"></a>

### quadraticBezierCurve.v0 : <code>Vector2</code>
The start point.

**Kind**: instance property of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
<a name="QuadraticBezierCurve+v1"></a>

### quadraticBezierCurve.v1 : <code>Vector2</code>
The control point.

**Kind**: instance property of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
<a name="QuadraticBezierCurve+v2"></a>

### quadraticBezierCurve.v2 : <code>Vector2</code>
The end point.

**Kind**: instance property of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
<a name="QuadraticBezierCurve+getPoint"></a>

### quadraticBezierCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the curve.

**Kind**: instance method of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
**Returns**: <code>Vector2</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="QuadraticBezierCurve3"></a>

## QuadraticBezierCurve3 ⇐ <code>Curve</code>
A curve representing a 3D Quadratic Bezier curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [QuadraticBezierCurve3](#QuadraticBezierCurve3) ⇐ <code>Curve</code>
    * [new QuadraticBezierCurve3([v0], [v1], [v2])](#new_QuadraticBezierCurve3_new)
    * [.isQuadraticBezierCurve3](#QuadraticBezierCurve3+isQuadraticBezierCurve3) : <code>boolean</code>
    * [.v0](#QuadraticBezierCurve3+v0) : <code>Vector3</code>
    * [.v1](#QuadraticBezierCurve3+v1) : <code>Vector3</code>
    * [.v2](#QuadraticBezierCurve3+v2) : <code>Vector3</code>
    * [.getPoint(t, [optionalTarget])](#QuadraticBezierCurve3+getPoint) ⇒ <code>Vector3</code>

<a name="new_QuadraticBezierCurve3_new"></a>

### new QuadraticBezierCurve3([v0], [v1], [v2])
Constructs a new Quadratic Bezier curve.


| Param | Type | Description |
| --- | --- | --- |
| [v0] | <code>Vector3</code> | The start point. |
| [v1] | <code>Vector3</code> | The control point. |
| [v2] | <code>Vector3</code> | The end point. |

<a name="QuadraticBezierCurve3+isQuadraticBezierCurve3"></a>

### quadraticBezierCurve3.isQuadraticBezierCurve3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="QuadraticBezierCurve3+v0"></a>

### quadraticBezierCurve3.v0 : <code>Vector3</code>
The start point.

**Kind**: instance property of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
<a name="QuadraticBezierCurve3+v1"></a>

### quadraticBezierCurve3.v1 : <code>Vector3</code>
The control point.

**Kind**: instance property of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
<a name="QuadraticBezierCurve3+v2"></a>

### quadraticBezierCurve3.v2 : <code>Vector3</code>
The end point.

**Kind**: instance property of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
<a name="QuadraticBezierCurve3+getPoint"></a>

### quadraticBezierCurve3.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a point on the curve.

**Kind**: instance method of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="SplineCurve"></a>

## SplineCurve ⇐ <code>Curve</code>
A curve representing a 2D spline curve.

```js
// Create a sine-like wave
const curve = new THREE.SplineCurve( [
	new THREE.Vector2( -10, 0 ),
	new THREE.Vector2( -5, 5 ),
	new THREE.Vector2( 0, 0 ),
	new THREE.Vector2( 5, -5 ),
	new THREE.Vector2( 10, 0 )
] );

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const splineObject = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [SplineCurve](#SplineCurve) ⇐ <code>Curve</code>
    * [new SplineCurve([points])](#new_SplineCurve_new)
    * [.isSplineCurve](#SplineCurve+isSplineCurve) : <code>boolean</code>
    * [.points](#SplineCurve+points) : <code>Array.&lt;Vector2&gt;</code>
    * [.getPoint(t, [optionalTarget])](#SplineCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_SplineCurve_new"></a>

### new SplineCurve([points])
Constructs a new 2D spline curve.


| Param | Type | Description |
| --- | --- | --- |
| [points] | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points defining the curve. |

<a name="SplineCurve+isSplineCurve"></a>

### splineCurve.isSplineCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SplineCurve</code>](#SplineCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SplineCurve+points"></a>

### splineCurve.points : <code>Array.&lt;Vector2&gt;</code>
An array of 2D points defining the curve.

**Kind**: instance property of [<code>SplineCurve</code>](#SplineCurve)  
<a name="SplineCurve+getPoint"></a>

### splineCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the curve.

**Kind**: instance method of [<code>SplineCurve</code>](#SplineCurve)  
**Returns**: <code>Vector2</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="BoxGeometry"></a>

## BoxGeometry ⇐ <code>BufferGeometry</code>
A geometry class for a rectangular cuboid with a given width, height, and depth.
On creation, the cuboid is centred on the origin, with each edge parallel to one
of the axes.

```js
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [BoxGeometry](#BoxGeometry) ⇐ <code>BufferGeometry</code>
    * [new BoxGeometry([width], [height], [depth], [widthSegments], [heightSegments], [depthSegments])](#new_BoxGeometry_new)
    * _instance_
        * [.parameters](#BoxGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#BoxGeometry.fromJSON) ⇒ [<code>BoxGeometry</code>](#BoxGeometry)

<a name="new_BoxGeometry_new"></a>

### new BoxGeometry([width], [height], [depth], [widthSegments], [heightSegments], [depthSegments])
Constructs a new box geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width. That is, the length of the edges parallel to the X axis. |
| [height] | <code>number</code> | <code>1</code> | The height. That is, the length of the edges parallel to the Y axis. |
| [depth] | <code>number</code> | <code>1</code> | The depth. That is, the length of the edges parallel to the Z axis. |
| [widthSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular faces along the width of the sides. |
| [heightSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular faces along the height of the sides. |
| [depthSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular faces along the depth of the sides. |

<a name="BoxGeometry+parameters"></a>

### boxGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>BoxGeometry</code>](#BoxGeometry)  
<a name="BoxGeometry.fromJSON"></a>

### BoxGeometry.fromJSON(data) ⇒ [<code>BoxGeometry</code>](#BoxGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>BoxGeometry</code>](#BoxGeometry)  
**Returns**: [<code>BoxGeometry</code>](#BoxGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="CapsuleGeometry"></a>

## CapsuleGeometry ⇐ <code>LatheGeometry</code>
A geometry class for a capsule with given radii and height. It is constructed using a lathe.

```js
const geometry = new THREE.CapsuleGeometry( 1, 1, 4, 8 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const capsule = new THREE.Mesh( geometry, material );
scene.add( capsule );
```

**Kind**: global class  
**Extends**: <code>LatheGeometry</code>  

* [CapsuleGeometry](#CapsuleGeometry) ⇐ <code>LatheGeometry</code>
    * [new CapsuleGeometry([radius], [length], [capSegments], [radialSegments])](#new_CapsuleGeometry_new)
    * _instance_
        * [.parameters](#CapsuleGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#CapsuleGeometry.fromJSON) ⇒ [<code>CapsuleGeometry</code>](#CapsuleGeometry)

<a name="new_CapsuleGeometry_new"></a>

### new CapsuleGeometry([radius], [length], [capSegments], [radialSegments])
Constructs a new capsule geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the capsule. |
| [length] | <code>number</code> | <code>1</code> | Length of the middle section. |
| [capSegments] | <code>number</code> | <code>4</code> | Number of curve segments used to build the caps. |
| [radialSegments] | <code>number</code> | <code>8</code> | Number of segmented faces around the circumference of the capsule. |

<a name="CapsuleGeometry+parameters"></a>

### capsuleGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>CapsuleGeometry</code>](#CapsuleGeometry)  
<a name="CapsuleGeometry.fromJSON"></a>

### CapsuleGeometry.fromJSON(data) ⇒ [<code>CapsuleGeometry</code>](#CapsuleGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>CapsuleGeometry</code>](#CapsuleGeometry)  
**Returns**: [<code>CapsuleGeometry</code>](#CapsuleGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="CircleGeometry"></a>

## CircleGeometry ⇐ <code>BufferGeometry</code>
A simple shape of Euclidean geometry. It is constructed from a
number of triangular segments that are oriented around a central point and
extend as far out as a given radius. It is built counter-clockwise from a
start angle and a given central angle. It can also be used to create
regular polygons, where the number of segments determines the number of
sides.

```js
const geometry = new THREE.CircleGeometry( 5, 32 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const circle = new THREE.Mesh( geometry, material );
scene.add( circle )
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [CircleGeometry](#CircleGeometry) ⇐ <code>BufferGeometry</code>
    * [new CircleGeometry([radius], [segments], [thetaStart], [thetaLength])](#new_CircleGeometry_new)
    * _instance_
        * [.parameters](#CircleGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#CircleGeometry.fromJSON) ⇒ [<code>CircleGeometry</code>](#CircleGeometry)

<a name="new_CircleGeometry_new"></a>

### new CircleGeometry([radius], [segments], [thetaStart], [thetaLength])
Constructs a new circle geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the circle. |
| [segments] | <code>number</code> | <code>32</code> | Number of segments (triangles), minimum = `3`. |
| [thetaStart] | <code>number</code> | <code>0</code> | Start angle for first segment in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI*2</code> | The central angle, often called theta, of the circular sector in radians. The default value results in a complete circle. |

<a name="CircleGeometry+parameters"></a>

### circleGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>CircleGeometry</code>](#CircleGeometry)  
<a name="CircleGeometry.fromJSON"></a>

### CircleGeometry.fromJSON(data) ⇒ [<code>CircleGeometry</code>](#CircleGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>CircleGeometry</code>](#CircleGeometry)  
**Returns**: [<code>CircleGeometry</code>](#CircleGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="ConeGeometry"></a>

## ConeGeometry ⇐ <code>CylinderGeometry</code>
A geometry class for representing a cone.

```js
const geometry = new THREE.ConeGeometry( 5, 20, 32 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const cone = new THREE.Mesh(geometry, material );
scene.add( cone );
```

**Kind**: global class  
**Extends**: <code>CylinderGeometry</code>  

* [ConeGeometry](#ConeGeometry) ⇐ <code>CylinderGeometry</code>
    * [new ConeGeometry([radius], [height], [radialSegments], [heightSegments], [openEnded], [thetaStart], [thetaLength])](#new_ConeGeometry_new)
    * _instance_
        * [.parameters](#ConeGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#ConeGeometry.fromJSON) ⇒ [<code>ConeGeometry</code>](#ConeGeometry)

<a name="new_ConeGeometry_new"></a>

### new ConeGeometry([radius], [height], [radialSegments], [heightSegments], [openEnded], [thetaStart], [thetaLength])
Constructs a new cone geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the cone base. |
| [height] | <code>number</code> | <code>1</code> | Height of the cone. |
| [radialSegments] | <code>number</code> | <code>32</code> | Number of segmented faces around the circumference of the cone. |
| [heightSegments] | <code>number</code> | <code>1</code> | Number of rows of faces along the height of the cone. |
| [openEnded] | <code>boolean</code> | <code>false</code> | Whether the base of the cone is open or capped. |
| [thetaStart] | <code>number</code> | <code>0</code> | Start angle for first segment, in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI*2</code> | The central angle, often called theta, of the circular sector, in radians. The default value results in a complete cone. |

<a name="ConeGeometry+parameters"></a>

### coneGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>ConeGeometry</code>](#ConeGeometry)  
<a name="ConeGeometry.fromJSON"></a>

### ConeGeometry.fromJSON(data) ⇒ [<code>ConeGeometry</code>](#ConeGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>ConeGeometry</code>](#ConeGeometry)  
**Returns**: [<code>ConeGeometry</code>](#ConeGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="CylinderGeometry"></a>

## CylinderGeometry ⇐ <code>BufferGeometry</code>
A geometry class for representing a cylinder.

```js
const geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const cylinder = new THREE.Mesh( geometry, material );
scene.add( cylinder );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [CylinderGeometry](#CylinderGeometry) ⇐ <code>BufferGeometry</code>
    * [new CylinderGeometry([radiusTop], [radiusBottom], [height], [radialSegments], [heightSegments], [openEnded], [thetaStart], [thetaLength])](#new_CylinderGeometry_new)
    * _instance_
        * [.parameters](#CylinderGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#CylinderGeometry.fromJSON) ⇒ [<code>CylinderGeometry</code>](#CylinderGeometry)

<a name="new_CylinderGeometry_new"></a>

### new CylinderGeometry([radiusTop], [radiusBottom], [height], [radialSegments], [heightSegments], [openEnded], [thetaStart], [thetaLength])
Constructs a new cylinder geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radiusTop] | <code>number</code> | <code>1</code> | Radius of the cylinder at the top. |
| [radiusBottom] | <code>number</code> | <code>1</code> | Radius of the cylinder at the bottom. |
| [height] | <code>number</code> | <code>1</code> | Height of the cylinder. |
| [radialSegments] | <code>number</code> | <code>32</code> | Number of segmented faces around the circumference of the cylinder. |
| [heightSegments] | <code>number</code> | <code>1</code> | Number of rows of faces along the height of the cylinder. |
| [openEnded] | <code>boolean</code> | <code>false</code> | Whether the base of the cylinder is open or capped. |
| [thetaStart] | <code>number</code> | <code>0</code> | Start angle for first segment, in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI*2</code> | The central angle, often called theta, of the circular sector, in radians. The default value results in a complete cylinder. |

<a name="CylinderGeometry+parameters"></a>

### cylinderGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>CylinderGeometry</code>](#CylinderGeometry)  
<a name="CylinderGeometry.fromJSON"></a>

### CylinderGeometry.fromJSON(data) ⇒ [<code>CylinderGeometry</code>](#CylinderGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>CylinderGeometry</code>](#CylinderGeometry)  
**Returns**: [<code>CylinderGeometry</code>](#CylinderGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="DodecahedronGeometry"></a>

## DodecahedronGeometry ⇐ <code>PolyhedronGeometry</code>
A geometry class for representing a dodecahedron.

```js
const geometry = new THREE.DodecahedronGeometry();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const dodecahedron = new THREE.Mesh( geometry, material );
scene.add( dodecahedron );
```

**Kind**: global class  
**Extends**: <code>PolyhedronGeometry</code>  

* [DodecahedronGeometry](#DodecahedronGeometry) ⇐ <code>PolyhedronGeometry</code>
    * [new DodecahedronGeometry([radius], [detail])](#new_DodecahedronGeometry_new)
    * _instance_
        * [.parameters](#DodecahedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#DodecahedronGeometry.fromJSON) ⇒ [<code>DodecahedronGeometry</code>](#DodecahedronGeometry)

<a name="new_DodecahedronGeometry_new"></a>

### new DodecahedronGeometry([radius], [detail])
Constructs a new dodecahedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the dodecahedron. |
| [detail] | <code>number</code> | <code>0</code> | Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron. |

<a name="DodecahedronGeometry+parameters"></a>

### dodecahedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>DodecahedronGeometry</code>](#DodecahedronGeometry)  
<a name="DodecahedronGeometry.fromJSON"></a>

### DodecahedronGeometry.fromJSON(data) ⇒ [<code>DodecahedronGeometry</code>](#DodecahedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>DodecahedronGeometry</code>](#DodecahedronGeometry)  
**Returns**: [<code>DodecahedronGeometry</code>](#DodecahedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="EdgesGeometry"></a>

## EdgesGeometry ⇐ <code>BufferGeometry</code>
Can be used as a helper object to view the edges of a geometry.

```js
const geometry = new THREE.BoxGeometry();
const edges = new THREE.EdgesGeometry( geometry );
const line = new THREE.LineSegments( edges );
scene.add( line );
```

Note: It is not yet possible to serialize/deserialize instances of this class.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [EdgesGeometry](#EdgesGeometry) ⇐ <code>BufferGeometry</code>
    * [new EdgesGeometry([geometry], [thresholdAngle])](#new_EdgesGeometry_new)
    * [.parameters](#EdgesGeometry+parameters) : <code>Object</code>

<a name="new_EdgesGeometry_new"></a>

### new EdgesGeometry([geometry], [thresholdAngle])
Constructs a new edges geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | <code></code> | The geometry. |
| [thresholdAngle] | <code>number</code> | <code>1</code> | An edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. |

<a name="EdgesGeometry+parameters"></a>

### edgesGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>EdgesGeometry</code>](#EdgesGeometry)  
<a name="ExtrudeGeometry"></a>

## ExtrudeGeometry ⇐ <code>BufferGeometry</code>
Creates extruded geometry from a path shape.

```js
const length = 12, width = 8;

const shape = new THREE.Shape();
shape.moveTo( 0,0 );
shape.lineTo( 0, width );
shape.lineTo( length, width );
shape.lineTo( length, 0 );
shape.lineTo( 0, 0 );

const geometry = new THREE.ExtrudeGeometry( shape );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const mesh = new THREE.Mesh( geometry, material ) ;
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [ExtrudeGeometry](#ExtrudeGeometry) ⇐ <code>BufferGeometry</code>
    * [new ExtrudeGeometry([shapes], [options])](#new_ExtrudeGeometry_new)
    * _instance_
        * [.parameters](#ExtrudeGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data, shapes)](#ExtrudeGeometry.fromJSON) ⇒ [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)
    * _inner_
        * [~Options](#ExtrudeGeometry..Options) : <code>Object</code>

<a name="new_ExtrudeGeometry_new"></a>

### new ExtrudeGeometry([shapes], [options])
Constructs a new extrude geometry.


| Param | Type | Description |
| --- | --- | --- |
| [shapes] | <code>Shape</code> \| <code>Array.&lt;Shape&gt;</code> | A shape or an array of shapes. |
| [options] | [<code>Options</code>](#ExtrudeGeometry..Options) | The extrude settings. |

<a name="ExtrudeGeometry+parameters"></a>

### extrudeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)  
<a name="ExtrudeGeometry.fromJSON"></a>

### ExtrudeGeometry.fromJSON(data, shapes) ⇒ [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)  
**Returns**: [<code>ExtrudeGeometry</code>](#ExtrudeGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |
| shapes | <code>Array.&lt;Shape&gt;</code> | An array of shapes. |

<a name="ExtrudeGeometry..Options"></a>

### ExtrudeGeometry~Options : <code>Object</code>
Represents the `options` type of the geometry's constructor.

**Kind**: inner typedef of [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [curveSegments] | <code>number</code> | <code>12</code> | Number of points on the curves. |
| [steps] | <code>number</code> | <code>1</code> | Number of points used for subdividing segments along the depth of the extruded spline. |
| [depth] | <code>number</code> | <code>1</code> | Depth to extrude the shape. |
| [bevelEnabled] | <code>boolean</code> | <code>true</code> | Whether to beveling to the shape or not. |
| [bevelThickness] | <code>number</code> | <code>0.2</code> | How deep into the original shape the bevel goes. |
| [bevelSize] | <code>number</code> | <code>bevelThickness-0.1</code> | Distance from the shape outline that the bevel extends. |
| [bevelOffset] | <code>number</code> | <code>0</code> | Distance from the shape outline that the bevel starts. |
| [bevelSegments] | <code>number</code> | <code>3</code> | Number of bevel layers. |
| [extrudePath] | <code>Curve</code> | <code></code> | A 3D spline path along which the shape should be extruded. Bevels not supported for path extrusion. |
| [UVGenerator] | <code>Object</code> |  | An object that provides UV generator functions for custom UV generation. |

<a name="IcosahedronGeometry"></a>

## IcosahedronGeometry ⇐ <code>PolyhedronGeometry</code>
A geometry class for representing an icosahedron.

```js
const geometry = new THREE.IcosahedronGeometry();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const icosahedron = new THREE.Mesh( geometry, material );
scene.add( icosahedron );
```

**Kind**: global class  
**Extends**: <code>PolyhedronGeometry</code>  

* [IcosahedronGeometry](#IcosahedronGeometry) ⇐ <code>PolyhedronGeometry</code>
    * [new IcosahedronGeometry([radius], [detail])](#new_IcosahedronGeometry_new)
    * _instance_
        * [.parameters](#IcosahedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#IcosahedronGeometry.fromJSON) ⇒ [<code>IcosahedronGeometry</code>](#IcosahedronGeometry)

<a name="new_IcosahedronGeometry_new"></a>

### new IcosahedronGeometry([radius], [detail])
Constructs a new icosahedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the icosahedron. |
| [detail] | <code>number</code> | <code>0</code> | Setting this to a value greater than `0` adds vertices making it no longer a icosahedron. |

<a name="IcosahedronGeometry+parameters"></a>

### icosahedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>IcosahedronGeometry</code>](#IcosahedronGeometry)  
<a name="IcosahedronGeometry.fromJSON"></a>

### IcosahedronGeometry.fromJSON(data) ⇒ [<code>IcosahedronGeometry</code>](#IcosahedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>IcosahedronGeometry</code>](#IcosahedronGeometry)  
**Returns**: [<code>IcosahedronGeometry</code>](#IcosahedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="LatheGeometry"></a>

## LatheGeometry ⇐ <code>BufferGeometry</code>
Creates meshes with axial symmetry like vases. The lathe rotates around the Y axis.

```js
const points = [];
for ( let i = 0; i < 10; i ++ ) {
	points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );
}
const geometry = new THREE.LatheGeometry( points );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const lathe = new THREE.Mesh( geometry, material );
scene.add( lathe );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [LatheGeometry](#LatheGeometry) ⇐ <code>BufferGeometry</code>
    * [new LatheGeometry([points], [segments], [phiStart], [phiLength])](#new_LatheGeometry_new)
    * _instance_
        * [.parameters](#LatheGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#LatheGeometry.fromJSON) ⇒ [<code>LatheGeometry</code>](#LatheGeometry)

<a name="new_LatheGeometry_new"></a>

### new LatheGeometry([points], [segments], [phiStart], [phiLength])
Constructs a new lathe geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [points] | <code>Array.&lt;(Vector2\|Vector3)&gt;</code> |  | An array of points in 2D space. The x-coordinate of each point must be greater than zero. |
| [segments] | <code>number</code> | <code>12</code> | The number of circumference segments to generate. |
| [phiStart] | <code>number</code> | <code>0</code> | The starting angle in radians. |
| [phiLength] | <code>number</code> | <code>Math.PI*2</code> | The radian (0 to 2PI) range of the lathed section 2PI is a closed lathe, less than 2PI is a portion. |

<a name="LatheGeometry+parameters"></a>

### latheGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>LatheGeometry</code>](#LatheGeometry)  
<a name="LatheGeometry.fromJSON"></a>

### LatheGeometry.fromJSON(data) ⇒ [<code>LatheGeometry</code>](#LatheGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>LatheGeometry</code>](#LatheGeometry)  
**Returns**: [<code>LatheGeometry</code>](#LatheGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="OctahedronGeometry"></a>

## OctahedronGeometry ⇐ <code>PolyhedronGeometry</code>
A geometry class for representing an octahedron.

```js
const geometry = new THREE.OctahedronGeometry();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const octahedron = new THREE.Mesh( geometry, material );
scene.add( octahedron );
```

**Kind**: global class  
**Extends**: <code>PolyhedronGeometry</code>  

* [OctahedronGeometry](#OctahedronGeometry) ⇐ <code>PolyhedronGeometry</code>
    * [new OctahedronGeometry([radius], [detail])](#new_OctahedronGeometry_new)
    * _instance_
        * [.parameters](#OctahedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#OctahedronGeometry.fromJSON) ⇒ [<code>OctahedronGeometry</code>](#OctahedronGeometry)

<a name="new_OctahedronGeometry_new"></a>

### new OctahedronGeometry([radius], [detail])
Constructs a new octahedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the octahedron. |
| [detail] | <code>number</code> | <code>0</code> | Setting this to a value greater than `0` adds vertices making it no longer a octahedron. |

<a name="OctahedronGeometry+parameters"></a>

### octahedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>OctahedronGeometry</code>](#OctahedronGeometry)  
<a name="OctahedronGeometry.fromJSON"></a>

### OctahedronGeometry.fromJSON(data) ⇒ [<code>OctahedronGeometry</code>](#OctahedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>OctahedronGeometry</code>](#OctahedronGeometry)  
**Returns**: [<code>OctahedronGeometry</code>](#OctahedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="PlaneGeometry"></a>

## PlaneGeometry ⇐ <code>BufferGeometry</code>
A geometry class for representing a plane.

```js
const geometry = new THREE.PlaneGeometry( 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
const plane = new THREE.Mesh( geometry, material );
scene.add( plane );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [PlaneGeometry](#PlaneGeometry) ⇐ <code>BufferGeometry</code>
    * [new PlaneGeometry([width], [height], [widthSegments], [heightSegments])](#new_PlaneGeometry_new)
    * _instance_
        * [.parameters](#PlaneGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#PlaneGeometry.fromJSON) ⇒ [<code>PlaneGeometry</code>](#PlaneGeometry)

<a name="new_PlaneGeometry_new"></a>

### new PlaneGeometry([width], [height], [widthSegments], [heightSegments])
Constructs a new plane geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width along the X axis. |
| [height] | <code>number</code> | <code>1</code> | The height along the Y axis |
| [widthSegments] | <code>number</code> | <code>1</code> | The number of segments along the X axis. |
| [heightSegments] | <code>number</code> | <code>1</code> | The number of segments along the Y axis. |

<a name="PlaneGeometry+parameters"></a>

### planeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>PlaneGeometry</code>](#PlaneGeometry)  
<a name="PlaneGeometry.fromJSON"></a>

### PlaneGeometry.fromJSON(data) ⇒ [<code>PlaneGeometry</code>](#PlaneGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>PlaneGeometry</code>](#PlaneGeometry)  
**Returns**: [<code>PlaneGeometry</code>](#PlaneGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="PolyhedronGeometry"></a>

## PolyhedronGeometry ⇐ <code>BufferGeometry</code>
A polyhedron is a solid in three dimensions with flat faces. This class
will take an array of vertices, project them onto a sphere, and then
divide them up to the desired level of detail.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [PolyhedronGeometry](#PolyhedronGeometry) ⇐ <code>BufferGeometry</code>
    * [new PolyhedronGeometry([vertices], [indices], [radius], [detail])](#new_PolyhedronGeometry_new)
    * _instance_
        * [.parameters](#PolyhedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#PolyhedronGeometry.fromJSON) ⇒ [<code>PolyhedronGeometry</code>](#PolyhedronGeometry)

<a name="new_PolyhedronGeometry_new"></a>

### new PolyhedronGeometry([vertices], [indices], [radius], [detail])
Constructs a new polyhedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [vertices] | <code>Array.&lt;number&gt;</code> |  | A flat array of vertices describing the base shape. |
| [indices] | <code>Array.&lt;number&gt;</code> |  | A flat array of indices describing the base shape. |
| [radius] | <code>number</code> | <code>1</code> | The radius of the shape. |
| [detail] | <code>number</code> | <code>0</code> | How many levels to subdivide the geometry. The more detail, the smoother the shape. |

<a name="PolyhedronGeometry+parameters"></a>

### polyhedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>PolyhedronGeometry</code>](#PolyhedronGeometry)  
<a name="PolyhedronGeometry.fromJSON"></a>

### PolyhedronGeometry.fromJSON(data) ⇒ [<code>PolyhedronGeometry</code>](#PolyhedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>PolyhedronGeometry</code>](#PolyhedronGeometry)  
**Returns**: [<code>PolyhedronGeometry</code>](#PolyhedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="RingGeometry"></a>

## RingGeometry ⇐ <code>BufferGeometry</code>
A class for generating a two-dimensional ring geometry.

```js
const geometry = new THREE.RingGeometry( 1, 5, 32 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [RingGeometry](#RingGeometry) ⇐ <code>BufferGeometry</code>
    * [new RingGeometry([innerRadius], [outerRadius], [thetaSegments], [phiSegments], [thetaStart], [thetaLength])](#new_RingGeometry_new)
    * _instance_
        * [.parameters](#RingGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#RingGeometry.fromJSON) ⇒ [<code>RingGeometry</code>](#RingGeometry)

<a name="new_RingGeometry_new"></a>

### new RingGeometry([innerRadius], [outerRadius], [thetaSegments], [phiSegments], [thetaStart], [thetaLength])
Constructs a new ring geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [innerRadius] | <code>number</code> | <code>0.5</code> | The inner radius of the ring. |
| [outerRadius] | <code>number</code> | <code>1</code> | The outer radius of the ring. |
| [thetaSegments] | <code>number</code> | <code>32</code> | Number of segments. A higher number means the ring will be more round. Minimum is `3`. |
| [phiSegments] | <code>number</code> | <code>1</code> | Number of segments per ring segment. Minimum is `1`. |
| [thetaStart] | <code>number</code> | <code>0</code> | Starting angle in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI*2</code> | Central angle in radians. |

<a name="RingGeometry+parameters"></a>

### ringGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>RingGeometry</code>](#RingGeometry)  
<a name="RingGeometry.fromJSON"></a>

### RingGeometry.fromJSON(data) ⇒ [<code>RingGeometry</code>](#RingGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>RingGeometry</code>](#RingGeometry)  
**Returns**: [<code>RingGeometry</code>](#RingGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="ShapeGeometry"></a>

## ShapeGeometry ⇐ <code>BufferGeometry</code>
Creates an one-sided polygonal geometry from one or more path shapes.

```js
const arcShape = new THREE.Shape()
	.moveTo( 5, 1 )
	.absarc( 1, 1, 4, 0, Math.PI * 2, false );

const geometry = new THREE.ShapeGeometry( arcShape );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.DoubleSide } );
const mesh = new THREE.Mesh( geometry, material ) ;
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [ShapeGeometry](#ShapeGeometry) ⇐ <code>BufferGeometry</code>
    * [new ShapeGeometry([shapes], [curveSegments])](#new_ShapeGeometry_new)
    * _instance_
        * [.parameters](#ShapeGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data, shapes)](#ShapeGeometry.fromJSON) ⇒ [<code>ShapeGeometry</code>](#ShapeGeometry)

<a name="new_ShapeGeometry_new"></a>

### new ShapeGeometry([shapes], [curveSegments])
Constructs a new shape geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [shapes] | <code>Shape</code> \| <code>Array.&lt;Shape&gt;</code> |  | A shape or an array of shapes. |
| [curveSegments] | <code>number</code> | <code>12</code> | Number of segments per shape. |

<a name="ShapeGeometry+parameters"></a>

### shapeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>ShapeGeometry</code>](#ShapeGeometry)  
<a name="ShapeGeometry.fromJSON"></a>

### ShapeGeometry.fromJSON(data, shapes) ⇒ [<code>ShapeGeometry</code>](#ShapeGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>ShapeGeometry</code>](#ShapeGeometry)  
**Returns**: [<code>ShapeGeometry</code>](#ShapeGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |
| shapes | <code>Array.&lt;Shape&gt;</code> | An array of shapes. |

<a name="SphereGeometry"></a>

## SphereGeometry ⇐ <code>BufferGeometry</code>
A class for generating a sphere geometry.

```js
const geometry = new THREE.SphereGeometry( 15, 32, 16 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const sphere = new THREE.Mesh( geometry, material );
scene.add( sphere );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [SphereGeometry](#SphereGeometry) ⇐ <code>BufferGeometry</code>
    * [new SphereGeometry([radius], [widthSegments], [heightSegments], [phiStart], [phiLength], [thetaStart], [thetaLength])](#new_SphereGeometry_new)
    * _instance_
        * [.parameters](#SphereGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#SphereGeometry.fromJSON) ⇒ [<code>SphereGeometry</code>](#SphereGeometry)

<a name="new_SphereGeometry_new"></a>

### new SphereGeometry([radius], [widthSegments], [heightSegments], [phiStart], [phiLength], [thetaStart], [thetaLength])
Constructs a new sphere geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | The sphere radius. |
| [widthSegments] | <code>number</code> | <code>32</code> | The number of horizontal segments. Minimum value is `3`. |
| [heightSegments] | <code>number</code> | <code>16</code> | The number of vertical segments. Minimum value is `2`. |
| [phiStart] | <code>number</code> | <code>0</code> | The horizontal starting angle in radians. |
| [phiLength] | <code>number</code> | <code>Math.PI*2</code> | The horizontal sweep angle size. |
| [thetaStart] | <code>number</code> | <code>0</code> | The vertical starting angle in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI</code> | The vertical sweep angle size. |

<a name="SphereGeometry+parameters"></a>

### sphereGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>SphereGeometry</code>](#SphereGeometry)  
<a name="SphereGeometry.fromJSON"></a>

### SphereGeometry.fromJSON(data) ⇒ [<code>SphereGeometry</code>](#SphereGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>SphereGeometry</code>](#SphereGeometry)  
**Returns**: [<code>SphereGeometry</code>](#SphereGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="TetrahedronGeometry"></a>

## TetrahedronGeometry ⇐ <code>PolyhedronGeometry</code>
A geometry class for representing an tetrahedron.

```js
const geometry = new THREE.TetrahedronGeometry();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const tetrahedron = new THREE.Mesh( geometry, material );
scene.add( tetrahedron );
```

**Kind**: global class  
**Extends**: <code>PolyhedronGeometry</code>  

* [TetrahedronGeometry](#TetrahedronGeometry) ⇐ <code>PolyhedronGeometry</code>
    * [new TetrahedronGeometry([radius], [detail])](#new_TetrahedronGeometry_new)
    * _instance_
        * [.parameters](#TetrahedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#TetrahedronGeometry.fromJSON) ⇒ [<code>TetrahedronGeometry</code>](#TetrahedronGeometry)

<a name="new_TetrahedronGeometry_new"></a>

### new TetrahedronGeometry([radius], [detail])
Constructs a new tetrahedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the tetrahedron. |
| [detail] | <code>number</code> | <code>0</code> | Setting this to a value greater than `0` adds vertices making it no longer a tetrahedron. |

<a name="TetrahedronGeometry+parameters"></a>

### tetrahedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>TetrahedronGeometry</code>](#TetrahedronGeometry)  
<a name="TetrahedronGeometry.fromJSON"></a>

### TetrahedronGeometry.fromJSON(data) ⇒ [<code>TetrahedronGeometry</code>](#TetrahedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>TetrahedronGeometry</code>](#TetrahedronGeometry)  
**Returns**: [<code>TetrahedronGeometry</code>](#TetrahedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="TorusGeometry"></a>

## TorusGeometry ⇐ <code>BufferGeometry</code>
A geometry class for representing an torus.

```js
const geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const torus = new THREE.Mesh( geometry, material );
scene.add( torus );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [TorusGeometry](#TorusGeometry) ⇐ <code>BufferGeometry</code>
    * [new TorusGeometry([radius], [tube], [radialSegments], [tubularSegments], [arc])](#new_TorusGeometry_new)
    * _instance_
        * [.parameters](#TorusGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#TorusGeometry.fromJSON) ⇒ [<code>TorusGeometry</code>](#TorusGeometry)

<a name="new_TorusGeometry_new"></a>

### new TorusGeometry([radius], [tube], [radialSegments], [tubularSegments], [arc])
Constructs a new torus geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the torus, from the center of the torus to the center of the tube. |
| [tube] | <code>number</code> | <code>0.4</code> | Radius of the tube. Must be smaller than `radius`. |
| [radialSegments] | <code>number</code> | <code>12</code> | The number of radial segments. |
| [tubularSegments] | <code>number</code> | <code>48</code> | The number of tubular segments. |
| [arc] | <code>number</code> | <code>Math.PI*2</code> | Central angle in radians. |

<a name="TorusGeometry+parameters"></a>

### torusGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>TorusGeometry</code>](#TorusGeometry)  
<a name="TorusGeometry.fromJSON"></a>

### TorusGeometry.fromJSON(data) ⇒ [<code>TorusGeometry</code>](#TorusGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>TorusGeometry</code>](#TorusGeometry)  
**Returns**: [<code>TorusGeometry</code>](#TorusGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="TorusKnotGeometry"></a>

## TorusKnotGeometry ⇐ <code>BufferGeometry</code>
Creates a torus knot, the particular shape of which is defined by a pair
of coprime integers, p and q. If p and q are not coprime, the result will
be a torus link.

```js
const geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const torusKnot = new THREE.Mesh( geometry, material );
scene.add( torusKnot );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [TorusKnotGeometry](#TorusKnotGeometry) ⇐ <code>BufferGeometry</code>
    * [new TorusKnotGeometry([radius], [tube], [tubularSegments], [radialSegments], [p], [q])](#new_TorusKnotGeometry_new)
    * _instance_
        * [.parameters](#TorusKnotGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#TorusKnotGeometry.fromJSON) ⇒ [<code>TorusKnotGeometry</code>](#TorusKnotGeometry)

<a name="new_TorusKnotGeometry_new"></a>

### new TorusKnotGeometry([radius], [tube], [tubularSegments], [radialSegments], [p], [q])
Constructs a new torus knot geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the torus knot. |
| [tube] | <code>number</code> | <code>0.4</code> | Radius of the tube. |
| [tubularSegments] | <code>number</code> | <code>64</code> | The number of tubular segments. |
| [radialSegments] | <code>number</code> | <code>8</code> | The number of radial segments. |
| [p] | <code>number</code> | <code>2</code> | This value determines, how many times the geometry winds around its axis of rotational symmetry. |
| [q] | <code>number</code> | <code>3</code> | This value determines, how many times the geometry winds around a circle in the interior of the torus. |

<a name="TorusKnotGeometry+parameters"></a>

### torusKnotGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>TorusKnotGeometry</code>](#TorusKnotGeometry)  
<a name="TorusKnotGeometry.fromJSON"></a>

### TorusKnotGeometry.fromJSON(data) ⇒ [<code>TorusKnotGeometry</code>](#TorusKnotGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>TorusKnotGeometry</code>](#TorusKnotGeometry)  
**Returns**: [<code>TorusKnotGeometry</code>](#TorusKnotGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="TubeGeometry"></a>

## TubeGeometry ⇐ <code>BufferGeometry</code>
Creates a tube that extrudes along a 3D curve.

```js
class CustomSinCurve extends THREE.Curve {

	getPoint( t, optionalTarget = new THREE.Vector3() ) {

		const tx = t * 3 - 1.5;
		const ty = Math.sin( 2 * Math.PI * t );
		const tz = 0;

		return optionalTarget.set( tx, ty, tz );
	}

}

const path = new CustomSinCurve( 10 );
const geometry = new THREE.TubeGeometry( path, 20, 2, 8, false );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [TubeGeometry](#TubeGeometry) ⇐ <code>BufferGeometry</code>
    * [new TubeGeometry([path], [tubularSegments], [radius], [radialSegments], [closed])](#new_TubeGeometry_new)
    * _instance_
        * [.parameters](#TubeGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#TubeGeometry.fromJSON) ⇒ [<code>TubeGeometry</code>](#TubeGeometry)

<a name="new_TubeGeometry_new"></a>

### new TubeGeometry([path], [tubularSegments], [radius], [radialSegments], [closed])
Constructs a new tube geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [path] | <code>Curve</code> | <code>QuadraticBezierCurve3</code> | A 3D curve defining the path of the tube. |
| [tubularSegments] | <code>number</code> | <code>64</code> | The number of segments that make up the tube. |
| [radius] | <code>number</code> | <code>1</code> | The radius of the tube. |
| [radialSegments] | <code>number</code> | <code>8</code> | The number of segments that make up the cross-section. |
| [closed] | <code>boolean</code> | <code>false</code> | Whether the tube is closed or not. |

<a name="TubeGeometry+parameters"></a>

### tubeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>TubeGeometry</code>](#TubeGeometry)  
<a name="TubeGeometry.fromJSON"></a>

### TubeGeometry.fromJSON(data) ⇒ [<code>TubeGeometry</code>](#TubeGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>TubeGeometry</code>](#TubeGeometry)  
**Returns**: [<code>TubeGeometry</code>](#TubeGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="WireframeGeometry"></a>

## WireframeGeometry ⇐ <code>BufferGeometry</code>
Can be used as a helper object to visualize a geometry as a wireframe.

```js
const geometry = new THREE.SphereGeometry();

const wireframe = new THREE.WireframeGeometry( geometry );

const line = new THREE.LineSegments( wireframe );
line.material.depthWrite = false;
line.material.opacity = 0.25;
line.material.transparent = true;

scene.add( line );
```

Note: It is not yet possible to serialize/deserialize instances of this class.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [WireframeGeometry](#WireframeGeometry) ⇐ <code>BufferGeometry</code>
    * [new WireframeGeometry([geometry])](#new_WireframeGeometry_new)
    * [.parameters](#WireframeGeometry+parameters) : <code>Object</code>

<a name="new_WireframeGeometry_new"></a>

### new WireframeGeometry([geometry])
Constructs a new wireframe geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | <code></code> | The geometry. |

<a name="WireframeGeometry+parameters"></a>

### wireframeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>WireframeGeometry</code>](#WireframeGeometry)  
<a name="ArrowHelper"></a>

## ArrowHelper ⇐ <code>Object3D</code>
An 3D arrow object for visualizing directions.

```js
const dir = new THREE.Vector3( 1, 2, 0 );

//normalize the direction vector (convert to vector of length 1)
dir.normalize();

const origin = new THREE.Vector3( 0, 0, 0 );
const length = 1;
const hex = 0xffff00;

const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
scene.add( arrowHelper );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [ArrowHelper](#ArrowHelper) ⇐ <code>Object3D</code>
    * [new ArrowHelper([dir], [origin], [length], [color], [headLength], [headWidth])](#new_ArrowHelper_new)
    * [.line](#ArrowHelper+line) : <code>Line</code>
    * [.cone](#ArrowHelper+cone) : <code>Mesh</code>
    * [.setDirection(dir)](#ArrowHelper+setDirection)
    * [.setLength(length, [headLength], [headWidth])](#ArrowHelper+setLength)
    * [.setColor(color)](#ArrowHelper+setColor)
    * [.dispose()](#ArrowHelper+dispose)

<a name="new_ArrowHelper_new"></a>

### new ArrowHelper([dir], [origin], [length], [color], [headLength], [headWidth])
Constructs a new arrow helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [dir] | <code>Vector3</code> | <code>(0, 0, 1)</code> | The (normalized) direction vector. |
| [origin] | <code>Vector3</code> | <code>(0, 0, 0)</code> | Point at which the arrow starts. |
| [length] | <code>number</code> | <code>1</code> | Length of the arrow in world units. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | Color of the arrow. |
| [headLength] | <code>number</code> | <code>length*0.2</code> | The length of the head of the arrow. |
| [headWidth] | <code>number</code> | <code>headLength*0.2</code> | The width of the head of the arrow. |

<a name="ArrowHelper+line"></a>

### arrowHelper.line : <code>Line</code>
The line part of the arrow helper.

**Kind**: instance property of [<code>ArrowHelper</code>](#ArrowHelper)  
<a name="ArrowHelper+cone"></a>

### arrowHelper.cone : <code>Mesh</code>
The cone part of the arrow helper.

**Kind**: instance property of [<code>ArrowHelper</code>](#ArrowHelper)  
<a name="ArrowHelper+setDirection"></a>

### arrowHelper.setDirection(dir)
Sets the direction of the helper.

**Kind**: instance method of [<code>ArrowHelper</code>](#ArrowHelper)  

| Param | Type | Description |
| --- | --- | --- |
| dir | <code>Vector3</code> | The normalized direction vector. |

<a name="ArrowHelper+setLength"></a>

### arrowHelper.setLength(length, [headLength], [headWidth])
Sets the length of the helper.

**Kind**: instance method of [<code>ArrowHelper</code>](#ArrowHelper)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| length | <code>number</code> |  | Length of the arrow in world units. |
| [headLength] | <code>number</code> | <code>length*0.2</code> | The length of the head of the arrow. |
| [headWidth] | <code>number</code> | <code>headLength*0.2</code> | The width of the head of the arrow. |

<a name="ArrowHelper+setColor"></a>

### arrowHelper.setColor(color)
Sets the color of the helper.

**Kind**: instance method of [<code>ArrowHelper</code>](#ArrowHelper)  

| Param | Type | Description |
| --- | --- | --- |
| color | <code>number</code> \| <code>Color</code> \| <code>string</code> | The color to set. |

<a name="ArrowHelper+dispose"></a>

### arrowHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>ArrowHelper</code>](#ArrowHelper)  
<a name="AxesHelper"></a>

## AxesHelper ⇐ <code>LineSegments</code>
An axis object to visualize the 3 axes in a simple way.
The X axis is red. The Y axis is green. The Z axis is blue.

```js
const axesHelper = new THREE.AxesHelper( 5 );
scene.add( axesHelper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [AxesHelper](#AxesHelper) ⇐ <code>LineSegments</code>
    * [new AxesHelper([size])](#new_AxesHelper_new)
    * [.setColors(xAxisColor, yAxisColor, zAxisColor)](#AxesHelper+setColors) ⇒ [<code>AxesHelper</code>](#AxesHelper)
    * [.dispose()](#AxesHelper+dispose)

<a name="new_AxesHelper_new"></a>

### new AxesHelper([size])
Constructs a new axes helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>1</code> | Size of the lines representing the axes. |

<a name="AxesHelper+setColors"></a>

### axesHelper.setColors(xAxisColor, yAxisColor, zAxisColor) ⇒ [<code>AxesHelper</code>](#AxesHelper)
Defines the colors of the axes helper.

**Kind**: instance method of [<code>AxesHelper</code>](#AxesHelper)  
**Returns**: [<code>AxesHelper</code>](#AxesHelper) - A reference to this axes helper.  

| Param | Type | Description |
| --- | --- | --- |
| xAxisColor | <code>number</code> \| <code>Color</code> \| <code>string</code> | The color for the x axis. |
| yAxisColor | <code>number</code> \| <code>Color</code> \| <code>string</code> | The color for the y axis. |
| zAxisColor | <code>number</code> \| <code>Color</code> \| <code>string</code> | The color for the z axis. |

<a name="AxesHelper+dispose"></a>

### axesHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>AxesHelper</code>](#AxesHelper)  
<a name="Box3Helper"></a>

## Box3Helper ⇐ <code>LineSegments</code>
A helper object to visualize an instance of [Box3](Box3).

```js
const box = new THREE.Box3();
box.setFromCenterAndSize( new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 2, 1, 3 ) );

const helper = new THREE.Box3Helper( box, 0xffff00 );
scene.add( helper )
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [Box3Helper](#Box3Helper) ⇐ <code>LineSegments</code>
    * [new Box3Helper(box, [color])](#new_Box3Helper_new)
    * [.box](#Box3Helper+box) : <code>Box3</code>
    * [.dispose()](#Box3Helper+dispose)

<a name="new_Box3Helper_new"></a>

### new Box3Helper(box, [color])
Constructs a new box3 helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| box | <code>Box3</code> |  | The box to visualize. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | The box's color. |

<a name="Box3Helper+box"></a>

### box3Helper.box : <code>Box3</code>
The box being visualized.

**Kind**: instance property of [<code>Box3Helper</code>](#Box3Helper)  
<a name="Box3Helper+dispose"></a>

### box3Helper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Box3Helper</code>](#Box3Helper)  
<a name="BoxHelper"></a>

## BoxHelper ⇐ <code>LineSegments</code>
Helper object to graphically show the world-axis-aligned bounding box
around an object. The actual bounding box is handled with [Box3](Box3),
this is just a visual helper for debugging. It can be automatically
resized with [update](#BoxHelper+update) when the object it's created from
is transformed. Note that the object must have a geometry for this to work,
so it won't work with sprites.

```js
const sphere = new THREE.SphereGeometry();
const object = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( 0xff0000 ) );
const box = new THREE.BoxHelper( object, 0xffff00 );
scene.add( box );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [BoxHelper](#BoxHelper) ⇐ <code>LineSegments</code>
    * [new BoxHelper([object], [color])](#new_BoxHelper_new)
    * [.object](#BoxHelper+object) : <code>Object3D</code>
    * [.update()](#BoxHelper+update)
    * [.setFromObject(object)](#BoxHelper+setFromObject) ⇒ [<code>BoxHelper</code>](#BoxHelper)
    * [.dispose()](#BoxHelper+dispose)

<a name="new_BoxHelper_new"></a>

### new BoxHelper([object], [color])
Constructs a new box helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [object] | <code>Object3D</code> |  | The 3D object to show the world-axis-aligned bounding box. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | The box's color. |

<a name="BoxHelper+object"></a>

### boxHelper.object : <code>Object3D</code>
The 3D object being visualized.

**Kind**: instance property of [<code>BoxHelper</code>](#BoxHelper)  
<a name="BoxHelper+update"></a>

### boxHelper.update()
Updates the helper's geometry to match the dimensions of the object,
including any children.

**Kind**: instance method of [<code>BoxHelper</code>](#BoxHelper)  
<a name="BoxHelper+setFromObject"></a>

### boxHelper.setFromObject(object) ⇒ [<code>BoxHelper</code>](#BoxHelper)
Updates the wireframe box for the passed object.

**Kind**: instance method of [<code>BoxHelper</code>](#BoxHelper)  
**Returns**: [<code>BoxHelper</code>](#BoxHelper) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to create the helper for. |

<a name="BoxHelper+dispose"></a>

### boxHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>BoxHelper</code>](#BoxHelper)  
<a name="CameraHelper"></a>

## CameraHelper ⇐ <code>LineSegments</code>
This helps with visualizing what a camera contains in its frustum. It
visualizes the frustum of a camera using a line segments.

Based on frustum visualization in [lightgl.js shadowmap example](https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html).

`CameraHelper` must be a child of the scene.

```js
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
const helper = new THREE.CameraHelper( camera );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [CameraHelper](#CameraHelper) ⇐ <code>LineSegments</code>
    * [new CameraHelper(camera)](#new_CameraHelper_new)
    * [.camera](#CameraHelper+camera) : <code>Camera</code>
    * [.pointMap](#CameraHelper+pointMap) : <code>Object.&lt;string, Array.&lt;number&gt;&gt;</code>
    * [.setColors(frustum, cone, up, target, cross)](#CameraHelper+setColors)
    * [.update()](#CameraHelper+update)
    * [.dispose()](#CameraHelper+dispose)

<a name="new_CameraHelper_new"></a>

### new CameraHelper(camera)
Constructs a new arrow helper.


| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera to visualize. |

<a name="CameraHelper+camera"></a>

### cameraHelper.camera : <code>Camera</code>
The camera being visualized.

**Kind**: instance property of [<code>CameraHelper</code>](#CameraHelper)  
<a name="CameraHelper+pointMap"></a>

### cameraHelper.pointMap : <code>Object.&lt;string, Array.&lt;number&gt;&gt;</code>
This contains the points used to visualize the camera.

**Kind**: instance property of [<code>CameraHelper</code>](#CameraHelper)  
<a name="CameraHelper+setColors"></a>

### cameraHelper.setColors(frustum, cone, up, target, cross)
Defines the colors of the helper.

**Kind**: instance method of [<code>CameraHelper</code>](#CameraHelper)  

| Param | Type | Description |
| --- | --- | --- |
| frustum | <code>Color</code> | The frustum line color. |
| cone | <code>Color</code> | The cone line color. |
| up | <code>Color</code> | The up line color. |
| target | <code>Color</code> | The target line color. |
| cross | <code>Color</code> | The cross line color. |

<a name="CameraHelper+update"></a>

### cameraHelper.update()
Updates the helper based on the projection matrix of the camera.

**Kind**: instance method of [<code>CameraHelper</code>](#CameraHelper)  
<a name="CameraHelper+dispose"></a>

### cameraHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>CameraHelper</code>](#CameraHelper)  
<a name="DirectionalLightHelper"></a>

## DirectionalLightHelper ⇐ <code>Object3D</code>
Helper object to assist with visualizing a [DirectionalLight](DirectionalLight)'s
effect on the scene. This consists of plane and a line representing the
light's position and direction.

```js
const light = new THREE.DirectionalLight( 0xFFFFFF );
scene.add( light );

const helper = new THREE.DirectionalLightHelper( light, 5 );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [DirectionalLightHelper](#DirectionalLightHelper) ⇐ <code>Object3D</code>
    * [new DirectionalLightHelper(light, [size], [color])](#new_DirectionalLightHelper_new)
    * [.light](#DirectionalLightHelper+light) : <code>DirectionalLight</code>
    * [.color](#DirectionalLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.lightPlane](#DirectionalLightHelper+lightPlane) : <code>Line</code>
    * [.targetLine](#DirectionalLightHelper+targetLine) : <code>Line</code>
    * [.dispose()](#DirectionalLightHelper+dispose)
    * [.update()](#DirectionalLightHelper+update)

<a name="new_DirectionalLightHelper_new"></a>

### new DirectionalLightHelper(light, [size], [color])
Constructs a new directional light helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>DirectionalLight</code> |  | The light to be visualized. |
| [size] | <code>number</code> | <code>1</code> | The dimensions of the plane. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> |  | The helper's color. If not set, the helper will take the color of the light. |

<a name="DirectionalLightHelper+light"></a>

### directionalLightHelper.light : <code>DirectionalLight</code>
The light being visualized.

**Kind**: instance property of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+color"></a>

### directionalLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The color parameter passed in the constructor.
If not set, the helper will take the color of the light.

**Kind**: instance property of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+lightPlane"></a>

### directionalLightHelper.lightPlane : <code>Line</code>
Contains the line showing the location of the directional light.

**Kind**: instance property of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+targetLine"></a>

### directionalLightHelper.targetLine : <code>Line</code>
Represents the target line of the directional light.

**Kind**: instance property of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+dispose"></a>

### directionalLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+update"></a>

### directionalLightHelper.update()
Updates the helper to match the position and direction of the
light being visualized.

**Kind**: instance method of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="GridHelper"></a>

## GridHelper ⇐ <code>LineSegments</code>
The helper is an object to define grids. Grids are two-dimensional
arrays of lines.

```js
const size = 10;
const divisions = 10;

const gridHelper = new THREE.GridHelper( size, divisions );
scene.add( gridHelper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [GridHelper](#GridHelper) ⇐ <code>LineSegments</code>
    * [new GridHelper([size], [divisions], [color1], [color2])](#new_GridHelper_new)
    * [.dispose()](#GridHelper+dispose)

<a name="new_GridHelper_new"></a>

### new GridHelper([size], [divisions], [color1], [color2])
Constructs a new grid helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>10</code> | The size of the grid. |
| [divisions] | <code>number</code> | <code>10</code> | The number of divisions across the grid. |
| [color1] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x444444</code> | The color of the center line. |
| [color2] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x888888</code> | The color of the lines of the grid. |

<a name="GridHelper+dispose"></a>

### gridHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>GridHelper</code>](#GridHelper)  
<a name="HemisphereLightHelper"></a>

## HemisphereLightHelper ⇐ <code>Object3D</code>
Creates a visual aid consisting of a spherical mesh for a
given [HemisphereLight](HemisphereLight).

```js
const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
const helper = new THREE.HemisphereLightHelper( light, 5 );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [HemisphereLightHelper](#HemisphereLightHelper) ⇐ <code>Object3D</code>
    * [new HemisphereLightHelper(light, [size], [color])](#new_HemisphereLightHelper_new)
    * [.light](#HemisphereLightHelper+light) : <code>HemisphereLight</code>
    * [.color](#HemisphereLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.dispose()](#HemisphereLightHelper+dispose)
    * [.update()](#HemisphereLightHelper+update)

<a name="new_HemisphereLightHelper_new"></a>

### new HemisphereLightHelper(light, [size], [color])
Constructs a new hemisphere light helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>HemisphereLight</code> |  | The light to be visualized. |
| [size] | <code>number</code> | <code>1</code> | The size of the mesh used to visualize the light. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> |  | The helper's color. If not set, the helper will take the color of the light. |

<a name="HemisphereLightHelper+light"></a>

### hemisphereLightHelper.light : <code>HemisphereLight</code>
The light being visualized.

**Kind**: instance property of [<code>HemisphereLightHelper</code>](#HemisphereLightHelper)  
<a name="HemisphereLightHelper+color"></a>

### hemisphereLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The color parameter passed in the constructor.
If not set, the helper will take the color of the light.

**Kind**: instance property of [<code>HemisphereLightHelper</code>](#HemisphereLightHelper)  
<a name="HemisphereLightHelper+dispose"></a>

### hemisphereLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>HemisphereLightHelper</code>](#HemisphereLightHelper)  
<a name="HemisphereLightHelper+update"></a>

### hemisphereLightHelper.update()
Updates the helper to match the position and direction of the
light being visualized.

**Kind**: instance method of [<code>HemisphereLightHelper</code>](#HemisphereLightHelper)  
<a name="PlaneHelper"></a>

## PlaneHelper ⇐ <code>Line</code>
A helper object to visualize an instance of [Plane](Plane).

```js
const plane = new THREE.Plane( new THREE.Vector3( 1, 1, 0.2 ), 3 );
const helper = new THREE.PlaneHelper( plane, 1, 0xffff00 );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>Line</code>  

* [PlaneHelper](#PlaneHelper) ⇐ <code>Line</code>
    * [new PlaneHelper(plane, [size], [hex])](#new_PlaneHelper_new)
    * [.plane](#PlaneHelper+plane) : <code>Plane</code>
    * [.size](#PlaneHelper+size) : <code>number</code>
    * [.dispose()](#PlaneHelper+dispose)

<a name="new_PlaneHelper_new"></a>

### new PlaneHelper(plane, [size], [hex])
Constructs a new plane helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| plane | <code>Plane</code> |  | The plane to be visualized. |
| [size] | <code>number</code> | <code>1</code> | The side length of plane helper. |
| [hex] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | The helper's color. |

<a name="PlaneHelper+plane"></a>

### planeHelper.plane : <code>Plane</code>
The plane being visualized.

**Kind**: instance property of [<code>PlaneHelper</code>](#PlaneHelper)  
<a name="PlaneHelper+size"></a>

### planeHelper.size : <code>number</code>
The side length of plane helper.

**Kind**: instance property of [<code>PlaneHelper</code>](#PlaneHelper)  
**Default**: <code>1</code>  
<a name="PlaneHelper+dispose"></a>

### planeHelper.dispose()
Updates the helper to match the position and direction of the
light being visualized.

**Kind**: instance method of [<code>PlaneHelper</code>](#PlaneHelper)  
<a name="PointLightHelper"></a>

## PointLightHelper ⇐ <code>Mesh</code>
This displays a helper object consisting of a spherical mesh for
visualizing an instance of [PointLight](PointLight).

```js
const pointLight = new THREE.PointLight( 0xff0000, 1, 100 );
pointLight.position.set( 10, 10, 10 );
scene.add( pointLight );

const sphereSize = 1;
const pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
scene.add( pointLightHelper );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [PointLightHelper](#PointLightHelper) ⇐ <code>Mesh</code>
    * [new PointLightHelper(light, [sphereSize], [color])](#new_PointLightHelper_new)
    * [.light](#PointLightHelper+light) : <code>HemisphereLight</code>
    * [.color](#PointLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.dispose()](#PointLightHelper+dispose)
    * [.update()](#PointLightHelper+update)

<a name="new_PointLightHelper_new"></a>

### new PointLightHelper(light, [sphereSize], [color])
Constructs a new point light helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>PointLight</code> |  | The light to be visualized. |
| [sphereSize] | <code>number</code> | <code>1</code> | The size of the sphere helper. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> |  | The helper's color. If not set, the helper will take the color of the light. |

<a name="PointLightHelper+light"></a>

### pointLightHelper.light : <code>HemisphereLight</code>
The light being visualized.

**Kind**: instance property of [<code>PointLightHelper</code>](#PointLightHelper)  
<a name="PointLightHelper+color"></a>

### pointLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The color parameter passed in the constructor.
If not set, the helper will take the color of the light.

**Kind**: instance property of [<code>PointLightHelper</code>](#PointLightHelper)  
<a name="PointLightHelper+dispose"></a>

### pointLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>PointLightHelper</code>](#PointLightHelper)  
<a name="PointLightHelper+update"></a>

### pointLightHelper.update()
Updates the helper to match the position of the
light being visualized.

**Kind**: instance method of [<code>PointLightHelper</code>](#PointLightHelper)  
<a name="PolarGridHelper"></a>

## PolarGridHelper ⇐ <code>LineSegments</code>
This helper is an object to define polar grids. Grids are
two-dimensional arrays of lines.

```js
const radius = 10;
const sectors = 16;
const rings = 8;
const divisions = 64;

const helper = new THREE.PolarGridHelper( radius, sectors, rings, divisions );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [PolarGridHelper](#PolarGridHelper) ⇐ <code>LineSegments</code>
    * [new PolarGridHelper([radius], [sectors], [rings], [divisions], [color1], [color2])](#new_PolarGridHelper_new)
    * [.dispose()](#PolarGridHelper+dispose)

<a name="new_PolarGridHelper_new"></a>

### new PolarGridHelper([radius], [sectors], [rings], [divisions], [color1], [color2])
Constructs a new polar grid helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>10</code> | The radius of the polar grid. This can be any positive number. |
| [sectors] | <code>number</code> | <code>16</code> | The number of sectors the grid will be divided into. This can be any positive integer. |
| [rings] | <code>number</code> | <code>16</code> | The number of rings. This can be any positive integer. |
| [divisions] | <code>number</code> | <code>64</code> | The number of line segments used for each circle. This can be any positive integer. |
| [color1] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x444444</code> | The first color used for grid elements. |
| [color2] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x888888</code> | The second color used for grid elements. |

<a name="PolarGridHelper+dispose"></a>

### polarGridHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>PolarGridHelper</code>](#PolarGridHelper)  
<a name="SkeletonHelper"></a>

## SkeletonHelper ⇐ <code>LineSegments</code>
A helper object to assist with visualizing a [Skeleton](Skeleton).

```js
const helper = new THREE.SkeletonHelper( skinnedMesh );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [SkeletonHelper](#SkeletonHelper) ⇐ <code>LineSegments</code>
    * [new SkeletonHelper(object)](#new_SkeletonHelper_new)
    * [.isSkeletonHelper](#SkeletonHelper+isSkeletonHelper) : <code>boolean</code>
    * [.root](#SkeletonHelper+root) : <code>Object3D</code>
    * [.bones](#SkeletonHelper+bones) : <code>Array.&lt;Bone&gt;</code>
    * [.dispose()](#SkeletonHelper+dispose)

<a name="new_SkeletonHelper_new"></a>

### new SkeletonHelper(object)
Constructs a new hemisphere light helper.


| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | Usually an instance of [SkinnedMesh](SkinnedMesh). However, any 3D object can be used if it represents a hierarchy of bones (see [Bone](Bone)). |

<a name="SkeletonHelper+isSkeletonHelper"></a>

### skeletonHelper.isSkeletonHelper : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SkeletonHelper</code>](#SkeletonHelper)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SkeletonHelper+root"></a>

### skeletonHelper.root : <code>Object3D</code>
The object being visualized.

**Kind**: instance property of [<code>SkeletonHelper</code>](#SkeletonHelper)  
<a name="SkeletonHelper+bones"></a>

### skeletonHelper.bones : <code>Array.&lt;Bone&gt;</code>
he list of bones that the helper visualizes.

**Kind**: instance property of [<code>SkeletonHelper</code>](#SkeletonHelper)  
<a name="SkeletonHelper+dispose"></a>

### skeletonHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>SkeletonHelper</code>](#SkeletonHelper)  
<a name="SpotLightHelper"></a>

## SpotLightHelper ⇐ <code>Object3D</code>
This displays a cone shaped helper object for a [SpotLight](SpotLight).

```js
const spotLight = new THREE.SpotLight( 0xffffff );
spotLight.position.set( 10, 10, 10 );
scene.add( spotLight );

const spotLightHelper = new THREE.SpotLightHelper( spotLight );
scene.add( spotLightHelper );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [SpotLightHelper](#SpotLightHelper) ⇐ <code>Object3D</code>
    * [new SpotLightHelper(light, [color])](#new_SpotLightHelper_new)
    * [.light](#SpotLightHelper+light) : <code>SpotLight</code>
    * [.color](#SpotLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.dispose()](#SpotLightHelper+dispose)
    * [.update()](#SpotLightHelper+update)

<a name="new_SpotLightHelper_new"></a>

### new SpotLightHelper(light, [color])
Constructs a new spot light helper.


| Param | Type | Description |
| --- | --- | --- |
| light | <code>HemisphereLight</code> | The light to be visualized. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | The helper's color. If not set, the helper will take the color of the light. |

<a name="SpotLightHelper+light"></a>

### spotLightHelper.light : <code>SpotLight</code>
The light being visualized.

**Kind**: instance property of [<code>SpotLightHelper</code>](#SpotLightHelper)  
<a name="SpotLightHelper+color"></a>

### spotLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The color parameter passed in the constructor.
If not set, the helper will take the color of the light.

**Kind**: instance property of [<code>SpotLightHelper</code>](#SpotLightHelper)  
<a name="SpotLightHelper+dispose"></a>

### spotLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>SpotLightHelper</code>](#SpotLightHelper)  
<a name="SpotLightHelper+update"></a>

### spotLightHelper.update()
Updates the helper to match the position and direction of the
light being visualized.

**Kind**: instance method of [<code>SpotLightHelper</code>](#SpotLightHelper)  
<a name="AmbientLight"></a>

## AmbientLight ⇐ <code>Light</code>
This light globally illuminates all objects in the scene equally.

It cannot be used to cast shadows as it does not have a direction.

```js
const light = new THREE.AmbientLight( 0x404040 ); // soft white light
scene.add( light );
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [AmbientLight](#AmbientLight) ⇐ <code>Light</code>
    * [new AmbientLight([color], [intensity])](#new_AmbientLight_new)
    * [.isAmbientLight](#AmbientLight+isAmbientLight) : <code>boolean</code>

<a name="new_AmbientLight_new"></a>

### new AmbientLight([color], [intensity])
Constructs a new ambient light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="AmbientLight+isAmbientLight"></a>

### ambientLight.isAmbientLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>AmbientLight</code>](#AmbientLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DirectionalLight"></a>

## DirectionalLight ⇐ <code>Light</code>
A light that gets emitted in a specific direction. This light will behave
as though it is infinitely far away and the rays produced from it are all
parallel. The common use case for this is to simulate daylight; the sun is
far enough away that its position can be considered to be infinite, and
all light rays coming from it are parallel.

A common point of confusion for directional lights is that setting the
rotation has no effect. This is because three.js's DirectionalLight is the
equivalent to what is often called a 'Target Direct Light' in other
applications.

This means that its direction is calculated as pointing from the light's
[Object3D#position](Object3D#position) to the [target](#DirectionalLight+target) position
(as opposed to a 'Free Direct Light' that just has a rotation
component).

This light can cast shadows - see the [DirectionalLightShadow](DirectionalLightShadow) for details.

```js
// White directional light at half intensity shining from the top.
const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
scene.add( directionalLight );
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [DirectionalLight](#DirectionalLight) ⇐ <code>Light</code>
    * [new DirectionalLight([color], [intensity])](#new_DirectionalLight_new)
    * [.isDirectionalLight](#DirectionalLight+isDirectionalLight) : <code>boolean</code>
    * [.target](#DirectionalLight+target) : <code>Object3D</code>
    * [.shadow](#DirectionalLight+shadow) : <code>DirectionalLightShadow</code>

<a name="new_DirectionalLight_new"></a>

### new DirectionalLight([color], [intensity])
Constructs a new directional light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="DirectionalLight+isDirectionalLight"></a>

### directionalLight.isDirectionalLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DirectionalLight</code>](#DirectionalLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DirectionalLight+target"></a>

### directionalLight.target : <code>Object3D</code>
The directional light points from its position to the
target's position.

For the target's position to be changed to anything other
than the default, it must be added to the scene.

It is also possible to set the target to be another 3D object
in the scene. The light will now track the target object.

**Kind**: instance property of [<code>DirectionalLight</code>](#DirectionalLight)  
<a name="DirectionalLight+shadow"></a>

### directionalLight.shadow : <code>DirectionalLightShadow</code>
This property holds the light's shadow configuration.

**Kind**: instance property of [<code>DirectionalLight</code>](#DirectionalLight)  
<a name="DirectionalLightShadow"></a>

## DirectionalLightShadow ⇐ <code>LightShadow</code>
Represents the shadow configuration of directional lights.

**Kind**: global class  
**Extends**: <code>LightShadow</code>  

* [DirectionalLightShadow](#DirectionalLightShadow) ⇐ <code>LightShadow</code>
    * [new DirectionalLightShadow()](#new_DirectionalLightShadow_new)
    * [.isDirectionalLightShadow](#DirectionalLightShadow+isDirectionalLightShadow) : <code>boolean</code>

<a name="new_DirectionalLightShadow_new"></a>

### new DirectionalLightShadow()
Constructs a new directional light shadow.

<a name="DirectionalLightShadow+isDirectionalLightShadow"></a>

### directionalLightShadow.isDirectionalLightShadow : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DirectionalLightShadow</code>](#DirectionalLightShadow)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="HemisphereLight"></a>

## HemisphereLight ⇐ <code>Light</code>
A light source positioned directly above the scene, with color fading from
the sky color to the ground color.

This light cannot be used to cast shadows.

```js
const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
scene.add( light );
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [HemisphereLight](#HemisphereLight) ⇐ <code>Light</code>
    * [new HemisphereLight([skyColor], [groundColor], [intensity])](#new_HemisphereLight_new)
    * [.isHemisphereLight](#HemisphereLight+isHemisphereLight) : <code>boolean</code>
    * [.groundColor](#HemisphereLight+groundColor) : <code>Color</code>

<a name="new_HemisphereLight_new"></a>

### new HemisphereLight([skyColor], [groundColor], [intensity])
Constructs a new hemisphere light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [skyColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's sky color. |
| [groundColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's ground color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="HemisphereLight+isHemisphereLight"></a>

### hemisphereLight.isHemisphereLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>HemisphereLight</code>](#HemisphereLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="HemisphereLight+groundColor"></a>

### hemisphereLight.groundColor : <code>Color</code>
The light's ground color.

**Kind**: instance property of [<code>HemisphereLight</code>](#HemisphereLight)  
<a name="Light"></a>

## *Light ⇐ <code>Object3D</code>*
Abstract base class for lights - all other light types inherit the
properties and methods described here.

**Kind**: global abstract class  
**Extends**: <code>Object3D</code>  

* *[Light](#Light) ⇐ <code>Object3D</code>*
    * *[new Light([color], [intensity])](#new_Light_new)*
    * *[.isLight](#Light+isLight) : <code>boolean</code>*
    * *[.color](#Light+color) : <code>Color</code>*
    * *[.intensity](#Light+intensity) : <code>number</code>*
    * *[.dispose()](#Light+dispose)*

<a name="new_Light_new"></a>

### *new Light([color], [intensity])*
Constructs a new light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="Light+isLight"></a>

### *light.isLight : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>Light</code>](#Light)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Light+color"></a>

### *light.color : <code>Color</code>*
The light's color.

**Kind**: instance property of [<code>Light</code>](#Light)  
<a name="Light+intensity"></a>

### *light.intensity : <code>number</code>*
The light's intensity.

**Kind**: instance property of [<code>Light</code>](#Light)  
**Default**: <code>1</code>  
<a name="Light+dispose"></a>

### *light.dispose()*
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Light</code>](#Light)  
<a name="LightProbe"></a>

## LightProbe ⇐ <code>Light</code>
Light probes are an alternative way of adding light to a 3D scene. Unlike
classical light sources (e.g. directional, point or spot lights), light
probes do not emit light. Instead they store information about light
passing through 3D space. During rendering, the light that hits a 3D
object is approximated by using the data from the light probe.

Light probes are usually created from (radiance) environment maps. The
class [LightProbeGenerator](LightProbeGenerator) can be used to create light probes from
cube textures or render targets. However, light estimation data could also
be provided in other forms e.g. by WebXR. This enables the rendering of
augmented reality content that reacts to real world lighting.

The current probe implementation in three.js supports so-called diffuse
light probes. This type of light probe is functionally equivalent to an
irradiance environment map.

**Kind**: global class  
**Extends**: <code>Light</code>  

* [LightProbe](#LightProbe) ⇐ <code>Light</code>
    * [new LightProbe(sh, [intensity])](#new_LightProbe_new)
    * [.isLightProbe](#LightProbe+isLightProbe) : <code>boolean</code>
    * [.sh](#LightProbe+sh) : <code>SphericalHarmonics3</code>
    * [.fromJSON(json)](#LightProbe+fromJSON) ⇒ [<code>LightProbe</code>](#LightProbe)

<a name="new_LightProbe_new"></a>

### new LightProbe(sh, [intensity])
Constructs a new light probe.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| sh | <code>SphericalHarmonics3</code> |  | The spherical harmonics which represents encoded lighting information. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="LightProbe+isLightProbe"></a>

### lightProbe.isLightProbe : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LightProbe</code>](#LightProbe)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LightProbe+sh"></a>

### lightProbe.sh : <code>SphericalHarmonics3</code>
A light probe uses spherical harmonics to encode lighting information.

**Kind**: instance property of [<code>LightProbe</code>](#LightProbe)  
<a name="LightProbe+fromJSON"></a>

### lightProbe.fromJSON(json) ⇒ [<code>LightProbe</code>](#LightProbe)
Deserializes the light prove from the given JSON.

**Kind**: instance method of [<code>LightProbe</code>](#LightProbe)  
**Returns**: [<code>LightProbe</code>](#LightProbe) - A reference to this light probe.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON holding the serialized light probe. |

<a name="LightShadow"></a>

## *LightShadow*
Abstract base class for light shadow classes. These classes
represent the shadow configuration for different light types.

**Kind**: global abstract class  

* *[LightShadow](#LightShadow)*
    * *[new LightShadow(camera)](#new_LightShadow_new)*
    * *[.camera](#LightShadow+camera) : <code>Camera</code>*
    * *[.intensity](#LightShadow+intensity) : <code>number</code>*
    * *[.bias](#LightShadow+bias) : <code>number</code>*
    * *[.normalBias](#LightShadow+normalBias) : <code>number</code>*
    * *[.radius](#LightShadow+radius) : <code>number</code>*
    * *[.blurSamples](#LightShadow+blurSamples) : <code>number</code>*
    * *[.mapSize](#LightShadow+mapSize) : <code>Vector2</code>*
    * *[.map](#LightShadow+map) : <code>RenderTarget</code>*
    * *[.mapPass](#LightShadow+mapPass) : <code>RenderTarget</code>*
    * *[.matrix](#LightShadow+matrix) : <code>Matrix4</code>*
    * *[.autoUpdate](#LightShadow+autoUpdate) : <code>boolean</code>*
    * *[.needsUpdate](#LightShadow+needsUpdate) : <code>boolean</code>*
    * *[.getViewportCount()](#LightShadow+getViewportCount) ⇒ <code>number</code>*
    * *[.getFrustum()](#LightShadow+getFrustum) ⇒ <code>Frustum</code>*
    * *[.updateMatrices(light)](#LightShadow+updateMatrices)*
    * *[.getViewport(viewportIndex)](#LightShadow+getViewport) ⇒ <code>Vector4</code>*
    * *[.getFrameExtents()](#LightShadow+getFrameExtents) ⇒ <code>Vector2</code>*
    * *[.dispose()](#LightShadow+dispose)*
    * *[.copy(source)](#LightShadow+copy) ⇒ [<code>LightShadow</code>](#LightShadow)*
    * *[.clone()](#LightShadow+clone) ⇒ [<code>LightShadow</code>](#LightShadow)*
    * *[.toJSON()](#LightShadow+toJSON) ⇒ <code>Object</code>*

<a name="new_LightShadow_new"></a>

### *new LightShadow(camera)*
Constructs a new light shadow.


| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The light's view of the world. |

<a name="LightShadow+camera"></a>

### *lightShadow.camera : <code>Camera</code>*
The light's view of the world.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
<a name="LightShadow+intensity"></a>

### *lightShadow.intensity : <code>number</code>*
The intensity of the shadow. The default is `1`.
Valid values are in the range `[0, 1]`.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>1</code>  
<a name="LightShadow+bias"></a>

### *lightShadow.bias : <code>number</code>*
Shadow map bias, how much to add or subtract from the normalized depth
when deciding whether a surface is in shadow.

The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
may help reduce artifacts in shadows.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>0</code>  
<a name="LightShadow+normalBias"></a>

### *lightShadow.normalBias : <code>number</code>*
Defines how much the position used to query the shadow map is offset along
the object normal. The default is `0`. Increasing this value can be used to
reduce shadow acne especially in large scenes where light shines onto
geometry at a shallow angle. The cost is that shadows may appear distorted.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>0</code>  
<a name="LightShadow+radius"></a>

### *lightShadow.radius : <code>number</code>*
Setting this to values greater than 1 will blur the edges of the shadow.
High values will cause unwanted banding effects in the shadows - a greater
map size will allow for a higher value to be used here before these effects
become visible.

The property has no effect when the shadow map type is `PCFSoftShadowMap` and
and it is recommended to increase softness by decreasing the shadow map size instead.

The property has no effect when the shadow map type is `BasicShadowMap`.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>1</code>  
<a name="LightShadow+blurSamples"></a>

### *lightShadow.blurSamples : <code>number</code>*
The amount of samples to use when blurring a VSM shadow map.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>8</code>  
<a name="LightShadow+mapSize"></a>

### *lightShadow.mapSize : <code>Vector2</code>*
Defines the width and height of the shadow map. Higher values give better quality
shadows at the cost of computation time. Values must be powers of two.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>(512,512)</code>  
<a name="LightShadow+map"></a>

### *lightShadow.map : <code>RenderTarget</code>*
The depth map generated using the internal camera; a location beyond a
pixel's depth is in shadow. Computed internally during rendering.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>null</code>  
<a name="LightShadow+mapPass"></a>

### *lightShadow.mapPass : <code>RenderTarget</code>*
The distribution map generated using the internal camera; an occlusion is
calculated based on the distribution of depths. Computed internally during
rendering.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>null</code>  
<a name="LightShadow+matrix"></a>

### *lightShadow.matrix : <code>Matrix4</code>*
Model to shadow camera space, to compute location and depth in shadow map.
This is computed internally during rendering.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
<a name="LightShadow+autoUpdate"></a>

### *lightShadow.autoUpdate : <code>boolean</code>*
Enables automatic updates of the light's shadow. If you do not require dynamic
lighting / shadows, you may set this to `false`.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>true</code>  
<a name="LightShadow+needsUpdate"></a>

### *lightShadow.needsUpdate : <code>boolean</code>*
When set to `true`, shadow maps will be updated in the next `render` call.
If you have set [autoUpdate](#LightShadow+autoUpdate) to `false`, you will need to
set this property to `true` and then make a render call to update the light's shadow.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>false</code>  
<a name="LightShadow+getViewportCount"></a>

### *lightShadow.getViewportCount() ⇒ <code>number</code>*
Used internally by the renderer to get the number of viewports that need
to be rendered for this shadow.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>number</code> - The viewport count.  
<a name="LightShadow+getFrustum"></a>

### *lightShadow.getFrustum() ⇒ <code>Frustum</code>*
Gets the shadow cameras frustum. Used internally by the renderer to cull objects.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>Frustum</code> - The shadow camera frustum.  
<a name="LightShadow+updateMatrices"></a>

### *lightShadow.updateMatrices(light)*
Update the matrices for the camera and shadow, used internally by the renderer.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light for which the shadow is being rendered. |

<a name="LightShadow+getViewport"></a>

### *lightShadow.getViewport(viewportIndex) ⇒ <code>Vector4</code>*
Returns a viewport definition for the given viewport index.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>Vector4</code> - The viewport.  

| Param | Type | Description |
| --- | --- | --- |
| viewportIndex | <code>number</code> | The viewport index. |

<a name="LightShadow+getFrameExtents"></a>

### *lightShadow.getFrameExtents() ⇒ <code>Vector2</code>*
Returns the frame extends.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>Vector2</code> - The frame extends.  
<a name="LightShadow+dispose"></a>

### *lightShadow.dispose()*
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
<a name="LightShadow+copy"></a>

### *lightShadow.copy(source) ⇒ [<code>LightShadow</code>](#LightShadow)*
Copies the values of the given light shadow instance to this instance.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: [<code>LightShadow</code>](#LightShadow) - A reference to this light shadow instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>LightShadow</code>](#LightShadow) | The light shadow to copy. |

<a name="LightShadow+clone"></a>

### *lightShadow.clone() ⇒ [<code>LightShadow</code>](#LightShadow)*
Returns a new light shadow instance with copied values from this instance.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: [<code>LightShadow</code>](#LightShadow) - A clone of this instance.  
<a name="LightShadow+toJSON"></a>

### *lightShadow.toJSON() ⇒ <code>Object</code>*
Serializes the light shadow into JSON.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>Object</code> - A JSON object representing the serialized light shadow.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  
<a name="PointLight"></a>

## PointLight ⇐ <code>Light</code>
A light that gets emitted from a single point in all directions. A common
use case for this is to replicate the light emitted from a bare
lightbulb.

This light can cast shadows - see the [PointLightShadow](PointLightShadow) for details.

```js
const light = new THREE.PointLight( 0xff0000, 1, 100 );
light.position.set( 50, 50, 50 );
scene.add( light );
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [PointLight](#PointLight) ⇐ <code>Light</code>
    * [new PointLight([color], [intensity], [distance], [decay])](#new_PointLight_new)
    * [.isPointLight](#PointLight+isPointLight) : <code>boolean</code>
    * [.distance](#PointLight+distance) : <code>number</code>
    * [.decay](#PointLight+decay) : <code>number</code>
    * [.shadow](#PointLight+shadow) : <code>PointLightShadow</code>
    * [.power](#PointLight+power) : <code>number</code>

<a name="new_PointLight_new"></a>

### new PointLight([color], [intensity], [distance], [decay])
Constructs a new point light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity measured in candela (cd). |
| [distance] | <code>number</code> | <code>0</code> | Maximum range of the light. `0` means no limit. |
| [decay] | <code>number</code> | <code>2</code> | The amount the light dims along the distance of the light. |

<a name="PointLight+isPointLight"></a>

### pointLight.isPointLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PointLight+distance"></a>

### pointLight.distance : <code>number</code>
When distance is zero, light will attenuate according to inverse-square
law to infinite distance. When distance is non-zero, light will attenuate
according to inverse-square law until near the distance cutoff, where it
will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not
physically correct.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
**Default**: <code>0</code>  
<a name="PointLight+decay"></a>

### pointLight.decay : <code>number</code>
The amount the light dims along the distance of the light. In context of
physically-correct rendering the default value should not be changed.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
**Default**: <code>2</code>  
<a name="PointLight+shadow"></a>

### pointLight.shadow : <code>PointLightShadow</code>
This property holds the light's shadow configuration.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
<a name="PointLight+power"></a>

### pointLight.power : <code>number</code>
The light's power. Power is the luminous power of the light measured in lumens (lm).
Changing the power will also change the light's intensity.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
<a name="PointLightShadow"></a>

## PointLightShadow ⇐ <code>LightShadow</code>
Represents the shadow configuration of point lights.

**Kind**: global class  
**Extends**: <code>LightShadow</code>  

* [PointLightShadow](#PointLightShadow) ⇐ <code>LightShadow</code>
    * [new PointLightShadow()](#new_PointLightShadow_new)
    * [.isPointLightShadow](#PointLightShadow+isPointLightShadow) : <code>boolean</code>
    * [.updateMatrices(light, [viewportIndex])](#PointLightShadow+updateMatrices)

<a name="new_PointLightShadow_new"></a>

### new PointLightShadow()
Constructs a new point light shadow.

<a name="PointLightShadow+isPointLightShadow"></a>

### pointLightShadow.isPointLightShadow : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointLightShadow</code>](#PointLightShadow)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PointLightShadow+updateMatrices"></a>

### pointLightShadow.updateMatrices(light, [viewportIndex])
Update the matrices for the camera and shadow, used internally by the renderer.

**Kind**: instance method of [<code>PointLightShadow</code>](#PointLightShadow)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>Light</code> |  | The light for which the shadow is being rendered. |
| [viewportIndex] | <code>number</code> | <code>0</code> | The viewport index. |

<a name="RectAreaLight"></a>

## RectAreaLight ⇐ <code>Light</code>
This class emits light uniformly across the face a rectangular plane.
This light type can be used to simulate light sources such as bright
windows or strip lighting.

Important Notes:

- There is no shadow support.
- Only PBR materials are supported.
- You have to include `RectAreaLightUniformsLib` (`WebGLRenderer`) or `RectAreaLightTexturesLib` (`WebGPURenderer`)
into your app and init the uniforms/textures.

```js
RectAreaLightUniformsLib.init(); // only relevant for WebGLRenderer
THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() ); //  only relevant for WebGPURenderer

const intensity = 1; const width = 10; const height = 10;
const rectLight = new THREE.RectAreaLight( 0xffffff, intensity, width, height );
rectLight.position.set( 5, 5, 0 );
rectLight.lookAt( 0, 0, 0 );
scene.add( rectLight )
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [RectAreaLight](#RectAreaLight) ⇐ <code>Light</code>
    * [new RectAreaLight([color], [intensity], [width], [height])](#new_RectAreaLight_new)
    * [.isRectAreaLight](#RectAreaLight+isRectAreaLight) : <code>boolean</code>
    * [.width](#RectAreaLight+width) : <code>number</code>
    * [.height](#RectAreaLight+height) : <code>number</code>
    * [.power](#RectAreaLight+power) : <code>number</code>

<a name="new_RectAreaLight_new"></a>

### new RectAreaLight([color], [intensity], [width], [height])
Constructs a new area light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |
| [width] | <code>number</code> | <code>10</code> | The width of the light. |
| [height] | <code>number</code> | <code>10</code> | The height of the light. |

<a name="RectAreaLight+isRectAreaLight"></a>

### rectAreaLight.isRectAreaLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>RectAreaLight</code>](#RectAreaLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="RectAreaLight+width"></a>

### rectAreaLight.width : <code>number</code>
The width of the light.

**Kind**: instance property of [<code>RectAreaLight</code>](#RectAreaLight)  
**Default**: <code>10</code>  
<a name="RectAreaLight+height"></a>

### rectAreaLight.height : <code>number</code>
The height of the light.

**Kind**: instance property of [<code>RectAreaLight</code>](#RectAreaLight)  
**Default**: <code>10</code>  
<a name="RectAreaLight+power"></a>

### rectAreaLight.power : <code>number</code>
The light's power. Power is the luminous power of the light measured in lumens (lm).
Changing the power will also change the light's intensity.

**Kind**: instance property of [<code>RectAreaLight</code>](#RectAreaLight)  
<a name="SpotLight"></a>

## SpotLight ⇐ <code>Light</code>
This light gets emitted from a single point in one direction, along a cone
that increases in size the further from the light it gets.

This light can cast shadows - see the [SpotLightShadow](SpotLightShadow) for details.

```js
// white spotlight shining from the side, modulated by a texture
const spotLight = new THREE.SpotLight( 0xffffff );
spotLight.position.set( 100, 1000, 100 );
spotLight.map = new THREE.TextureLoader().load( url );

spotLight.castShadow = true;
spotLight.shadow.mapSize.width = 1024;
spotLight.shadow.mapSize.height = 1024;
spotLight.shadow.camera.near = 500;
spotLight.shadow.camera.far = 4000;
spotLight.shadow.camera.fov = 30;s
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [SpotLight](#SpotLight) ⇐ <code>Light</code>
    * [new SpotLight([color], [intensity], [distance], [angle], [penumbra], [decay])](#new_SpotLight_new)
    * [.isSpotLight](#SpotLight+isSpotLight) : <code>boolean</code>
    * [.target](#SpotLight+target) : <code>Object3D</code>
    * [.distance](#SpotLight+distance) : <code>number</code>
    * [.angle](#SpotLight+angle) : <code>number</code>
    * [.penumbra](#SpotLight+penumbra) : <code>number</code>
    * [.decay](#SpotLight+decay) : <code>number</code>
    * [.map](#SpotLight+map) : <code>Texture</code>
    * [.shadow](#SpotLight+shadow) : <code>SpotLightShadow</code>
    * [.power](#SpotLight+power) : <code>number</code>

<a name="new_SpotLight_new"></a>

### new SpotLight([color], [intensity], [distance], [angle], [penumbra], [decay])
Constructs a new spot light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity measured in candela (cd). |
| [distance] | <code>number</code> | <code>0</code> | Maximum range of the light. `0` means no limit. |
| [angle] | <code>number</code> | <code>Math.PI/3</code> | Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`. |
| [penumbra] | <code>number</code> | <code>0</code> | Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`. |
| [decay] | <code>number</code> | <code>2</code> | The amount the light dims along the distance of the light. |

<a name="SpotLight+isSpotLight"></a>

### spotLight.isSpotLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SpotLight+target"></a>

### spotLight.target : <code>Object3D</code>
The spot light points from its position to the
target's position.

For the target's position to be changed to anything other
than the default, it must be added to the scene.

It is also possible to set the target to be another 3D object
in the scene. The light will now track the target object.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
<a name="SpotLight+distance"></a>

### spotLight.distance : <code>number</code>
Maximum range of the light. `0` means no limit.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>0</code>  
<a name="SpotLight+angle"></a>

### spotLight.angle : <code>number</code>
Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>Math.PI/3</code>  
<a name="SpotLight+penumbra"></a>

### spotLight.penumbra : <code>number</code>
Percent of the spotlight cone that is attenuated due to penumbra.
Value range is `[0,1]`.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>0</code>  
<a name="SpotLight+decay"></a>

### spotLight.decay : <code>number</code>
The amount the light dims along the distance of the light. In context of
physically-correct rendering the default value should not be changed.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>2</code>  
<a name="SpotLight+map"></a>

### spotLight.map : <code>Texture</code>
A texture used to modulate the color of the light. The spot light
color is mixed with the RGB value of this texture, with a ratio
corresponding to its alpha value. The cookie-like masking effect is
reproduced using pixel values (0, 0, 0, 1-cookie_value).

*Warning*: This property is disabled if [Object3D#castShadow](Object3D#castShadow) is set to `false`.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>null</code>  
<a name="SpotLight+shadow"></a>

### spotLight.shadow : <code>SpotLightShadow</code>
This property holds the light's shadow configuration.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
<a name="SpotLight+power"></a>

### spotLight.power : <code>number</code>
The light's power. Power is the luminous power of the light measured in lumens (lm).
 Changing the power will also change the light's intensity.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
<a name="SpotLightShadow"></a>

## SpotLightShadow ⇐ <code>LightShadow</code>
Represents the shadow configuration of directional lights.

**Kind**: global class  
**Extends**: <code>LightShadow</code>  

* [SpotLightShadow](#SpotLightShadow) ⇐ <code>LightShadow</code>
    * [new SpotLightShadow()](#new_SpotLightShadow_new)
    * [.isSpotLightShadow](#SpotLightShadow+isSpotLightShadow) : <code>boolean</code>
    * [.focus](#SpotLightShadow+focus) : <code>number</code>

<a name="new_SpotLightShadow_new"></a>

### new SpotLightShadow()
Constructs a new spot light shadow.

<a name="SpotLightShadow+isSpotLightShadow"></a>

### spotLightShadow.isSpotLightShadow : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SpotLightShadow</code>](#SpotLightShadow)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SpotLightShadow+focus"></a>

### spotLightShadow.focus : <code>number</code>
Used to focus the shadow camera. The camera's field of view is set as a
percentage of the spotlight's field-of-view. Range is `[0, 1]`.

**Kind**: instance property of [<code>SpotLightShadow</code>](#SpotLightShadow)  
**Default**: <code>1</code>  
<a name="IESSpotLight"></a>

## IESSpotLight ⇐ <code>SpotLight</code>
A IES version of [SpotLight](SpotLight). Can only be used with [WebGPURenderer](WebGPURenderer).

**Kind**: global class  
**Extends**: <code>SpotLight</code>  

* [IESSpotLight](#IESSpotLight) ⇐ <code>SpotLight</code>
    * [new IESSpotLight([color], [intensity], [distance], [angle], [penumbra], [decay])](#new_IESSpotLight_new)
    * [.iesMap](#IESSpotLight+iesMap) : <code>Texture</code>

<a name="new_IESSpotLight_new"></a>

### new IESSpotLight([color], [intensity], [distance], [angle], [penumbra], [decay])
Constructs a new IES spot light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity measured in candela (cd). |
| [distance] | <code>number</code> | <code>0</code> | Maximum range of the light. `0` means no limit. |
| [angle] | <code>number</code> | <code>Math.PI/3</code> | Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`. |
| [penumbra] | <code>number</code> | <code>0</code> | Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`. |
| [decay] | <code>number</code> | <code>2</code> | The amount the light dims along the distance of the light. |

<a name="IESSpotLight+iesMap"></a>

### iesSpotLight.iesMap : <code>Texture</code>
TODO

**Kind**: instance property of [<code>IESSpotLight</code>](#IESSpotLight)  
**Default**: <code>null</code>  
<a name="AnimationLoader"></a>

## AnimationLoader ⇐ <code>Loader</code>
Class for loading animation clips in the JSON format. The files are internally
loaded via [FileLoader](FileLoader).

```js
const loader = new THREE.AnimationLoader();
const animations = await loader.loadAsync( 'animations/animation.js' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [AnimationLoader](#AnimationLoader) ⇐ <code>Loader</code>
    * [new AnimationLoader([manager])](#new_AnimationLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#AnimationLoader+load)
    * [.parse(json)](#AnimationLoader+parse) ⇒ <code>Array.&lt;AnimationClip&gt;</code>

<a name="new_AnimationLoader_new"></a>

### new AnimationLoader([manager])
Constructs a new animation loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="AnimationLoader+load"></a>

### animationLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and pass the loaded animations as an array
holding instances of [AnimationClip](AnimationClip) to the `onLoad()` callback.

**Kind**: instance method of [<code>AnimationLoader</code>](#AnimationLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="AnimationLoader+parse"></a>

### animationLoader.parse(json) ⇒ <code>Array.&lt;AnimationClip&gt;</code>
Parses the given JSON object and returns an array of animation clips.

**Kind**: instance method of [<code>AnimationLoader</code>](#AnimationLoader)  
**Returns**: <code>Array.&lt;AnimationClip&gt;</code> - The parsed animation clips.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized animation clips. |

<a name="AudioLoader"></a>

## AudioLoader ⇐ <code>Loader</code>
Class for loading audio buffers. Audios are internally
loaded via [FileLoader](FileLoader).

```js
const audioListener = new THREE.AudioListener();
const ambientSound = new THREE.Audio( audioListener );

const loader = new THREE.AudioLoader();
const audioBuffer = await loader.loadAsync( 'audio/ambient_ocean.ogg' );

ambientSound.setBuffer( audioBuffer );
ambientSound.play();
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [AudioLoader](#AudioLoader) ⇐ <code>Loader</code>
    * [new AudioLoader([manager])](#new_AudioLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#AudioLoader+load)

<a name="new_AudioLoader_new"></a>

### new AudioLoader([manager])
Constructs a new audio loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="AudioLoader+load"></a>

### audioLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded audio buffer
to the `onLoad()` callback.

**Kind**: instance method of [<code>AudioLoader</code>](#AudioLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="BufferGeometryLoader"></a>

## BufferGeometryLoader ⇐ <code>Loader</code>
Class for loading geometries. The files are internally
loaded via [FileLoader](FileLoader).

```js
const loader = new THREE.BufferGeometryLoader();
const geometry = await loader.loadAsync( 'models/json/pressure.json' );

const material = new THREE.MeshBasicMaterial( { color: 0xF5F5F5 } );
const object = new THREE.Mesh( geometry, material );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [BufferGeometryLoader](#BufferGeometryLoader) ⇐ <code>Loader</code>
    * [new BufferGeometryLoader([manager])](#new_BufferGeometryLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#BufferGeometryLoader+load)
    * [.parse(json)](#BufferGeometryLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_BufferGeometryLoader_new"></a>

### new BufferGeometryLoader([manager])
Constructs a new geometry loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="BufferGeometryLoader+load"></a>

### bufferGeometryLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and pass the loaded geometry to the `onLoad()` callback.

**Kind**: instance method of [<code>BufferGeometryLoader</code>](#BufferGeometryLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="BufferGeometryLoader+parse"></a>

### bufferGeometryLoader.parse(json) ⇒ <code>BufferGeometry</code>
Parses the given JSON object and returns a geometry.

**Kind**: instance method of [<code>BufferGeometryLoader</code>](#BufferGeometryLoader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized geometry. |

<a name="Cache"></a>

## Cache
A simple caching system, used internally by [FileLoader](FileLoader).
To enable caching across all loaders that use [FileLoader](FileLoader), add `THREE.Cache.enabled = true.` once in your app.

**Kind**: global class  

* [Cache](#Cache)
    * [.enabled](#Cache.enabled) : <code>boolean</code>
    * [.files](#Cache.files) : <code>Object.&lt;string, Object&gt;</code>
    * [.add(key, file)](#Cache.add)
    * [.get(key)](#Cache.get) ⇒ <code>Object</code> \| <code>undefined</code>
    * [.remove(key)](#Cache.remove)
    * [.clear()](#Cache.clear)

<a name="Cache.enabled"></a>

### Cache.enabled : <code>boolean</code>
Whether caching is enabled or not.

**Kind**: static property of [<code>Cache</code>](#Cache)  
**Default**: <code>false</code>  
<a name="Cache.files"></a>

### Cache.files : <code>Object.&lt;string, Object&gt;</code>
A dictionary that holds cached files.

**Kind**: static property of [<code>Cache</code>](#Cache)  
<a name="Cache.add"></a>

### Cache.add(key, file)
Adds a cache entry with a key to reference the file. If this key already
holds a file, it is overwritten.

**Kind**: static method of [<code>Cache</code>](#Cache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | The key to reference the cached file. |
| file | <code>Object</code> | The file to be cached. |

<a name="Cache.get"></a>

### Cache.get(key) ⇒ <code>Object</code> \| <code>undefined</code>
Gets the cached value for the given key.

**Kind**: static method of [<code>Cache</code>](#Cache)  
**Returns**: <code>Object</code> \| <code>undefined</code> - The cached file. If the key does not exist `undefined` is returned.  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | The key to reference the cached file. |

<a name="Cache.remove"></a>

### Cache.remove(key)
Removes the cached file associated with the given key.

**Kind**: static method of [<code>Cache</code>](#Cache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | The key to reference the cached file. |

<a name="Cache.clear"></a>

### Cache.clear()
Remove all values from the cache.

**Kind**: static method of [<code>Cache</code>](#Cache)  
<a name="CompressedTextureLoader"></a>

## *CompressedTextureLoader ⇐ <code>Loader</code>*
Abstract base class for loading compressed texture formats S3TC, ASTC or ETC.
Textures are internally loaded via [FileLoader](FileLoader).

Derived classes have to implement the `parse()` method which holds the parsing
for the respective format.

**Kind**: global abstract class  
**Extends**: <code>Loader</code>  

* *[CompressedTextureLoader](#CompressedTextureLoader) ⇐ <code>Loader</code>*
    * *[new CompressedTextureLoader([manager])](#new_CompressedTextureLoader_new)*
    * _instance_
        * *[.load(url, onLoad, onProgress, onError)](#CompressedTextureLoader+load) ⇒ <code>CompressedTexture</code>*
    * _inner_
        * *[~TexData](#CompressedTextureLoader..TexData) : <code>Object</code>*

<a name="new_CompressedTextureLoader_new"></a>

### *new CompressedTextureLoader([manager])*
Constructs a new compressed texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="CompressedTextureLoader+load"></a>

### *compressedTextureLoader.load(url, onLoad, onProgress, onError) ⇒ <code>CompressedTexture</code>*
Starts loading from the given URL and passes the loaded compressed texture
to the `onLoad()` callback. The method also returns a new texture object which can
directly be used for material creation. If you do it this way, the texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>CompressedTextureLoader</code>](#CompressedTextureLoader)  
**Returns**: <code>CompressedTexture</code> - The compressed texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="CompressedTextureLoader..TexData"></a>

### *CompressedTextureLoader~TexData : <code>Object</code>*
Represents the result object type of the `parse()` method.

**Kind**: inner typedef of [<code>CompressedTextureLoader</code>](#CompressedTextureLoader)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the base mip. |
| height | <code>number</code> | The width of the base mip. |
| isCubemap | <code>boolean</code> | Whether the data represent a cubemap or not. |
| mipmapCount | <code>number</code> | The mipmap count. |
| mipmaps | <code>Array.&lt;{data:TypedArray, width:number, height:number}&gt;</code> | An array holding the mipmaps. Each entry holds the data and the dimensions for each level. |
| format | <code>number</code> | The texture format. |

<a name="CubeTextureLoader"></a>

## CubeTextureLoader ⇐ <code>Loader</code>
Class for loading cube textures. Images are internally loaded via [ImageLoader](ImageLoader).

The loader returns an instance of [CubeTexture](CubeTexture) and expects the cube map to
be defined as six separate images representing the sides of a cube. Other cube map definitions
like vertical and horizontal cross, column and row layouts are not supported.

Note that, by convention, cube maps are specified in a coordinate system
in which positive-x is to the right when looking up the positive-z axis --
in other words, using a left-handed coordinate system. Since three.js uses
a right-handed coordinate system, environment maps used in three.js will
have pos-x and neg-x swapped.

The loaded cube texture is in sRGB color space. Meaning [Texture#colorSpace](Texture#colorSpace)
is set to `SRGBColorSpace` by default.

```js
const loader = new THREE.CubeTextureLoader().setPath( 'textures/cubeMaps/' );
const cubeTexture = await loader.loadAsync( [
	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
] );
scene.background = cubeTexture;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [CubeTextureLoader](#CubeTextureLoader) ⇐ <code>Loader</code>
    * [new CubeTextureLoader([manager])](#new_CubeTextureLoader_new)
    * [.load(urls, onLoad, onProgress, onError)](#CubeTextureLoader+load) ⇒ <code>CubeTexture</code>

<a name="new_CubeTextureLoader_new"></a>

### new CubeTextureLoader([manager])
Constructs a new cube texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="CubeTextureLoader+load"></a>

### cubeTextureLoader.load(urls, onLoad, onProgress, onError) ⇒ <code>CubeTexture</code>
Starts loading from the given URL and pass the fully loaded cube texture
to the `onLoad()` callback. The method also returns a new cube texture object which can
directly be used for material creation. If you do it this way, the cube texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>CubeTextureLoader</code>](#CubeTextureLoader)  
**Returns**: <code>CubeTexture</code> - The cube texture.  

| Param | Type | Description |
| --- | --- | --- |
| urls | <code>Array.&lt;string&gt;</code> | Array of 6 URLs to images, one for each side of the cube texture. The urls should be specified in the following order: pos-x, neg-x, pos-y, neg-y, pos-z, neg-z. An array of data URIs are allowed as well. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Unsupported in this loader. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="DataTextureLoader"></a>

## *DataTextureLoader ⇐ <code>Loader</code>*
Abstract base class for loading binary texture formats RGBE, EXR or TGA.
Textures are internally loaded via [FileLoader](FileLoader).

Derived classes have to implement the `parse()` method which holds the parsing
for the respective format.

**Kind**: global abstract class  
**Extends**: <code>Loader</code>  

* *[DataTextureLoader](#DataTextureLoader) ⇐ <code>Loader</code>*
    * *[new DataTextureLoader([manager])](#new_DataTextureLoader_new)*
    * _instance_
        * *[.load(url, onLoad, onProgress, onError)](#DataTextureLoader+load) ⇒ <code>DataTexture</code>*
    * _inner_
        * *[~TexData](#DataTextureLoader..TexData) : <code>Object</code>*

<a name="new_DataTextureLoader_new"></a>

### *new DataTextureLoader([manager])*
Constructs a new data texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="DataTextureLoader+load"></a>

### *dataTextureLoader.load(url, onLoad, onProgress, onError) ⇒ <code>DataTexture</code>*
Starts loading from the given URL and passes the loaded data texture
to the `onLoad()` callback. The method also returns a new texture object which can
directly be used for material creation. If you do it this way, the texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>DataTextureLoader</code>](#DataTextureLoader)  
**Returns**: <code>DataTexture</code> - The data texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="DataTextureLoader..TexData"></a>

### *DataTextureLoader~TexData : <code>Object</code>*
Represents the result object type of the `parse()` method.

**Kind**: inner typedef of [<code>DataTextureLoader</code>](#DataTextureLoader)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [image] | <code>Object</code> |  | An object holding width, height and the texture data. |
| [width] | <code>number</code> |  | The width of the base mip. |
| [height] | <code>number</code> |  | The width of the base mip. |
| [data] | <code>TypedArray</code> |  | The texture data. |
| [format] | <code>number</code> |  | The texture format. |
| [type] | <code>number</code> |  | The texture type. |
| [flipY] | <code>boolean</code> |  | If set to `true`, the texture is flipped along the vertical axis when uploaded to the GPU. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [anisotropy] | <code>number</code> | <code>1</code> | The anisotropy value. |
| [generateMipmaps] | <code>boolean</code> |  | Whether to generate mipmaps or not. |
| [colorSpace] | <code>string</code> |  | The color space. |
| [magFilter] | <code>number</code> |  | The mag filter. |
| [minFilter] | <code>number</code> |  | The min filter. |
| [mipmaps] | <code>Array.&lt;Object&gt;</code> |  | The mipmaps. |

<a name="FileLoader"></a>

## FileLoader ⇐ <code>Loader</code>
A low level class for loading resources with the Fetch API, used internally by
most loaders. It can also be used directly to load any file type that does
not have a loader.

This loader supports caching. If you want to use it, add `THREE.Cache.enabled = true;`
once to your application.

```js
const loader = new THREE.FileLoader();
const data = await loader.loadAsync( 'example.txt' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [FileLoader](#FileLoader) ⇐ <code>Loader</code>
    * [new FileLoader([manager])](#new_FileLoader_new)
    * [.mimeType](#FileLoader+mimeType) : <code>string</code>
    * [.responseType](#FileLoader+responseType) : <code>&#x27;arraybuffer&#x27;</code> \| <code>&#x27;blob&#x27;</code> \| <code>&#x27;document&#x27;</code> \| <code>&#x27;json&#x27;</code> \| <code>&#x27;&#x27;</code>
    * [.load(url, onLoad, [onProgress], [onError])](#FileLoader+load) ⇒ <code>any</code> \| <code>undefined</code>
    * [.setResponseType(value)](#FileLoader+setResponseType) ⇒ [<code>FileLoader</code>](#FileLoader)
    * [.setMimeType(value)](#FileLoader+setMimeType) ⇒ [<code>FileLoader</code>](#FileLoader)

<a name="new_FileLoader_new"></a>

### new FileLoader([manager])
Constructs a new file loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="FileLoader+mimeType"></a>

### fileLoader.mimeType : <code>string</code>
The expected mime type.

**Kind**: instance property of [<code>FileLoader</code>](#FileLoader)  
<a name="FileLoader+responseType"></a>

### fileLoader.responseType : <code>&#x27;arraybuffer&#x27;</code> \| <code>&#x27;blob&#x27;</code> \| <code>&#x27;document&#x27;</code> \| <code>&#x27;json&#x27;</code> \| <code>&#x27;&#x27;</code>
The expected response type.

**Kind**: instance property of [<code>FileLoader</code>](#FileLoader)  
**Default**: <code>&#x27;&#x27;</code>  
<a name="FileLoader+load"></a>

### fileLoader.load(url, onLoad, [onProgress], [onError]) ⇒ <code>any</code> \| <code>undefined</code>
Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.

**Kind**: instance method of [<code>FileLoader</code>](#FileLoader)  
**Returns**: <code>any</code> \| <code>undefined</code> - The cached resource if available.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| [onProgress] | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| [onError] | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="FileLoader+setResponseType"></a>

### fileLoader.setResponseType(value) ⇒ [<code>FileLoader</code>](#FileLoader)
Sets the expected response type.

**Kind**: instance method of [<code>FileLoader</code>](#FileLoader)  
**Returns**: [<code>FileLoader</code>](#FileLoader) - A reference to this file loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>&#x27;arraybuffer&#x27;</code> \| <code>&#x27;blob&#x27;</code> \| <code>&#x27;document&#x27;</code> \| <code>&#x27;json&#x27;</code> \| <code>&#x27;&#x27;</code> | The response type. |

<a name="FileLoader+setMimeType"></a>

### fileLoader.setMimeType(value) ⇒ [<code>FileLoader</code>](#FileLoader)
Sets the expected mime type of the loaded file.

**Kind**: instance method of [<code>FileLoader</code>](#FileLoader)  
**Returns**: [<code>FileLoader</code>](#FileLoader) - A reference to this file loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>string</code> | The mime type. |

<a name="ImageBitmapLoader"></a>

## ImageBitmapLoader ⇐ <code>Loader</code>
A loader for loading images as an [ImageBitmap](https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap).
An `ImageBitmap` provides an asynchronous and resource efficient pathway to prepare
textures for rendering.

Note that [Texture#flipY](Texture#flipY) and [Texture#premultiplyAlpha](Texture#premultiplyAlpha) are ignored with image bitmaps.
They needs these configuration on bitmap creation unlike regular images need them on uploading to GPU.

You need to set the equivalent options via [setOptions](#ImageBitmapLoader+setOptions) instead.

Also note that unlike [FileLoader](FileLoader), this loader does not avoid multiple concurrent requests to the same URL.

```js
const loader = new THREE.ImageBitmapLoader();
loader.setOptions( { imageOrientation: 'flipY' } ); // set options if needed
const imageBitmap = await loader.loadAsync( 'image.png' );

const texture = new THREE.Texture( imageBitmap );
texture.needsUpdate = true;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ImageBitmapLoader](#ImageBitmapLoader) ⇐ <code>Loader</code>
    * [new ImageBitmapLoader([manager])](#new_ImageBitmapLoader_new)
    * [.isImageBitmapLoader](#ImageBitmapLoader+isImageBitmapLoader) : <code>boolean</code>
    * [.options](#ImageBitmapLoader+options) : <code>Object</code>
    * [.setOptions(options)](#ImageBitmapLoader+setOptions) ⇒ [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)
    * [.load(url, onLoad, onProgress, onError)](#ImageBitmapLoader+load) ⇒ <code>ImageBitmap</code> \| <code>undefined</code>

<a name="new_ImageBitmapLoader_new"></a>

### new ImageBitmapLoader([manager])
Constructs a new image bitmap loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="ImageBitmapLoader+isImageBitmapLoader"></a>

### imageBitmapLoader.isImageBitmapLoader : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ImageBitmapLoader+options"></a>

### imageBitmapLoader.options : <code>Object</code>
Represents the loader options.

**Kind**: instance property of [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)  
**Default**: <code>{premultiplyAlpha:&#x27;none&#x27;}</code>  
<a name="ImageBitmapLoader+setOptions"></a>

### imageBitmapLoader.setOptions(options) ⇒ [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)
Sets the given loader options. The structure of the object must match the `options` parameter of
[createImageBitmap](https://developer.mozilla.org/en-US/docs/Web/API/Window/createImageBitmap).

**Kind**: instance method of [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)  
**Returns**: [<code>ImageBitmapLoader</code>](#ImageBitmapLoader) - A reference to this image bitmap loader.  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>Object</code> | The loader options to set. |

<a name="ImageBitmapLoader+load"></a>

### imageBitmapLoader.load(url, onLoad, onProgress, onError) ⇒ <code>ImageBitmap</code> \| <code>undefined</code>
Starts loading from the given URL and pass the loaded image bitmap to the `onLoad()` callback.

**Kind**: instance method of [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)  
**Returns**: <code>ImageBitmap</code> \| <code>undefined</code> - The image bitmap.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Unsupported in this loader. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="ImageLoader"></a>

## ImageLoader ⇐ <code>Loader</code>
A loader for loading images. The class loads images with the HTML `Image` API.

```js
const loader = new THREE.ImageLoader();
const image = await loader.loadAsync( 'image.png' );
```
Please note that `ImageLoader` has dropped support for progress
events in `r84`. For an `ImageLoader` that supports progress events, see
[this thread](https://github.com/mrdoob/three.js/issues/10439#issuecomment-275785639).

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ImageLoader](#ImageLoader) ⇐ <code>Loader</code>
    * [new ImageLoader([manager])](#new_ImageLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#ImageLoader+load) ⇒ <code>Image</code>

<a name="new_ImageLoader_new"></a>

### new ImageLoader([manager])
Constructs a new image loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="ImageLoader+load"></a>

### imageLoader.load(url, onLoad, onProgress, onError) ⇒ <code>Image</code>
Starts loading from the given URL and passes the loaded image
to the `onLoad()` callback. The method also returns a new `Image` object which can
directly be used for texture creation. If you do it this way, the texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>ImageLoader</code>](#ImageLoader)  
**Returns**: <code>Image</code> - The image.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Unsupported in this loader. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

## Classes

<dl>
<dt><a href="#Loader">Loader</a></dt>
<dd><p>Abstract base class for loaders.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#onProgressCallback">onProgressCallback</a> : <code>function</code></dt>
<dd><p>Callback for onProgress in loaders.</p>
</dd>
<dt><a href="#onErrorCallback">onErrorCallback</a> : <code>function</code></dt>
<dd><p>Callback for onError in loaders.</p>
</dd>
</dl>

<a name="Loader"></a>

## *Loader*
Abstract base class for loaders.

**Kind**: global abstract class  

* *[Loader](#Loader)*
    * *[new Loader([manager])](#new_Loader_new)*
    * _instance_
        * *[.manager](#Loader+manager) : <code>LoadingManager</code>*
        * *[.crossOrigin](#Loader+crossOrigin) : <code>string</code>*
        * *[.withCredentials](#Loader+withCredentials) : <code>boolean</code>*
        * *[.path](#Loader+path) : <code>string</code>*
        * *[.resourcePath](#Loader+resourcePath) : <code>string</code>*
        * *[.requestHeader](#Loader+requestHeader) : <code>Object.&lt;string, any&gt;</code>*
        * *[.load(url, onLoad, [onProgress], [onError])](#Loader+load)*
        * *[.loadAsync(url, [onProgress])](#Loader+loadAsync) ⇒ <code>Promise</code>*
        * *[.parse(data)](#Loader+parse)*
        * *[.setCrossOrigin(crossOrigin)](#Loader+setCrossOrigin) ⇒ [<code>Loader</code>](#Loader)*
        * *[.setWithCredentials(value)](#Loader+setWithCredentials) ⇒ [<code>Loader</code>](#Loader)*
        * *[.setPath(path)](#Loader+setPath) ⇒ [<code>Loader</code>](#Loader)*
        * *[.setResourcePath(resourcePath)](#Loader+setResourcePath) ⇒ [<code>Loader</code>](#Loader)*
        * *[.setRequestHeader(requestHeader)](#Loader+setRequestHeader) ⇒ [<code>Loader</code>](#Loader)*
    * _static_
        * *[.DEFAULT_MATERIAL_NAME](#Loader.DEFAULT_MATERIAL_NAME) : <code>string</code>*

<a name="new_Loader_new"></a>

### *new Loader([manager])*
Constructs a new loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="Loader+manager"></a>

### *loader.manager : <code>LoadingManager</code>*
The loading manager.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
**Default**: <code>DefaultLoadingManager</code>  
<a name="Loader+crossOrigin"></a>

### *loader.crossOrigin : <code>string</code>*
The crossOrigin string to implement CORS for loading the url from a
different domain that allows CORS.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
**Default**: <code>&quot;&#x27;anonymous&#x27;&quot;</code>  
<a name="Loader+withCredentials"></a>

### *loader.withCredentials : <code>boolean</code>*
Whether the XMLHttpRequest uses credentials.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
**Default**: <code>false</code>  
<a name="Loader+path"></a>

### *loader.path : <code>string</code>*
The base path from which the asset will be loaded.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
<a name="Loader+resourcePath"></a>

### *loader.resourcePath : <code>string</code>*
The base path from which additional resources like textures will be loaded.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
<a name="Loader+requestHeader"></a>

### *loader.requestHeader : <code>Object.&lt;string, any&gt;</code>*
The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header)
used in HTTP request.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
<a name="Loader+load"></a>

### *loader.load(url, onLoad, [onProgress], [onError])*
This method needs to be implemented by all concrete loaders. It holds the
logic for loading assets from the backend.

**Kind**: instance method of [<code>Loader</code>](#Loader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| [onProgress] | [<code>onProgressCallback</code>](#onProgressCallback) | Executed while the loading is in progress. |
| [onError] | [<code>onErrorCallback</code>](#onErrorCallback) | Executed when errors occur. |

<a name="Loader+loadAsync"></a>

### *loader.loadAsync(url, [onProgress]) ⇒ <code>Promise</code>*
A async version of [load](#Loader+load).

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: <code>Promise</code> - A Promise that resolves when the asset has been loaded.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. |
| [onProgress] | [<code>onProgressCallback</code>](#onProgressCallback) | Executed while the loading is in progress. |

<a name="Loader+parse"></a>

### *loader.parse(data)*
This method needs to be implemented by all concrete loaders. It holds the
logic for parsing the asset into three.js entities.

**Kind**: instance method of [<code>Loader</code>](#Loader)  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>any</code> | The data to parse. |

<a name="Loader+setCrossOrigin"></a>

### *loader.setCrossOrigin(crossOrigin) ⇒ [<code>Loader</code>](#Loader)*
Sets the `crossOrigin` String to implement CORS for loading the URL
from a different domain that allows CORS.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| crossOrigin | <code>string</code> | The `crossOrigin` value. |

<a name="Loader+setWithCredentials"></a>

### *loader.setWithCredentials(value) ⇒ [<code>Loader</code>](#Loader)*
Whether the XMLHttpRequest uses credentials such as cookies, authorization
headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials).

Note: This setting has no effect if you are loading files locally or from the same domain.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The `withCredentials` value. |

<a name="Loader+setPath"></a>

### *loader.setPath(path) ⇒ [<code>Loader</code>](#Loader)*
Sets the base path for the asset.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The base path. |

<a name="Loader+setResourcePath"></a>

### *loader.setResourcePath(resourcePath) ⇒ [<code>Loader</code>](#Loader)*
Sets the base path for dependent resources like textures.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| resourcePath | <code>string</code> | The resource path. |

<a name="Loader+setRequestHeader"></a>

### *loader.setRequestHeader(requestHeader) ⇒ [<code>Loader</code>](#Loader)*
Sets the given request header.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| requestHeader | <code>Object</code> | A [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) for configuring the HTTP request. |

<a name="Loader.DEFAULT_MATERIAL_NAME"></a>

### *Loader.DEFAULT\_MATERIAL\_NAME : <code>string</code>*
The default material name that is used by loaders
when creating materials for loaded 3D objects.

Note: Not all loaders might honor this setting.

**Kind**: static property of [<code>Loader</code>](#Loader)  
**Default**: <code>&quot;&#x27;__DEFAULT&#x27;&quot;</code>  
<a name="onProgressCallback"></a>

## onProgressCallback : <code>function</code>
Callback for onProgress in loaders.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| event | <code>ProgressEvent</code> | An instance of `ProgressEvent` that represents the current loading status. |

<a name="onErrorCallback"></a>

## onErrorCallback : <code>function</code>
Callback for onError in loaders.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| error | <code>Error</code> | The error which occurred during the loading process. |

<a name="LoaderUtils"></a>

## LoaderUtils
A class with loader utility functions.

**Kind**: global class  

* [LoaderUtils](#LoaderUtils)
    * [.extractUrlBase(url)](#LoaderUtils.extractUrlBase) ⇒ <code>string</code>
    * [.resolveURL(url, path)](#LoaderUtils.resolveURL) ⇒ <code>string</code>

<a name="LoaderUtils.extractUrlBase"></a>

### LoaderUtils.extractUrlBase(url) ⇒ <code>string</code>
Extracts the base URL from the given URL.

**Kind**: static method of [<code>LoaderUtils</code>](#LoaderUtils)  
**Returns**: <code>string</code> - The extracted base URL.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL to extract the base URL from. |

<a name="LoaderUtils.resolveURL"></a>

### LoaderUtils.resolveURL(url, path) ⇒ <code>string</code>
Resolves relative URLs against the given path. Absolute paths, data urls,
and blob URLs will be returned as is. Invalid URLs will return an empty
string.

**Kind**: static method of [<code>LoaderUtils</code>](#LoaderUtils)  
**Returns**: <code>string</code> - The resolved URL.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL to resolve. |
| path | <code>string</code> | The base path for relative URLs to be resolved against. |

## Classes

<dl>
<dt><a href="#LoadingManager">LoadingManager</a></dt>
<dd><p>Handles and keeps track of loaded and pending data. A default global
instance of this class is created and used by loaders if not supplied
manually.</p>
<p>In general that should be sufficient, however there are times when it can
be useful to have separate loaders - for example if you want to show
separate loading bars for objects and textures.</p>
<pre><code class="language-js">const manager = new THREE.LoadingManager();
manager.onLoad = () =&gt; console.log( &#39;Loading complete!&#39; );

const loader1 = new OBJLoader( manager );
const loader2 = new ColladaLoader( manager );
</code></pre>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#DefaultLoadingManager">DefaultLoadingManager</a> : <code><a href="#LoadingManager">LoadingManager</a></code></dt>
<dd><p>The global default loading manager.</p>
</dd>
</dl>

<a name="LoadingManager"></a>

## LoadingManager
Handles and keeps track of loaded and pending data. A default global
instance of this class is created and used by loaders if not supplied
manually.

In general that should be sufficient, however there are times when it can
be useful to have separate loaders - for example if you want to show
separate loading bars for objects and textures.

```js
const manager = new THREE.LoadingManager();
manager.onLoad = () => console.log( 'Loading complete!' );

const loader1 = new OBJLoader( manager );
const loader2 = new ColladaLoader( manager );
```

**Kind**: global class  

* [LoadingManager](#LoadingManager)
    * [new LoadingManager([onLoad], [onProgress], [onError])](#new_LoadingManager_new)
    * [.onStart](#LoadingManager+onStart) : <code>function</code> \| <code>undefined</code>
    * [.onLoad](#LoadingManager+onLoad) : <code>function</code> \| <code>undefined</code>
    * [.onProgress](#LoadingManager+onProgress) : <code>function</code> \| <code>undefined</code>
    * [.onError](#LoadingManager+onError) : <code>function</code> \| <code>undefined</code>
    * [.itemStart(url)](#LoadingManager+itemStart)
    * [.itemEnd(url)](#LoadingManager+itemEnd)
    * [.itemError(url)](#LoadingManager+itemError)
    * [.resolveURL(url)](#LoadingManager+resolveURL) ⇒ <code>string</code>
    * [.setURLModifier(transform)](#LoadingManager+setURLModifier) ⇒ [<code>LoadingManager</code>](#LoadingManager)
    * [.addHandler(regex, loader)](#LoadingManager+addHandler) ⇒ [<code>LoadingManager</code>](#LoadingManager)
    * [.removeHandler(regex)](#LoadingManager+removeHandler) ⇒ [<code>LoadingManager</code>](#LoadingManager)
    * [.getHandler(file)](#LoadingManager+getHandler) ⇒ <code>Loader</code>

<a name="new_LoadingManager_new"></a>

### new LoadingManager([onLoad], [onProgress], [onError])
Constructs a new loading manager.


| Param | Type | Description |
| --- | --- | --- |
| [onLoad] | <code>function</code> | Executes when all items have been loaded. |
| [onProgress] | <code>function</code> | Executes when single items have been loaded. |
| [onError] | <code>function</code> | Executes when an error occurs. |

<a name="LoadingManager+onStart"></a>

### loadingManager.onStart : <code>function</code> \| <code>undefined</code>
Executes when an item starts loading.

**Kind**: instance property of [<code>LoadingManager</code>](#LoadingManager)  
**Default**: <code>undefined</code>  
<a name="LoadingManager+onLoad"></a>

### loadingManager.onLoad : <code>function</code> \| <code>undefined</code>
Executes when all items have been loaded.

**Kind**: instance property of [<code>LoadingManager</code>](#LoadingManager)  
**Default**: <code>undefined</code>  
<a name="LoadingManager+onProgress"></a>

### loadingManager.onProgress : <code>function</code> \| <code>undefined</code>
Executes when single items have been loaded.

**Kind**: instance property of [<code>LoadingManager</code>](#LoadingManager)  
**Default**: <code>undefined</code>  
<a name="LoadingManager+onError"></a>

### loadingManager.onError : <code>function</code> \| <code>undefined</code>
Executes when an error occurs.

**Kind**: instance property of [<code>LoadingManager</code>](#LoadingManager)  
**Default**: <code>undefined</code>  
<a name="LoadingManager+itemStart"></a>

### loadingManager.itemStart(url)
This should be called by any loader using the manager when the loader
starts loading an item.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL to load. |

<a name="LoadingManager+itemEnd"></a>

### loadingManager.itemEnd(url)
This should be called by any loader using the manager when the loader
ended loading an item.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL of the loaded item. |

<a name="LoadingManager+itemError"></a>

### loadingManager.itemError(url)
This should be called by any loader using the manager when the loader
encounters an error when loading an item.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL of the item that produces an error. |

<a name="LoadingManager+resolveURL"></a>

### loadingManager.resolveURL(url) ⇒ <code>string</code>
Given a URL, uses the URL modifier callback (if any) and returns a
resolved URL. If no URL modifier is set, returns the original URL.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: <code>string</code> - The resolved URL.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL to load. |

<a name="LoadingManager+setURLModifier"></a>

### loadingManager.setURLModifier(transform) ⇒ [<code>LoadingManager</code>](#LoadingManager)
If provided, the callback will be passed each resource URL before a
request is sent. The callback may return the original URL, or a new URL to
override loading behavior. This behavior can be used to load assets from
.ZIP files, drag-and-drop APIs, and Data URIs.

```js
const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3};

const manager = new THREE.LoadingManager();

// Initialize loading manager with URL callback.
const objectURLs = [];
manager.setURLModifier( ( url ) => {

	url = URL.createObjectURL( blobs[ url ] );
	objectURLs.push( url );
	return url;

} );

// Load as usual, then revoke the blob URLs.
const loader = new GLTFLoader( manager );
loader.load( 'fish.gltf', (gltf) => {

	scene.add( gltf.scene );
	objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );

} );
```

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: [<code>LoadingManager</code>](#LoadingManager) - A reference to this loading manager.  

| Param | Type | Description |
| --- | --- | --- |
| transform | <code>function</code> | URL modifier callback. Called with an URL and must return a resolved URL. |

<a name="LoadingManager+addHandler"></a>

### loadingManager.addHandler(regex, loader) ⇒ [<code>LoadingManager</code>](#LoadingManager)
Registers a loader with the given regular expression. Can be used to
define what loader should be used in order to load specific files. A
typical use case is to overwrite the default loader for textures.

```js
// add handler for TGA textures
manager.addHandler( /\.tga$/i, new TGALoader() );
```

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: [<code>LoadingManager</code>](#LoadingManager) - A reference to this loading manager.  

| Param | Type | Description |
| --- | --- | --- |
| regex | <code>string</code> | A regular expression. |
| loader | <code>Loader</code> | A loader that should handle matched cases. |

<a name="LoadingManager+removeHandler"></a>

### loadingManager.removeHandler(regex) ⇒ [<code>LoadingManager</code>](#LoadingManager)
Removes the loader for the given regular expression.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: [<code>LoadingManager</code>](#LoadingManager) - A reference to this loading manager.  

| Param | Type | Description |
| --- | --- | --- |
| regex | <code>string</code> | A regular expression. |

<a name="LoadingManager+getHandler"></a>

### loadingManager.getHandler(file) ⇒ <code>Loader</code>
Can be used to retrieve the registered loader for the given file path.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: <code>Loader</code> - The registered loader. Returns `null` if no loader was found.  

| Param | Type | Description |
| --- | --- | --- |
| file | <code>string</code> | The file path. |

<a name="DefaultLoadingManager"></a>

## DefaultLoadingManager : [<code>LoadingManager</code>](#LoadingManager)
The global default loading manager.

**Kind**: global constant  
<a name="MaterialLoader"></a>

## MaterialLoader ⇐ <code>Loader</code>
Class for loading geometries. The files are internally
loaded via [FileLoader](FileLoader).

```js
const loader = new THREE.MaterialLoader();
const material = await loader.loadAsync( 'material.json' );
```
This loader does not support node materials. Use [NodeMaterialLoader](NodeMaterialLoader) instead.

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MaterialLoader](#MaterialLoader) ⇐ <code>Loader</code>
    * [new MaterialLoader([manager])](#new_MaterialLoader_new)
    * _instance_
        * [.textures](#MaterialLoader+textures) : <code>Object.&lt;string, Texture&gt;</code>
        * [.load(url, onLoad, onProgress, onError)](#MaterialLoader+load)
        * [.parse(json)](#MaterialLoader+parse) ⇒ <code>Material</code>
        * [.setTextures(value)](#MaterialLoader+setTextures) ⇒ [<code>MaterialLoader</code>](#MaterialLoader)
        * [.createMaterialFromType(type)](#MaterialLoader+createMaterialFromType) ⇒ <code>Material</code>
    * _static_
        * [.createMaterialFromType(type)](#MaterialLoader.createMaterialFromType) ⇒ <code>Material</code>

<a name="new_MaterialLoader_new"></a>

### new MaterialLoader([manager])
Constructs a new material loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="MaterialLoader+textures"></a>

### materialLoader.textures : <code>Object.&lt;string, Texture&gt;</code>
A dictionary holding textures used by the material.

**Kind**: instance property of [<code>MaterialLoader</code>](#MaterialLoader)  
<a name="MaterialLoader+load"></a>

### materialLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and pass the loaded material to the `onLoad()` callback.

**Kind**: instance method of [<code>MaterialLoader</code>](#MaterialLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MaterialLoader+parse"></a>

### materialLoader.parse(json) ⇒ <code>Material</code>
Parses the given JSON object and returns a material.

**Kind**: instance method of [<code>MaterialLoader</code>](#MaterialLoader)  
**Returns**: <code>Material</code> - The parsed material.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized material. |

<a name="MaterialLoader+setTextures"></a>

### materialLoader.setTextures(value) ⇒ [<code>MaterialLoader</code>](#MaterialLoader)
Textures are not embedded in the material JSON so they have
to be injected before the loading process starts.

**Kind**: instance method of [<code>MaterialLoader</code>](#MaterialLoader)  
**Returns**: [<code>MaterialLoader</code>](#MaterialLoader) - A reference to this material loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object</code> | A dictionary holding textures for material properties. |

<a name="MaterialLoader+createMaterialFromType"></a>

### materialLoader.createMaterialFromType(type) ⇒ <code>Material</code>
Creates a material for the given type.

**Kind**: instance method of [<code>MaterialLoader</code>](#MaterialLoader)  
**Returns**: <code>Material</code> - The new material.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The material type. |

<a name="MaterialLoader.createMaterialFromType"></a>

### MaterialLoader.createMaterialFromType(type) ⇒ <code>Material</code>
Creates a material for the given type.

**Kind**: static method of [<code>MaterialLoader</code>](#MaterialLoader)  
**Returns**: <code>Material</code> - The new material.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The material type. |

<a name="ObjectLoader"></a>

## ObjectLoader ⇐ <code>Loader</code>
A loader for loading a JSON resource in the [JSON Object/Scene format](https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4).
The files are internally loaded via [FileLoader](FileLoader).

```js
const loader = new THREE.ObjectLoader();
const obj = await loader.loadAsync( 'models/json/example.json' );
scene.add( obj );

// Alternatively, to parse a previously loaded JSON structure
const object = await loader.parseAsync( a_json_object );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ObjectLoader](#ObjectLoader) ⇐ <code>Loader</code>
    * [new ObjectLoader([manager])](#new_ObjectLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#ObjectLoader+load)
    * [.loadAsync(url, onProgress)](#ObjectLoader+loadAsync) ⇒ <code>Promise.&lt;Object3D&gt;</code>
    * [.parse(json, onLoad)](#ObjectLoader+parse) ⇒ <code>Object3D</code>
    * [.parseAsync(json)](#ObjectLoader+parseAsync) ⇒ <code>Promise.&lt;Object3D&gt;</code>

<a name="new_ObjectLoader_new"></a>

### new ObjectLoader([manager])
Constructs a new object loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="ObjectLoader+load"></a>

### objectLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and pass the loaded 3D object to the `onLoad()` callback.

**Kind**: instance method of [<code>ObjectLoader</code>](#ObjectLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="ObjectLoader+loadAsync"></a>

### objectLoader.loadAsync(url, onProgress) ⇒ <code>Promise.&lt;Object3D&gt;</code>
Async version of [load](#ObjectLoader+load).

**Kind**: instance method of [<code>ObjectLoader</code>](#ObjectLoader)  
**Returns**: <code>Promise.&lt;Object3D&gt;</code> - A Promise that resolves with the loaded 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |

<a name="ObjectLoader+parse"></a>

### objectLoader.parse(json, onLoad) ⇒ <code>Object3D</code>
Parses the given JSON. This is used internally by [load](#ObjectLoader+load)
but can also be used directly to parse a previously loaded JSON structure.

**Kind**: instance method of [<code>ObjectLoader</code>](#ObjectLoader)  
**Returns**: <code>Object3D</code> - The parsed 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized 3D object. |
| onLoad | <code>onLoad</code> | Executed when all resources (e.g. textures) have been fully loaded. |

<a name="ObjectLoader+parseAsync"></a>

### objectLoader.parseAsync(json) ⇒ <code>Promise.&lt;Object3D&gt;</code>
Async version of [parse](#ObjectLoader+parse).

**Kind**: instance method of [<code>ObjectLoader</code>](#ObjectLoader)  
**Returns**: <code>Promise.&lt;Object3D&gt;</code> - A Promise that resolves with the parsed 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized 3D object. |

<a name="TextureLoader"></a>

## TextureLoader ⇐ <code>Loader</code>
Class for loading textures. Images are internally
loaded via [ImageLoader](ImageLoader).

```js
const loader = new THREE.TextureLoader();
const texture = await loader.loadAsync( 'textures/land_ocean_ice_cloud_2048.jpg' );

const material = new THREE.MeshBasicMaterial( { map:texture } );
```
Please note that `TextureLoader` has dropped support for progress
events in `r84`. For a `TextureLoader` that supports progress events, see
[this thread](https://github.com/mrdoob/three.js/issues/10439#issuecomment-293260145).

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [TextureLoader](#TextureLoader) ⇐ <code>Loader</code>
    * [new TextureLoader([manager])](#new_TextureLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#TextureLoader+load) ⇒ <code>Texture</code>

<a name="new_TextureLoader_new"></a>

### new TextureLoader([manager])
Constructs a new texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TextureLoader+load"></a>

### textureLoader.load(url, onLoad, onProgress, onError) ⇒ <code>Texture</code>
Starts loading from the given URL and pass the fully loaded texture
to the `onLoad()` callback. The method also returns a new texture object which can
directly be used for material creation. If you do it this way, the texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>TextureLoader</code>](#TextureLoader)  
**Returns**: <code>Texture</code> - The texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Unsupported in this loader. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="NodeLoader"></a>

## NodeLoader ⇐ <code>Loader</code>
A loader for loading node objects in the three.js JSON Object/Scene format.

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [NodeLoader](#NodeLoader) ⇐ <code>Loader</code>
    * [new NodeLoader([manager])](#new_NodeLoader_new)
    * [.textures](#NodeLoader+textures) : <code>Object.&lt;string, Texture&gt;</code>
    * [.nodes](#NodeLoader+nodes) : <code>Object.&lt;string, Node.constructor&gt;</code>
    * [.load(url, onLoad, onProgress, onError)](#NodeLoader+load)
    * [.parseNodes([json])](#NodeLoader+parseNodes) ⇒ <code>Object.&lt;string, Node&gt;</code>
    * [.parse(json)](#NodeLoader+parse) ⇒ <code>Node</code>
    * [.setTextures(value)](#NodeLoader+setTextures) ⇒ [<code>NodeLoader</code>](#NodeLoader)
    * [.setNodes(value)](#NodeLoader+setNodes) ⇒ [<code>NodeLoader</code>](#NodeLoader)
    * [.createNodeFromType(type)](#NodeLoader+createNodeFromType) ⇒ <code>Node</code>

<a name="new_NodeLoader_new"></a>

### new NodeLoader([manager])
Constructs a new node loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | A reference to a loading manager. |

<a name="NodeLoader+textures"></a>

### nodeLoader.textures : <code>Object.&lt;string, Texture&gt;</code>
Represents a dictionary of textures.

**Kind**: instance property of [<code>NodeLoader</code>](#NodeLoader)  
<a name="NodeLoader+nodes"></a>

### nodeLoader.nodes : <code>Object.&lt;string, Node.constructor&gt;</code>
Represents a dictionary of node types.

**Kind**: instance property of [<code>NodeLoader</code>](#NodeLoader)  
<a name="NodeLoader+load"></a>

### nodeLoader.load(url, onLoad, onProgress, onError)
Loads the node definitions from the given URL.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. |
| onLoad | <code>function</code> | Will be called when load completes. |
| onProgress | <code>function</code> | Will be called while load progresses. |
| onError | <code>function</code> | Will be called when errors are thrown during the loading process. |

<a name="NodeLoader+parseNodes"></a>

### nodeLoader.parseNodes([json]) ⇒ <code>Object.&lt;string, Node&gt;</code>
Parse the node dependencies for the loaded node.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: <code>Object.&lt;string, Node&gt;</code> - A dictionary with node dependencies.  

| Param | Type | Description |
| --- | --- | --- |
| [json] | <code>Array.&lt;Object&gt;</code> | The JSON definition |

<a name="NodeLoader+parse"></a>

### nodeLoader.parse(json) ⇒ <code>Node</code>
Parses the node from the given JSON.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: <code>Node</code> - The parsed node.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |
| json.type | <code>string</code> | The node type. |
| json.uuid | <code>string</code> | The node UUID. |
| [json.nodes] | <code>Array.&lt;Object&gt;</code> | The node dependencies. |
| [json.meta] | <code>Object</code> | The meta data. |

<a name="NodeLoader+setTextures"></a>

### nodeLoader.setTextures(value) ⇒ [<code>NodeLoader</code>](#NodeLoader)
Defines the dictionary of textures.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: [<code>NodeLoader</code>](#NodeLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, Texture&gt;</code> | The texture library defines as `<uuid,texture>`. |

<a name="NodeLoader+setNodes"></a>

### nodeLoader.setNodes(value) ⇒ [<code>NodeLoader</code>](#NodeLoader)
Defines the dictionary of node types.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: [<code>NodeLoader</code>](#NodeLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, Node.constructor&gt;</code> | The node library defined as `<classname,class>`. |

<a name="NodeLoader+createNodeFromType"></a>

### nodeLoader.createNodeFromType(type) ⇒ <code>Node</code>
Creates a node object from the given type.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: <code>Node</code> - The created node instance.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The node type. |

<a name="NodeMaterialLoader"></a>

## NodeMaterialLoader ⇐ <code>MaterialLoader</code>
A special type of material loader for loading node materials.

**Kind**: global class  
**Extends**: <code>MaterialLoader</code>  

* [NodeMaterialLoader](#NodeMaterialLoader) ⇐ <code>MaterialLoader</code>
    * [new NodeMaterialLoader([manager])](#new_NodeMaterialLoader_new)
    * [.nodes](#NodeMaterialLoader+nodes) : <code>Object.&lt;string, Node.constructor&gt;</code>
    * [.nodeMaterials](#NodeMaterialLoader+nodeMaterials) : <code>Object.&lt;string, NodeMaterial.constructor&gt;</code>
    * [.parse(json)](#NodeMaterialLoader+parse) ⇒ <code>NodeMaterial</code>
    * [.setNodes(value)](#NodeMaterialLoader+setNodes) ⇒ <code>NodeLoader</code>
    * [.setNodeMaterials(value)](#NodeMaterialLoader+setNodeMaterials) ⇒ <code>NodeLoader</code>
    * [.createMaterialFromType(type)](#NodeMaterialLoader+createMaterialFromType) ⇒ <code>Node</code>

<a name="new_NodeMaterialLoader_new"></a>

### new NodeMaterialLoader([manager])
Constructs a new node material loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | A reference to a loading manager. |

<a name="NodeMaterialLoader+nodes"></a>

### nodeMaterialLoader.nodes : <code>Object.&lt;string, Node.constructor&gt;</code>
Represents a dictionary of node types.

**Kind**: instance property of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
<a name="NodeMaterialLoader+nodeMaterials"></a>

### nodeMaterialLoader.nodeMaterials : <code>Object.&lt;string, NodeMaterial.constructor&gt;</code>
Represents a dictionary of node material types.

**Kind**: instance property of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
<a name="NodeMaterialLoader+parse"></a>

### nodeMaterialLoader.parse(json) ⇒ <code>NodeMaterial</code>
Parses the node material from the given JSON.

**Kind**: instance method of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
**Returns**: <code>NodeMaterial</code> - . The parsed material.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |

<a name="NodeMaterialLoader+setNodes"></a>

### nodeMaterialLoader.setNodes(value) ⇒ <code>NodeLoader</code>
Defines the dictionary of node types.

**Kind**: instance method of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
**Returns**: <code>NodeLoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, Node.constructor&gt;</code> | The node library defined as `<classname,class>`. |

<a name="NodeMaterialLoader+setNodeMaterials"></a>

### nodeMaterialLoader.setNodeMaterials(value) ⇒ <code>NodeLoader</code>
Defines the dictionary of node material types.

**Kind**: instance method of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
**Returns**: <code>NodeLoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, NodeMaterial.constructor&gt;</code> | The node material library defined as `<classname,class>`. |

<a name="NodeMaterialLoader+createMaterialFromType"></a>

### nodeMaterialLoader.createMaterialFromType(type) ⇒ <code>Node</code>
Creates a node material from the given type.

**Kind**: instance method of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
**Returns**: <code>Node</code> - The created node material instance.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The node material type. |

<a name="NodeObjectLoader"></a>

## NodeObjectLoader ⇐ <code>ObjectLoader</code>
A special type of object loader for loading 3D objects using
node materials.

**Kind**: global class  
**Extends**: <code>ObjectLoader</code>  

* [NodeObjectLoader](#NodeObjectLoader) ⇐ <code>ObjectLoader</code>
    * [new NodeObjectLoader([manager])](#new_NodeObjectLoader_new)
    * [.nodes](#NodeObjectLoader+nodes) : <code>Object.&lt;string, Node.constructor&gt;</code>
    * [.nodeMaterials](#NodeObjectLoader+nodeMaterials) : <code>Object.&lt;string, NodeMaterial.constructor&gt;</code>
    * [.setNodes(value)](#NodeObjectLoader+setNodes) ⇒ [<code>NodeObjectLoader</code>](#NodeObjectLoader)
    * [.setNodeMaterials(value)](#NodeObjectLoader+setNodeMaterials) ⇒ [<code>NodeObjectLoader</code>](#NodeObjectLoader)
    * [.parse(json, onLoad)](#NodeObjectLoader+parse) ⇒ <code>Object3D</code>
    * [.parseNodes(json, textures)](#NodeObjectLoader+parseNodes) ⇒ <code>Object.&lt;string, Node&gt;</code>
    * [.parseMaterials(json, textures)](#NodeObjectLoader+parseMaterials) ⇒ <code>Object.&lt;string, NodeMaterial&gt;</code>

<a name="new_NodeObjectLoader_new"></a>

### new NodeObjectLoader([manager])
Constructs a new node object loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | A reference to a loading manager. |

<a name="NodeObjectLoader+nodes"></a>

### nodeObjectLoader.nodes : <code>Object.&lt;string, Node.constructor&gt;</code>
Represents a dictionary of node types.

**Kind**: instance property of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
<a name="NodeObjectLoader+nodeMaterials"></a>

### nodeObjectLoader.nodeMaterials : <code>Object.&lt;string, NodeMaterial.constructor&gt;</code>
Represents a dictionary of node material types.

**Kind**: instance property of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
<a name="NodeObjectLoader+setNodes"></a>

### nodeObjectLoader.setNodes(value) ⇒ [<code>NodeObjectLoader</code>](#NodeObjectLoader)
Defines the dictionary of node types.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: [<code>NodeObjectLoader</code>](#NodeObjectLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, Node.constructor&gt;</code> | The node library defined as `<classname,class>`. |

<a name="NodeObjectLoader+setNodeMaterials"></a>

### nodeObjectLoader.setNodeMaterials(value) ⇒ [<code>NodeObjectLoader</code>](#NodeObjectLoader)
Defines the dictionary of node material types.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: [<code>NodeObjectLoader</code>](#NodeObjectLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, NodeMaterial.constructor&gt;</code> | The node material library defined as `<classname,class>`. |

<a name="NodeObjectLoader+parse"></a>

### nodeObjectLoader.parse(json, onLoad) ⇒ <code>Object3D</code>
Parses the node objects from the given JSON.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: <code>Object3D</code> - . The parsed 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |
| onLoad | <code>function</code> | The onLoad callback function. |

<a name="NodeObjectLoader+parseNodes"></a>

### nodeObjectLoader.parseNodes(json, textures) ⇒ <code>Object.&lt;string, Node&gt;</code>
Parses the node objects from the given JSON and textures.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: <code>Object.&lt;string, Node&gt;</code> - . The parsed nodes.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |
| textures | <code>Object.&lt;string, Texture&gt;</code> | The texture library. |

<a name="NodeObjectLoader+parseMaterials"></a>

### nodeObjectLoader.parseMaterials(json, textures) ⇒ <code>Object.&lt;string, NodeMaterial&gt;</code>
Parses the node objects from the given JSON and textures.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: <code>Object.&lt;string, NodeMaterial&gt;</code> - . The parsed materials.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |
| textures | <code>Object.&lt;string, Texture&gt;</code> | The texture library. |

<a name="LineBasicMaterial"></a>

## LineBasicMaterial ⇐ <code>Material</code>
A material for rendering line primitives.

Materials define the appearance of renderable 3D objects.

```js
const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [LineBasicMaterial](#LineBasicMaterial) ⇐ <code>Material</code>
    * [new LineBasicMaterial([parameters])](#new_LineBasicMaterial_new)
    * [.isLineBasicMaterial](#LineBasicMaterial+isLineBasicMaterial) : <code>boolean</code>
    * [.color](#LineBasicMaterial+color) : <code>Color</code>
    * [.map](#LineBasicMaterial+map) : <code>Texture</code>
    * [.linewidth](#LineBasicMaterial+linewidth) : <code>number</code>
    * [.linecap](#LineBasicMaterial+linecap) : <code>&#x27;butt&#x27;</code> \| <code>&#x27;round&#x27;</code> \| <code>&#x27;square&#x27;</code>
    * [.linejoin](#LineBasicMaterial+linejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.fog](#LineBasicMaterial+fog) : <code>boolean</code>

<a name="new_LineBasicMaterial_new"></a>

### new LineBasicMaterial([parameters])
Constructs a new line basic material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="LineBasicMaterial+isLineBasicMaterial"></a>

### lineBasicMaterial.isLineBasicMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineBasicMaterial+color"></a>

### lineBasicMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="LineBasicMaterial+map"></a>

### lineBasicMaterial.map : <code>Texture</code>
Sets the color of the lines using data from a texture. The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>null</code>  
<a name="LineBasicMaterial+linewidth"></a>

### lineBasicMaterial.linewidth : <code>number</code>
Controls line thickness or lines.

Can only be used with [SVGRenderer](SVGRenderer). WebGL and WebGPU
ignore this setting and always render line primitives with a
width of one pixel.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>1</code>  
<a name="LineBasicMaterial+linecap"></a>

### lineBasicMaterial.linecap : <code>&#x27;butt&#x27;</code> \| <code>&#x27;round&#x27;</code> \| <code>&#x27;square&#x27;</code>
Defines appearance of line ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="LineBasicMaterial+linejoin"></a>

### lineBasicMaterial.linejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of line joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="LineBasicMaterial+fog"></a>

### lineBasicMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>true</code>  
<a name="LineDashedMaterial"></a>

## LineDashedMaterial ⇐ <code>LineBasicMaterial</code>
A material for rendering line primitives.

Materials define the appearance of renderable 3D objects.

```js
const material = new THREE.LineDashedMaterial( {
	color: 0xffffff,
	scale: 1,
	dashSize: 3,
	gapSize: 1,
} );
```

**Kind**: global class  
**Extends**: <code>LineBasicMaterial</code>  

* [LineDashedMaterial](#LineDashedMaterial) ⇐ <code>LineBasicMaterial</code>
    * [new LineDashedMaterial([parameters])](#new_LineDashedMaterial_new)
    * [.isLineDashedMaterial](#LineDashedMaterial+isLineDashedMaterial) : <code>boolean</code>
    * [.scale](#LineDashedMaterial+scale) : <code>number</code>
    * [.dashSize](#LineDashedMaterial+dashSize) : <code>number</code>
    * [.gapSize](#LineDashedMaterial+gapSize) : <code>number</code>

<a name="new_LineDashedMaterial_new"></a>

### new LineDashedMaterial([parameters])
Constructs a new line dashed material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="LineDashedMaterial+isLineDashedMaterial"></a>

### lineDashedMaterial.isLineDashedMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineDashedMaterial</code>](#LineDashedMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineDashedMaterial+scale"></a>

### lineDashedMaterial.scale : <code>number</code>
The scale of the dashed part of a line.

**Kind**: instance property of [<code>LineDashedMaterial</code>](#LineDashedMaterial)  
**Default**: <code>1</code>  
<a name="LineDashedMaterial+dashSize"></a>

### lineDashedMaterial.dashSize : <code>number</code>
The size of the dash. This is both the gap with the stroke.

**Kind**: instance property of [<code>LineDashedMaterial</code>](#LineDashedMaterial)  
**Default**: <code>3</code>  
<a name="LineDashedMaterial+gapSize"></a>

### lineDashedMaterial.gapSize : <code>number</code>
The size of the gap.

**Kind**: instance property of [<code>LineDashedMaterial</code>](#LineDashedMaterial)  
**Default**: <code>1</code>  
<a name="Material"></a>

## *Material ⇐ <code>EventDispatcher</code>*
Abstract base class for materials.

Materials define the appearance of renderable 3D objects.

**Kind**: global abstract class  
**Extends**: <code>EventDispatcher</code>  

* *[Material](#Material) ⇐ <code>EventDispatcher</code>*
    * *[new Material()](#new_Material_new)*
    * *[.isMaterial](#Material+isMaterial) : <code>boolean</code>*
    * *[.id](#Material+id) : <code>number</code>*
    * *[.uuid](#Material+uuid) : <code>string</code>*
    * *[.name](#Material+name) : <code>string</code>*
    * *[.type](#Material+type) : <code>string</code>*
    * *[.blending](#Material+blending) : <code>NoBlending</code> \| <code>NormalBlending</code> \| <code>AdditiveBlending</code> \| <code>SubtractiveBlending</code> \| <code>MultiplyBlending</code> \| <code>CustomBlending</code>*
    * *[.side](#Material+side) : <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code>*
    * *[.vertexColors](#Material+vertexColors) : <code>boolean</code>*
    * *[.opacity](#Material+opacity) : <code>number</code>*
    * *[.transparent](#Material+transparent) : <code>boolean</code>*
    * *[.alphaHash](#Material+alphaHash) : <code>boolean</code>*
    * *[.blendSrc](#Material+blendSrc) : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
    * *[.blendDst](#Material+blendDst) : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
    * *[.blendEquation](#Material+blendEquation) : <code>AddEquation</code> \| <code>SubtractEquation</code> \| <code>ReverseSubtractEquation</code> \| <code>MinEquation</code> \| <code>MaxEquation</code>*
    * *[.blendSrcAlpha](#Material+blendSrcAlpha) : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
    * *[.blendDstAlpha](#Material+blendDstAlpha) : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
    * *[.blendEquationAlpha](#Material+blendEquationAlpha) : <code>AddEquation</code> \| <code>SubtractEquation</code> \| <code>ReverseSubtractEquation</code> \| <code>MinEquation</code> \| <code>MaxEquation</code>*
    * *[.blendColor](#Material+blendColor) : <code>Color</code>*
    * *[.blendAlpha](#Material+blendAlpha) : <code>number</code>*
    * *[.depthFunc](#Material+depthFunc) : <code>NeverDepth</code> \| <code>AlwaysDepth</code> \| <code>LessDepth</code> \| <code>LessEqualDepth</code> \| <code>EqualDepth</code> \| <code>GreaterEqualDepth</code> \| <code>GreaterDepth</code> \| <code>NotEqualDepth</code>*
    * *[.depthTest](#Material+depthTest) : <code>boolean</code>*
    * *[.depthWrite](#Material+depthWrite) : <code>boolean</code>*
    * *[.stencilWriteMask](#Material+stencilWriteMask) : <code>number</code>*
    * *[.stencilFunc](#Material+stencilFunc) : <code>NeverStencilFunc</code> \| <code>LessStencilFunc</code> \| <code>EqualStencilFunc</code> \| <code>LessEqualStencilFunc</code> \| <code>GreaterStencilFunc</code> \| <code>NotEqualStencilFunc</code> \| <code>GreaterEqualStencilFunc</code> \| <code>AlwaysStencilFunc</code>*
    * *[.stencilRef](#Material+stencilRef) : <code>number</code>*
    * *[.stencilFuncMask](#Material+stencilFuncMask) : <code>number</code>*
    * *[.stencilFail](#Material+stencilFail) : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
    * *[.stencilZFail](#Material+stencilZFail) : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
    * *[.stencilZPass](#Material+stencilZPass) : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
    * *[.stencilWrite](#Material+stencilWrite) : <code>boolean</code>*
    * *[.clippingPlanes](#Material+clippingPlanes) : <code>Array.&lt;Plane&gt;</code>*
    * *[.clipIntersection](#Material+clipIntersection) : <code>boolean</code>*
    * *[.clipShadows](#Material+clipShadows) : <code>boolean</code>*
    * *[.shadowSide](#Material+shadowSide) : <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code>*
    * *[.colorWrite](#Material+colorWrite) : <code>boolean</code>*
    * *[.precision](#Material+precision) : <code>&#x27;highp&#x27;</code> \| <code>&#x27;mediump&#x27;</code> \| <code>&#x27;lowp&#x27;</code>*
    * *[.polygonOffset](#Material+polygonOffset) : <code>boolean</code>*
    * *[.polygonOffsetFactor](#Material+polygonOffsetFactor) : <code>number</code>*
    * *[.polygonOffsetUnits](#Material+polygonOffsetUnits) : <code>number</code>*
    * *[.dithering](#Material+dithering) : <code>boolean</code>*
    * *[.alphaToCoverage](#Material+alphaToCoverage) : <code>boolean</code>*
    * *[.premultipliedAlpha](#Material+premultipliedAlpha) : <code>boolean</code>*
    * *[.forceSinglePass](#Material+forceSinglePass) : <code>boolean</code>*
    * *[.allowOverride](#Material+allowOverride) : <code>boolean</code>*
    * *[.visible](#Material+visible) : <code>boolean</code>*
    * *[.toneMapped](#Material+toneMapped) : <code>boolean</code>*
    * *[.userData](#Material+userData) : <code>Object</code>*
    * *[.version](#Material+version) : <code>number</code>*
    * *[.alphaTest](#Material+alphaTest) : <code>number</code>*
    * *[.needsUpdate](#Material+needsUpdate) : <code>boolean</code>*
    * *[.onBeforeRender(renderer, scene, camera, geometry, object, group)](#Material+onBeforeRender)*
    * *[.onBeforeCompile(shaderobject, renderer)](#Material+onBeforeCompile)*
    * *[.customProgramCacheKey()](#Material+customProgramCacheKey) ⇒ <code>string</code>*
    * *[.setValues([values])](#Material+setValues)*
    * *[.toJSON(meta)](#Material+toJSON) ⇒ <code>Object</code>*
    * *[.clone()](#Material+clone) ⇒ [<code>Material</code>](#Material)*
    * *[.copy(source)](#Material+copy) ⇒ [<code>Material</code>](#Material)*
    * *[.dispose()](#Material+dispose)*
    * *["dispose"](#Material+event_dispose)*

<a name="new_Material_new"></a>

### *new Material()*
Constructs a new material.

<a name="Material+isMaterial"></a>

### *material.isMaterial : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Material+id"></a>

### *material.id : <code>number</code>*
The ID of the material.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Read only**: true  
<a name="Material+uuid"></a>

### *material.uuid : <code>string</code>*
The UUID of the material.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Read only**: true  
<a name="Material+name"></a>

### *material.name : <code>string</code>*
The name of the material.

**Kind**: instance property of [<code>Material</code>](#Material)  
<a name="Material+type"></a>

### *material.type : <code>string</code>*
The type property is used for detecting the object type
in context of serialization/deserialization.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Read only**: true  
<a name="Material+blending"></a>

### *material.blending : <code>NoBlending</code> \| <code>NormalBlending</code> \| <code>AdditiveBlending</code> \| <code>SubtractiveBlending</code> \| <code>MultiplyBlending</code> \| <code>CustomBlending</code>*
Defines the blending type of the material.

It must be set to `CustomBlending` if custom blending properties like
[blendSrc](#Material+blendSrc), [blendDst](#Material+blendDst) or [blendEquation](#Material+blendEquation)
should have any effect.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>NormalBlending</code>  
<a name="Material+side"></a>

### *material.side : <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code>*
Defines which side of faces will be rendered - front, back or both.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>FrontSide</code>  
<a name="Material+vertexColors"></a>

### *material.vertexColors : <code>boolean</code>*
If set to `true`, vertex colors should be used.

The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
four (RGBA) component color buffer attribute is used.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+opacity"></a>

### *material.opacity : <code>number</code>*
Defines how transparent the material is.
A value of `0.0` indicates fully transparent, `1.0` is fully opaque.

If the [transparent](#Material+transparent) is not set to `true`,
the material will remain fully opaque and this value will only affect its color.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>1</code>  
<a name="Material+transparent"></a>

### *material.transparent : <code>boolean</code>*
Defines whether this material is transparent. This has an effect on
rendering as transparent objects need special treatment and are rendered
after non-transparent objects.

When set to true, the extent to which the material is transparent is
controlled by [opacity](#Material+opacity).

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+alphaHash"></a>

### *material.alphaHash : <code>boolean</code>*
Enables alpha hashed transparency, an alternative to [transparent](#Material+transparent) or
[alphaTest](#Material+alphaTest). The material will not be rendered if opacity is lower than
a random threshold. Randomization introduces some grain or noise, but approximates alpha
blending without the associated problems of sorting. Using TAA can reduce the resulting noise.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+blendSrc"></a>

### *material.blendSrc : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
Defines the blending source factor.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>SrcAlphaFactor</code>  
<a name="Material+blendDst"></a>

### *material.blendDst : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
Defines the blending destination factor.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>OneMinusSrcAlphaFactor</code>  
<a name="Material+blendEquation"></a>

### *material.blendEquation : <code>AddEquation</code> \| <code>SubtractEquation</code> \| <code>ReverseSubtractEquation</code> \| <code>MinEquation</code> \| <code>MaxEquation</code>*
Defines the blending equation.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>AddEquation</code>  
<a name="Material+blendSrcAlpha"></a>

### *material.blendSrcAlpha : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
Defines the blending source alpha factor.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+blendDstAlpha"></a>

### *material.blendDstAlpha : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
Defines the blending destination alpha factor.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+blendEquationAlpha"></a>

### *material.blendEquationAlpha : <code>AddEquation</code> \| <code>SubtractEquation</code> \| <code>ReverseSubtractEquation</code> \| <code>MinEquation</code> \| <code>MaxEquation</code>*
Defines the blending equation of the alpha channel.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+blendColor"></a>

### *material.blendColor : <code>Color</code>*
Represents the RGB values of the constant blend color.

This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>(0,0,0)</code>  
<a name="Material+blendAlpha"></a>

### *material.blendAlpha : <code>number</code>*
Represents the alpha value of the constant blend color.

This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
<a name="Material+depthFunc"></a>

### *material.depthFunc : <code>NeverDepth</code> \| <code>AlwaysDepth</code> \| <code>LessDepth</code> \| <code>LessEqualDepth</code> \| <code>EqualDepth</code> \| <code>GreaterEqualDepth</code> \| <code>GreaterDepth</code> \| <code>NotEqualDepth</code>*
Defines the depth function.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>LessEqualDepth</code>  
<a name="Material+depthTest"></a>

### *material.depthTest : <code>boolean</code>*
Whether to have depth test enabled when rendering this material.
When the depth test is disabled, the depth write will also be implicitly disabled.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+depthWrite"></a>

### *material.depthWrite : <code>boolean</code>*
Whether rendering this material has any effect on the depth buffer.

When drawing 2D overlays it can be useful to disable the depth writing in
order to layer several things together without creating z-index artifacts.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+stencilWriteMask"></a>

### *material.stencilWriteMask : <code>number</code>*
The bit mask to use when writing to the stencil buffer.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0xff</code>  
<a name="Material+stencilFunc"></a>

### *material.stencilFunc : <code>NeverStencilFunc</code> \| <code>LessStencilFunc</code> \| <code>EqualStencilFunc</code> \| <code>LessEqualStencilFunc</code> \| <code>GreaterStencilFunc</code> \| <code>NotEqualStencilFunc</code> \| <code>GreaterEqualStencilFunc</code> \| <code>AlwaysStencilFunc</code>*
The stencil comparison function to use.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>AlwaysStencilFunc</code>  
<a name="Material+stencilRef"></a>

### *material.stencilRef : <code>number</code>*
The value to use when performing stencil comparisons or stencil operations.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
<a name="Material+stencilFuncMask"></a>

### *material.stencilFuncMask : <code>number</code>*
The bit mask to use when comparing against the stencil buffer.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0xff</code>  
<a name="Material+stencilFail"></a>

### *material.stencilFail : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
Which stencil operation to perform when the comparison function returns `false`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>KeepStencilOp</code>  
<a name="Material+stencilZFail"></a>

### *material.stencilZFail : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
Which stencil operation to perform when the comparison function returns
`true` but the depth test fails.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>KeepStencilOp</code>  
<a name="Material+stencilZPass"></a>

### *material.stencilZPass : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
Which stencil operation to perform when the comparison function returns
`true` and the depth test passes.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>KeepStencilOp</code>  
<a name="Material+stencilWrite"></a>

### *material.stencilWrite : <code>boolean</code>*
Whether stencil operations are performed against the stencil buffer. In
order to perform writes or comparisons against the stencil buffer this
value must be `true`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+clippingPlanes"></a>

### *material.clippingPlanes : <code>Array.&lt;Plane&gt;</code>*
User-defined clipping planes specified as THREE.Plane objects in world
space. These planes apply to the objects this material is attached to.
Points in space whose signed distance to the plane is negative are clipped
(not rendered). This requires [WebGLRenderer#localClippingEnabled](WebGLRenderer#localClippingEnabled) to
be `true`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+clipIntersection"></a>

### *material.clipIntersection : <code>boolean</code>*
Changes the behavior of clipping planes so that only their intersection is
clipped, rather than their union.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+clipShadows"></a>

### *material.clipShadows : <code>boolean</code>*
Defines whether to clip shadows according to the clipping planes specified
on this material.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+shadowSide"></a>

### *material.shadowSide : <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code>*
Defines which side of faces cast shadows. If `null`, the side casting shadows
is determined as follows:

- When [side](#Material+side) is set to `FrontSide`, the back side cast shadows.
- When [side](#Material+side) is set to `BackSide`, the front side cast shadows.
- When [side](#Material+side) is set to `DoubleSide`, both sides cast shadows.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+colorWrite"></a>

### *material.colorWrite : <code>boolean</code>*
Whether to render the material's color.

This can be used in conjunction with [Object3D#renderOder](Object3D#renderOder) to create invisible
objects that occlude other objects.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+precision"></a>

### *material.precision : <code>&#x27;highp&#x27;</code> \| <code>&#x27;mediump&#x27;</code> \| <code>&#x27;lowp&#x27;</code>*
Override the renderer's default precision for this material.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+polygonOffset"></a>

### *material.polygonOffset : <code>boolean</code>*
Whether to use polygon offset or not. When enabled, each fragment's depth value will
be offset after it is interpolated from the depth values of the appropriate vertices.
The offset is added before the depth test is performed and before the value is written
into the depth buffer.

Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
rendering solids with highlighted edges.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+polygonOffsetFactor"></a>

### *material.polygonOffsetFactor : <code>number</code>*
Specifies a scale factor that is used to create a variable depth offset for each polygon.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
<a name="Material+polygonOffsetUnits"></a>

### *material.polygonOffsetUnits : <code>number</code>*
Is multiplied by an implementation-specific value to create a constant depth offset.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
<a name="Material+dithering"></a>

### *material.dithering : <code>boolean</code>*
Whether to apply dithering to the color to remove the appearance of banding.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+alphaToCoverage"></a>

### *material.alphaToCoverage : <code>boolean</code>*
Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
(meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
will smooth aliasing on clip plane edges and alphaTest-clipped edges.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+premultipliedAlpha"></a>

### *material.premultipliedAlpha : <code>boolean</code>*
Whether to premultiply the alpha (transparency) value.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+forceSinglePass"></a>

### *material.forceSinglePass : <code>boolean</code>*
Whether double-sided, transparent objects should be rendered with a single pass or not.

The engine renders double-sided, transparent objects with two draw calls (back faces first,
then front faces) to mitigate transparency artifacts. There are scenarios however where this
approach produces no quality gains but still doubles draw calls e.g. when rendering flat
vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
disable the two pass rendering to avoid performance issues.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+allowOverride"></a>

### *material.allowOverride : <code>boolean</code>*
Whether it's possible to override the material with [Scene#overrideMaterial](Scene#overrideMaterial) or not.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+visible"></a>

### *material.visible : <code>boolean</code>*
Defines whether 3D objects using this material are visible.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+toneMapped"></a>

### *material.toneMapped : <code>boolean</code>*
Defines whether this material is tone mapped according to the renderer's tone mapping setting.

It is ignored when rendering to a render target or using post processing or when using
`WebGPURenderer`. In all these cases, all materials are honored by tone mapping.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+userData"></a>

### *material.userData : <code>Object</code>*
An object that can be used to store custom data about the Material. It
should not hold references to functions as these will not be cloned.

**Kind**: instance property of [<code>Material</code>](#Material)  
<a name="Material+version"></a>

### *material.version : <code>number</code>*
This starts at `0` and counts how many times [needsUpdate](#Material+needsUpdate) is set to `true`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Material+alphaTest"></a>

### *material.alphaTest : <code>number</code>*
Sets the alpha value to be used when running an alpha test. The material
will not be rendered if the opacity is lower than this value.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Material+needsUpdate"></a>

### *material.needsUpdate : <code>boolean</code>*
Setting this property to `true` indicates the engine the material
needs to be recompiled.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Material+onBeforeRender"></a>

### *material.onBeforeRender(renderer, scene, camera, geometry, object, group)*
An optional callback that is executed immediately before the material is used to render a 3D object.

This method can only be used when rendering with [WebGLRenderer](WebGLRenderer).

**Kind**: instance method of [<code>Material</code>](#Material)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| scene | <code>Scene</code> | The scene. |
| camera | <code>Camera</code> | The camera that is used to render the scene. |
| geometry | <code>BufferGeometry</code> | The 3D object's geometry. |
| object | <code>Object3D</code> | The 3D object. |
| group | <code>Object</code> | The geometry group data. |

<a name="Material+onBeforeCompile"></a>

### *material.onBeforeCompile(shaderobject, renderer)*
An optional callback that is executed immediately before the shader
program is compiled. This function is called with the shader source code
as a parameter. Useful for the modification of built-in materials.

This method can only be used when rendering with [WebGLRenderer](WebGLRenderer). The
recommended approach when customizing materials is to use `WebGPURenderer` with the new
Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).

**Kind**: instance method of [<code>Material</code>](#Material)  

| Param | Type | Description |
| --- | --- | --- |
| shaderobject | <code>Object</code> | The object holds the uniforms and the vertex and fragment shader source. |
| renderer | <code>WebGLRenderer</code> | A reference to the renderer. |

<a name="Material+customProgramCacheKey"></a>

### *material.customProgramCacheKey() ⇒ <code>string</code>*
In case [onBeforeCompile](#Material+onBeforeCompile) is used, this callback can be used to identify
values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
shader or recompile the shader for this material as needed.

This method can only be used when rendering with [WebGLRenderer](WebGLRenderer).

**Kind**: instance method of [<code>Material</code>](#Material)  
**Returns**: <code>string</code> - The custom program cache key.  
<a name="Material+setValues"></a>

### *material.setValues([values])*
This method can be used to set default values from parameter objects.
It is a generic implementation so it can be used with different types
of materials.

**Kind**: instance method of [<code>Material</code>](#Material)  

| Param | Type | Description |
| --- | --- | --- |
| [values] | <code>Object</code> | The material values to set. |

<a name="Material+toJSON"></a>

### *material.toJSON(meta) ⇒ <code>Object</code>*
Serializes the material into JSON.

**Kind**: instance method of [<code>Material</code>](#Material)  
**Returns**: <code>Object</code> - A JSON object representing the serialized material.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Material+clone"></a>

### *material.clone() ⇒ [<code>Material</code>](#Material)*
Returns a new material with copied values from this instance.

**Kind**: instance method of [<code>Material</code>](#Material)  
**Returns**: [<code>Material</code>](#Material) - A clone of this instance.  
<a name="Material+copy"></a>

### *material.copy(source) ⇒ [<code>Material</code>](#Material)*
Copies the values of the given material to this instance.

**Kind**: instance method of [<code>Material</code>](#Material)  
**Returns**: [<code>Material</code>](#Material) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>Material</code>](#Material) | The material to copy. |

<a name="Material+dispose"></a>

### *material.dispose()*
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Material</code>](#Material)  
**Emits**: [<code>dispose</code>](#Material+event_dispose)  
<a name="Material+event_dispose"></a>

### *"dispose"*
Fires when the material has been disposed of.

**Kind**: event emitted by [<code>Material</code>](#Material)  
<a name="MeshBasicMaterial"></a>

## MeshBasicMaterial ⇐ <code>Material</code>
A material for drawing geometries in a simple shaded (flat or wireframe) way.

This material is not affected by lights.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshBasicMaterial](#MeshBasicMaterial) ⇐ <code>Material</code>
    * [new MeshBasicMaterial([parameters])](#new_MeshBasicMaterial_new)
    * [.isMeshBasicMaterial](#MeshBasicMaterial+isMeshBasicMaterial) : <code>boolean</code>
    * [.color](#MeshBasicMaterial+color) : <code>Color</code>
    * [.map](#MeshBasicMaterial+map) : <code>Texture</code>
    * [.lightMap](#MeshBasicMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshBasicMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshBasicMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshBasicMaterial+aoMapIntensity) : <code>number</code>
    * [.specularMap](#MeshBasicMaterial+specularMap) : <code>Texture</code>
    * [.alphaMap](#MeshBasicMaterial+alphaMap) : <code>Texture</code>
    * [.envMap](#MeshBasicMaterial+envMap) : <code>Texture</code>
    * [.envMapRotation](#MeshBasicMaterial+envMapRotation) : <code>Euler</code>
    * [.combine](#MeshBasicMaterial+combine) : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
    * [.reflectivity](#MeshBasicMaterial+reflectivity) : <code>number</code>
    * [.refractionRatio](#MeshBasicMaterial+refractionRatio) : <code>number</code>
    * [.wireframe](#MeshBasicMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshBasicMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshBasicMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshBasicMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.fog](#MeshBasicMaterial+fog) : <code>boolean</code>

<a name="new_MeshBasicMaterial_new"></a>

### new MeshBasicMaterial([parameters])
Constructs a new mesh basic material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshBasicMaterial+isMeshBasicMaterial"></a>

### meshBasicMaterial.isMeshBasicMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshBasicMaterial+color"></a>

### meshBasicMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshBasicMaterial+map"></a>

### meshBasicMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+lightMap"></a>

### meshBasicMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+lightMapIntensity"></a>

### meshBasicMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>1</code>  
<a name="MeshBasicMaterial+aoMap"></a>

### meshBasicMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+aoMapIntensity"></a>

### meshBasicMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>1</code>  
<a name="MeshBasicMaterial+specularMap"></a>

### meshBasicMaterial.specularMap : <code>Texture</code>
Specular map used by the material.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+alphaMap"></a>

### meshBasicMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+envMap"></a>

### meshBasicMaterial.envMap : <code>Texture</code>
The environment map.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+envMapRotation"></a>

### meshBasicMaterial.envMapRotation : <code>Euler</code>
The rotation of the environment map in radians.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshBasicMaterial+combine"></a>

### meshBasicMaterial.combine : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
How to combine the result of the surface's color with the environment map, if any.

When set to `MixOperation`, the [reflectivity](#MeshBasicMaterial+reflectivity) is used to
blend between the two colors.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>MultiplyOperation</code>  
<a name="MeshBasicMaterial+reflectivity"></a>

### meshBasicMaterial.reflectivity : <code>number</code>
How much the environment map affects the surface.
The valid range is between `0` (no reflections) and `1` (full reflections).

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>1</code>  
<a name="MeshBasicMaterial+refractionRatio"></a>

### meshBasicMaterial.refractionRatio : <code>number</code>
The index of refraction (IOR) of air (approximately 1) divided by the
index of refraction of the material. It is used with environment mapping
modes [CubeRefractionMapping](CubeRefractionMapping) and [EquirectangularRefractionMapping](EquirectangularRefractionMapping).
The refraction ratio should not exceed `1`.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>0.98</code>  
<a name="MeshBasicMaterial+wireframe"></a>

### meshBasicMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>false</code>  
<a name="MeshBasicMaterial+wireframeLinewidth"></a>

### meshBasicMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>1</code>  
<a name="MeshBasicMaterial+wireframeLinecap"></a>

### meshBasicMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshBasicMaterial+wireframeLinejoin"></a>

### meshBasicMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshBasicMaterial+fog"></a>

### meshBasicMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>true</code>  
<a name="MeshDepthMaterial"></a>

## MeshDepthMaterial ⇐ <code>Material</code>
A material for drawing geometry by depth. Depth is based off of the camera
near and far plane. White is nearest, black is farthest.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshDepthMaterial](#MeshDepthMaterial) ⇐ <code>Material</code>
    * [new MeshDepthMaterial([parameters])](#new_MeshDepthMaterial_new)
    * [.isMeshDepthMaterial](#MeshDepthMaterial+isMeshDepthMaterial) : <code>boolean</code>
    * [.depthPacking](#MeshDepthMaterial+depthPacking) : <code>BasicDepthPacking</code> \| <code>RGBADepthPacking</code> \| <code>RGBDepthPacking</code> \| <code>RGDepthPacking</code>
    * [.map](#MeshDepthMaterial+map) : <code>Texture</code>
    * [.alphaMap](#MeshDepthMaterial+alphaMap) : <code>Texture</code>
    * [.displacementMap](#MeshDepthMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshDepthMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshDepthMaterial+displacementBias) : <code>number</code>
    * [.wireframe](#MeshDepthMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshDepthMaterial+wireframeLinewidth) : <code>number</code>

<a name="new_MeshDepthMaterial_new"></a>

### new MeshDepthMaterial([parameters])
Constructs a new mesh depth material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshDepthMaterial+isMeshDepthMaterial"></a>

### meshDepthMaterial.isMeshDepthMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshDepthMaterial+depthPacking"></a>

### meshDepthMaterial.depthPacking : <code>BasicDepthPacking</code> \| <code>RGBADepthPacking</code> \| <code>RGBDepthPacking</code> \| <code>RGDepthPacking</code>
Type for depth packing.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>BasicDepthPacking</code>  
<a name="MeshDepthMaterial+map"></a>

### meshDepthMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest).

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>null</code>  
<a name="MeshDepthMaterial+alphaMap"></a>

### meshDepthMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>null</code>  
<a name="MeshDepthMaterial+displacementMap"></a>

### meshDepthMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>null</code>  
<a name="MeshDepthMaterial+displacementScale"></a>

### meshDepthMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>0</code>  
<a name="MeshDepthMaterial+displacementBias"></a>

### meshDepthMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>0</code>  
<a name="MeshDepthMaterial+wireframe"></a>

### meshDepthMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>false</code>  
<a name="MeshDepthMaterial+wireframeLinewidth"></a>

### meshDepthMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

WebGL and WebGPU ignore this property and always render
1 pixel wide lines.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>1</code>  
<a name="MeshDistanceMaterial"></a>

## MeshDistanceMaterial ⇐ <code>Material</code>
A material used internally for implementing shadow mapping with
point lights.

Can also be used to customize the shadow casting of an object by assigning
an instance of `MeshDistanceMaterial` to [Object3D#customDistanceMaterial](Object3D#customDistanceMaterial).
The following examples demonstrates this approach in order to ensure
transparent parts of objects do no cast shadows.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshDistanceMaterial](#MeshDistanceMaterial) ⇐ <code>Material</code>
    * [new MeshDistanceMaterial([parameters])](#new_MeshDistanceMaterial_new)
    * [.isMeshDistanceMaterial](#MeshDistanceMaterial+isMeshDistanceMaterial) : <code>boolean</code>
    * [.map](#MeshDistanceMaterial+map) : <code>Texture</code>
    * [.alphaMap](#MeshDistanceMaterial+alphaMap) : <code>Texture</code>
    * [.displacementMap](#MeshDistanceMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshDistanceMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshDistanceMaterial+displacementBias) : <code>number</code>

<a name="new_MeshDistanceMaterial_new"></a>

### new MeshDistanceMaterial([parameters])
Constructs a new mesh distance material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshDistanceMaterial+isMeshDistanceMaterial"></a>

### meshDistanceMaterial.isMeshDistanceMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshDistanceMaterial+map"></a>

### meshDistanceMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest).

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>null</code>  
<a name="MeshDistanceMaterial+alphaMap"></a>

### meshDistanceMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>null</code>  
<a name="MeshDistanceMaterial+displacementMap"></a>

### meshDistanceMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>null</code>  
<a name="MeshDistanceMaterial+displacementScale"></a>

### meshDistanceMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>0</code>  
<a name="MeshDistanceMaterial+displacementBias"></a>

### meshDistanceMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>0</code>  
<a name="MeshLambertMaterial"></a>

## MeshLambertMaterial ⇐ <code>Material</code>
A material for non-shiny surfaces, without specular highlights.

The material uses a non-physically based [Lambertian](https://en.wikipedia.org/wiki/Lambertian_reflectance)
model for calculating reflectance. This can simulate some surfaces (such
as untreated wood or stone) well, but cannot simulate shiny surfaces with
specular highlights (such as varnished wood). `MeshLambertMaterial` uses per-fragment
shading.

Due to the simplicity of the reflectance and illumination models,
performance will be greater when using this material over the
[MeshPhongMaterial](MeshPhongMaterial), [MeshStandardMaterial](MeshStandardMaterial) or
[MeshPhysicalMaterial](MeshPhysicalMaterial), at the cost of some graphical accuracy.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshLambertMaterial](#MeshLambertMaterial) ⇐ <code>Material</code>
    * [new MeshLambertMaterial([parameters])](#new_MeshLambertMaterial_new)
    * [.isMeshLambertMaterial](#MeshLambertMaterial+isMeshLambertMaterial) : <code>boolean</code>
    * [.color](#MeshLambertMaterial+color) : <code>Color</code>
    * [.map](#MeshLambertMaterial+map) : <code>Texture</code>
    * [.lightMap](#MeshLambertMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshLambertMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshLambertMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshLambertMaterial+aoMapIntensity) : <code>number</code>
    * [.emissive](#MeshLambertMaterial+emissive) : <code>Color</code>
    * [.emissiveIntensity](#MeshLambertMaterial+emissiveIntensity) : <code>number</code>
    * [.emissiveMap](#MeshLambertMaterial+emissiveMap) : <code>Texture</code>
    * [.bumpMap](#MeshLambertMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshLambertMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshLambertMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshLambertMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshLambertMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshLambertMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshLambertMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshLambertMaterial+displacementBias) : <code>number</code>
    * [.specularMap](#MeshLambertMaterial+specularMap) : <code>Texture</code>
    * [.alphaMap](#MeshLambertMaterial+alphaMap) : <code>Texture</code>
    * [.envMap](#MeshLambertMaterial+envMap) : <code>Texture</code>
    * [.envMapRotation](#MeshLambertMaterial+envMapRotation) : <code>Euler</code>
    * [.combine](#MeshLambertMaterial+combine) : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
    * [.reflectivity](#MeshLambertMaterial+reflectivity) : <code>number</code>
    * [.refractionRatio](#MeshLambertMaterial+refractionRatio) : <code>number</code>
    * [.wireframe](#MeshLambertMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshLambertMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshLambertMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshLambertMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.flatShading](#MeshLambertMaterial+flatShading) : <code>boolean</code>
    * [.fog](#MeshLambertMaterial+fog) : <code>boolean</code>

<a name="new_MeshLambertMaterial_new"></a>

### new MeshLambertMaterial([parameters])
Constructs a new mesh lambert material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshLambertMaterial+isMeshLambertMaterial"></a>

### meshLambertMaterial.isMeshLambertMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshLambertMaterial+color"></a>

### meshLambertMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshLambertMaterial+map"></a>

### meshLambertMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+lightMap"></a>

### meshLambertMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+lightMapIntensity"></a>

### meshLambertMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+aoMap"></a>

### meshLambertMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+aoMapIntensity"></a>

### meshLambertMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+emissive"></a>

### meshLambertMaterial.emissive : <code>Color</code>
Emissive (light) color of the material, essentially a solid color
unaffected by other lighting.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshLambertMaterial+emissiveIntensity"></a>

### meshLambertMaterial.emissiveIntensity : <code>number</code>
Intensity of the emissive light. Modulates the emissive color.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+emissiveMap"></a>

### meshLambertMaterial.emissiveMap : <code>Texture</code>
Set emissive (glow) map. The emissive map color is modulated by the
emissive color and the emissive intensity. If you have an emissive map,
be sure to set the emissive color to something other than black.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+bumpMap"></a>

### meshLambertMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+bumpScale"></a>

### meshLambertMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+normalMap"></a>

### meshLambertMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+normalMapType"></a>

### meshLambertMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshLambertMaterial+normalScale"></a>

### meshLambertMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshLambertMaterial+displacementMap"></a>

### meshLambertMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+displacementScale"></a>

### meshLambertMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>0</code>  
<a name="MeshLambertMaterial+displacementBias"></a>

### meshLambertMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>0</code>  
<a name="MeshLambertMaterial+specularMap"></a>

### meshLambertMaterial.specularMap : <code>Texture</code>
Specular map used by the material.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+alphaMap"></a>

### meshLambertMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+envMap"></a>

### meshLambertMaterial.envMap : <code>Texture</code>
The environment map.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+envMapRotation"></a>

### meshLambertMaterial.envMapRotation : <code>Euler</code>
The rotation of the environment map in radians.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshLambertMaterial+combine"></a>

### meshLambertMaterial.combine : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
How to combine the result of the surface's color with the environment map, if any.

When set to `MixOperation`, the [MeshBasicMaterial#reflectivity](MeshBasicMaterial#reflectivity) is used to
blend between the two colors.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>MultiplyOperation</code>  
<a name="MeshLambertMaterial+reflectivity"></a>

### meshLambertMaterial.reflectivity : <code>number</code>
How much the environment map affects the surface.
The valid range is between `0` (no reflections) and `1` (full reflections).

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+refractionRatio"></a>

### meshLambertMaterial.refractionRatio : <code>number</code>
The index of refraction (IOR) of air (approximately 1) divided by the
index of refraction of the material. It is used with environment mapping
modes [CubeRefractionMapping](CubeRefractionMapping) and [EquirectangularRefractionMapping](EquirectangularRefractionMapping).
The refraction ratio should not exceed `1`.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>0.98</code>  
<a name="MeshLambertMaterial+wireframe"></a>

### meshLambertMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>false</code>  
<a name="MeshLambertMaterial+wireframeLinewidth"></a>

### meshLambertMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+wireframeLinecap"></a>

### meshLambertMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshLambertMaterial+wireframeLinejoin"></a>

### meshLambertMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshLambertMaterial+flatShading"></a>

### meshLambertMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>false</code>  
<a name="MeshLambertMaterial+fog"></a>

### meshLambertMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>true</code>  
<a name="MeshMatcapMaterial"></a>

## MeshMatcapMaterial ⇐ <code>Material</code>
This material is defined by a MatCap (or Lit Sphere) texture, which encodes the
material color and shading.

`MeshMatcapMaterial` does not respond to lights since the matcap image file encodes
baked lighting. It will cast a shadow onto an object that receives shadows
(and shadow clipping works), but it will not self-shadow or receive
shadows.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshMatcapMaterial](#MeshMatcapMaterial) ⇐ <code>Material</code>
    * [new MeshMatcapMaterial([parameters])](#new_MeshMatcapMaterial_new)
    * [.isMeshMatcapMaterial](#MeshMatcapMaterial+isMeshMatcapMaterial) : <code>boolean</code>
    * [.color](#MeshMatcapMaterial+color) : <code>Color</code>
    * [.matcap](#MeshMatcapMaterial+matcap) : <code>Texture</code>
    * [.map](#MeshMatcapMaterial+map) : <code>Texture</code>
    * [.bumpMap](#MeshMatcapMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshMatcapMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshMatcapMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshMatcapMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshMatcapMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshMatcapMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshMatcapMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshMatcapMaterial+displacementBias) : <code>number</code>
    * [.alphaMap](#MeshMatcapMaterial+alphaMap) : <code>Texture</code>
    * [.flatShading](#MeshMatcapMaterial+flatShading) : <code>boolean</code>
    * [.fog](#MeshMatcapMaterial+fog) : <code>boolean</code>

<a name="new_MeshMatcapMaterial_new"></a>

### new MeshMatcapMaterial([parameters])
Constructs a new mesh matcap material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshMatcapMaterial+isMeshMatcapMaterial"></a>

### meshMatcapMaterial.isMeshMatcapMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshMatcapMaterial+color"></a>

### meshMatcapMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshMatcapMaterial+matcap"></a>

### meshMatcapMaterial.matcap : <code>Texture</code>
The matcap map.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+map"></a>

### meshMatcapMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+bumpMap"></a>

### meshMatcapMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+bumpScale"></a>

### meshMatcapMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>1</code>  
<a name="MeshMatcapMaterial+normalMap"></a>

### meshMatcapMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+normalMapType"></a>

### meshMatcapMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshMatcapMaterial+normalScale"></a>

### meshMatcapMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshMatcapMaterial+displacementMap"></a>

### meshMatcapMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+displacementScale"></a>

### meshMatcapMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>0</code>  
<a name="MeshMatcapMaterial+displacementBias"></a>

### meshMatcapMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>0</code>  
<a name="MeshMatcapMaterial+alphaMap"></a>

### meshMatcapMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+flatShading"></a>

### meshMatcapMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>false</code>  
<a name="MeshMatcapMaterial+fog"></a>

### meshMatcapMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>true</code>  
<a name="MeshNormalMaterial"></a>

## MeshNormalMaterial ⇐ <code>Material</code>
A material that maps the normal vectors to RGB colors.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshNormalMaterial](#MeshNormalMaterial) ⇐ <code>Material</code>
    * [new MeshNormalMaterial([parameters])](#new_MeshNormalMaterial_new)
    * [.isMeshNormalMaterial](#MeshNormalMaterial+isMeshNormalMaterial) : <code>boolean</code>
    * [.bumpMap](#MeshNormalMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshNormalMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshNormalMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshNormalMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshNormalMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshNormalMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshNormalMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshNormalMaterial+displacementBias) : <code>number</code>
    * [.wireframe](#MeshNormalMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshNormalMaterial+wireframeLinewidth) : <code>number</code>
    * [.flatShading](#MeshNormalMaterial+flatShading) : <code>boolean</code>

<a name="new_MeshNormalMaterial_new"></a>

### new MeshNormalMaterial([parameters])
Constructs a new mesh normal material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshNormalMaterial+isMeshNormalMaterial"></a>

### meshNormalMaterial.isMeshNormalMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshNormalMaterial+bumpMap"></a>

### meshNormalMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>null</code>  
<a name="MeshNormalMaterial+bumpScale"></a>

### meshNormalMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>1</code>  
<a name="MeshNormalMaterial+normalMap"></a>

### meshNormalMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>null</code>  
<a name="MeshNormalMaterial+normalMapType"></a>

### meshNormalMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshNormalMaterial+normalScale"></a>

### meshNormalMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshNormalMaterial+displacementMap"></a>

### meshNormalMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>null</code>  
<a name="MeshNormalMaterial+displacementScale"></a>

### meshNormalMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>0</code>  
<a name="MeshNormalMaterial+displacementBias"></a>

### meshNormalMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>0</code>  
<a name="MeshNormalMaterial+wireframe"></a>

### meshNormalMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>false</code>  
<a name="MeshNormalMaterial+wireframeLinewidth"></a>

### meshNormalMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

WebGL and WebGPU ignore this property and always render
1 pixel wide lines.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>1</code>  
<a name="MeshNormalMaterial+flatShading"></a>

### meshNormalMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>false</code>  
<a name="MeshPhongMaterial"></a>

## MeshPhongMaterial ⇐ <code>Material</code>
A material for shiny surfaces with specular highlights.

The material uses a non-physically based [Blinn-Phong](https://en.wikipedia.org/wiki/Blinn-Phong_shading_model)
model for calculating reflectance. Unlike the Lambertian model used in the
[MeshLambertMaterial](MeshLambertMaterial) this can simulate shiny surfaces with specular
highlights (such as varnished wood). `MeshPhongMaterial` uses per-fragment shading.

Performance will generally be greater when using this material over the
[MeshStandardMaterial](MeshStandardMaterial) or [MeshPhysicalMaterial](MeshPhysicalMaterial), at the cost of
some graphical accuracy.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshPhongMaterial](#MeshPhongMaterial) ⇐ <code>Material</code>
    * [new MeshPhongMaterial([parameters])](#new_MeshPhongMaterial_new)
    * [.isMeshPhongMaterial](#MeshPhongMaterial+isMeshPhongMaterial) : <code>boolean</code>
    * [.color](#MeshPhongMaterial+color) : <code>Color</code>
    * [.specular](#MeshPhongMaterial+specular) : <code>Color</code>
    * [.shininess](#MeshPhongMaterial+shininess) : <code>number</code>
    * [.map](#MeshPhongMaterial+map) : <code>Texture</code>
    * [.lightMap](#MeshPhongMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshPhongMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshPhongMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshPhongMaterial+aoMapIntensity) : <code>number</code>
    * [.emissive](#MeshPhongMaterial+emissive) : <code>Color</code>
    * [.emissiveIntensity](#MeshPhongMaterial+emissiveIntensity) : <code>number</code>
    * [.emissiveMap](#MeshPhongMaterial+emissiveMap) : <code>Texture</code>
    * [.bumpMap](#MeshPhongMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshPhongMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshPhongMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshPhongMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshPhongMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshPhongMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshPhongMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshPhongMaterial+displacementBias) : <code>number</code>
    * [.specularMap](#MeshPhongMaterial+specularMap) : <code>Texture</code>
    * [.alphaMap](#MeshPhongMaterial+alphaMap) : <code>Texture</code>
    * [.envMap](#MeshPhongMaterial+envMap) : <code>Texture</code>
    * [.envMapRotation](#MeshPhongMaterial+envMapRotation) : <code>Euler</code>
    * [.combine](#MeshPhongMaterial+combine) : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
    * [.reflectivity](#MeshPhongMaterial+reflectivity) : <code>number</code>
    * [.refractionRatio](#MeshPhongMaterial+refractionRatio) : <code>number</code>
    * [.wireframe](#MeshPhongMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshPhongMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshPhongMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshPhongMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.flatShading](#MeshPhongMaterial+flatShading) : <code>boolean</code>
    * [.fog](#MeshPhongMaterial+fog) : <code>boolean</code>

<a name="new_MeshPhongMaterial_new"></a>

### new MeshPhongMaterial([parameters])
Constructs a new mesh phong material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshPhongMaterial+isMeshPhongMaterial"></a>

### meshPhongMaterial.isMeshPhongMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPhongMaterial+color"></a>

### meshPhongMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshPhongMaterial+specular"></a>

### meshPhongMaterial.specular : <code>Color</code>
Specular color of the material. The default color is set to `0x111111` (very dark grey)

This defines how shiny the material is and the color of its shine.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
<a name="MeshPhongMaterial+shininess"></a>

### meshPhongMaterial.shininess : <code>number</code>
How shiny the specular highlight is; a higher value gives a sharper highlight.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>30</code>  
<a name="MeshPhongMaterial+map"></a>

### meshPhongMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+lightMap"></a>

### meshPhongMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+lightMapIntensity"></a>

### meshPhongMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+aoMap"></a>

### meshPhongMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+aoMapIntensity"></a>

### meshPhongMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+emissive"></a>

### meshPhongMaterial.emissive : <code>Color</code>
Emissive (light) color of the material, essentially a solid color
unaffected by other lighting.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshPhongMaterial+emissiveIntensity"></a>

### meshPhongMaterial.emissiveIntensity : <code>number</code>
Intensity of the emissive light. Modulates the emissive color.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+emissiveMap"></a>

### meshPhongMaterial.emissiveMap : <code>Texture</code>
Set emissive (glow) map. The emissive map color is modulated by the
emissive color and the emissive intensity. If you have an emissive map,
be sure to set the emissive color to something other than black.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+bumpMap"></a>

### meshPhongMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+bumpScale"></a>

### meshPhongMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+normalMap"></a>

### meshPhongMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+normalMapType"></a>

### meshPhongMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshPhongMaterial+normalScale"></a>

### meshPhongMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshPhongMaterial+displacementMap"></a>

### meshPhongMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+displacementScale"></a>

### meshPhongMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhongMaterial+displacementBias"></a>

### meshPhongMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhongMaterial+specularMap"></a>

### meshPhongMaterial.specularMap : <code>Texture</code>
The specular map value affects both how much the specular surface
highlight contributes and how much of the environment map affects the
surface.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+alphaMap"></a>

### meshPhongMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+envMap"></a>

### meshPhongMaterial.envMap : <code>Texture</code>
The environment map.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+envMapRotation"></a>

### meshPhongMaterial.envMapRotation : <code>Euler</code>
The rotation of the environment map in radians.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshPhongMaterial+combine"></a>

### meshPhongMaterial.combine : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
How to combine the result of the surface's color with the environment map, if any.

When set to `MixOperation`, the [MeshBasicMaterial#reflectivity](MeshBasicMaterial#reflectivity) is used to
blend between the two colors.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>MultiplyOperation</code>  
<a name="MeshPhongMaterial+reflectivity"></a>

### meshPhongMaterial.reflectivity : <code>number</code>
How much the environment map affects the surface.
The valid range is between `0` (no reflections) and `1` (full reflections).

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+refractionRatio"></a>

### meshPhongMaterial.refractionRatio : <code>number</code>
The index of refraction (IOR) of air (approximately 1) divided by the
index of refraction of the material. It is used with environment mapping
modes [CubeRefractionMapping](CubeRefractionMapping) and [EquirectangularRefractionMapping](EquirectangularRefractionMapping).
The refraction ratio should not exceed `1`.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>0.98</code>  
<a name="MeshPhongMaterial+wireframe"></a>

### meshPhongMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>false</code>  
<a name="MeshPhongMaterial+wireframeLinewidth"></a>

### meshPhongMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+wireframeLinecap"></a>

### meshPhongMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshPhongMaterial+wireframeLinejoin"></a>

### meshPhongMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshPhongMaterial+flatShading"></a>

### meshPhongMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>false</code>  
<a name="MeshPhongMaterial+fog"></a>

### meshPhongMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalMaterial"></a>

## MeshPhysicalMaterial ⇐ <code>MeshStandardMaterial</code>
An extension of the [MeshStandardMaterial](MeshStandardMaterial), providing more advanced
physically-based rendering properties:

- Anisotropy: Ability to represent the anisotropic property of materials
as observable with brushed metals.
- Clearcoat: Some materials — like car paints, carbon fiber, and wet surfaces — require
a clear, reflective layer on top of another layer that may be irregular or rough.
Clearcoat approximates this effect, without the need for a separate transparent surface.
- Iridescence: Allows to render the effect where hue varies  depending on the viewing
angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
wings of many insects.
- Physically-based transparency: One limitation of [Material#opacity](Material#opacity) is that highly
transparent materials are less reflective. Physically-based transmission provides a more
realistic option for thin, transparent surfaces like glass.
- Advanced reflectivity: More flexible reflectivity for non-metallic materials.
- Sheen: Can be used for representing cloth and fabric materials.

As a result of these complex shading features, `MeshPhysicalMaterial` has a
higher performance cost, per pixel, than other three.js materials. Most
effects are disabled by default, and add cost as they are enabled. For
best results, always specify an environment map when using this material.

**Kind**: global class  
**Extends**: <code>MeshStandardMaterial</code>  

* [MeshPhysicalMaterial](#MeshPhysicalMaterial) ⇐ <code>MeshStandardMaterial</code>
    * [new MeshPhysicalMaterial([parameters])](#new_MeshPhysicalMaterial_new)
    * [.isMeshPhysicalMaterial](#MeshPhysicalMaterial+isMeshPhysicalMaterial) : <code>boolean</code>
    * [.anisotropyRotation](#MeshPhysicalMaterial+anisotropyRotation) : <code>number</code>
    * [.anisotropyMap](#MeshPhysicalMaterial+anisotropyMap) : <code>Texture</code>
    * [.clearcoatMap](#MeshPhysicalMaterial+clearcoatMap) : <code>Texture</code>
    * [.clearcoatRoughness](#MeshPhysicalMaterial+clearcoatRoughness) : <code>number</code>
    * [.clearcoatRoughnessMap](#MeshPhysicalMaterial+clearcoatRoughnessMap) : <code>Texture</code>
    * [.clearcoatNormalScale](#MeshPhysicalMaterial+clearcoatNormalScale) : <code>Vector2</code>
    * [.clearcoatNormalMap](#MeshPhysicalMaterial+clearcoatNormalMap) : <code>Texture</code>
    * [.ior](#MeshPhysicalMaterial+ior) : <code>number</code>
    * [.reflectivity](#MeshPhysicalMaterial+reflectivity) : <code>number</code>
    * [.iridescenceMap](#MeshPhysicalMaterial+iridescenceMap) : <code>Texture</code>
    * [.iridescenceIOR](#MeshPhysicalMaterial+iridescenceIOR) : <code>number</code>
    * [.iridescenceThicknessRange](#MeshPhysicalMaterial+iridescenceThicknessRange) : <code>Array.&lt;number, number&gt;</code>
    * [.iridescenceThicknessMap](#MeshPhysicalMaterial+iridescenceThicknessMap) : <code>Texture</code>
    * [.sheenColor](#MeshPhysicalMaterial+sheenColor) : <code>Color</code>
    * [.sheenColorMap](#MeshPhysicalMaterial+sheenColorMap) : <code>Texture</code>
    * [.sheenRoughness](#MeshPhysicalMaterial+sheenRoughness) : <code>number</code>
    * [.sheenRoughnessMap](#MeshPhysicalMaterial+sheenRoughnessMap) : <code>Texture</code>
    * [.transmissionMap](#MeshPhysicalMaterial+transmissionMap) : <code>Texture</code>
    * [.thickness](#MeshPhysicalMaterial+thickness) : <code>number</code>
    * [.thicknessMap](#MeshPhysicalMaterial+thicknessMap) : <code>Texture</code>
    * [.attenuationDistance](#MeshPhysicalMaterial+attenuationDistance) : <code>number</code>
    * [.attenuationColor](#MeshPhysicalMaterial+attenuationColor) : <code>Color</code>
    * [.specularIntensity](#MeshPhysicalMaterial+specularIntensity) : <code>number</code>
    * [.specularIntensityMap](#MeshPhysicalMaterial+specularIntensityMap) : <code>Texture</code>
    * [.specularColor](#MeshPhysicalMaterial+specularColor) : <code>Color</code>
    * [.specularColorMap](#MeshPhysicalMaterial+specularColorMap) : <code>Texture</code>
    * [.anisotropy](#MeshPhysicalMaterial+anisotropy) : <code>number</code>
    * [.clearcoat](#MeshPhysicalMaterial+clearcoat) : <code>number</code>
    * [.iridescence](#MeshPhysicalMaterial+iridescence) : <code>number</code>
    * [.dispersion](#MeshPhysicalMaterial+dispersion) : <code>number</code>
    * [.sheen](#MeshPhysicalMaterial+sheen) : <code>number</code>
    * [.transmission](#MeshPhysicalMaterial+transmission) : <code>number</code>

<a name="new_MeshPhysicalMaterial_new"></a>

### new MeshPhysicalMaterial([parameters])
Constructs a new mesh physical material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshPhysicalMaterial+isMeshPhysicalMaterial"></a>

### meshPhysicalMaterial.isMeshPhysicalMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPhysicalMaterial+anisotropyRotation"></a>

### meshPhysicalMaterial.anisotropyRotation : <code>number</code>
The rotation of the anisotropy in tangent, bitangent space, measured in radians
counter-clockwise from the tangent. When `anisotropyMap` is present, this
property provides additional rotation to the vectors in the texture.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhysicalMaterial+anisotropyMap"></a>

### meshPhysicalMaterial.anisotropyMap : <code>Texture</code>
Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
bitangent space, to be rotated by `anisotropyRotation`. The blue channel
contains strength as `[0, 1]` to be multiplied by `anisotropy`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+clearcoatMap"></a>

### meshPhysicalMaterial.clearcoatMap : <code>Texture</code>
The red channel of this texture is multiplied against `clearcoat`,
for per-pixel control over a coating's intensity.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+clearcoatRoughness"></a>

### meshPhysicalMaterial.clearcoatRoughness : <code>number</code>
Roughness of the clear coat layer, from `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+clearcoatRoughnessMap"></a>

### meshPhysicalMaterial.clearcoatRoughnessMap : <code>Texture</code>
The green channel of this texture is multiplied against
`clearcoatRoughness`, for per-pixel control over a coating's roughness.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+clearcoatNormalScale"></a>

### meshPhysicalMaterial.clearcoatNormalScale : <code>Vector2</code>
How much `clearcoatNormalMap` affects the clear coat layer, from
`(0,0)` to `(1,1)`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshPhysicalMaterial+clearcoatNormalMap"></a>

### meshPhysicalMaterial.clearcoatNormalMap : <code>Texture</code>
Can be used to enable independent normals for the clear coat layer.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+ior"></a>

### meshPhysicalMaterial.ior : <code>number</code>
Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1.5</code>  
<a name="MeshPhysicalMaterial+reflectivity"></a>

### meshPhysicalMaterial.reflectivity : <code>number</code>
Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
corresponds to an index-of-refraction of `1.5`.

This models the reflectivity of non-metallic materials. It has no effect
when `metalness` is `1.0`

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0.5</code>  
<a name="MeshPhysicalMaterial+iridescenceMap"></a>

### meshPhysicalMaterial.iridescenceMap : <code>Texture</code>
The red channel of this texture is multiplied against `iridescence`, for per-pixel
control over iridescence.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+iridescenceIOR"></a>

### meshPhysicalMaterial.iridescenceIOR : <code>number</code>
Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
Between `1.0` to `2.333`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1.3</code>  
<a name="MeshPhysicalMaterial+iridescenceThicknessRange"></a>

### meshPhysicalMaterial.iridescenceThicknessRange : <code>Array.&lt;number, number&gt;</code>
Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
		 Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>[100,400]</code>  
<a name="MeshPhysicalMaterial+iridescenceThicknessMap"></a>

### meshPhysicalMaterial.iridescenceThicknessMap : <code>Texture</code>
A texture that defines the thickness of the iridescence layer, stored in the green channel.
Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
- `0.0` in the green channel will result in thickness equal to first element of the array.
- `1.0` in the green channel will result in thickness equal to second element of the array.
- Values in-between will linearly interpolate between the elements of the array.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+sheenColor"></a>

### meshPhysicalMaterial.sheenColor : <code>Color</code>
The sheen tint.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshPhysicalMaterial+sheenColorMap"></a>

### meshPhysicalMaterial.sheenColorMap : <code>Texture</code>
The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
over sheen tint.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+sheenRoughness"></a>

### meshPhysicalMaterial.sheenRoughness : <code>number</code>
Roughness of the sheen layer, from `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhysicalMaterial+sheenRoughnessMap"></a>

### meshPhysicalMaterial.sheenRoughnessMap : <code>Texture</code>
The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
over sheen roughness.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+transmissionMap"></a>

### meshPhysicalMaterial.transmissionMap : <code>Texture</code>
The red channel of this texture is multiplied against `transmission`, for per-pixel control over
optical transparency.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+thickness"></a>

### meshPhysicalMaterial.thickness : <code>number</code>
The thickness of the volume beneath the surface. The value is given in the
coordinate space of the mesh. If the value is `0` the material is
thin-walled. Otherwise the material is a volume boundary.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+thicknessMap"></a>

### meshPhysicalMaterial.thicknessMap : <code>Texture</code>
A texture that defines the thickness, stored in the green channel. This will
be multiplied by `thickness`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+attenuationDistance"></a>

### meshPhysicalMaterial.attenuationDistance : <code>number</code>
Density of the medium given as the average distance that light travels in
the medium before interacting with a particle. The value is given in world
space units, and must be greater than zero.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>Infinity</code>  
<a name="MeshPhysicalMaterial+attenuationColor"></a>

### meshPhysicalMaterial.attenuationColor : <code>Color</code>
The color that white light turns into due to absorption when reaching the
attenuation distance.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshPhysicalMaterial+specularIntensity"></a>

### meshPhysicalMaterial.specularIntensity : <code>number</code>
A float that scales the amount of specular reflection for non-metals only.
When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhysicalMaterial+specularIntensityMap"></a>

### meshPhysicalMaterial.specularIntensityMap : <code>Texture</code>
The alpha channel of this texture is multiplied against `specularIntensity`,
for per-pixel control over specular intensity.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+specularColor"></a>

### meshPhysicalMaterial.specularColor : <code>Color</code>
Tints the specular reflection at normal incidence for non-metals only.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshPhysicalMaterial+specularColorMap"></a>

### meshPhysicalMaterial.specularColorMap : <code>Texture</code>
The RGB channels of this texture are multiplied against `specularColor`,
for per-pixel control over specular color.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+anisotropy"></a>

### meshPhysicalMaterial.anisotropy : <code>number</code>
The anisotropy strength.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+clearcoat"></a>

### meshPhysicalMaterial.clearcoat : <code>number</code>
Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
clear coat related properties to enable multilayer materials that have a
thin translucent layer over the base layer.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+iridescence"></a>

### meshPhysicalMaterial.iridescence : <code>number</code>
The intensity of the iridescence layer, simulating RGB color shift based on the angle between
the surface and the viewer, from `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+dispersion"></a>

### meshPhysicalMaterial.dispersion : <code>number</code>
Defines the strength of the angular separation of colors (chromatic aberration) transmitting
through a relatively clear volume. Any value zero or larger is valid, the typical range of
realistic values is `[0, 1]`. This property can be only be used with transmissive objects.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+sheen"></a>

### meshPhysicalMaterial.sheen : <code>number</code>
The intensity of the sheen layer, from `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+transmission"></a>

### meshPhysicalMaterial.transmission : <code>number</code>
Degree of transmission (or optical transparency), from `0.0` to `1.0`.

Thin, transparent or semitransparent, plastic or glass materials remain
largely reflective even if they are fully transmissive. The transmission
property can be used to model these materials.

When transmission is non-zero, `opacity` should be  set to `1`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshStandardMaterial"></a>

## MeshStandardMaterial ⇐ <code>Material</code>
A standard physically based material, using Metallic-Roughness workflow.

Physically based rendering (PBR) has recently become the standard in many
3D applications, such as [Unity](https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/),
[Unreal](https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/) and
[3D Studio Max](http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017).

This approach differs from older approaches in that instead of using
approximations for the way in which light interacts with a surface, a
physically correct model is used. The idea is that, instead of tweaking
materials to look good under specific lighting, a material can be created
that will react 'correctly' under all lighting scenarios.

In practice this gives a more accurate and realistic looking result than
the [MeshLambertMaterial](MeshLambertMaterial) or [MeshPhongMaterial](MeshPhongMaterial), at the cost of
being somewhat more computationally expensive. `MeshStandardMaterial` uses per-fragment
shading.

Note that for best results you should always specify an environment map when using this material.

For a non-technical introduction to the concept of PBR and how to set up a
PBR material, check out these articles by the people at [marmoset](https://www.marmoset.co):

- [Basic Theory of Physically Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
- [Physically Based Rendering and You Can Too](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)

Technical details of the approach used in three.js (and most other PBR systems) can be found is this
[paper from Disney](https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf)
(pdf), by Brent Burley.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshStandardMaterial](#MeshStandardMaterial) ⇐ <code>Material</code>
    * [new MeshStandardMaterial([parameters])](#new_MeshStandardMaterial_new)
    * [.isMeshStandardMaterial](#MeshStandardMaterial+isMeshStandardMaterial) : <code>boolean</code>
    * [.color](#MeshStandardMaterial+color) : <code>Color</code>
    * [.roughness](#MeshStandardMaterial+roughness) : <code>number</code>
    * [.metalness](#MeshStandardMaterial+metalness) : <code>number</code>
    * [.map](#MeshStandardMaterial+map) : <code>Texture</code>
    * [.lightMap](#MeshStandardMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshStandardMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshStandardMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshStandardMaterial+aoMapIntensity) : <code>number</code>
    * [.emissive](#MeshStandardMaterial+emissive) : <code>Color</code>
    * [.emissiveIntensity](#MeshStandardMaterial+emissiveIntensity) : <code>number</code>
    * [.emissiveMap](#MeshStandardMaterial+emissiveMap) : <code>Texture</code>
    * [.bumpMap](#MeshStandardMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshStandardMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshStandardMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshStandardMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshStandardMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshStandardMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshStandardMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshStandardMaterial+displacementBias) : <code>number</code>
    * [.roughnessMap](#MeshStandardMaterial+roughnessMap) : <code>Texture</code>
    * [.metalnessMap](#MeshStandardMaterial+metalnessMap) : <code>Texture</code>
    * [.alphaMap](#MeshStandardMaterial+alphaMap) : <code>Texture</code>
    * [.envMap](#MeshStandardMaterial+envMap) : <code>Texture</code>
    * [.envMapRotation](#MeshStandardMaterial+envMapRotation) : <code>Euler</code>
    * [.envMapIntensity](#MeshStandardMaterial+envMapIntensity) : <code>number</code>
    * [.wireframe](#MeshStandardMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshStandardMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshStandardMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshStandardMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.flatShading](#MeshStandardMaterial+flatShading) : <code>boolean</code>
    * [.fog](#MeshStandardMaterial+fog) : <code>boolean</code>

<a name="new_MeshStandardMaterial_new"></a>

### new MeshStandardMaterial([parameters])
Constructs a new mesh standard material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshStandardMaterial+isMeshStandardMaterial"></a>

### meshStandardMaterial.isMeshStandardMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshStandardMaterial+color"></a>

### meshStandardMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshStandardMaterial+roughness"></a>

### meshStandardMaterial.roughness : <code>number</code>
How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
means fully diffuse. If `roughnessMap` is also provided,
both values are multiplied.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+metalness"></a>

### meshStandardMaterial.metalness : <code>number</code>
How much the material is like a metal. Non-metallic materials such as wood
or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
A value between `0.0` and `1.0` could be used for a rusty metal look.
If `metalnessMap` is also provided, both values are multiplied.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>0</code>  
<a name="MeshStandardMaterial+map"></a>

### meshStandardMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+lightMap"></a>

### meshStandardMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+lightMapIntensity"></a>

### meshStandardMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+aoMap"></a>

### meshStandardMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+aoMapIntensity"></a>

### meshStandardMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+emissive"></a>

### meshStandardMaterial.emissive : <code>Color</code>
Emissive (light) color of the material, essentially a solid color
unaffected by other lighting.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshStandardMaterial+emissiveIntensity"></a>

### meshStandardMaterial.emissiveIntensity : <code>number</code>
Intensity of the emissive light. Modulates the emissive color.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+emissiveMap"></a>

### meshStandardMaterial.emissiveMap : <code>Texture</code>
Set emissive (glow) map. The emissive map color is modulated by the
emissive color and the emissive intensity. If you have an emissive map,
be sure to set the emissive color to something other than black.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+bumpMap"></a>

### meshStandardMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+bumpScale"></a>

### meshStandardMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+normalMap"></a>

### meshStandardMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+normalMapType"></a>

### meshStandardMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshStandardMaterial+normalScale"></a>

### meshStandardMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshStandardMaterial+displacementMap"></a>

### meshStandardMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+displacementScale"></a>

### meshStandardMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>0</code>  
<a name="MeshStandardMaterial+displacementBias"></a>

### meshStandardMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>0</code>  
<a name="MeshStandardMaterial+roughnessMap"></a>

### meshStandardMaterial.roughnessMap : <code>Texture</code>
The green channel of this texture is used to alter the roughness of the
material.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+metalnessMap"></a>

### meshStandardMaterial.metalnessMap : <code>Texture</code>
The blue channel of this texture is used to alter the metalness of the
material.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+alphaMap"></a>

### meshStandardMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+envMap"></a>

### meshStandardMaterial.envMap : <code>Texture</code>
The environment map. To ensure a physically correct rendering, environment maps
are internally pre-processed with [PMREMGenerator](PMREMGenerator).

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+envMapRotation"></a>

### meshStandardMaterial.envMapRotation : <code>Euler</code>
The rotation of the environment map in radians.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshStandardMaterial+envMapIntensity"></a>

### meshStandardMaterial.envMapIntensity : <code>number</code>
Scales the effect of the environment map by multiplying its color.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+wireframe"></a>

### meshStandardMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>false</code>  
<a name="MeshStandardMaterial+wireframeLinewidth"></a>

### meshStandardMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+wireframeLinecap"></a>

### meshStandardMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshStandardMaterial+wireframeLinejoin"></a>

### meshStandardMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshStandardMaterial+flatShading"></a>

### meshStandardMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>false</code>  
<a name="MeshStandardMaterial+fog"></a>

### meshStandardMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>true</code>  
<a name="MeshToonMaterial"></a>

## MeshToonMaterial ⇐ <code>Material</code>
A material implementing toon shading.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshToonMaterial](#MeshToonMaterial) ⇐ <code>Material</code>
    * [new MeshToonMaterial([parameters])](#new_MeshToonMaterial_new)
    * [.isMeshToonMaterial](#MeshToonMaterial+isMeshToonMaterial) : <code>boolean</code>
    * [.color](#MeshToonMaterial+color) : <code>Color</code>
    * [.map](#MeshToonMaterial+map) : <code>Texture</code>
    * [.gradientMap](#MeshToonMaterial+gradientMap) : <code>Texture</code>
    * [.lightMap](#MeshToonMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshToonMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshToonMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshToonMaterial+aoMapIntensity) : <code>number</code>
    * [.emissive](#MeshToonMaterial+emissive) : <code>Color</code>
    * [.emissiveIntensity](#MeshToonMaterial+emissiveIntensity) : <code>number</code>
    * [.emissiveMap](#MeshToonMaterial+emissiveMap) : <code>Texture</code>
    * [.bumpMap](#MeshToonMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshToonMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshToonMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshToonMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshToonMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshToonMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshToonMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshToonMaterial+displacementBias) : <code>number</code>
    * [.alphaMap](#MeshToonMaterial+alphaMap) : <code>Texture</code>
    * [.wireframe](#MeshToonMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshToonMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshToonMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshToonMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.fog](#MeshToonMaterial+fog) : <code>boolean</code>

<a name="new_MeshToonMaterial_new"></a>

### new MeshToonMaterial([parameters])
Constructs a new mesh toon material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshToonMaterial+isMeshToonMaterial"></a>

### meshToonMaterial.isMeshToonMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshToonMaterial+color"></a>

### meshToonMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshToonMaterial+map"></a>

### meshToonMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+gradientMap"></a>

### meshToonMaterial.gradientMap : <code>Texture</code>
Gradient map for toon shading. It's required to set
[Texture#minFilter](Texture#minFilter) and [Texture#magFilter](Texture#magFilter) to {@linkNearestFilter}
when using this type of texture.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+lightMap"></a>

### meshToonMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+lightMapIntensity"></a>

### meshToonMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+aoMap"></a>

### meshToonMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+aoMapIntensity"></a>

### meshToonMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+emissive"></a>

### meshToonMaterial.emissive : <code>Color</code>
Emissive (light) color of the material, essentially a solid color
unaffected by other lighting.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshToonMaterial+emissiveIntensity"></a>

### meshToonMaterial.emissiveIntensity : <code>number</code>
Intensity of the emissive light. Modulates the emissive color.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+emissiveMap"></a>

### meshToonMaterial.emissiveMap : <code>Texture</code>
Set emissive (glow) map. The emissive map color is modulated by the
emissive color and the emissive intensity. If you have an emissive map,
be sure to set the emissive color to something other than black.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+bumpMap"></a>

### meshToonMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+bumpScale"></a>

### meshToonMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+normalMap"></a>

### meshToonMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+normalMapType"></a>

### meshToonMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshToonMaterial+normalScale"></a>

### meshToonMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshToonMaterial+displacementMap"></a>

### meshToonMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+displacementScale"></a>

### meshToonMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>0</code>  
<a name="MeshToonMaterial+displacementBias"></a>

### meshToonMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>0</code>  
<a name="MeshToonMaterial+alphaMap"></a>

### meshToonMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+wireframe"></a>

### meshToonMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>false</code>  
<a name="MeshToonMaterial+wireframeLinewidth"></a>

### meshToonMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+wireframeLinecap"></a>

### meshToonMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshToonMaterial+wireframeLinejoin"></a>

### meshToonMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshToonMaterial+fog"></a>

### meshToonMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>true</code>  
<a name="PointsMaterial"></a>

## PointsMaterial ⇐ <code>Material</code>
A material for rendering point primitives.

Materials define the appearance of renderable 3D objects.

```js
const vertices = [];

for ( let i = 0; i < 10000; i ++ ) {
	const x = THREE.MathUtils.randFloatSpread( 2000 );
	const y = THREE.MathUtils.randFloatSpread( 2000 );
	const z = THREE.MathUtils.randFloatSpread( 2000 );

	vertices.push( x, y, z );
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
const material = new THREE.PointsMaterial( { color: 0x888888 } );
const points = new THREE.Points( geometry, material );
scene.add( points );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [PointsMaterial](#PointsMaterial) ⇐ <code>Material</code>
    * [new PointsMaterial([parameters])](#new_PointsMaterial_new)
    * [.isPointsMaterial](#PointsMaterial+isPointsMaterial) : <code>boolean</code>
    * [.color](#PointsMaterial+color) : <code>Color</code>
    * [.map](#PointsMaterial+map) : <code>Texture</code>
    * [.alphaMap](#PointsMaterial+alphaMap) : <code>Texture</code>
    * [.size](#PointsMaterial+size) : <code>number</code>
    * [.sizeAttenuation](#PointsMaterial+sizeAttenuation) : <code>boolean</code>
    * [.fog](#PointsMaterial+fog) : <code>boolean</code>

<a name="new_PointsMaterial_new"></a>

### new PointsMaterial([parameters])
Constructs a new points material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="PointsMaterial+isPointsMaterial"></a>

### pointsMaterial.isPointsMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PointsMaterial+color"></a>

### pointsMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="PointsMaterial+map"></a>

### pointsMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>null</code>  
<a name="PointsMaterial+alphaMap"></a>

### pointsMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>null</code>  
<a name="PointsMaterial+size"></a>

### pointsMaterial.size : <code>number</code>
Defines the size of the points in pixels.

Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete).

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>1</code>  
<a name="PointsMaterial+sizeAttenuation"></a>

### pointsMaterial.sizeAttenuation : <code>boolean</code>
Specifies whether size of individual points is attenuated by the camera depth (perspective camera only).

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>true</code>  
<a name="PointsMaterial+fog"></a>

### pointsMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>true</code>  
<a name="RawShaderMaterial"></a>

## RawShaderMaterial ⇐ <code>ShaderMaterial</code>
This class works just like [ShaderMaterial](ShaderMaterial), except that definitions
of built-in uniforms and attributes are not automatically prepended to the
GLSL shader code.

`RawShaderMaterial` can only be used with [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>ShaderMaterial</code>  

* [RawShaderMaterial](#RawShaderMaterial) ⇐ <code>ShaderMaterial</code>
    * [new RawShaderMaterial([parameters])](#new_RawShaderMaterial_new)
    * [.isRawShaderMaterial](#RawShaderMaterial+isRawShaderMaterial) : <code>boolean</code>

<a name="new_RawShaderMaterial_new"></a>

### new RawShaderMaterial([parameters])
Constructs a new raw shader material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="RawShaderMaterial+isRawShaderMaterial"></a>

### rawShaderMaterial.isRawShaderMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>RawShaderMaterial</code>](#RawShaderMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShaderMaterial"></a>

## ShaderMaterial ⇐ <code>Material</code>
A material rendered with custom shaders. A shader is a small program written in GLSL.
that runs on the GPU. You may want to use a custom shader if you need to implement an
effect not included with any of the built-in materials.

There are the following notes to bear in mind when using a `ShaderMaterial`:

- `ShaderMaterial` can only be used with [WebGLRenderer](WebGLRenderer).
- Built in attributes and uniforms are passed to the shaders along with your code. If
you don't want that, use [RawShaderMaterial](RawShaderMaterial) instead.
- You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
to be placed right above the loop. The loop formatting has to correspond to a defined standard.
  - The loop has to be [normalized](https://en.wikipedia.org/wiki/Normalized_loop).
  - The loop variable has to be *i*.
  - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
value of *i* for the given iteration and can be used in preprocessor
statements.

```js
const material = new THREE.ShaderMaterial( {
	uniforms: {
		time: { value: 1.0 },
		resolution: { value: new THREE.Vector2() }
	},
	vertexShader: document.getElementById( 'vertexShader' ).textContent,
	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
} );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [ShaderMaterial](#ShaderMaterial) ⇐ <code>Material</code>
    * [new ShaderMaterial([parameters])](#new_ShaderMaterial_new)
    * _instance_
        * [.isShaderMaterial](#ShaderMaterial+isShaderMaterial) : <code>boolean</code>
        * [.defines](#ShaderMaterial+defines) : <code>Object</code>
        * [.uniforms](#ShaderMaterial+uniforms) : <code>Object</code>
        * [.uniformsGroups](#ShaderMaterial+uniformsGroups) : <code>Array.&lt;UniformsGroup&gt;</code>
        * [.vertexShader](#ShaderMaterial+vertexShader) : <code>string</code>
        * [.fragmentShader](#ShaderMaterial+fragmentShader) : <code>string</code>
        * [.linewidth](#ShaderMaterial+linewidth) : <code>number</code>
        * [.wireframe](#ShaderMaterial+wireframe) : <code>boolean</code>
        * [.wireframeLinewidth](#ShaderMaterial+wireframeLinewidth) : <code>number</code>
        * [.fog](#ShaderMaterial+fog) : <code>boolean</code>
        * [.lights](#ShaderMaterial+lights) : <code>boolean</code>
        * [.clipping](#ShaderMaterial+clipping) : <code>boolean</code>
        * [.forceSinglePass](#ShaderMaterial+forceSinglePass) : <code>boolean</code>
        * [.extensions](#ShaderMaterial+extensions) : <code>Object</code>
        * [.defaultAttributeValues](#ShaderMaterial+defaultAttributeValues) : <code>Object</code>
        * [.index0AttributeName](#ShaderMaterial+index0AttributeName) : <code>string</code> \| <code>undefined</code>
        * [.uniformsNeedUpdate](#ShaderMaterial+uniformsNeedUpdate) : <code>boolean</code>
        * [.glslVersion](#ShaderMaterial+glslVersion) : <code>GLSL1</code> \| <code>GLSL3</code>
    * _inner_
        * [~Shader](#ShaderMaterial..Shader) : <code>Object</code>

<a name="new_ShaderMaterial_new"></a>

### new ShaderMaterial([parameters])
Constructs a new shader material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="ShaderMaterial+isShaderMaterial"></a>

### shaderMaterial.isShaderMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShaderMaterial+defines"></a>

### shaderMaterial.defines : <code>Object</code>
Defines custom constants using `#define` directives within the GLSL code
for both the vertex shader and the fragment shader; each key/value pair
yields another directive.
```js
defines: {
	FOO: 15,
	BAR: true
}
```
Yields the lines:
```
#define FOO 15
#define BAR true
```

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+uniforms"></a>

### shaderMaterial.uniforms : <code>Object</code>
An object of the form:
```js
{
	"uniform1": { value: 1.0 },
	"uniform2": { value: 2 }
}
```
specifying the uniforms to be passed to the shader code; keys are uniform
names, values are definitions of the form
```
{
	value: 1.0
}
```
where `value` is the value of the uniform. Names must match the name of
the uniform, as defined in the GLSL code. Note that uniforms are refreshed
on every frame, so updating the value of the uniform will immediately
update the value available to the GLSL code.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+uniformsGroups"></a>

### shaderMaterial.uniformsGroups : <code>Array.&lt;UniformsGroup&gt;</code>
An array holding uniforms groups for configuring UBOs.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+vertexShader"></a>

### shaderMaterial.vertexShader : <code>string</code>
Vertex shader GLSL code. This is the actual code for the shader.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+fragmentShader"></a>

### shaderMaterial.fragmentShader : <code>string</code>
Fragment shader GLSL code. This is the actual code for the shader.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+linewidth"></a>

### shaderMaterial.linewidth : <code>number</code>
Controls line thickness or lines.

WebGL and WebGPU ignore this setting and always render line primitives with a
width of one pixel.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>1</code>  
<a name="ShaderMaterial+wireframe"></a>

### shaderMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+wireframeLinewidth"></a>

### shaderMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

WebGL and WebGPU ignore this property and always render
1 pixel wide lines.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>1</code>  
<a name="ShaderMaterial+fog"></a>

### shaderMaterial.fog : <code>boolean</code>
Define whether the material color is affected by global fog settings; `true`
to pass fog uniforms to the shader.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+lights"></a>

### shaderMaterial.lights : <code>boolean</code>
Defines whether this material uses lighting; `true` to pass uniform data
related to lighting to this shader.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+clipping"></a>

### shaderMaterial.clipping : <code>boolean</code>
Defines whether this material supports clipping; `true` to let the renderer
pass the clippingPlanes uniform.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+forceSinglePass"></a>

### shaderMaterial.forceSinglePass : <code>boolean</code>
Overwritten and set to `true` by default.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>true</code>  
<a name="ShaderMaterial+extensions"></a>

### shaderMaterial.extensions : <code>Object</code>
This object allows to enable certain WebGL 2 extensions.

- clipCullDistance: set to `true` to use vertex shader clipping
- multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+defaultAttributeValues"></a>

### shaderMaterial.defaultAttributeValues : <code>Object</code>
When the rendered geometry doesn't include these attributes but the
material does, these default values will be passed to the shaders. This
avoids errors when buffer data is missing.

- color: [ 1, 1, 1 ]
- uv: [ 0, 0 ]
- uv1: [ 0, 0 ]

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+index0AttributeName"></a>

### shaderMaterial.index0AttributeName : <code>string</code> \| <code>undefined</code>
If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation)
to bind a generic vertex index to an attribute variable.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>&quot;undefined&quot;</code>  
<a name="ShaderMaterial+uniformsNeedUpdate"></a>

### shaderMaterial.uniformsNeedUpdate : <code>boolean</code>
Can be used to force a uniform update while changing uniforms in
[Object3D#onBeforeRender](Object3D#onBeforeRender).

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+glslVersion"></a>

### shaderMaterial.glslVersion : <code>GLSL1</code> \| <code>GLSL3</code>
Defines the GLSL version of custom shader code.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>null</code>  
<a name="ShaderMaterial..Shader"></a>

### ShaderMaterial~Shader : <code>Object</code>
This type represents the fields required to store and run the shader code.

**Kind**: inner typedef of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the shader. |
| uniforms | <code>Object.&lt;string, Uniform&gt;</code> | The uniforms of the shader. |
| defines | <code>Object.&lt;string, any&gt;</code> | The defines of the shader. |
| vertexShader | <code>string</code> | The vertex shader code. |
| fragmentShader | <code>string</code> | The fragment shader code. |

<a name="ShadowMaterial"></a>

## ShadowMaterial ⇐ <code>Material</code>
This material can receive shadows, but otherwise is completely transparent.

```js
const geometry = new THREE.PlaneGeometry( 2000, 2000 );
geometry.rotateX( - Math.PI / 2 );

const material = new THREE.ShadowMaterial();
material.opacity = 0.2;

const plane = new THREE.Mesh( geometry, material );
plane.position.y = -200;
plane.receiveShadow = true;
scene.add( plane );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [ShadowMaterial](#ShadowMaterial) ⇐ <code>Material</code>
    * [new ShadowMaterial([parameters])](#new_ShadowMaterial_new)
    * [.isShadowMaterial](#ShadowMaterial+isShadowMaterial) : <code>boolean</code>
    * [.color](#ShadowMaterial+color) : <code>Color</code>
    * [.transparent](#ShadowMaterial+transparent) : <code>boolean</code>
    * [.fog](#ShadowMaterial+fog) : <code>boolean</code>

<a name="new_ShadowMaterial_new"></a>

### new ShadowMaterial([parameters])
Constructs a new shadow material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="ShadowMaterial+isShadowMaterial"></a>

### shadowMaterial.isShadowMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowMaterial</code>](#ShadowMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowMaterial+color"></a>

### shadowMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>ShadowMaterial</code>](#ShadowMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="ShadowMaterial+transparent"></a>

### shadowMaterial.transparent : <code>boolean</code>
Overwritten since shadow materials are transparent
by default.

**Kind**: instance property of [<code>ShadowMaterial</code>](#ShadowMaterial)  
**Default**: <code>true</code>  
<a name="ShadowMaterial+fog"></a>

### shadowMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>ShadowMaterial</code>](#ShadowMaterial)  
**Default**: <code>true</code>  
<a name="SpriteMaterial"></a>

## SpriteMaterial ⇐ <code>Material</code>
A material for rendering instances of [Sprite](Sprite).

```js
const map = new THREE.TextureLoader().load( 'textures/sprite.png' );
const material = new THREE.SpriteMaterial( { map: map, color: 0xffffff } );

const sprite = new THREE.Sprite( material );
sprite.scale.set(200, 200, 1)
scene.add( sprite );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [SpriteMaterial](#SpriteMaterial) ⇐ <code>Material</code>
    * [new SpriteMaterial([parameters])](#new_SpriteMaterial_new)
    * [.isSpriteMaterial](#SpriteMaterial+isSpriteMaterial) : <code>boolean</code>
    * [.color](#SpriteMaterial+color) : <code>Color</code>
    * [.map](#SpriteMaterial+map) : <code>Texture</code>
    * [.alphaMap](#SpriteMaterial+alphaMap) : <code>Texture</code>
    * [.rotation](#SpriteMaterial+rotation) : <code>number</code>
    * [.sizeAttenuation](#SpriteMaterial+sizeAttenuation) : <code>boolean</code>
    * [.transparent](#SpriteMaterial+transparent) : <code>boolean</code>
    * [.fog](#SpriteMaterial+fog) : <code>boolean</code>

<a name="new_SpriteMaterial_new"></a>

### new SpriteMaterial([parameters])
Constructs a new sprite material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="SpriteMaterial+isSpriteMaterial"></a>

### spriteMaterial.isSpriteMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SpriteMaterial+color"></a>

### spriteMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="SpriteMaterial+map"></a>

### spriteMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>null</code>  
<a name="SpriteMaterial+alphaMap"></a>

### spriteMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>null</code>  
<a name="SpriteMaterial+rotation"></a>

### spriteMaterial.rotation : <code>number</code>
The rotation of the sprite in radians.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>0</code>  
<a name="SpriteMaterial+sizeAttenuation"></a>

### spriteMaterial.sizeAttenuation : <code>boolean</code>
Specifies whether size of the sprite is attenuated by the camera depth (perspective camera only).

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>true</code>  
<a name="SpriteMaterial+transparent"></a>

### spriteMaterial.transparent : <code>boolean</code>
Overwritten since sprite materials are transparent
by default.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>true</code>  
<a name="SpriteMaterial+fog"></a>

### spriteMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>true</code>  
<a name="Line2NodeMaterial"></a>

## Line2NodeMaterial ⇐ <code>NodeMaterial</code>
This node material can be used to render lines with a size larger than one
by representing them as instanced meshes.

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [Line2NodeMaterial](#Line2NodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new Line2NodeMaterial([parameters])](#new_Line2NodeMaterial_new)
    * [.isLine2NodeMaterial](#Line2NodeMaterial+isLine2NodeMaterial) : <code>boolean</code>
    * [.useColor](#Line2NodeMaterial+useColor) : <code>boolean</code>
    * [.dashOffset](#Line2NodeMaterial+dashOffset) : <code>number</code>
    * [.lineWidth](#Line2NodeMaterial+lineWidth) : <code>number</code>
    * [.lineColorNode](#Line2NodeMaterial+lineColorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.offsetNode](#Line2NodeMaterial+offsetNode) : <code>Node.&lt;float&gt;</code>
    * [.dashScaleNode](#Line2NodeMaterial+dashScaleNode) : <code>Node.&lt;float&gt;</code>
    * [.dashSizeNode](#Line2NodeMaterial+dashSizeNode) : <code>Node.&lt;float&gt;</code>
    * [.gapSizeNode](#Line2NodeMaterial+gapSizeNode) : <code>Node.&lt;float&gt;</code>
    * [.blending](#Line2NodeMaterial+blending) : <code>number</code>
    * [.worldUnits](#Line2NodeMaterial+worldUnits) : <code>boolean</code>
    * [.dashed](#Line2NodeMaterial+dashed) : <code>boolean</code>
    * [.alphaToCoverage](#Line2NodeMaterial+alphaToCoverage) : <code>boolean</code>
    * [.setup(builder)](#Line2NodeMaterial+setup)

<a name="new_Line2NodeMaterial_new"></a>

### new Line2NodeMaterial([parameters])
Constructs a new node material for wide line rendering.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parameters] | <code>Object</code> | <code>{}</code> | The configuration parameter. |

<a name="Line2NodeMaterial+isLine2NodeMaterial"></a>

### line2NodeMaterial.isLine2NodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Line2NodeMaterial+useColor"></a>

### line2NodeMaterial.useColor : <code>boolean</code>
Whether vertex colors should be used or not.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>false</code>  
<a name="Line2NodeMaterial+dashOffset"></a>

### line2NodeMaterial.dashOffset : <code>number</code>
The dash offset.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>0</code>  
<a name="Line2NodeMaterial+lineWidth"></a>

### line2NodeMaterial.lineWidth : <code>number</code>
The line width.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>0</code>  
<a name="Line2NodeMaterial+lineColorNode"></a>

### line2NodeMaterial.lineColorNode : <code>Node.&lt;vec3&gt;</code>
Defines the lines color.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+offsetNode"></a>

### line2NodeMaterial.offsetNode : <code>Node.&lt;float&gt;</code>
Defines the offset.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+dashScaleNode"></a>

### line2NodeMaterial.dashScaleNode : <code>Node.&lt;float&gt;</code>
Defines the dash scale.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+dashSizeNode"></a>

### line2NodeMaterial.dashSizeNode : <code>Node.&lt;float&gt;</code>
Defines the dash size.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+gapSizeNode"></a>

### line2NodeMaterial.gapSizeNode : <code>Node.&lt;float&gt;</code>
Defines the gap size.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+blending"></a>

### line2NodeMaterial.blending : <code>number</code>
Blending is set to `NoBlending` since transparency
is not supported, yet.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>0</code>  
<a name="Line2NodeMaterial+worldUnits"></a>

### line2NodeMaterial.worldUnits : <code>boolean</code>
Whether the lines should sized in world units or not.
When set to `false` the unit is pixel.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>false</code>  
<a name="Line2NodeMaterial+dashed"></a>

### line2NodeMaterial.dashed : <code>boolean</code>
Whether the lines should be dashed or not.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>false</code>  
<a name="Line2NodeMaterial+alphaToCoverage"></a>

### line2NodeMaterial.alphaToCoverage : <code>boolean</code>
Whether alpha to coverage should be used or not.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>true</code>  
<a name="Line2NodeMaterial+setup"></a>

### line2NodeMaterial.setup(builder)
Setups the vertex and fragment stage of this node material.

**Kind**: instance method of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LineBasicNodeMaterial"></a>

## LineBasicNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [LineBasicMaterial](LineBasicMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [LineBasicNodeMaterial](#LineBasicNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new LineBasicNodeMaterial([parameters])](#new_LineBasicNodeMaterial_new)
    * [.isLineBasicNodeMaterial](#LineBasicNodeMaterial+isLineBasicNodeMaterial) : <code>boolean</code>

<a name="new_LineBasicNodeMaterial_new"></a>

### new LineBasicNodeMaterial([parameters])
Constructs a new line basic node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="LineBasicNodeMaterial+isLineBasicNodeMaterial"></a>

### lineBasicNodeMaterial.isLineBasicNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineBasicNodeMaterial</code>](#LineBasicNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineDashedNodeMaterial"></a>

## LineDashedNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of  [LineDashedMaterial](LineDashedMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [LineDashedNodeMaterial](#LineDashedNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new LineDashedNodeMaterial([parameters])](#new_LineDashedNodeMaterial_new)
    * [.isLineDashedNodeMaterial](#LineDashedNodeMaterial+isLineDashedNodeMaterial) : <code>boolean</code>
    * [.dashOffset](#LineDashedNodeMaterial+dashOffset) : <code>number</code>
    * [.offsetNode](#LineDashedNodeMaterial+offsetNode) : <code>Node.&lt;float&gt;</code>
    * [.dashScaleNode](#LineDashedNodeMaterial+dashScaleNode) : <code>Node.&lt;float&gt;</code>
    * [.dashSizeNode](#LineDashedNodeMaterial+dashSizeNode) : <code>Node.&lt;float&gt;</code>
    * [.gapSizeNode](#LineDashedNodeMaterial+gapSizeNode) : <code>Node.&lt;float&gt;</code>
    * [.setupVariants(builder)](#LineDashedNodeMaterial+setupVariants)

<a name="new_LineDashedNodeMaterial_new"></a>

### new LineDashedNodeMaterial([parameters])
Constructs a new line dashed node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="LineDashedNodeMaterial+isLineDashedNodeMaterial"></a>

### lineDashedNodeMaterial.isLineDashedNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineDashedNodeMaterial+dashOffset"></a>

### lineDashedNodeMaterial.dashOffset : <code>number</code>
The dash offset.

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>0</code>  
<a name="LineDashedNodeMaterial+offsetNode"></a>

### lineDashedNodeMaterial.offsetNode : <code>Node.&lt;float&gt;</code>
The offset of dash materials is by default inferred from the `dashOffset`
property. This node property allows to overwrite the default
and define the offset with a node instead.

If you don't want to overwrite the offset but modify the existing
value instead, use [materialLineDashOffset](materialLineDashOffset).

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>null</code>  
<a name="LineDashedNodeMaterial+dashScaleNode"></a>

### lineDashedNodeMaterial.dashScaleNode : <code>Node.&lt;float&gt;</code>
The scale of dash materials is by default inferred from the `scale`
property. This node property allows to overwrite the default
and define the scale with a node instead.

If you don't want to overwrite the scale but modify the existing
value instead, use [materialLineScale](materialLineScale).

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>null</code>  
<a name="LineDashedNodeMaterial+dashSizeNode"></a>

### lineDashedNodeMaterial.dashSizeNode : <code>Node.&lt;float&gt;</code>
The dash size of dash materials is by default inferred from the `dashSize`
property. This node property allows to overwrite the default
and define the dash size with a node instead.

If you don't want to overwrite the dash size but modify the existing
value instead, use [materialLineDashSize](materialLineDashSize).

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>null</code>  
<a name="LineDashedNodeMaterial+gapSizeNode"></a>

### lineDashedNodeMaterial.gapSizeNode : <code>Node.&lt;float&gt;</code>
The gap size of dash materials is by default inferred from the `gapSize`
property. This node property allows to overwrite the default
and define the gap size with a node instead.

If you don't want to overwrite the gap size but modify the existing
value instead, use [materialLineGapSize](materialLineGapSize).

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>null</code>  
<a name="LineDashedNodeMaterial+setupVariants"></a>

### lineDashedNodeMaterial.setupVariants(builder)
Setups the dash specific node variables.

**Kind**: instance method of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshBasicNodeMaterial"></a>

## MeshBasicNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshBasicMaterial](MeshBasicMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshBasicNodeMaterial](#MeshBasicNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshBasicNodeMaterial([parameters])](#new_MeshBasicNodeMaterial_new)
    * [.isMeshBasicNodeMaterial](#MeshBasicNodeMaterial+isMeshBasicNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshBasicNodeMaterial+lights) : <code>boolean</code>
    * [.setupNormal()](#MeshBasicNodeMaterial+setupNormal) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupEnvironment(builder)](#MeshBasicNodeMaterial+setupEnvironment) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
    * [.setupLightMap(builder)](#MeshBasicNodeMaterial+setupLightMap) ⇒ <code>BasicLightMapNode.&lt;vec3&gt;</code>
    * [.setupOutgoingLight()](#MeshBasicNodeMaterial+setupOutgoingLight) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupLightingModel()](#MeshBasicNodeMaterial+setupLightingModel) ⇒ <code>BasicLightingModel</code>

<a name="new_MeshBasicNodeMaterial_new"></a>

### new MeshBasicNodeMaterial([parameters])
Constructs a new mesh basic node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshBasicNodeMaterial+isMeshBasicNodeMaterial"></a>

### meshBasicNodeMaterial.isMeshBasicNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshBasicNodeMaterial+lights"></a>

### meshBasicNodeMaterial.lights : <code>boolean</code>
Although the basic material is by definition unlit, we set
this property to `true` since we use a lighting model to compute
the outgoing light of the fragment shader.

**Kind**: instance property of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshBasicNodeMaterial+setupNormal"></a>

### meshBasicNodeMaterial.setupNormal() ⇒ <code>Node.&lt;vec3&gt;</code>
Basic materials are not affected by normal and bump maps so we
return by default [normalView](normalView).

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The normal node.  
<a name="MeshBasicNodeMaterial+setupEnvironment"></a>

### meshBasicNodeMaterial.setupEnvironment(builder) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
Overwritten since this type of material uses [BasicEnvironmentNode](BasicEnvironmentNode)
to implement the default environment mapping.

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>BasicEnvironmentNode.&lt;vec3&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshBasicNodeMaterial+setupLightMap"></a>

### meshBasicNodeMaterial.setupLightMap(builder) ⇒ <code>BasicLightMapNode.&lt;vec3&gt;</code>
This method must be overwritten since light maps are evaluated
with a special scaling factor for basic materials.

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>BasicLightMapNode.&lt;vec3&gt;</code> - The light map node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshBasicNodeMaterial+setupOutgoingLight"></a>

### meshBasicNodeMaterial.setupOutgoingLight() ⇒ <code>Node.&lt;vec3&gt;</code>
The material overwrites this method because `lights` is set to `true` but
we still want to return the diffuse color as the outgoing light.

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The outgoing light node.  
<a name="MeshBasicNodeMaterial+setupLightingModel"></a>

### meshBasicNodeMaterial.setupLightingModel() ⇒ <code>BasicLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>BasicLightingModel</code> - The lighting model.  
<a name="MeshLambertNodeMaterial"></a>

## MeshLambertNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshLambertMaterial](MeshLambertMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshLambertNodeMaterial](#MeshLambertNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshLambertNodeMaterial([parameters])](#new_MeshLambertNodeMaterial_new)
    * [.isMeshLambertNodeMaterial](#MeshLambertNodeMaterial+isMeshLambertNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshLambertNodeMaterial+lights) : <code>boolean</code>
    * [.setupEnvironment(builder)](#MeshLambertNodeMaterial+setupEnvironment) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
    * [.setupLightingModel()](#MeshLambertNodeMaterial+setupLightingModel) ⇒ <code>PhongLightingModel</code>

<a name="new_MeshLambertNodeMaterial_new"></a>

### new MeshLambertNodeMaterial([parameters])
Constructs a new mesh lambert node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshLambertNodeMaterial+isMeshLambertNodeMaterial"></a>

### meshLambertNodeMaterial.isMeshLambertNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshLambertNodeMaterial</code>](#MeshLambertNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshLambertNodeMaterial+lights"></a>

### meshLambertNodeMaterial.lights : <code>boolean</code>
Set to `true` because lambert materials react on lights.

**Kind**: instance property of [<code>MeshLambertNodeMaterial</code>](#MeshLambertNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshLambertNodeMaterial+setupEnvironment"></a>

### meshLambertNodeMaterial.setupEnvironment(builder) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
Overwritten since this type of material uses [BasicEnvironmentNode](BasicEnvironmentNode)
to implement the default environment mapping.

**Kind**: instance method of [<code>MeshLambertNodeMaterial</code>](#MeshLambertNodeMaterial)  
**Returns**: <code>BasicEnvironmentNode.&lt;vec3&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshLambertNodeMaterial+setupLightingModel"></a>

### meshLambertNodeMaterial.setupLightingModel() ⇒ <code>PhongLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshLambertNodeMaterial</code>](#MeshLambertNodeMaterial)  
**Returns**: <code>PhongLightingModel</code> - The lighting model.  
<a name="MeshMatcapNodeMaterial"></a>

## MeshMatcapNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshMatcapMaterial](MeshMatcapMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshMatcapNodeMaterial](#MeshMatcapNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshMatcapNodeMaterial([parameters])](#new_MeshMatcapNodeMaterial_new)
    * [.isMeshMatcapNodeMaterial](#MeshMatcapNodeMaterial+isMeshMatcapNodeMaterial) : <code>boolean</code>
    * [.setupVariants(builder)](#MeshMatcapNodeMaterial+setupVariants)

<a name="new_MeshMatcapNodeMaterial_new"></a>

### new MeshMatcapNodeMaterial([parameters])
Constructs a new mesh normal node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshMatcapNodeMaterial+isMeshMatcapNodeMaterial"></a>

### meshMatcapNodeMaterial.isMeshMatcapNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshMatcapNodeMaterial</code>](#MeshMatcapNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshMatcapNodeMaterial+setupVariants"></a>

### meshMatcapNodeMaterial.setupVariants(builder)
Setups the matcap specific node variables.

**Kind**: instance method of [<code>MeshMatcapNodeMaterial</code>](#MeshMatcapNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshNormalNodeMaterial"></a>

## MeshNormalNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshNormalMaterial](MeshNormalMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshNormalNodeMaterial](#MeshNormalNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshNormalNodeMaterial([parameters])](#new_MeshNormalNodeMaterial_new)
    * [.isMeshNormalNodeMaterial](#MeshNormalNodeMaterial+isMeshNormalNodeMaterial) : <code>boolean</code>
    * [.setupDiffuseColor()](#MeshNormalNodeMaterial+setupDiffuseColor)

<a name="new_MeshNormalNodeMaterial_new"></a>

### new MeshNormalNodeMaterial([parameters])
Constructs a new mesh normal node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshNormalNodeMaterial+isMeshNormalNodeMaterial"></a>

### meshNormalNodeMaterial.isMeshNormalNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshNormalNodeMaterial</code>](#MeshNormalNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshNormalNodeMaterial+setupDiffuseColor"></a>

### meshNormalNodeMaterial.setupDiffuseColor()
Overwrites the default implementation by computing the diffuse color
based on the normal data.

**Kind**: instance method of [<code>MeshNormalNodeMaterial</code>](#MeshNormalNodeMaterial)  
<a name="MeshPhongNodeMaterial"></a>

## MeshPhongNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshPhongMaterial](MeshPhongMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshPhongNodeMaterial](#MeshPhongNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshPhongNodeMaterial([parameters])](#new_MeshPhongNodeMaterial_new)
    * [.isMeshPhongNodeMaterial](#MeshPhongNodeMaterial+isMeshPhongNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshPhongNodeMaterial+lights) : <code>boolean</code>
    * [.shininessNode](#MeshPhongNodeMaterial+shininessNode) : <code>Node.&lt;float&gt;</code>
    * [.specularNode](#MeshPhongNodeMaterial+specularNode) : <code>Node.&lt;vec3&gt;</code>
    * [.setupEnvironment(builder)](#MeshPhongNodeMaterial+setupEnvironment) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
    * [.setupLightingModel()](#MeshPhongNodeMaterial+setupLightingModel) ⇒ <code>PhongLightingModel</code>
    * [.setupVariants(builder)](#MeshPhongNodeMaterial+setupVariants)

<a name="new_MeshPhongNodeMaterial_new"></a>

### new MeshPhongNodeMaterial([parameters])
Constructs a new mesh lambert node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshPhongNodeMaterial+isMeshPhongNodeMaterial"></a>

### meshPhongNodeMaterial.isMeshPhongNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPhongNodeMaterial+lights"></a>

### meshPhongNodeMaterial.lights : <code>boolean</code>
Set to `true` because phong materials react on lights.

**Kind**: instance property of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhongNodeMaterial+shininessNode"></a>

### meshPhongNodeMaterial.shininessNode : <code>Node.&lt;float&gt;</code>
The shininess of phong materials is by default inferred from the `shininess`
property. This node property allows to overwrite the default
and define the shininess with a node instead.

If you don't want to overwrite the shininess but modify the existing
value instead, use [materialShininess](materialShininess).

**Kind**: instance property of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongNodeMaterial+specularNode"></a>

### meshPhongNodeMaterial.specularNode : <code>Node.&lt;vec3&gt;</code>
The specular color of phong materials is by default inferred from the
`specular` property. This node property allows to overwrite the default
and define the specular color with a node instead.

If you don't want to overwrite the specular color but modify the existing
value instead, use [materialSpecular](materialSpecular).

**Kind**: instance property of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongNodeMaterial+setupEnvironment"></a>

### meshPhongNodeMaterial.setupEnvironment(builder) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
Overwritten since this type of material uses [BasicEnvironmentNode](BasicEnvironmentNode)
to implement the default environment mapping.

**Kind**: instance method of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Returns**: <code>BasicEnvironmentNode.&lt;vec3&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshPhongNodeMaterial+setupLightingModel"></a>

### meshPhongNodeMaterial.setupLightingModel() ⇒ <code>PhongLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Returns**: <code>PhongLightingModel</code> - The lighting model.  
<a name="MeshPhongNodeMaterial+setupVariants"></a>

### meshPhongNodeMaterial.setupVariants(builder)
Setups the phong specific node variables.

**Kind**: instance method of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshPhysicalNodeMaterial"></a>

## MeshPhysicalNodeMaterial ⇐ <code>MeshStandardNodeMaterial</code>
Node material version of [MeshPhysicalMaterial](MeshPhysicalMaterial).

**Kind**: global class  
**Extends**: <code>MeshStandardNodeMaterial</code>  

* [MeshPhysicalNodeMaterial](#MeshPhysicalNodeMaterial) ⇐ <code>MeshStandardNodeMaterial</code>
    * [new MeshPhysicalNodeMaterial([parameters])](#new_MeshPhysicalNodeMaterial_new)
    * [.isMeshPhysicalNodeMaterial](#MeshPhysicalNodeMaterial+isMeshPhysicalNodeMaterial) : <code>boolean</code>
    * [.clearcoatNode](#MeshPhysicalNodeMaterial+clearcoatNode) : <code>Node.&lt;float&gt;</code>
    * [.clearcoatRoughnessNode](#MeshPhysicalNodeMaterial+clearcoatRoughnessNode) : <code>Node.&lt;float&gt;</code>
    * [.clearcoatNormalNode](#MeshPhysicalNodeMaterial+clearcoatNormalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.sheenNode](#MeshPhysicalNodeMaterial+sheenNode) : <code>Node.&lt;vec3&gt;</code>
    * [.sheenRoughnessNode](#MeshPhysicalNodeMaterial+sheenRoughnessNode) : <code>Node.&lt;float&gt;</code>
    * [.iridescenceNode](#MeshPhysicalNodeMaterial+iridescenceNode) : <code>Node.&lt;float&gt;</code>
    * [.iridescenceIORNode](#MeshPhysicalNodeMaterial+iridescenceIORNode) : <code>Node.&lt;float&gt;</code>
    * [.iridescenceThicknessNode](#MeshPhysicalNodeMaterial+iridescenceThicknessNode) : <code>Node.&lt;float&gt;</code>
    * [.specularIntensityNode](#MeshPhysicalNodeMaterial+specularIntensityNode) : <code>Node.&lt;float&gt;</code>
    * [.specularColorNode](#MeshPhysicalNodeMaterial+specularColorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.iorNode](#MeshPhysicalNodeMaterial+iorNode) : <code>Node.&lt;float&gt;</code>
    * [.transmissionNode](#MeshPhysicalNodeMaterial+transmissionNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessNode](#MeshPhysicalNodeMaterial+thicknessNode) : <code>Node.&lt;float&gt;</code>
    * [.attenuationDistanceNode](#MeshPhysicalNodeMaterial+attenuationDistanceNode) : <code>Node.&lt;float&gt;</code>
    * [.attenuationColorNode](#MeshPhysicalNodeMaterial+attenuationColorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.dispersionNode](#MeshPhysicalNodeMaterial+dispersionNode) : <code>Node.&lt;float&gt;</code>
    * [.anisotropyNode](#MeshPhysicalNodeMaterial+anisotropyNode) : <code>Node.&lt;float&gt;</code>
    * [.useClearcoat](#MeshPhysicalNodeMaterial+useClearcoat) : <code>boolean</code>
    * [.useIridescence](#MeshPhysicalNodeMaterial+useIridescence) : <code>boolean</code>
    * [.useSheen](#MeshPhysicalNodeMaterial+useSheen) : <code>boolean</code>
    * [.useAnisotropy](#MeshPhysicalNodeMaterial+useAnisotropy) : <code>boolean</code>
    * [.useTransmission](#MeshPhysicalNodeMaterial+useTransmission) : <code>boolean</code>
    * [.useDispersion](#MeshPhysicalNodeMaterial+useDispersion) : <code>boolean</code>
    * [.setupSpecular()](#MeshPhysicalNodeMaterial+setupSpecular)
    * [.setupLightingModel()](#MeshPhysicalNodeMaterial+setupLightingModel) ⇒ <code>PhysicalLightingModel</code>
    * [.setupVariants(builder)](#MeshPhysicalNodeMaterial+setupVariants)
    * [.setupClearcoatNormal()](#MeshPhysicalNodeMaterial+setupClearcoatNormal) ⇒ <code>Node.&lt;vec3&gt;</code>

<a name="new_MeshPhysicalNodeMaterial_new"></a>

### new MeshPhysicalNodeMaterial([parameters])
Constructs a new mesh physical node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshPhysicalNodeMaterial+isMeshPhysicalNodeMaterial"></a>

### meshPhysicalNodeMaterial.isMeshPhysicalNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPhysicalNodeMaterial+clearcoatNode"></a>

### meshPhysicalNodeMaterial.clearcoatNode : <code>Node.&lt;float&gt;</code>
The clearcoat of physical materials is by default inferred from the `clearcoat`
and `clearcoatMap` properties. This node property allows to overwrite the default
and define the clearcoat with a node instead.

If you don't want to overwrite the clearcoat but modify the existing
value instead, use [materialClearcoat](materialClearcoat).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+clearcoatRoughnessNode"></a>

### meshPhysicalNodeMaterial.clearcoatRoughnessNode : <code>Node.&lt;float&gt;</code>
The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`
and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default
and define the clearcoat roughness with a node instead.

If you don't want to overwrite the clearcoat roughness but modify the existing
value instead, use [materialClearcoatRoughness](materialClearcoatRoughness).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+clearcoatNormalNode"></a>

### meshPhysicalNodeMaterial.clearcoatNormalNode : <code>Node.&lt;vec3&gt;</code>
The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`
property. This node property allows to overwrite the default
and define the clearcoat normal with a node instead.

If you don't want to overwrite the clearcoat normal but modify the existing
value instead, use [materialClearcoatNormal](materialClearcoatNormal).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+sheenNode"></a>

### meshPhysicalNodeMaterial.sheenNode : <code>Node.&lt;vec3&gt;</code>
The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`
and `sheenColorMap` properties. This node property allows to overwrite the default
and define the sheen with a node instead.

If you don't want to overwrite the sheen but modify the existing
value instead, use [materialSheen](materialSheen).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+sheenRoughnessNode"></a>

### meshPhysicalNodeMaterial.sheenRoughnessNode : <code>Node.&lt;float&gt;</code>
The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and
`sheenRoughnessMap` properties. This node property allows to overwrite the default
and define the sheen roughness with a node instead.

If you don't want to overwrite the sheen roughness but modify the existing
value instead, use [materialSheenRoughness](materialSheenRoughness).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+iridescenceNode"></a>

### meshPhysicalNodeMaterial.iridescenceNode : <code>Node.&lt;float&gt;</code>
The iridescence of physical materials is by default inferred from the `iridescence`
property. This node property allows to overwrite the default
and define the iridescence with a node instead.

If you don't want to overwrite the iridescence but modify the existing
value instead, use [materialIridescence](materialIridescence).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+iridescenceIORNode"></a>

### meshPhysicalNodeMaterial.iridescenceIORNode : <code>Node.&lt;float&gt;</code>
The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`
property. This node property allows to overwrite the default
and define the iridescence IOR with a node instead.

If you don't want to overwrite the iridescence IOR but modify the existing
value instead, use [materialIridescenceIOR](materialIridescenceIOR).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+iridescenceThicknessNode"></a>

### meshPhysicalNodeMaterial.iridescenceThicknessNode : <code>Node.&lt;float&gt;</code>
The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`
and `iridescenceThicknessMap` properties. This node property allows to overwrite the default
and define the iridescence thickness with a node instead.

If you don't want to overwrite the iridescence thickness but modify the existing
value instead, use [materialIridescenceThickness](materialIridescenceThickness).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+specularIntensityNode"></a>

### meshPhysicalNodeMaterial.specularIntensityNode : <code>Node.&lt;float&gt;</code>
The specular intensity of physical materials is by default inferred from the `specularIntensity`
and `specularIntensityMap` properties. This node property allows to overwrite the default
and define the specular intensity with a node instead.

If you don't want to overwrite the specular intensity but modify the existing
value instead, use [materialSpecularIntensity](materialSpecularIntensity).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+specularColorNode"></a>

### meshPhysicalNodeMaterial.specularColorNode : <code>Node.&lt;vec3&gt;</code>
The specular color of physical materials is by default inferred from the `specularColor`
and `specularColorMap` properties. This node property allows to overwrite the default
and define the specular color with a node instead.

If you don't want to overwrite the specular color but modify the existing
value instead, use [materialSpecularColor](materialSpecularColor).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+iorNode"></a>

### meshPhysicalNodeMaterial.iorNode : <code>Node.&lt;float&gt;</code>
The ior of physical materials is by default inferred from the `ior`
property. This node property allows to overwrite the default
and define the ior with a node instead.

If you don't want to overwrite the ior but modify the existing
value instead, use [materialIOR](materialIOR).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+transmissionNode"></a>

### meshPhysicalNodeMaterial.transmissionNode : <code>Node.&lt;float&gt;</code>
The transmission of physical materials is by default inferred from the `transmission` and
`transmissionMap` properties. This node property allows to overwrite the default
and define the transmission with a node instead.

If you don't want to overwrite the transmission but modify the existing
value instead, use [materialTransmission](materialTransmission).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+thicknessNode"></a>

### meshPhysicalNodeMaterial.thicknessNode : <code>Node.&lt;float&gt;</code>
The thickness of physical materials is by default inferred from the `thickness` and
`thicknessMap` properties. This node property allows to overwrite the default
and define the thickness with a node instead.

If you don't want to overwrite the thickness but modify the existing
value instead, use [materialThickness](materialThickness).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+attenuationDistanceNode"></a>

### meshPhysicalNodeMaterial.attenuationDistanceNode : <code>Node.&lt;float&gt;</code>
The attenuation distance of physical materials is by default inferred from the
`attenuationDistance` property. This node property allows to overwrite the default
and define the attenuation distance with a node instead.

If you don't want to overwrite the attenuation distance but modify the existing
value instead, use [materialAttenuationDistance](materialAttenuationDistance).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+attenuationColorNode"></a>

### meshPhysicalNodeMaterial.attenuationColorNode : <code>Node.&lt;vec3&gt;</code>
The attenuation color of physical materials is by default inferred from the
`attenuationColor` property. This node property allows to overwrite the default
and define the attenuation color with a node instead.

If you don't want to overwrite the attenuation color but modify the existing
value instead, use [materialAttenuationColor](materialAttenuationColor).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+dispersionNode"></a>

### meshPhysicalNodeMaterial.dispersionNode : <code>Node.&lt;float&gt;</code>
The dispersion of physical materials is by default inferred from the
`dispersion` property. This node property allows to overwrite the default
and define the dispersion with a node instead.

If you don't want to overwrite the dispersion but modify the existing
value instead, use [materialDispersion](materialDispersion).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+anisotropyNode"></a>

### meshPhysicalNodeMaterial.anisotropyNode : <code>Node.&lt;float&gt;</code>
The anisotropy of physical materials is by default inferred from the
`anisotropy` property. This node property allows to overwrite the default
and define the anisotropy with a node instead.

If you don't want to overwrite the anisotropy but modify the existing
value instead, use [materialAnisotropy](materialAnisotropy).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+useClearcoat"></a>

### meshPhysicalNodeMaterial.useClearcoat : <code>boolean</code>
Whether the lighting model should use clearcoat or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useIridescence"></a>

### meshPhysicalNodeMaterial.useIridescence : <code>boolean</code>
Whether the lighting model should use iridescence or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useSheen"></a>

### meshPhysicalNodeMaterial.useSheen : <code>boolean</code>
Whether the lighting model should use sheen or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useAnisotropy"></a>

### meshPhysicalNodeMaterial.useAnisotropy : <code>boolean</code>
Whether the lighting model should use anisotropy or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useTransmission"></a>

### meshPhysicalNodeMaterial.useTransmission : <code>boolean</code>
Whether the lighting model should use transmission or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useDispersion"></a>

### meshPhysicalNodeMaterial.useDispersion : <code>boolean</code>
Whether the lighting model should use dispersion or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+setupSpecular"></a>

### meshPhysicalNodeMaterial.setupSpecular()
Setups the specular related node variables.

**Kind**: instance method of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
<a name="MeshPhysicalNodeMaterial+setupLightingModel"></a>

### meshPhysicalNodeMaterial.setupLightingModel() ⇒ <code>PhysicalLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Returns**: <code>PhysicalLightingModel</code> - The lighting model.  
<a name="MeshPhysicalNodeMaterial+setupVariants"></a>

### meshPhysicalNodeMaterial.setupVariants(builder)
Setups the physical specific node variables.

**Kind**: instance method of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshPhysicalNodeMaterial+setupClearcoatNormal"></a>

### meshPhysicalNodeMaterial.setupClearcoatNormal() ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the clearcoat normal node.

**Kind**: instance method of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The clearcoat normal.  
## Classes

<dl>
<dt><a href="#SSSLightingModel">SSSLightingModel</a> ⇐ <code>PhysicalLightingModel</code></dt>
<dd><p>Represents the lighting model for <a href="#MeshSSSNodeMaterial">MeshSSSNodeMaterial</a>.</p>
</dd>
<dt><a href="#MeshSSSNodeMaterial">MeshSSSNodeMaterial</a> ⇐ <code>MeshPhysicalNodeMaterial</code></dt>
<dd><p>This node material is an experimental extension of <a href="MeshPhysicalNodeMaterial">MeshPhysicalNodeMaterial</a>
that implements a Subsurface scattering (SSS) term.</p>
</dd>
</dl>

<a name="SSSLightingModel"></a>

## SSSLightingModel ⇐ <code>PhysicalLightingModel</code>
Represents the lighting model for [MeshSSSNodeMaterial](#MeshSSSNodeMaterial).

**Kind**: global class  
**Extends**: <code>PhysicalLightingModel</code>  

* [SSSLightingModel](#SSSLightingModel) ⇐ <code>PhysicalLightingModel</code>
    * [new SSSLightingModel([clearcoat], [sheen], [iridescence], [anisotropy], [transmission], [dispersion], [sss])](#new_SSSLightingModel_new)
    * [.useSSS](#SSSLightingModel+useSSS) : <code>boolean</code>
    * [.direct(input, builder)](#SSSLightingModel+direct)

<a name="new_SSSLightingModel_new"></a>

### new SSSLightingModel([clearcoat], [sheen], [iridescence], [anisotropy], [transmission], [dispersion], [sss])
Constructs a new physical lighting model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [clearcoat] | <code>boolean</code> | <code>false</code> | Whether clearcoat is supported or not. |
| [sheen] | <code>boolean</code> | <code>false</code> | Whether sheen is supported or not. |
| [iridescence] | <code>boolean</code> | <code>false</code> | Whether iridescence is supported or not. |
| [anisotropy] | <code>boolean</code> | <code>false</code> | Whether anisotropy is supported or not. |
| [transmission] | <code>boolean</code> | <code>false</code> | Whether transmission is supported or not. |
| [dispersion] | <code>boolean</code> | <code>false</code> | Whether dispersion is supported or not. |
| [sss] | <code>boolean</code> | <code>false</code> | Whether SSS is supported or not. |

<a name="SSSLightingModel+useSSS"></a>

### sssLightingModel.useSSS : <code>boolean</code>
Whether the lighting model should use SSS or not.

**Kind**: instance property of [<code>SSSLightingModel</code>](#SSSLightingModel)  
**Default**: <code>false</code>  
<a name="SSSLightingModel+direct"></a>

### sssLightingModel.direct(input, builder)
Extends the default implementation with a SSS term.

Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look](https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/)

**Kind**: instance method of [<code>SSSLightingModel</code>](#SSSLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Object</code> | The input data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshSSSNodeMaterial"></a>

## MeshSSSNodeMaterial ⇐ <code>MeshPhysicalNodeMaterial</code>
This node material is an experimental extension of [MeshPhysicalNodeMaterial](MeshPhysicalNodeMaterial)
that implements a Subsurface scattering (SSS) term.

**Kind**: global class  
**Extends**: <code>MeshPhysicalNodeMaterial</code>  

* [MeshSSSNodeMaterial](#MeshSSSNodeMaterial) ⇐ <code>MeshPhysicalNodeMaterial</code>
    * [new MeshSSSNodeMaterial([parameters])](#new_MeshSSSNodeMaterial_new)
    * [.thicknessColorNode](#MeshSSSNodeMaterial+thicknessColorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.thicknessDistortionNode](#MeshSSSNodeMaterial+thicknessDistortionNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessAmbientNode](#MeshSSSNodeMaterial+thicknessAmbientNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessAttenuationNode](#MeshSSSNodeMaterial+thicknessAttenuationNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessPowerNode](#MeshSSSNodeMaterial+thicknessPowerNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessScaleNode](#MeshSSSNodeMaterial+thicknessScaleNode) : <code>Node.&lt;float&gt;</code>
    * [.useSSS](#MeshSSSNodeMaterial+useSSS) : <code>boolean</code>
    * [.setupLightingModel()](#MeshSSSNodeMaterial+setupLightingModel) ⇒ [<code>SSSLightingModel</code>](#SSSLightingModel)

<a name="new_MeshSSSNodeMaterial_new"></a>

### new MeshSSSNodeMaterial([parameters])
Constructs a new mesh SSS node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshSSSNodeMaterial+thicknessColorNode"></a>

### meshSSSNodeMaterial.thicknessColorNode : <code>Node.&lt;vec3&gt;</code>
Represents the thickness color.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshSSSNodeMaterial+thicknessDistortionNode"></a>

### meshSSSNodeMaterial.thicknessDistortionNode : <code>Node.&lt;float&gt;</code>
Represents the distortion factor.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+thicknessAmbientNode"></a>

### meshSSSNodeMaterial.thicknessAmbientNode : <code>Node.&lt;float&gt;</code>
Represents the thickness ambient factor.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+thicknessAttenuationNode"></a>

### meshSSSNodeMaterial.thicknessAttenuationNode : <code>Node.&lt;float&gt;</code>
Represents the thickness attenuation.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+thicknessPowerNode"></a>

### meshSSSNodeMaterial.thicknessPowerNode : <code>Node.&lt;float&gt;</code>
Represents the thickness power.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+thicknessScaleNode"></a>

### meshSSSNodeMaterial.thicknessScaleNode : <code>Node.&lt;float&gt;</code>
Represents the thickness scale.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+useSSS"></a>

### meshSSSNodeMaterial.useSSS : <code>boolean</code>
Whether the lighting model should use SSS or not.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshSSSNodeMaterial+setupLightingModel"></a>

### meshSSSNodeMaterial.setupLightingModel() ⇒ [<code>SSSLightingModel</code>](#SSSLightingModel)
Setups the lighting model.

**Kind**: instance method of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
**Returns**: [<code>SSSLightingModel</code>](#SSSLightingModel) - The lighting model.  
<a name="MeshStandardNodeMaterial"></a>

## MeshStandardNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshStandardMaterial](MeshStandardMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshStandardNodeMaterial](#MeshStandardNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshStandardNodeMaterial([parameters])](#new_MeshStandardNodeMaterial_new)
    * [.isMeshStandardNodeMaterial](#MeshStandardNodeMaterial+isMeshStandardNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshStandardNodeMaterial+lights) : <code>boolean</code>
    * [.emissiveNode](#MeshStandardNodeMaterial+emissiveNode) : <code>Node.&lt;vec3&gt;</code>
    * [.metalnessNode](#MeshStandardNodeMaterial+metalnessNode) : <code>Node.&lt;float&gt;</code>
    * [.roughnessNode](#MeshStandardNodeMaterial+roughnessNode) : <code>Node.&lt;float&gt;</code>
    * [.setupEnvironment(builder)](#MeshStandardNodeMaterial+setupEnvironment) ⇒ <code>EnvironmentNode.&lt;vec3&gt;</code>
    * [.setupLightingModel()](#MeshStandardNodeMaterial+setupLightingModel) ⇒ <code>PhysicalLightingModel</code>
    * [.setupSpecular()](#MeshStandardNodeMaterial+setupSpecular)
    * [.setupVariants(builder)](#MeshStandardNodeMaterial+setupVariants)

<a name="new_MeshStandardNodeMaterial_new"></a>

### new MeshStandardNodeMaterial([parameters])
Constructs a new mesh standard node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshStandardNodeMaterial+isMeshStandardNodeMaterial"></a>

### meshStandardNodeMaterial.isMeshStandardNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshStandardNodeMaterial+lights"></a>

### meshStandardNodeMaterial.lights : <code>boolean</code>
Set to `true` because standard materials react on lights.

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshStandardNodeMaterial+emissiveNode"></a>

### meshStandardNodeMaterial.emissiveNode : <code>Node.&lt;vec3&gt;</code>
The emissive color of standard materials is by default inferred from the `emissive`,
`emissiveIntensity` and `emissiveMap` properties. This node property allows to
overwrite the default and define the emissive color with a node instead.

If you don't want to overwrite the emissive color but modify the existing
value instead, use [materialEmissive](materialEmissive).

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardNodeMaterial+metalnessNode"></a>

### meshStandardNodeMaterial.metalnessNode : <code>Node.&lt;float&gt;</code>
The metalness of standard materials is by default inferred from the `metalness`,
and `metalnessMap` properties. This node property allows to
overwrite the default and define the metalness with a node instead.

If you don't want to overwrite the metalness but modify the existing
value instead, use [materialMetalness](materialMetalness).

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardNodeMaterial+roughnessNode"></a>

### meshStandardNodeMaterial.roughnessNode : <code>Node.&lt;float&gt;</code>
The roughness of standard materials is by default inferred from the `roughness`,
and `roughnessMap` properties. This node property allows to
overwrite the default and define the roughness with a node instead.

If you don't want to overwrite the roughness but modify the existing
value instead, use [materialRoughness](materialRoughness).

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardNodeMaterial+setupEnvironment"></a>

### meshStandardNodeMaterial.setupEnvironment(builder) ⇒ <code>EnvironmentNode.&lt;vec3&gt;</code>
Overwritten since this type of material uses [EnvironmentNode](EnvironmentNode)
to implement the PBR (PMREM based) environment mapping. Besides, the
method honors `Scene.environment`.

**Kind**: instance method of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Returns**: <code>EnvironmentNode.&lt;vec3&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshStandardNodeMaterial+setupLightingModel"></a>

### meshStandardNodeMaterial.setupLightingModel() ⇒ <code>PhysicalLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Returns**: <code>PhysicalLightingModel</code> - The lighting model.  
<a name="MeshStandardNodeMaterial+setupSpecular"></a>

### meshStandardNodeMaterial.setupSpecular()
Setups the specular related node variables.

**Kind**: instance method of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
<a name="MeshStandardNodeMaterial+setupVariants"></a>

### meshStandardNodeMaterial.setupVariants(builder)
Setups the standard specific node variables.

**Kind**: instance method of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshToonNodeMaterial"></a>

## MeshToonNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshToonMaterial](MeshToonMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshToonNodeMaterial](#MeshToonNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshToonNodeMaterial([parameters])](#new_MeshToonNodeMaterial_new)
    * [.isMeshToonNodeMaterial](#MeshToonNodeMaterial+isMeshToonNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshToonNodeMaterial+lights) : <code>boolean</code>
    * [.setupLightingModel()](#MeshToonNodeMaterial+setupLightingModel) ⇒ <code>ToonLightingModel</code>

<a name="new_MeshToonNodeMaterial_new"></a>

### new MeshToonNodeMaterial([parameters])
Constructs a new mesh toon node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshToonNodeMaterial+isMeshToonNodeMaterial"></a>

### meshToonNodeMaterial.isMeshToonNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshToonNodeMaterial</code>](#MeshToonNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshToonNodeMaterial+lights"></a>

### meshToonNodeMaterial.lights : <code>boolean</code>
Set to `true` because toon materials react on lights.

**Kind**: instance property of [<code>MeshToonNodeMaterial</code>](#MeshToonNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshToonNodeMaterial+setupLightingModel"></a>

### meshToonNodeMaterial.setupLightingModel() ⇒ <code>ToonLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshToonNodeMaterial</code>](#MeshToonNodeMaterial)  
**Returns**: <code>ToonLightingModel</code> - The lighting model.  
<a name="NodeMaterial"></a>

## NodeMaterial ⇐ <code>Material</code>
Base class for all node materials.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [NodeMaterial](#NodeMaterial) ⇐ <code>Material</code>
    * [new NodeMaterial()](#new_NodeMaterial_new)
    * [.type](#NodeMaterial+type) : <code>string</code>
    * [.isNodeMaterial](#NodeMaterial+isNodeMaterial) : <code>boolean</code>
    * [.fog](#NodeMaterial+fog) : <code>boolean</code>
    * [.lights](#NodeMaterial+lights) : <code>boolean</code>
    * [.hardwareClipping](#NodeMaterial+hardwareClipping) : <code>boolean</code>
    * [.lightsNode](#NodeMaterial+lightsNode) : <code>LightsNode</code>
    * [.envNode](#NodeMaterial+envNode) : <code>Node.&lt;vec3&gt;</code>
    * [.aoNode](#NodeMaterial+aoNode) : <code>Node.&lt;float&gt;</code>
    * [.colorNode](#NodeMaterial+colorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.normalNode](#NodeMaterial+normalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.opacityNode](#NodeMaterial+opacityNode) : <code>Node.&lt;float&gt;</code>
    * [.backdropNode](#NodeMaterial+backdropNode) : <code>Node.&lt;vec3&gt;</code>
    * [.backdropAlphaNode](#NodeMaterial+backdropAlphaNode) : <code>Node.&lt;float&gt;</code>
    * [.alphaTestNode](#NodeMaterial+alphaTestNode) : <code>Node.&lt;float&gt;</code>
    * [.positionNode](#NodeMaterial+positionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.geometryNode](#NodeMaterial+geometryNode) : <code>function</code>
    * [.depthNode](#NodeMaterial+depthNode) : <code>Node.&lt;float&gt;</code>
    * [.shadowPositionNode](#NodeMaterial+shadowPositionNode) : <code>Node.&lt;float&gt;</code>
    * [.receivedShadowNode](#NodeMaterial+receivedShadowNode) : <code>function</code> \| <code>FunctionNode.&lt;vec4&gt;</code>
    * [.castShadowNode](#NodeMaterial+castShadowNode) : <code>Node.&lt;vec4&gt;</code>
    * [.outputNode](#NodeMaterial+outputNode) : <code>Node.&lt;vec4&gt;</code>
    * [.mrtNode](#NodeMaterial+mrtNode) : <code>MRTNode</code>
    * [.fragmentNode](#NodeMaterial+fragmentNode) : <code>Node.&lt;vec4&gt;</code>
    * [.vertexNode](#NodeMaterial+vertexNode) : <code>Node.&lt;vec4&gt;</code>
    * [.customProgramCacheKey()](#NodeMaterial+customProgramCacheKey) ⇒ <code>string</code>
    * [.build(builder)](#NodeMaterial+build)
    * [.setupObserver(builder)](#NodeMaterial+setupObserver) ⇒ <code>NodeMaterialObserver</code>
    * [.setup(builder)](#NodeMaterial+setup)
    * [.setupClipping(builder)](#NodeMaterial+setupClipping) ⇒ <code>ClippingNode</code>
    * [.setupHardwareClipping(builder)](#NodeMaterial+setupHardwareClipping)
    * [.setupDepth(builder)](#NodeMaterial+setupDepth)
    * [.setupPositionView(builder)](#NodeMaterial+setupPositionView) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupModelViewProjection(builder)](#NodeMaterial+setupModelViewProjection) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setupVertex(builder)](#NodeMaterial+setupVertex) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setupPosition(builder)](#NodeMaterial+setupPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupDiffuseColor(builder, geometry)](#NodeMaterial+setupDiffuseColor)
    * *[.setupVariants(builder)](#NodeMaterial+setupVariants)*
    * [.setupOutgoingLight()](#NodeMaterial+setupOutgoingLight) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupNormal()](#NodeMaterial+setupNormal) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupEnvironment(builder)](#NodeMaterial+setupEnvironment) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setupLightMap(builder)](#NodeMaterial+setupLightMap) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupLights(builder)](#NodeMaterial+setupLights) ⇒ <code>LightsNode</code>
    * *[.setupLightingModel(builder)](#NodeMaterial+setupLightingModel) ⇒ <code>LightingModel</code>*
    * [.setupLighting(builder)](#NodeMaterial+setupLighting) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupFog(builder, outputNode)](#NodeMaterial+setupFog) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setupOutput(builder, outputNode)](#NodeMaterial+setupOutput) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setDefaultValues(material)](#NodeMaterial+setDefaultValues)
    * [.toJSON(meta)](#NodeMaterial+toJSON) ⇒ <code>Object</code>
    * [.copy(source)](#NodeMaterial+copy) ⇒ [<code>NodeMaterial</code>](#NodeMaterial)

<a name="new_NodeMaterial_new"></a>

### new NodeMaterial()
Constructs a new node material.

<a name="NodeMaterial+type"></a>

### nodeMaterial.type : <code>string</code>
Represents the type of the node material.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
<a name="NodeMaterial+isNodeMaterial"></a>

### nodeMaterial.isNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="NodeMaterial+fog"></a>

### nodeMaterial.fog : <code>boolean</code>
Whether this material is affected by fog or not.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>true</code>  
<a name="NodeMaterial+lights"></a>

### nodeMaterial.lights : <code>boolean</code>
Whether this material is affected by lights or not.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>false</code>  
<a name="NodeMaterial+hardwareClipping"></a>

### nodeMaterial.hardwareClipping : <code>boolean</code>
Whether this material uses hardware clipping or not.
This property is managed by the engine and should not be
modified by apps.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>false</code>  
<a name="NodeMaterial+lightsNode"></a>

### nodeMaterial.lightsNode : <code>LightsNode</code>
Node materials which set their `lights` property to `true`
are affected by all lights of the scene. Sometimes selective
lighting is wanted which means only _some_ lights in the scene
affect a material. This can be achieved by creating an instance
of [LightsNode](LightsNode) with a list of selective
lights and assign the node to this property.

```js
const customLightsNode = lights( [ light1, light2 ] );
material.lightsNode = customLightsNode;
```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+envNode"></a>

### nodeMaterial.envNode : <code>Node.&lt;vec3&gt;</code>
The environment of node materials can be defined by an environment
map assigned to the `envMap` property or by `Scene.environment`
if the node material is a PBR material. This node property allows to overwrite
the default behavior and define the environment with a custom node.

```js
material.envNode = pmremTexture( renderTarget.texture );
```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+aoNode"></a>

### nodeMaterial.aoNode : <code>Node.&lt;float&gt;</code>
The lighting of node materials might be influenced by ambient occlusion.
The default AO is inferred from an ambient occlusion map assigned to `aoMap`
and the respective `aoMapIntensity`. This node property allows to overwrite
the default and define the ambient occlusion with a custom node instead.

If you don't want to overwrite the diffuse color but modify the existing
values instead, use [materialAO](materialAO).

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+colorNode"></a>

### nodeMaterial.colorNode : <code>Node.&lt;vec3&gt;</code>
The diffuse color of node materials is by default inferred from the
`color` and `map` properties. This node property allows to overwrite the default
and define the diffuse color with a node instead.

```js
material.colorNode = color( 0xff0000 ); // define red color
```

If you don't want to overwrite the diffuse color but modify the existing
values instead, use [materialColor](materialColor).

```js
material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint
```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+normalNode"></a>

### nodeMaterial.normalNode : <code>Node.&lt;vec3&gt;</code>
The normals of node materials are by default inferred from the `normalMap`/`normalScale`
or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default
and define the normals with a node instead.

If you don't want to overwrite the normals but modify the existing values instead,
use [materialNormal](materialNormal).

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+opacityNode"></a>

### nodeMaterial.opacityNode : <code>Node.&lt;float&gt;</code>
The opacity of node materials is by default inferred from the `opacity`
and `alphaMap` properties. This node property allows to overwrite the default
and define the opacity with a node instead.

If you don't want to overwrite the normals but modify the existing
value instead, use [materialOpacity](materialOpacity).

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+backdropNode"></a>

### nodeMaterial.backdropNode : <code>Node.&lt;vec3&gt;</code>
This node can be used to to implement a variety of filter-like effects. The idea is
to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it
to create an arbitrary effect and then assign the node composition to this property.
Everything behind the object using this material will now be affected by a filter.

```js
const material = new NodeMaterial()
material.transparent = true;

// everything behind the object will be monochromatic
material.backdropNode = saturation( viewportSharedTexture().rgb, 0 );
```

Backdrop computations are part of the lighting so only lit materials can use this property.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+backdropAlphaNode"></a>

### nodeMaterial.backdropAlphaNode : <code>Node.&lt;float&gt;</code>
This node allows to modulate the influence of `backdropNode` to the outgoing light.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+alphaTestNode"></a>

### nodeMaterial.alphaTestNode : <code>Node.&lt;float&gt;</code>
The alpha test of node materials is by default inferred from the `alphaTest`
property. This node property allows to overwrite the default and define the
alpha test with a node instead.

If you don't want to overwrite the alpha test but modify the existing
value instead, use [materialAlphaTest](materialAlphaTest).

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+positionNode"></a>

### nodeMaterial.positionNode : <code>Node.&lt;vec3&gt;</code>
The local vertex positions are computed based on multiple factors like the
attribute data, morphing or skinning. This node property allows to overwrite
the default and define local vertex positions with nodes instead.

If you don't want to overwrite the vertex positions but modify the existing
values instead, use [positionLocal](positionLocal).

```js
material.positionNode = positionLocal.add( displace );
```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+geometryNode"></a>

### nodeMaterial.geometryNode : <code>function</code>
This node property is intended for logic which modifies geometry data once or per animation step.
Apps usually place such logic randomly in initialization routines or in the animation loop.
`geometryNode` is intended as a dedicated API so there is an intended spot where geometry modifications
can be implemented.

The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example
would be a GPU based particle system that provides a node material for usage on app level. The particle
simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is
eventually assigned to `geometryNode`.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+depthNode"></a>

### nodeMaterial.depthNode : <code>Node.&lt;float&gt;</code>
Allows to overwrite depth values in the fragment shader.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+shadowPositionNode"></a>

### nodeMaterial.shadowPositionNode : <code>Node.&lt;float&gt;</code>
Allows to overwrite the position used for shadow map rendering which
is by default [positionWorld](positionWorld), the vertex position
in world space.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+receivedShadowNode"></a>

### nodeMaterial.receivedShadowNode : <code>function</code> \| <code>FunctionNode.&lt;vec4&gt;</code>
This node can be used to influence how an object using this node material
receive shadows.

```js
const totalShadows = float( 1 ).toVar();
material.receivedShadowNode = Fn( ( [ shadow ] ) => {
	totalShadows.mulAssign( shadow );
	//return float( 1 ); // bypass received shadows
	return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color
} );

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+castShadowNode"></a>

### nodeMaterial.castShadowNode : <code>Node.&lt;vec4&gt;</code>
This node can be used to influence how an object using this node material
casts shadows. To apply a color to shadows, you can simply do:

```js
material.castShadowNode = vec4( 1, 0, 0, 1 );
```

Which can be nice to fake colored shadows of semi-transparent objects. It
is also common to use the property with `Fn` function so checks are performed
per fragment.

```js
materialCustomShadow.castShadowNode = Fn( () => {
	hash( vertexIndex ).greaterThan( 0.5 ).discard();
	return materialColor;
} )();
 ```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+outputNode"></a>

### nodeMaterial.outputNode : <code>Node.&lt;vec4&gt;</code>
This node can be used to define the final output of the material.

TODO: Explain the differences to `fragmentNode`.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+mrtNode"></a>

### nodeMaterial.mrtNode : <code>MRTNode</code>
MRT configuration is done on renderer or pass level. This node allows to
overwrite what values are written into MRT targets on material level. This
can be useful for implementing selective FX features that should only affect
specific objects.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+fragmentNode"></a>

### nodeMaterial.fragmentNode : <code>Node.&lt;vec4&gt;</code>
This node property can be used if you need complete freedom in implementing
the fragment shader. Assigning a node will replace the built-in material
logic used in the fragment stage.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+vertexNode"></a>

### nodeMaterial.vertexNode : <code>Node.&lt;vec4&gt;</code>
This node property can be used if you need complete freedom in implementing
the vertex shader. Assigning a node will replace the built-in material logic
used in the vertex stage.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+customProgramCacheKey"></a>

### nodeMaterial.customProgramCacheKey() ⇒ <code>string</code>
Allows to define a custom cache key that influence the material key computation
for render objects.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>string</code> - The custom cache key.  
<a name="NodeMaterial+build"></a>

### nodeMaterial.build(builder)
Builds this material with the given node builder.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupObserver"></a>

### nodeMaterial.setupObserver(builder) ⇒ <code>NodeMaterialObserver</code>
Setups a node material observer with the given builder.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>NodeMaterialObserver</code> - The node material observer.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setup"></a>

### nodeMaterial.setup(builder)
Setups the vertex and fragment stage of this node material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupClipping"></a>

### nodeMaterial.setupClipping(builder) ⇒ <code>ClippingNode</code>
Setups the clipping node.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>ClippingNode</code> - The clipping node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupHardwareClipping"></a>

### nodeMaterial.setupHardwareClipping(builder)
Setups the hardware clipping if available on the current device.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupDepth"></a>

### nodeMaterial.setupDepth(builder)
Setups the depth of this material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupPositionView"></a>

### nodeMaterial.setupPositionView(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the position node in view space. This method exists
so derived node materials can modify the implementation e.g. sprite materials.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The position in view space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupModelViewProjection"></a>

### nodeMaterial.setupModelViewProjection(builder) ⇒ <code>Node.&lt;vec4&gt;</code>
Setups the position in clip space.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The position in view space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupVertex"></a>

### nodeMaterial.setupVertex(builder) ⇒ <code>Node.&lt;vec4&gt;</code>
Setups the logic for the vertex stage.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The position in clip space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupPosition"></a>

### nodeMaterial.setupPosition(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the computation of the position in local space.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The position in local space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupDiffuseColor"></a>

### nodeMaterial.setupDiffuseColor(builder, geometry)
Setups the computation of the material's diffuse color.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| geometry | <code>BufferGeometry</code> | The geometry. |

<a name="NodeMaterial+setupVariants"></a>

### *nodeMaterial.setupVariants(builder)*
Abstract interface method that can be implemented by derived materials
to setup material-specific node variables.

**Kind**: instance abstract method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupOutgoingLight"></a>

### nodeMaterial.setupOutgoingLight() ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the outgoing light node variable

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The outgoing light node.  
<a name="NodeMaterial+setupNormal"></a>

### nodeMaterial.setupNormal() ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the normal node from the material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The normal node.  
<a name="NodeMaterial+setupEnvironment"></a>

### nodeMaterial.setupEnvironment(builder) ⇒ <code>Node.&lt;vec4&gt;</code>
Setups the environment node from the material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupLightMap"></a>

### nodeMaterial.setupLightMap(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the light map node from the material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The light map node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupLights"></a>

### nodeMaterial.setupLights(builder) ⇒ <code>LightsNode</code>
Setups the lights node based on the scene, environment and material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>LightsNode</code> - The lights node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupLightingModel"></a>

### *nodeMaterial.setupLightingModel(builder) ⇒ <code>LightingModel</code>*
This method should be implemented by most derived materials
since it defines the material's lighting model.

**Kind**: instance abstract method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>LightingModel</code> - The lighting model.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupLighting"></a>

### nodeMaterial.setupLighting(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the outgoing light node.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The outgoing light node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupFog"></a>

### nodeMaterial.setupFog(builder, outputNode) ⇒ <code>Node.&lt;vec4&gt;</code>
Setup the fog.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| outputNode | <code>Node.&lt;vec4&gt;</code> | The existing output node. |

<a name="NodeMaterial+setupOutput"></a>

### nodeMaterial.setupOutput(builder, outputNode) ⇒ <code>Node.&lt;vec4&gt;</code>
Setups the output node.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| outputNode | <code>Node.&lt;vec4&gt;</code> | The existing output node. |

<a name="NodeMaterial+setDefaultValues"></a>

### nodeMaterial.setDefaultValues(material)
Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
there is `MeshBasicNodeMaterial`. This utility method is intended for
defining all material properties of the classic type in the node type.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| material | <code>Material</code> | The material to copy properties with their values to this node material. |

<a name="NodeMaterial+toJSON"></a>

### nodeMaterial.toJSON(meta) ⇒ <code>Object</code>
Serializes this material to JSON.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Object</code> - The serialized node.  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | The meta information for serialization. |

<a name="NodeMaterial+copy"></a>

### nodeMaterial.copy(source) ⇒ [<code>NodeMaterial</code>](#NodeMaterial)
Copies the properties of the given node material to this instance.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: [<code>NodeMaterial</code>](#NodeMaterial) - A reference to this node material.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>NodeMaterial</code>](#NodeMaterial) | The material to copy. |

<a name="PointsNodeMaterial"></a>

## PointsNodeMaterial ⇐ <code>SpriteNodeMaterial</code>
Node material version of [PointsMaterial](PointsMaterial).

**Kind**: global class  
**Extends**: <code>SpriteNodeMaterial</code>  

* [PointsNodeMaterial](#PointsNodeMaterial) ⇐ <code>SpriteNodeMaterial</code>
    * [new PointsNodeMaterial([parameters])](#new_PointsNodeMaterial_new)
    * [.sizeNode](#PointsNodeMaterial+sizeNode) : <code>Node.&lt;vec2&gt;</code>
    * [.isPointsNodeMaterial](#PointsNodeMaterial+isPointsNodeMaterial) : <code>boolean</code>
    * [.alphaToCoverage](#PointsNodeMaterial+alphaToCoverage) : <code>boolean</code>

<a name="new_PointsNodeMaterial_new"></a>

### new PointsNodeMaterial([parameters])
Constructs a new points node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="PointsNodeMaterial+sizeNode"></a>

### pointsNodeMaterial.sizeNode : <code>Node.&lt;vec2&gt;</code>
This node property provides an additional way to set the point size.

**Kind**: instance property of [<code>PointsNodeMaterial</code>](#PointsNodeMaterial)  
**Default**: <code>null</code>  
<a name="PointsNodeMaterial+isPointsNodeMaterial"></a>

### pointsNodeMaterial.isPointsNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointsNodeMaterial</code>](#PointsNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PointsNodeMaterial+alphaToCoverage"></a>

### pointsNodeMaterial.alphaToCoverage : <code>boolean</code>
Whether alpha to coverage should be used or not.

**Kind**: instance property of [<code>PointsNodeMaterial</code>](#PointsNodeMaterial)  
**Default**: <code>true</code>  
<a name="ShadowNodeMaterial"></a>

## ShadowNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [ShadowMaterial](ShadowMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [ShadowNodeMaterial](#ShadowNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new ShadowNodeMaterial([parameters])](#new_ShadowNodeMaterial_new)
    * [.isShadowNodeMaterial](#ShadowNodeMaterial+isShadowNodeMaterial) : <code>boolean</code>
    * [.lights](#ShadowNodeMaterial+lights) : <code>boolean</code>
    * [.transparent](#ShadowNodeMaterial+transparent) : <code>boolean</code>
    * [.setupLightingModel()](#ShadowNodeMaterial+setupLightingModel) ⇒ <code>ShadowMaskModel</code>

<a name="new_ShadowNodeMaterial_new"></a>

### new ShadowNodeMaterial([parameters])
Constructs a new shadow node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="ShadowNodeMaterial+isShadowNodeMaterial"></a>

### shadowNodeMaterial.isShadowNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowNodeMaterial</code>](#ShadowNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowNodeMaterial+lights"></a>

### shadowNodeMaterial.lights : <code>boolean</code>
Set to `true` because so it's possible to implement
the shadow mask effect.

**Kind**: instance property of [<code>ShadowNodeMaterial</code>](#ShadowNodeMaterial)  
**Default**: <code>true</code>  
<a name="ShadowNodeMaterial+transparent"></a>

### shadowNodeMaterial.transparent : <code>boolean</code>
Overwritten since shadow materials are transparent
by default.

**Kind**: instance property of [<code>ShadowNodeMaterial</code>](#ShadowNodeMaterial)  
**Default**: <code>true</code>  
<a name="ShadowNodeMaterial+setupLightingModel"></a>

### shadowNodeMaterial.setupLightingModel() ⇒ <code>ShadowMaskModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>ShadowNodeMaterial</code>](#ShadowNodeMaterial)  
**Returns**: <code>ShadowMaskModel</code> - The lighting model.  
<a name="SpriteNodeMaterial"></a>

## SpriteNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [SpriteMaterial](SpriteMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [SpriteNodeMaterial](#SpriteNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new SpriteNodeMaterial([parameters])](#new_SpriteNodeMaterial_new)
    * [.isSpriteNodeMaterial](#SpriteNodeMaterial+isSpriteNodeMaterial) : <code>boolean</code>
    * [.positionNode](#SpriteNodeMaterial+positionNode) : <code>Node.&lt;vec2&gt;</code>
    * [.rotationNode](#SpriteNodeMaterial+rotationNode) : <code>Node.&lt;float&gt;</code>
    * [.scaleNode](#SpriteNodeMaterial+scaleNode) : <code>Node.&lt;vec2&gt;</code>
    * [.transparent](#SpriteNodeMaterial+transparent) : <code>boolean</code>
    * [.sizeAttenuation](#SpriteNodeMaterial+sizeAttenuation) : <code>boolean</code>
    * [.setupPositionView(builder)](#SpriteNodeMaterial+setupPositionView) ⇒ <code>Node.&lt;vec3&gt;</code>

<a name="new_SpriteNodeMaterial_new"></a>

### new SpriteNodeMaterial([parameters])
Constructs a new sprite node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="SpriteNodeMaterial+isSpriteNodeMaterial"></a>

### spriteNodeMaterial.isSpriteNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SpriteNodeMaterial+positionNode"></a>

### spriteNodeMaterial.positionNode : <code>Node.&lt;vec2&gt;</code>
This property makes it possible to define the position of the sprite with a
node. That can be useful when the material is used with instanced rendering
and node data are defined with an instanced attribute node:
```js
const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );
material.positionNode = instancedBufferAttribute( positionAttribute );
```
Another possibility is to compute the instanced data with a compute shader:
```js
const positionBuffer = instancedArray( particleCount, 'vec3' );
particleMaterial.positionNode = positionBuffer.toAttribute();
```

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>null</code>  
<a name="SpriteNodeMaterial+rotationNode"></a>

### spriteNodeMaterial.rotationNode : <code>Node.&lt;float&gt;</code>
The rotation of sprite materials is by default inferred from the `rotation`,
property. This node property allows to overwrite the default and define
the rotation with a node instead.

If you don't want to overwrite the rotation but modify the existing
value instead, use [materialRotation](materialRotation).

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>null</code>  
<a name="SpriteNodeMaterial+scaleNode"></a>

### spriteNodeMaterial.scaleNode : <code>Node.&lt;vec2&gt;</code>
This node property provides an additional way to scale sprites next to
`Object3D.scale`. The scale transformation based in `Object3D.scale`
is multiplied with the scale value of this node in the vertex shader.

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>null</code>  
<a name="SpriteNodeMaterial+transparent"></a>

### spriteNodeMaterial.transparent : <code>boolean</code>
In Sprites, the transparent property is enabled by default.

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>true</code>  
<a name="SpriteNodeMaterial+sizeAttenuation"></a>

### spriteNodeMaterial.sizeAttenuation : <code>boolean</code>
Whether to use size attenuation or not.

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>true</code>  
<a name="SpriteNodeMaterial+setupPositionView"></a>

### spriteNodeMaterial.setupPositionView(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the position node in view space. This method implements
the sprite specific vertex shader.

**Kind**: instance method of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The position in view space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="VolumeNodeMaterial"></a>

## VolumeNodeMaterial ⇐ <code>NodeMaterial</code>
Volume node material.

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [VolumeNodeMaterial](#VolumeNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new VolumeNodeMaterial([parameters])](#new_VolumeNodeMaterial_new)
    * [.isVolumeNodeMaterial](#VolumeNodeMaterial+isVolumeNodeMaterial) : <code>boolean</code>
    * [.steps](#VolumeNodeMaterial+steps) : <code>number</code>
    * [.offsetNode](#VolumeNodeMaterial+offsetNode) : <code>Node.&lt;float&gt;</code>
    * [.scatteringNode](#VolumeNodeMaterial+scatteringNode) : <code>function</code> \| <code>FunctionNode.&lt;vec4&gt;</code>

<a name="new_VolumeNodeMaterial_new"></a>

### new VolumeNodeMaterial([parameters])
Constructs a new volume node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="VolumeNodeMaterial+isVolumeNodeMaterial"></a>

### volumeNodeMaterial.isVolumeNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VolumeNodeMaterial</code>](#VolumeNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VolumeNodeMaterial+steps"></a>

### volumeNodeMaterial.steps : <code>number</code>
Number of steps used for raymarching.

**Kind**: instance property of [<code>VolumeNodeMaterial</code>](#VolumeNodeMaterial)  
**Default**: <code>25</code>  
<a name="VolumeNodeMaterial+offsetNode"></a>

### volumeNodeMaterial.offsetNode : <code>Node.&lt;float&gt;</code>
Offsets the distance a ray has been traveled through a volume.
Can be used to implement dithering to reduce banding.

**Kind**: instance property of [<code>VolumeNodeMaterial</code>](#VolumeNodeMaterial)  
**Default**: <code>null</code>  
<a name="VolumeNodeMaterial+scatteringNode"></a>

### volumeNodeMaterial.scatteringNode : <code>function</code> \| <code>FunctionNode.&lt;vec4&gt;</code>
Node used for scattering calculations.

**Kind**: instance property of [<code>VolumeNodeMaterial</code>](#VolumeNodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterialObserver"></a>

## NodeMaterialObserver
This class is used by [WebGPURenderer](WebGPURenderer) as management component.
It's primary purpose is to determine whether render objects require a
refresh right before they are going to be rendered or not.

**Kind**: global class  

* [NodeMaterialObserver](#NodeMaterialObserver)
    * [new NodeMaterialObserver(builder)](#new_NodeMaterialObserver_new)
    * [.renderObjects](#NodeMaterialObserver+renderObjects) : <code>WeakMap.&lt;RenderObject, Object&gt;</code>
    * [.hasNode](#NodeMaterialObserver+hasNode) : <code>boolean</code>
    * [.hasAnimation](#NodeMaterialObserver+hasAnimation) : <code>boolean</code>
    * [.refreshUniforms](#NodeMaterialObserver+refreshUniforms) : <code>Array.&lt;string&gt;</code>
    * [.renderId](#NodeMaterialObserver+renderId) : <code>number</code>
    * [.firstInitialization(renderObject)](#NodeMaterialObserver+firstInitialization) ⇒ <code>boolean</code>
    * [.getRenderObjectData(renderObject)](#NodeMaterialObserver+getRenderObjectData) ⇒ <code>Object</code>
    * [.getAttributesData(attributes)](#NodeMaterialObserver+getAttributesData) ⇒ <code>Object</code>
    * [.containsNode(builder)](#NodeMaterialObserver+containsNode) ⇒ <code>boolean</code>
    * [.getMaterialData(material)](#NodeMaterialObserver+getMaterialData) ⇒ <code>Object</code>
    * [.equals(renderObject)](#NodeMaterialObserver+equals) ⇒ <code>boolean</code>
    * [.needsRefresh(renderObject, nodeFrame)](#NodeMaterialObserver+needsRefresh) ⇒ <code>boolean</code>

<a name="new_NodeMaterialObserver_new"></a>

### new NodeMaterialObserver(builder)
Constructs a new node material observer.


| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The node builder. |

<a name="NodeMaterialObserver+renderObjects"></a>

### nodeMaterialObserver.renderObjects : <code>WeakMap.&lt;RenderObject, Object&gt;</code>
A node material can be used by more than one render object so the
monitor must maintain a list of render objects.

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
<a name="NodeMaterialObserver+hasNode"></a>

### nodeMaterialObserver.hasNode : <code>boolean</code>
Whether the material uses node objects or not.

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
<a name="NodeMaterialObserver+hasAnimation"></a>

### nodeMaterialObserver.hasAnimation : <code>boolean</code>
Whether the node builder's 3D object is animated or not.

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
<a name="NodeMaterialObserver+refreshUniforms"></a>

### nodeMaterialObserver.refreshUniforms : <code>Array.&lt;string&gt;</code>
A list of all possible material uniforms

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
<a name="NodeMaterialObserver+renderId"></a>

### nodeMaterialObserver.renderId : <code>number</code>
Holds the current render ID from the node frame.

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Default**: <code>0</code>  
<a name="NodeMaterialObserver+firstInitialization"></a>

### nodeMaterialObserver.firstInitialization(renderObject) ⇒ <code>boolean</code>
Returns `true` if the given render object is verified for the first time of this observer.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>boolean</code> - Whether the given render object is verified for the first time of this observer.  

| Param | Type | Description |
| --- | --- | --- |
| renderObject | <code>RenderObject</code> | The render object. |

<a name="NodeMaterialObserver+getRenderObjectData"></a>

### nodeMaterialObserver.getRenderObjectData(renderObject) ⇒ <code>Object</code>
Returns monitoring data for the given render object.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>Object</code> - The monitoring data.  

| Param | Type | Description |
| --- | --- | --- |
| renderObject | <code>RenderObject</code> | The render object. |

<a name="NodeMaterialObserver+getAttributesData"></a>

### nodeMaterialObserver.getAttributesData(attributes) ⇒ <code>Object</code>
Returns an attribute data structure holding the attributes versions for
monitoring.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>Object</code> - An object for monitoring the versions of attributes.  

| Param | Type | Description |
| --- | --- | --- |
| attributes | <code>Object</code> | The geometry attributes. |

<a name="NodeMaterialObserver+containsNode"></a>

### nodeMaterialObserver.containsNode(builder) ⇒ <code>boolean</code>
Returns `true` if the node builder's material uses
node properties.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>boolean</code> - Whether the node builder's material uses node properties or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterialObserver+getMaterialData"></a>

### nodeMaterialObserver.getMaterialData(material) ⇒ <code>Object</code>
Returns a material data structure holding the material property values for
monitoring.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>Object</code> - An object for monitoring material properties.  

| Param | Type | Description |
| --- | --- | --- |
| material | <code>Material</code> | The material. |

<a name="NodeMaterialObserver+equals"></a>

### nodeMaterialObserver.equals(renderObject) ⇒ <code>boolean</code>
Returns `true` if the given render object has not changed its state.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>boolean</code> - Whether the given render object has changed its state or not.  

| Param | Type | Description |
| --- | --- | --- |
| renderObject | <code>RenderObject</code> | The render object. |

<a name="NodeMaterialObserver+needsRefresh"></a>

### nodeMaterialObserver.needsRefresh(renderObject, nodeFrame) ⇒ <code>boolean</code>
Checks if the given render object requires a refresh.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>boolean</code> - Whether the given render object requires a refresh or not.  

| Param | Type | Description |
| --- | --- | --- |
| renderObject | <code>RenderObject</code> | The render object. |
| nodeFrame | <code>NodeFrame</code> | The current node frame. |

<a name="Box2"></a>

## Box2
Represents an axis-aligned bounding box (AABB) in 2D space.

**Kind**: global class  

* [Box2](#Box2)
    * [new Box2([min], [max])](#new_Box2_new)
    * [.isBox2](#Box2+isBox2) : <code>boolean</code>
    * [.min](#Box2+min) : <code>Vector2</code>
    * [.max](#Box2+max) : <code>Vector2</code>
    * [.set(min, max)](#Box2+set) ⇒ [<code>Box2</code>](#Box2)
    * [.setFromPoints(points)](#Box2+setFromPoints) ⇒ [<code>Box2</code>](#Box2)
    * [.setFromCenterAndSize(center, size)](#Box2+setFromCenterAndSize) ⇒ [<code>Box2</code>](#Box2)
    * [.clone()](#Box2+clone) ⇒ [<code>Box2</code>](#Box2)
    * [.copy(box)](#Box2+copy) ⇒ [<code>Box2</code>](#Box2)
    * [.makeEmpty()](#Box2+makeEmpty) ⇒ [<code>Box2</code>](#Box2)
    * [.isEmpty()](#Box2+isEmpty) ⇒ <code>boolean</code>
    * [.getCenter(target)](#Box2+getCenter) ⇒ <code>Vector2</code>
    * [.getSize(target)](#Box2+getSize) ⇒ <code>Vector2</code>
    * [.expandByPoint(point)](#Box2+expandByPoint) ⇒ [<code>Box2</code>](#Box2)
    * [.expandByVector(vector)](#Box2+expandByVector) ⇒ [<code>Box2</code>](#Box2)
    * [.expandByScalar(scalar)](#Box2+expandByScalar) ⇒ [<code>Box2</code>](#Box2)
    * [.containsPoint(point)](#Box2+containsPoint) ⇒ <code>boolean</code>
    * [.containsBox(box)](#Box2+containsBox) ⇒ <code>boolean</code>
    * [.getParameter(point, target)](#Box2+getParameter) ⇒ <code>Vector2</code>
    * [.intersectsBox(box)](#Box2+intersectsBox) ⇒ <code>boolean</code>
    * [.clampPoint(point, target)](#Box2+clampPoint) ⇒ <code>Vector2</code>
    * [.distanceToPoint(point)](#Box2+distanceToPoint) ⇒ <code>number</code>
    * [.intersect(box)](#Box2+intersect) ⇒ [<code>Box2</code>](#Box2)
    * [.union(box)](#Box2+union) ⇒ [<code>Box2</code>](#Box2)
    * [.translate(offset)](#Box2+translate) ⇒ [<code>Box2</code>](#Box2)
    * [.equals(box)](#Box2+equals) ⇒ <code>boolean</code>

<a name="new_Box2_new"></a>

### new Box2([min], [max])
Constructs a new bounding box.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [min] | <code>Vector2</code> | <code>(Infinity,Infinity)</code> | A vector representing the lower boundary of the box. |
| [max] | <code>Vector2</code> | <code>(-Infinity,-Infinity)</code> | A vector representing the upper boundary of the box. |

<a name="Box2+isBox2"></a>

### box2.isBox2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Box2</code>](#Box2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Box2+min"></a>

### box2.min : <code>Vector2</code>
The lower boundary of the box.

**Kind**: instance property of [<code>Box2</code>](#Box2)  
<a name="Box2+max"></a>

### box2.max : <code>Vector2</code>
The upper boundary of the box.

**Kind**: instance property of [<code>Box2</code>](#Box2)  
<a name="Box2+set"></a>

### box2.set(min, max) ⇒ [<code>Box2</code>](#Box2)
Sets the lower and upper boundaries of this box.
Please note that this method only copies the values from the given objects.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>Vector2</code> | The lower boundary of the box. |
| max | <code>Vector2</code> | The upper boundary of the box. |

<a name="Box2+setFromPoints"></a>

### box2.setFromPoints(points) ⇒ [<code>Box2</code>](#Box2)
Sets the upper and lower bounds of this box so it encloses the position data
in the given array.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> | An array holding 2D position data as instances of [Vector2](Vector2). |

<a name="Box2+setFromCenterAndSize"></a>

### box2.setFromCenterAndSize(center, size) ⇒ [<code>Box2</code>](#Box2)
Centers this box on the given center vector and sets this box's width, height and
depth to the given size values.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| center | <code>Vector2</code> | The center of the box. |
| size | <code>Vector2</code> | The x and y dimensions of the box. |

<a name="Box2+clone"></a>

### box2.clone() ⇒ [<code>Box2</code>](#Box2)
Returns a new box with copied values from this instance.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A clone of this instance.  
<a name="Box2+copy"></a>

### box2.copy(box) ⇒ [<code>Box2</code>](#Box2)
Copies the values of the given box to this instance.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The box to copy. |

<a name="Box2+makeEmpty"></a>

### box2.makeEmpty() ⇒ [<code>Box2</code>](#Box2)
Makes this box empty which means in encloses a zero space in 2D.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  
<a name="Box2+isEmpty"></a>

### box2.isEmpty() ⇒ <code>boolean</code>
Returns true if this box includes zero points within its bounds.
Note that a box with equal lower and upper bounds still includes one
point, the one both bounds share.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether this box is empty or not.  
<a name="Box2+getCenter"></a>

### box2.getCenter(target) ⇒ <code>Vector2</code>
Returns the center point of this box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>Vector2</code> - The center point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The target vector that is used to store the method's result. |

<a name="Box2+getSize"></a>

### box2.getSize(target) ⇒ <code>Vector2</code>
Returns the dimensions of this box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>Vector2</code> - The size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The target vector that is used to store the method's result. |

<a name="Box2+expandByPoint"></a>

### box2.expandByPoint(point) ⇒ [<code>Box2</code>](#Box2)
Expands the boundaries of this box to include the given point.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | The point that should be included by the bounding box. |

<a name="Box2+expandByVector"></a>

### box2.expandByVector(vector) ⇒ [<code>Box2</code>](#Box2)
Expands this box equilaterally by the given vector. The width of this
box will be expanded by the x component of the vector in both
directions. The height of this box will be expanded by the y component of
the vector in both directions.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| vector | <code>Vector2</code> | The vector that should expand the bounding box. |

<a name="Box2+expandByScalar"></a>

### box2.expandByScalar(scalar) ⇒ [<code>Box2</code>](#Box2)
Expands each dimension of the box by the given scalar. If negative, the
dimensions of the box will be contracted.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar value that should expand the bounding box. |

<a name="Box2+containsPoint"></a>

### box2.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies within or on the boundaries of this box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether the bounding box contains the given point or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | The point to test. |

<a name="Box2+containsBox"></a>

### box2.containsBox(box) ⇒ <code>boolean</code>
Returns `true` if this bounding box includes the entirety of the given bounding box.
If this box and the given one are identical, this function also returns `true`.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether the bounding box contains the given bounding box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The bounding box to test. |

<a name="Box2+getParameter"></a>

### box2.getParameter(point, target) ⇒ <code>Vector2</code>
Returns a point as a proportion of this box's width and height.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>Vector2</code> - A point as a proportion of this box's width and height.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | A point in 2D space. |
| target | <code>Vector2</code> | The target vector that is used to store the method's result. |

<a name="Box2+intersectsBox"></a>

### box2.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box intersects with this bounding box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether the given bounding box intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The bounding box to test. |

<a name="Box2+clampPoint"></a>

### box2.clampPoint(point, target) ⇒ <code>Vector2</code>
Clamps the given point within the bounds of this box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>Vector2</code> - The clamped point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | The point to clamp. |
| target | <code>Vector2</code> | The target vector that is used to store the method's result. |

<a name="Box2+distanceToPoint"></a>

### box2.distanceToPoint(point) ⇒ <code>number</code>
Returns the euclidean distance from any edge of this box to the specified point. If
the given point lies inside of this box, the distance will be `0`.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>number</code> - The euclidean distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | The point to compute the distance to. |

<a name="Box2+intersect"></a>

### box2.intersect(box) ⇒ [<code>Box2</code>](#Box2)
Computes the intersection of this bounding box and the given one, setting the upper
bound of this box to the lesser of the two boxes' upper bounds and the
lower bound of this box to the greater of the two boxes' lower bounds. If
there's no overlap, makes this box empty.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The bounding box to intersect with. |

<a name="Box2+union"></a>

### box2.union(box) ⇒ [<code>Box2</code>](#Box2)
Computes the union of this box and another and the given one, setting the upper
bound of this box to the greater of the two boxes' upper bounds and the
lower bound of this box to the lesser of the two boxes' lower bounds.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The bounding box that will be unioned with this instance. |

<a name="Box2+translate"></a>

### box2.translate(offset) ⇒ [<code>Box2</code>](#Box2)
Adds the given offset to both the upper and lower bounds of this bounding box,
effectively moving it in 2D space.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| offset | <code>Vector2</code> | The offset that should be used to translate the bounding box. |

<a name="Box2+equals"></a>

### box2.equals(box) ⇒ <code>boolean</code>
Returns `true` if this bounding box is equal with the given one.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether this bounding box is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The box to test for equality. |

<a name="Box3"></a>

## Box3
Represents an axis-aligned bounding box (AABB) in 3D space.

**Kind**: global class  

* [Box3](#Box3)
    * [new Box3([min], [max])](#new_Box3_new)
    * [.isBox3](#Box3+isBox3) : <code>boolean</code>
    * [.min](#Box3+min) : <code>Vector3</code>
    * [.max](#Box3+max) : <code>Vector3</code>
    * [.set(min, max)](#Box3+set) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromArray(array)](#Box3+setFromArray) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromBufferAttribute(attribute)](#Box3+setFromBufferAttribute) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromPoints(points)](#Box3+setFromPoints) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromCenterAndSize(center, size)](#Box3+setFromCenterAndSize) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromObject(object, [precise])](#Box3+setFromObject) ⇒ [<code>Box3</code>](#Box3)
    * [.clone()](#Box3+clone) ⇒ [<code>Box3</code>](#Box3)
    * [.copy(box)](#Box3+copy) ⇒ [<code>Box3</code>](#Box3)
    * [.makeEmpty()](#Box3+makeEmpty) ⇒ [<code>Box3</code>](#Box3)
    * [.isEmpty()](#Box3+isEmpty) ⇒ <code>boolean</code>
    * [.getCenter(target)](#Box3+getCenter) ⇒ <code>Vector3</code>
    * [.getSize(target)](#Box3+getSize) ⇒ <code>Vector3</code>
    * [.expandByPoint(point)](#Box3+expandByPoint) ⇒ [<code>Box3</code>](#Box3)
    * [.expandByVector(vector)](#Box3+expandByVector) ⇒ [<code>Box3</code>](#Box3)
    * [.expandByScalar(scalar)](#Box3+expandByScalar) ⇒ [<code>Box3</code>](#Box3)
    * [.expandByObject(object, precise)](#Box3+expandByObject) ⇒ [<code>Box3</code>](#Box3)
    * [.containsPoint(point)](#Box3+containsPoint) ⇒ <code>boolean</code>
    * [.containsBox(box)](#Box3+containsBox) ⇒ <code>boolean</code>
    * [.getParameter(point, target)](#Box3+getParameter) ⇒ <code>Vector3</code>
    * [.intersectsBox(box)](#Box3+intersectsBox) ⇒ <code>boolean</code>
    * [.intersectsSphere(sphere)](#Box3+intersectsSphere) ⇒ <code>boolean</code>
    * [.intersectsPlane(plane)](#Box3+intersectsPlane) ⇒ <code>boolean</code>
    * [.intersectsTriangle(triangle)](#Box3+intersectsTriangle) ⇒ <code>boolean</code>
    * [.clampPoint(point, target)](#Box3+clampPoint) ⇒ <code>Vector3</code>
    * [.distanceToPoint(point)](#Box3+distanceToPoint) ⇒ <code>number</code>
    * [.getBoundingSphere(target)](#Box3+getBoundingSphere) ⇒ <code>Sphere</code>
    * [.intersect(box)](#Box3+intersect) ⇒ [<code>Box3</code>](#Box3)
    * [.union(box)](#Box3+union) ⇒ [<code>Box3</code>](#Box3)
    * [.applyMatrix4(matrix)](#Box3+applyMatrix4) ⇒ [<code>Box3</code>](#Box3)
    * [.translate(offset)](#Box3+translate) ⇒ [<code>Box3</code>](#Box3)
    * [.equals(box)](#Box3+equals) ⇒ <code>boolean</code>

<a name="new_Box3_new"></a>

### new Box3([min], [max])
Constructs a new bounding box.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [min] | <code>Vector3</code> | <code>(Infinity,Infinity,Infinity)</code> | A vector representing the lower boundary of the box. |
| [max] | <code>Vector3</code> | <code>(-Infinity,-Infinity,-Infinity)</code> | A vector representing the upper boundary of the box. |

<a name="Box3+isBox3"></a>

### box3.isBox3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Box3</code>](#Box3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Box3+min"></a>

### box3.min : <code>Vector3</code>
The lower boundary of the box.

**Kind**: instance property of [<code>Box3</code>](#Box3)  
<a name="Box3+max"></a>

### box3.max : <code>Vector3</code>
The upper boundary of the box.

**Kind**: instance property of [<code>Box3</code>](#Box3)  
<a name="Box3+set"></a>

### box3.set(min, max) ⇒ [<code>Box3</code>](#Box3)
Sets the lower and upper boundaries of this box.
Please note that this method only copies the values from the given objects.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>Vector3</code> | The lower boundary of the box. |
| max | <code>Vector3</code> | The upper boundary of the box. |

<a name="Box3+setFromArray"></a>

### box3.setFromArray(array) ⇒ [<code>Box3</code>](#Box3)
Sets the upper and lower bounds of this box so it encloses the position data
in the given array.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> | An array holding 3D position data. |

<a name="Box3+setFromBufferAttribute"></a>

### box3.setFromBufferAttribute(attribute) ⇒ [<code>Box3</code>](#Box3)
Sets the upper and lower bounds of this box so it encloses the position data
in the given buffer attribute.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | A buffer attribute holding 3D position data. |

<a name="Box3+setFromPoints"></a>

### box3.setFromPoints(points) ⇒ [<code>Box3</code>](#Box3)
Sets the upper and lower bounds of this box so it encloses the position data
in the given array.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | An array holding 3D position data as instances of [Vector3](Vector3). |

<a name="Box3+setFromCenterAndSize"></a>

### box3.setFromCenterAndSize(center, size) ⇒ [<code>Box3</code>](#Box3)
Centers this box on the given center vector and sets this box's width, height and
depth to the given size values.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| center | <code>Vector3</code> | The center of the box. |
| size | <code>Vector3</code> | The x, y and z dimensions of the box. |

<a name="Box3+setFromObject"></a>

### box3.setFromObject(object, [precise]) ⇒ [<code>Box3</code>](#Box3)
Computes the world-axis-aligned bounding box for the given 3D object
(including its children), accounting for the object's, and children's,
world transforms. The function may result in a larger box than strictly necessary.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object to compute the bounding box for. |
| [precise] | <code>boolean</code> | <code>false</code> | If set to `true`, the method computes the smallest world-axis-aligned bounding box at the expense of more computation. |

<a name="Box3+clone"></a>

### box3.clone() ⇒ [<code>Box3</code>](#Box3)
Returns a new box with copied values from this instance.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A clone of this instance.  
<a name="Box3+copy"></a>

### box3.copy(box) ⇒ [<code>Box3</code>](#Box3)
Copies the values of the given box to this instance.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The box to copy. |

<a name="Box3+makeEmpty"></a>

### box3.makeEmpty() ⇒ [<code>Box3</code>](#Box3)
Makes this box empty which means in encloses a zero space in 3D.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  
<a name="Box3+isEmpty"></a>

### box3.isEmpty() ⇒ <code>boolean</code>
Returns true if this box includes zero points within its bounds.
Note that a box with equal lower and upper bounds still includes one
point, the one both bounds share.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether this box is empty or not.  
<a name="Box3+getCenter"></a>

### box3.getCenter(target) ⇒ <code>Vector3</code>
Returns the center point of this box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Vector3</code> - The center point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Box3+getSize"></a>

### box3.getSize(target) ⇒ <code>Vector3</code>
Returns the dimensions of this box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Vector3</code> - The size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Box3+expandByPoint"></a>

### box3.expandByPoint(point) ⇒ [<code>Box3</code>](#Box3)
Expands the boundaries of this box to include the given point.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point that should be included by the bounding box. |

<a name="Box3+expandByVector"></a>

### box3.expandByVector(vector) ⇒ [<code>Box3</code>](#Box3)
Expands this box equilaterally by the given vector. The width of this
box will be expanded by the x component of the vector in both
directions. The height of this box will be expanded by the y component of
the vector in both directions. The depth of this box will be
expanded by the z component of the vector in both directions.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| vector | <code>Vector3</code> | The vector that should expand the bounding box. |

<a name="Box3+expandByScalar"></a>

### box3.expandByScalar(scalar) ⇒ [<code>Box3</code>](#Box3)
Expands each dimension of the box by the given scalar. If negative, the
dimensions of the box will be contracted.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar value that should expand the bounding box. |

<a name="Box3+expandByObject"></a>

### box3.expandByObject(object, precise) ⇒ [<code>Box3</code>](#Box3)
Expands the boundaries of this box to include the given 3D object and
its children, accounting for the object's, and children's, world
transforms. The function may result in a larger box than strictly
necessary (unless the precise parameter is set to true).

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object that should expand the bounding box. |
| precise | <code>boolean</code> | <code>false</code> | If set to `true`, the method expands the bounding box as little as necessary at the expense of more computation. |

<a name="Box3+containsPoint"></a>

### box3.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies within or on the boundaries of this box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the bounding box contains the given point or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to test. |

<a name="Box3+containsBox"></a>

### box3.containsBox(box) ⇒ <code>boolean</code>
Returns `true` if this bounding box includes the entirety of the given bounding box.
If this box and the given one are identical, this function also returns `true`.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the bounding box contains the given bounding box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The bounding box to test. |

<a name="Box3+getParameter"></a>

### box3.getParameter(point, target) ⇒ <code>Vector3</code>
Returns a point as a proportion of this box's width, height and depth.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Vector3</code> - A point as a proportion of this box's width, height and depth.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Box3+intersectsBox"></a>

### box3.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box intersects with this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the given bounding box intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The bounding box to test. |

<a name="Box3+intersectsSphere"></a>

### box3.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if the given bounding sphere intersects with this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the given bounding sphere intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="Box3+intersectsPlane"></a>

### box3.intersectsPlane(plane) ⇒ <code>boolean</code>
Returns `true` if the given plane intersects with this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the given plane intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to test. |

<a name="Box3+intersectsTriangle"></a>

### box3.intersectsTriangle(triangle) ⇒ <code>boolean</code>
Returns `true` if the given triangle intersects with this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the given triangle intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| triangle | <code>Triangle</code> | The triangle to test. |

<a name="Box3+clampPoint"></a>

### box3.clampPoint(point, target) ⇒ <code>Vector3</code>
Clamps the given point within the bounds of this box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Vector3</code> - The clamped point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to clamp. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Box3+distanceToPoint"></a>

### box3.distanceToPoint(point) ⇒ <code>number</code>
Returns the euclidean distance from any edge of this box to the specified point. If
the given point lies inside of this box, the distance will be `0`.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>number</code> - The euclidean distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to compute the distance to. |

<a name="Box3+getBoundingSphere"></a>

### box3.getBoundingSphere(target) ⇒ <code>Sphere</code>
Returns a bounding sphere that encloses this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Sphere</code> - The bounding sphere that encloses this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Sphere</code> | The target sphere that is used to store the method's result. |

<a name="Box3+intersect"></a>

### box3.intersect(box) ⇒ [<code>Box3</code>](#Box3)
Computes the intersection of this bounding box and the given one, setting the upper
bound of this box to the lesser of the two boxes' upper bounds and the
lower bound of this box to the greater of the two boxes' lower bounds. If
there's no overlap, makes this box empty.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The bounding box to intersect with. |

<a name="Box3+union"></a>

### box3.union(box) ⇒ [<code>Box3</code>](#Box3)
Computes the union of this box and another and the given one, setting the upper
bound of this box to the greater of the two boxes' upper bounds and the
lower bound of this box to the lesser of the two boxes' lower bounds.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The bounding box that will be unioned with this instance. |

<a name="Box3+applyMatrix4"></a>

### box3.applyMatrix4(matrix) ⇒ [<code>Box3</code>](#Box3)
Transforms this bounding box by the given 4x4 transformation matrix.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |

<a name="Box3+translate"></a>

### box3.translate(offset) ⇒ [<code>Box3</code>](#Box3)
Adds the given offset to both the upper and lower bounds of this bounding box,
effectively moving it in 3D space.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| offset | <code>Vector3</code> | The offset that should be used to translate the bounding box. |

<a name="Box3+equals"></a>

### box3.equals(box) ⇒ <code>boolean</code>
Returns `true` if this bounding box is equal with the given one.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether this bounding box is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The box to test for equality. |

<a name="Color"></a>

## Color
A Color instance is represented by RGB components in the linear <i>working
color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
strings) are converted to the working color space automatically.

```js
// converted automatically from SRGBColorSpace to LinearSRGBColorSpace
const color = new THREE.Color().setHex( 0x112233 );
```
Source color spaces may be specified explicitly, to ensure correct conversions.
```js
// assumed already LinearSRGBColorSpace; no conversion
const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );

// converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
```
If THREE.ColorManagement is disabled, no conversions occur. For details,
see <i>Color management</i>. Iterating through a Color instance will yield
its components (r, g, b) in the corresponding order. A Color can be initialised
in any of the following ways:
```js
//empty constructor - will default white
const color1 = new THREE.Color();

//Hexadecimal color (recommended)
const color2 = new THREE.Color( 0xff0000 );

//RGB string
const color3 = new THREE.Color("rgb(255, 0, 0)");
const color4 = new THREE.Color("rgb(100%, 0%, 0%)");

//X11 color name - all 140 color names are supported.
//Note the lack of CamelCase in the name
const color5 = new THREE.Color( 'skyblue' );
//HSL string
const color6 = new THREE.Color("hsl(0, 100%, 50%)");

//Separate RGB values between 0 and 1
const color7 = new THREE.Color( 1, 0, 0 );
```

**Kind**: global class  

* [Color](#Color)
    * [new Color([r], [g], [b])](#new_Color_new)
    * _instance_
        * [.isColor](#Color+isColor) : <code>boolean</code>
        * [.r](#Color+r) : <code>number</code>
        * [.g](#Color+g) : <code>number</code>
        * [.b](#Color+b) : <code>number</code>
        * [.set([r], [g], [b])](#Color+set) ⇒ [<code>Color</code>](#Color)
        * [.setScalar(scalar)](#Color+setScalar) ⇒ [<code>Color</code>](#Color)
        * [.setHex(hex, [colorSpace])](#Color+setHex) ⇒ [<code>Color</code>](#Color)
        * [.setRGB(r, g, b, [colorSpace])](#Color+setRGB) ⇒ [<code>Color</code>](#Color)
        * [.setHSL(h, s, l, [colorSpace])](#Color+setHSL) ⇒ [<code>Color</code>](#Color)
        * [.setStyle(style, [colorSpace])](#Color+setStyle) ⇒ [<code>Color</code>](#Color)
        * [.setColorName(style, [colorSpace])](#Color+setColorName) ⇒ [<code>Color</code>](#Color)
        * [.clone()](#Color+clone) ⇒ [<code>Color</code>](#Color)
        * [.copy(color)](#Color+copy) ⇒ [<code>Color</code>](#Color)
        * [.copySRGBToLinear(color)](#Color+copySRGBToLinear) ⇒ [<code>Color</code>](#Color)
        * [.copyLinearToSRGB(color)](#Color+copyLinearToSRGB) ⇒ [<code>Color</code>](#Color)
        * [.convertSRGBToLinear()](#Color+convertSRGBToLinear) ⇒ [<code>Color</code>](#Color)
        * [.convertLinearToSRGB()](#Color+convertLinearToSRGB) ⇒ [<code>Color</code>](#Color)
        * [.getHex([colorSpace])](#Color+getHex) ⇒ <code>number</code>
        * [.getHexString([colorSpace])](#Color+getHexString) ⇒ <code>string</code>
        * [.getHSL(target, [colorSpace])](#Color+getHSL) ⇒ <code>Object</code>
        * [.getRGB(target, [colorSpace])](#Color+getRGB) ⇒ [<code>Color</code>](#Color)
        * [.getStyle([colorSpace])](#Color+getStyle) ⇒ <code>string</code>
        * [.offsetHSL(h, s, l)](#Color+offsetHSL) ⇒ [<code>Color</code>](#Color)
        * [.add(color)](#Color+add) ⇒ [<code>Color</code>](#Color)
        * [.addColors(color1, color2)](#Color+addColors) ⇒ [<code>Color</code>](#Color)
        * [.addScalar(s)](#Color+addScalar) ⇒ [<code>Color</code>](#Color)
        * [.sub(color)](#Color+sub) ⇒ [<code>Color</code>](#Color)
        * [.multiply(color)](#Color+multiply) ⇒ [<code>Color</code>](#Color)
        * [.multiplyScalar(s)](#Color+multiplyScalar) ⇒ [<code>Color</code>](#Color)
        * [.lerp(color, alpha)](#Color+lerp) ⇒ [<code>Color</code>](#Color)
        * [.lerpColors(color1, color2, alpha)](#Color+lerpColors) ⇒ [<code>Color</code>](#Color)
        * [.lerpHSL(color, alpha)](#Color+lerpHSL) ⇒ [<code>Color</code>](#Color)
        * [.setFromVector3(v)](#Color+setFromVector3) ⇒ [<code>Color</code>](#Color)
        * [.applyMatrix3(m)](#Color+applyMatrix3) ⇒ [<code>Color</code>](#Color)
        * [.equals(c)](#Color+equals) ⇒ <code>boolean</code>
        * [.fromArray(array, [offset])](#Color+fromArray) ⇒ [<code>Color</code>](#Color)
        * [.toArray([array], [offset])](#Color+toArray) ⇒ <code>Array.&lt;number&gt;</code>
        * [.fromBufferAttribute(attribute, index)](#Color+fromBufferAttribute) ⇒ [<code>Color</code>](#Color)
        * [.toJSON()](#Color+toJSON) ⇒ <code>number</code>
    * _static_
        * [.NAMES](#Color.NAMES) : <code>Object</code>

<a name="new_Color_new"></a>

### new Color([r], [g], [b])
Constructs a new color.

Note that standard method of specifying color in three.js is with a hexadecimal triplet,
and that method is used throughout the rest of the documentation.


| Param | Type | Description |
| --- | --- | --- |
| [r] | <code>number</code> \| <code>string</code> \| [<code>Color</code>](#Color) | The red component of the color. If `g` and `b` are not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance. |
| [g] | <code>number</code> | The green component. |
| [b] | <code>number</code> | The blue component. |

<a name="Color+isColor"></a>

### color.isColor : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Color</code>](#Color)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Color+r"></a>

### color.r : <code>number</code>
The red component.

**Kind**: instance property of [<code>Color</code>](#Color)  
**Default**: <code>1</code>  
<a name="Color+g"></a>

### color.g : <code>number</code>
The green component.

**Kind**: instance property of [<code>Color</code>](#Color)  
**Default**: <code>1</code>  
<a name="Color+b"></a>

### color.b : <code>number</code>
The blue component.

**Kind**: instance property of [<code>Color</code>](#Color)  
**Default**: <code>1</code>  
<a name="Color+set"></a>

### color.set([r], [g], [b]) ⇒ [<code>Color</code>](#Color)
Sets the colors's components from the given values.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| [r] | <code>number</code> \| <code>string</code> \| [<code>Color</code>](#Color) | The red component of the color. If `g` and `b` are not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance. |
| [g] | <code>number</code> | The green component. |
| [b] | <code>number</code> | The blue component. |

<a name="Color+setScalar"></a>

### color.setScalar(scalar) ⇒ [<code>Color</code>](#Color)
Sets the colors's components to the given scalar value.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar value. |

<a name="Color+setHex"></a>

### color.setHex(hex, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from a hexadecimal value.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| hex | <code>number</code> |  | The hexadecimal value. |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+setRGB"></a>

### color.setRGB(r, g, b, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from RGB values.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| r | <code>number</code> |  | Red channel value between `0.0` and `1.0`. |
| g | <code>number</code> |  | Green channel value between `0.0` and `1.0`. |
| b | <code>number</code> |  | Blue channel value between `0.0` and `1.0`. |
| [colorSpace] | <code>string</code> | <code>&quot;ColorManagement.workingColorSpace&quot;</code> | The color space. |

<a name="Color+setHSL"></a>

### color.setHSL(h, s, l, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from RGB values.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| h | <code>number</code> |  | Hue value between `0.0` and `1.0`. |
| s | <code>number</code> |  | Saturation value between `0.0` and `1.0`. |
| l | <code>number</code> |  | Lightness value between `0.0` and `1.0`. |
| [colorSpace] | <code>string</code> | <code>&quot;ColorManagement.workingColorSpace&quot;</code> | The color space. |

<a name="Color+setStyle"></a>

### color.setStyle(style, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
`rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -
all 140 color names are supported).

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| style | <code>string</code> |  | Color as a CSS-style string. |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+setColorName"></a>

### color.setColorName(style, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from a color name. Faster than [setStyle](#Color+setStyle) if
you don't need the other CSS-style formats.

For convenience, the list of names is exposed in `Color.NAMES` as a hash.
```js
Color.NAMES.aliceblue // returns 0xF0F8FF
```

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| style | <code>string</code> |  | The color name. |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+clone"></a>

### color.clone() ⇒ [<code>Color</code>](#Color)
Returns a new color with copied values from this instance.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A clone of this instance.  
<a name="Color+copy"></a>

### color.copy(color) ⇒ [<code>Color</code>](#Color)
Copies the values of the given color to this instance.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to copy. |

<a name="Color+copySRGBToLinear"></a>

### color.copySRGBToLinear(color) ⇒ [<code>Color</code>](#Color)
Copies the given color into this color, and then converts this color from
`SRGBColorSpace` to `LinearSRGBColorSpace`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to copy/convert. |

<a name="Color+copyLinearToSRGB"></a>

### color.copyLinearToSRGB(color) ⇒ [<code>Color</code>](#Color)
Copies the given color into this color, and then converts this color from
`LinearSRGBColorSpace` to `SRGBColorSpace`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to copy/convert. |

<a name="Color+convertSRGBToLinear"></a>

### color.convertSRGBToLinear() ⇒ [<code>Color</code>](#Color)
Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  
<a name="Color+convertLinearToSRGB"></a>

### color.convertLinearToSRGB() ⇒ [<code>Color</code>](#Color)
Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  
<a name="Color+getHex"></a>

### color.getHex([colorSpace]) ⇒ <code>number</code>
Returns the hexadecimal value of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>number</code> - The hexadecimal value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+getHexString"></a>

### color.getHexString([colorSpace]) ⇒ <code>string</code>
Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>string</code> - The hexadecimal value as a string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+getHSL"></a>

### color.getHSL(target, [colorSpace]) ⇒ <code>Object</code>
Converts the colors RGB values into the HSL format and stores them into the
given target object.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>Object</code> - The HSL representation of this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| target | <code>Object</code> |  | The target object that is used to store the method's result. |
| [colorSpace] | <code>string</code> | <code>&quot;ColorManagement.workingColorSpace&quot;</code> | The color space. |

<a name="Color+getRGB"></a>

### color.getRGB(target, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Returns the RGB values of this color and stores them into the given target object.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - The RGB representation of this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| target | [<code>Color</code>](#Color) |  | The target color that is used to store the method's result. |
| [colorSpace] | <code>string</code> | <code>&quot;ColorManagement.workingColorSpace&quot;</code> | The color space. |

<a name="Color+getStyle"></a>

### color.getStyle([colorSpace]) ⇒ <code>string</code>
Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>string</code> - The CSS representation of this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+offsetHSL"></a>

### color.offsetHSL(h, s, l) ⇒ [<code>Color</code>](#Color)
Adds the given HSL values to this color's values.
Internally, this converts the color's RGB values to HSL, adds HSL
and then converts the color back to RGB.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| h | <code>number</code> | Hue value between `0.0` and `1.0`. |
| s | <code>number</code> | Saturation value between `0.0` and `1.0`. |
| l | <code>number</code> | Lightness value between `0.0` and `1.0`. |

<a name="Color+add"></a>

### color.add(color) ⇒ [<code>Color</code>](#Color)
Adds the RGB values of the given color to the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to add. |

<a name="Color+addColors"></a>

### color.addColors(color1, color2) ⇒ [<code>Color</code>](#Color)
Adds the RGB values of the given colors and stores the result in this instance.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color1 | [<code>Color</code>](#Color) | The first color. |
| color2 | [<code>Color</code>](#Color) | The second color. |

<a name="Color+addScalar"></a>

### color.addScalar(s) ⇒ [<code>Color</code>](#Color)
Adds the given scalar value to the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to add. |

<a name="Color+sub"></a>

### color.sub(color) ⇒ [<code>Color</code>](#Color)
Subtracts the RGB values of the given color from the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to subtract. |

<a name="Color+multiply"></a>

### color.multiply(color) ⇒ [<code>Color</code>](#Color)
Multiplies the RGB values of the given color with the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to multiply. |

<a name="Color+multiplyScalar"></a>

### color.multiplyScalar(s) ⇒ [<code>Color</code>](#Color)
Multiplies the given scalar value with the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to multiply. |

<a name="Color+lerp"></a>

### color.lerp(color, alpha) ⇒ [<code>Color</code>](#Color)
Linearly interpolates this color's RGB values toward the RGB values of the
given color. The alpha argument can be thought of as the ratio between
the two colors, where `0.0` is this color and `1.0` is the first argument.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to converge on. |
| alpha | <code>number</code> | The interpolation factor in the closed interval `[0,1]`. |

<a name="Color+lerpColors"></a>

### color.lerpColors(color1, color2, alpha) ⇒ [<code>Color</code>](#Color)
Linearly interpolates between the given colors and stores the result in this instance.
The alpha argument can be thought of as the ratio between the two colors, where `0.0`
is the first and `1.0` is the second color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color1 | [<code>Color</code>](#Color) | The first color. |
| color2 | [<code>Color</code>](#Color) | The second color. |
| alpha | <code>number</code> | The interpolation factor in the closed interval `[0,1]`. |

<a name="Color+lerpHSL"></a>

### color.lerpHSL(color, alpha) ⇒ [<code>Color</code>](#Color)
Linearly interpolates this color's HSL values toward the HSL values of the
given color. It differs from [lerp](#Color+lerp) by not interpolating straight
from one color to the other, but instead going through all the hues in between
those two colors. The alpha argument can be thought of as the ratio between
the two colors, where 0.0 is this color and 1.0 is the first argument.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to converge on. |
| alpha | <code>number</code> | The interpolation factor in the closed interval `[0,1]`. |

<a name="Color+setFromVector3"></a>

### color.setFromVector3(v) ⇒ [<code>Color</code>](#Color)
Sets the color's RGB components from the given 3D vector.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The vector to set. |

<a name="Color+applyMatrix3"></a>

### color.applyMatrix3(m) ⇒ [<code>Color</code>](#Color)
Transforms this color with the given 3x3 matrix.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix. |

<a name="Color+equals"></a>

### color.equals(c) ⇒ <code>boolean</code>
Returns `true` if this color is equal with the given one.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>boolean</code> - Whether this bounding color is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| c | [<code>Color</code>](#Color) | The color to test for equality. |

<a name="Color+fromArray"></a>

### color.fromArray(array, [offset]) ⇒ [<code>Color</code>](#Color)
Sets this color's RGB components from the given array.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the RGB values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Color+toArray"></a>

### color.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the RGB components of this color to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>Array.&lt;number&gt;</code> - The color components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the color components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Color+fromBufferAttribute"></a>

### color.fromBufferAttribute(attribute, index) ⇒ [<code>Color</code>](#Color)
Sets the components of this color from the given buffer attribute.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding color data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Color+toJSON"></a>

### color.toJSON() ⇒ <code>number</code>
This methods defines the serialization result of this class. Returns the color
as a hexadecimal value.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>number</code> - The hexadecimal value.  
<a name="Color.NAMES"></a>

### Color.NAMES : <code>Object</code>
A dictionary with X11 color names.

Note that multiple words such as Dark Orange become the string 'darkorange'.

**Kind**: static property of [<code>Color</code>](#Color)  
<a name="Cylindrical"></a>

## Cylindrical
This class can be used to represent points in 3D space as
[Cylindrical coordinates](https://en.wikipedia.org/wiki/Cylindrical_coordinate_system).

**Kind**: global class  

* [Cylindrical](#Cylindrical)
    * [new Cylindrical([radius], [theta], [y])](#new_Cylindrical_new)
    * [.radius](#Cylindrical+radius) : <code>number</code>
    * [.theta](#Cylindrical+theta) : <code>number</code>
    * [.y](#Cylindrical+y) : <code>number</code>
    * [.set(radius, theta, y)](#Cylindrical+set) ⇒ [<code>Cylindrical</code>](#Cylindrical)
    * [.copy(other)](#Cylindrical+copy) ⇒ [<code>Cylindrical</code>](#Cylindrical)
    * [.setFromVector3(v)](#Cylindrical+setFromVector3) ⇒ [<code>Cylindrical</code>](#Cylindrical)
    * [.setFromCartesianCoords(x, y, z)](#Cylindrical+setFromCartesianCoords) ⇒ [<code>Cylindrical</code>](#Cylindrical)
    * [.clone()](#Cylindrical+clone) ⇒ [<code>Cylindrical</code>](#Cylindrical)

<a name="new_Cylindrical_new"></a>

### new Cylindrical([radius], [theta], [y])
Constructs a new cylindrical.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | The distance from the origin to a point in the x-z plane. |
| [theta] | <code>number</code> | <code>0</code> | A counterclockwise angle in the x-z plane measured in radians from the positive z-axis. |
| [y] | <code>number</code> | <code>0</code> | The height above the x-z plane. |

<a name="Cylindrical+radius"></a>

### cylindrical.radius : <code>number</code>
The distance from the origin to a point in the x-z plane.

**Kind**: instance property of [<code>Cylindrical</code>](#Cylindrical)  
**Default**: <code>1</code>  
<a name="Cylindrical+theta"></a>

### cylindrical.theta : <code>number</code>
A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.

**Kind**: instance property of [<code>Cylindrical</code>](#Cylindrical)  
**Default**: <code>0</code>  
<a name="Cylindrical+y"></a>

### cylindrical.y : <code>number</code>
The height above the x-z plane.

**Kind**: instance property of [<code>Cylindrical</code>](#Cylindrical)  
**Default**: <code>0</code>  
<a name="Cylindrical+set"></a>

### cylindrical.set(radius, theta, y) ⇒ [<code>Cylindrical</code>](#Cylindrical)
Sets the cylindrical components by copying the given values.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A reference to this cylindrical.  

| Param | Type | Description |
| --- | --- | --- |
| radius | <code>number</code> | The radius. |
| theta | <code>number</code> | The theta angle. |
| y | <code>number</code> | The height value. |

<a name="Cylindrical+copy"></a>

### cylindrical.copy(other) ⇒ [<code>Cylindrical</code>](#Cylindrical)
Copies the values of the given cylindrical to this instance.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A reference to this cylindrical.  

| Param | Type | Description |
| --- | --- | --- |
| other | [<code>Cylindrical</code>](#Cylindrical) | The cylindrical to copy. |

<a name="Cylindrical+setFromVector3"></a>

### cylindrical.setFromVector3(v) ⇒ [<code>Cylindrical</code>](#Cylindrical)
Sets the cylindrical components from the given vector which is assumed to hold
Cartesian coordinates.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A reference to this cylindrical.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The vector to set. |

<a name="Cylindrical+setFromCartesianCoords"></a>

### cylindrical.setFromCartesianCoords(x, y, z) ⇒ [<code>Cylindrical</code>](#Cylindrical)
Sets the cylindrical components from the given Cartesian coordinates.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A reference to this cylindrical.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value. |
| y | <code>number</code> | The x value. |
| z | <code>number</code> | The x value. |

<a name="Cylindrical+clone"></a>

### cylindrical.clone() ⇒ [<code>Cylindrical</code>](#Cylindrical)
Returns a new cylindrical with copied values from this instance.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A clone of this instance.  
<a name="Euler"></a>

## Euler
A class representing Euler angles.

Euler angles describe a rotational transformation by rotating an object on
its various axes in specified amounts per axis, and a specified axis
order.

Iterating through an instance will yield its components (x, y, z,
order) in the corresponding order.

```js
const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
const b = new THREE.Vector3( 1, 0, 1 );
b.applyEuler(a);
```

**Kind**: global class  

* [Euler](#Euler)
    * [new Euler([x], [y], [z], [order])](#new_Euler_new)
    * _instance_
        * [.isEuler](#Euler+isEuler) : <code>boolean</code>
        * [.x](#Euler+x) : <code>number</code>
        * [.y](#Euler+y) : <code>number</code>
        * [.z](#Euler+z) : <code>number</code>
        * [.order](#Euler+order) : <code>string</code>
        * [.set(x, y, z, [order])](#Euler+set) ⇒ [<code>Euler</code>](#Euler)
        * [.clone()](#Euler+clone) ⇒ [<code>Euler</code>](#Euler)
        * [.copy(euler)](#Euler+copy) ⇒ [<code>Euler</code>](#Euler)
        * [.setFromRotationMatrix(m, [order], [update])](#Euler+setFromRotationMatrix) ⇒ [<code>Euler</code>](#Euler)
        * [.setFromQuaternion(q, [order], [update])](#Euler+setFromQuaternion) ⇒ [<code>Euler</code>](#Euler)
        * [.setFromVector3(v, [order])](#Euler+setFromVector3) ⇒ [<code>Euler</code>](#Euler)
        * [.reorder([newOrder])](#Euler+reorder) ⇒ [<code>Euler</code>](#Euler)
        * [.equals(euler)](#Euler+equals) ⇒ <code>boolean</code>
        * [.fromArray(array)](#Euler+fromArray) ⇒ [<code>Euler</code>](#Euler)
        * [.toArray([array], [offset])](#Euler+toArray) ⇒ <code>Array.&lt;number, number, number, string&gt;</code>
    * _static_
        * [.DEFAULT_ORDER](#Euler.DEFAULT_ORDER) : <code>string</code>

<a name="new_Euler_new"></a>

### new Euler([x], [y], [z], [order])
Constructs a new euler instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The angle of the x axis in radians. |
| [y] | <code>number</code> | <code>0</code> | The angle of the y axis in radians. |
| [z] | <code>number</code> | <code>0</code> | The angle of the z axis in radians. |
| [order] | <code>string</code> | <code>&quot;Euler.DEFAULT_ORDER&quot;</code> | A string representing the order that the rotations are applied. |

<a name="Euler+isEuler"></a>

### euler.isEuler : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Euler+x"></a>

### euler.x : <code>number</code>
The angle of the x axis in radians.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>0</code>  
<a name="Euler+y"></a>

### euler.y : <code>number</code>
The angle of the y axis in radians.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>0</code>  
<a name="Euler+z"></a>

### euler.z : <code>number</code>
The angle of the z axis in radians.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>0</code>  
<a name="Euler+order"></a>

### euler.order : <code>string</code>
A string representing the order that the rotations are applied.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>&quot;&#x27;XYZ&#x27;&quot;</code>  
<a name="Euler+set"></a>

### euler.set(x, y, z, [order]) ⇒ [<code>Euler</code>](#Euler)
Sets the Euler components.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The angle of the x axis in radians. |
| y | <code>number</code> | The angle of the y axis in radians. |
| z | <code>number</code> | The angle of the z axis in radians. |
| [order] | <code>string</code> | A string representing the order that the rotations are applied. |

<a name="Euler+clone"></a>

### euler.clone() ⇒ [<code>Euler</code>](#Euler)
Returns a new Euler instance with copied values from this instance.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A clone of this instance.  
<a name="Euler+copy"></a>

### euler.copy(euler) ⇒ [<code>Euler</code>](#Euler)
Copies the values of the given Euler instance to this instance.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| euler | [<code>Euler</code>](#Euler) | The Euler instance to copy. |

<a name="Euler+setFromRotationMatrix"></a>

### euler.setFromRotationMatrix(m, [order], [update]) ⇒ [<code>Euler</code>](#Euler)
Sets the angles of this Euler instance from a pure rotation matrix.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| m | <code>Matrix4</code> |  | A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled). |
| [order] | <code>string</code> |  | A string representing the order that the rotations are applied. |
| [update] | <code>boolean</code> | <code>true</code> | Whether the internal `onChange` callback should be executed or not. |

<a name="Euler+setFromQuaternion"></a>

### euler.setFromQuaternion(q, [order], [update]) ⇒ [<code>Euler</code>](#Euler)
Sets the angles of this Euler instance from a normalized quaternion.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| q | <code>Quaternion</code> |  | A normalized Quaternion. |
| [order] | <code>string</code> |  | A string representing the order that the rotations are applied. |
| [update] | <code>boolean</code> | <code>true</code> | Whether the internal `onChange` callback should be executed or not. |

<a name="Euler+setFromVector3"></a>

### euler.setFromVector3(v, [order]) ⇒ [<code>Euler</code>](#Euler)
Sets the angles of this Euler instance from the given vector.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The vector. |
| [order] | <code>string</code> | A string representing the order that the rotations are applied. |

<a name="Euler+reorder"></a>

### euler.reorder([newOrder]) ⇒ [<code>Euler</code>](#Euler)
Resets the euler angle with a new order by creating a quaternion from this
euler angle and then setting this euler angle with the quaternion and the
new order.

Warning: This discards revolution information.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| [newOrder] | <code>string</code> | A string representing the new order that the rotations are applied. |

<a name="Euler+equals"></a>

### euler.equals(euler) ⇒ <code>boolean</code>
Returns `true` if this Euler instance is equal with the given one.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: <code>boolean</code> - Whether this Euler instance is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| euler | [<code>Euler</code>](#Euler) | The Euler instance to test for equality. |

<a name="Euler+fromArray"></a>

### euler.fromArray(array) ⇒ [<code>Euler</code>](#Euler)
Sets this Euler instance's components to values from the given array. The first three
entries of the array are assign to the x,y and z components. An optional fourth entry
defines the Euler order.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array.&lt;number, number, number, ?string&gt;</code> | An array holding the Euler component values. |

<a name="Euler+toArray"></a>

### euler.toArray([array], [offset]) ⇒ <code>Array.&lt;number, number, number, string&gt;</code>
Writes the components of this Euler instance to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: <code>Array.&lt;number, number, number, string&gt;</code> - The Euler components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number, number, number, string&gt;</code> | <code>[]</code> | The target array holding the Euler components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Euler.DEFAULT_ORDER"></a>

### Euler.DEFAULT\_ORDER : <code>string</code>
The default Euler angle order.

**Kind**: static property of [<code>Euler</code>](#Euler)  
**Default**: <code>&quot;&#x27;XYZ&#x27;&quot;</code>  
<a name="Frustum"></a>

## Frustum
Frustums are used to determine what is inside the camera's field of view.
They help speed up the rendering process - objects which lie outside a camera's
frustum can safely be excluded from rendering.

This class is mainly intended for use internally by a renderer.

**Kind**: global class  

* [Frustum](#Frustum)
    * [new Frustum([p0], [p1], [p2], [p3], [p4], [p5])](#new_Frustum_new)
    * [.planes](#Frustum+planes) : <code>Array.&lt;Plane&gt;</code>
    * [.set([p0], [p1], [p2], [p3], [p4], [p5])](#Frustum+set) ⇒ [<code>Frustum</code>](#Frustum)
    * [.copy(frustum)](#Frustum+copy) ⇒ [<code>Frustum</code>](#Frustum)
    * [.setFromProjectionMatrix(m, coordinateSystem)](#Frustum+setFromProjectionMatrix) ⇒ [<code>Frustum</code>](#Frustum)
    * [.intersectsObject(object)](#Frustum+intersectsObject) ⇒ <code>boolean</code>
    * [.intersectsSprite(sprite)](#Frustum+intersectsSprite) ⇒ <code>boolean</code>
    * [.intersectsSphere(sphere)](#Frustum+intersectsSphere) ⇒ <code>boolean</code>
    * [.intersectsBox(box)](#Frustum+intersectsBox) ⇒ <code>boolean</code>
    * [.containsPoint(point)](#Frustum+containsPoint) ⇒ <code>boolean</code>
    * [.clone()](#Frustum+clone) ⇒ [<code>Frustum</code>](#Frustum)

<a name="new_Frustum_new"></a>

### new Frustum([p0], [p1], [p2], [p3], [p4], [p5])
Constructs a new frustum.


| Param | Type | Description |
| --- | --- | --- |
| [p0] | <code>Plane</code> | The first plane that encloses the frustum. |
| [p1] | <code>Plane</code> | The second plane that encloses the frustum. |
| [p2] | <code>Plane</code> | The third plane that encloses the frustum. |
| [p3] | <code>Plane</code> | The fourth plane that encloses the frustum. |
| [p4] | <code>Plane</code> | The fifth plane that encloses the frustum. |
| [p5] | <code>Plane</code> | The sixth plane that encloses the frustum. |

<a name="Frustum+planes"></a>

### frustum.planes : <code>Array.&lt;Plane&gt;</code>
This array holds the planes that enclose the frustum.

**Kind**: instance property of [<code>Frustum</code>](#Frustum)  
<a name="Frustum+set"></a>

### frustum.set([p0], [p1], [p2], [p3], [p4], [p5]) ⇒ [<code>Frustum</code>](#Frustum)
Sets the frustum planes by copying the given planes.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: [<code>Frustum</code>](#Frustum) - A reference to this frustum.  

| Param | Type | Description |
| --- | --- | --- |
| [p0] | <code>Plane</code> | The first plane that encloses the frustum. |
| [p1] | <code>Plane</code> | The second plane that encloses the frustum. |
| [p2] | <code>Plane</code> | The third plane that encloses the frustum. |
| [p3] | <code>Plane</code> | The fourth plane that encloses the frustum. |
| [p4] | <code>Plane</code> | The fifth plane that encloses the frustum. |
| [p5] | <code>Plane</code> | The sixth plane that encloses the frustum. |

<a name="Frustum+copy"></a>

### frustum.copy(frustum) ⇒ [<code>Frustum</code>](#Frustum)
Copies the values of the given frustum to this instance.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: [<code>Frustum</code>](#Frustum) - A reference to this frustum.  

| Param | Type | Description |
| --- | --- | --- |
| frustum | [<code>Frustum</code>](#Frustum) | The frustum to copy. |

<a name="Frustum+setFromProjectionMatrix"></a>

### frustum.setFromProjectionMatrix(m, coordinateSystem) ⇒ [<code>Frustum</code>](#Frustum)
Sets the frustum planes from the given projection matrix.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: [<code>Frustum</code>](#Frustum) - A reference to this frustum.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The projection matrix. |
| coordinateSystem | <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code> | The coordinate system. |

<a name="Frustum+intersectsObject"></a>

### frustum.intersectsObject(object) ⇒ <code>boolean</code>
Returns `true` if the 3D object's bounding sphere is intersecting this frustum.

Note that the 3D object must have a geometry so that the bounding sphere can be calculated.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the 3D object's bounding sphere is intersecting this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to test. |

<a name="Frustum+intersectsSprite"></a>

### frustum.intersectsSprite(sprite) ⇒ <code>boolean</code>
Returns `true` if the given sprite is intersecting this frustum.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the sprite is intersecting this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| sprite | <code>Sprite</code> | The sprite to test. |

<a name="Frustum+intersectsSphere"></a>

### frustum.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if the given bounding sphere is intersecting this frustum.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the bounding sphere is intersecting this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="Frustum+intersectsBox"></a>

### frustum.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box is intersecting this frustum.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the bounding box is intersecting this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The bounding box to test. |

<a name="Frustum+containsPoint"></a>

### frustum.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies within the frustum.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the point lies within this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to test. |

<a name="Frustum+clone"></a>

### frustum.clone() ⇒ [<code>Frustum</code>](#Frustum)
Returns a new frustum with copied values from this instance.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: [<code>Frustum</code>](#Frustum) - A clone of this instance.  
<a name="Interpolant"></a>

## *Interpolant*
Abstract base class of interpolants over parametric samples.

The parameter domain is one dimensional, typically the time or a path
along a curve defined by the data.

The sample values can have any dimensionality and derived classes may
apply special interpretations to the data.

This class provides the interval seek in a Template Method, deferring
the actual interpolation to derived classes.

Time complexity is O(1) for linear access crossing at most two points
and O(log N) for random access, where N is the number of positions.

References: [http://www.oodesign.com/template-method-pattern.html](http://www.oodesign.com/template-method-pattern.html)

**Kind**: global abstract class  

* *[Interpolant](#Interpolant)*
    * *[new Interpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])](#new_Interpolant_new)*
    * *[.parameterPositions](#Interpolant+parameterPositions) : <code>TypedArray</code>*
    * *[.resultBuffer](#Interpolant+resultBuffer) : <code>TypedArray</code>*
    * *[.sampleValues](#Interpolant+sampleValues) : <code>TypedArray</code>*
    * *[.valueSize](#Interpolant+valueSize) : <code>TypedArray</code>*
    * *[.settings](#Interpolant+settings) : <code>Object</code>*
    * *[.DefaultSettings_](#Interpolant+DefaultSettings_) : <code>Object</code>*
    * *[.evaluate(t)](#Interpolant+evaluate) ⇒ <code>TypedArray</code>*
    * *[.getSettings_()](#Interpolant+getSettings_) ⇒ <code>Object</code>*
    * *[.copySampleValue_(index)](#Interpolant+copySampleValue_) ⇒ <code>TypedArray</code>*
    * **[.interpolate_(i1, t0, t, t1)](#Interpolant+interpolate_) ⇒ <code>TypedArray</code>**
    * *[.intervalChanged_(i1, t0, t)](#Interpolant+intervalChanged_)*

<a name="new_Interpolant_new"></a>

### *new Interpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])*
Constructs a new interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

<a name="Interpolant+parameterPositions"></a>

### *interpolant.parameterPositions : <code>TypedArray</code>*
The parameter positions.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+resultBuffer"></a>

### *interpolant.resultBuffer : <code>TypedArray</code>*
The result buffer.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+sampleValues"></a>

### *interpolant.sampleValues : <code>TypedArray</code>*
The sample values.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+valueSize"></a>

### *interpolant.valueSize : <code>TypedArray</code>*
The value size.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+settings"></a>

### *interpolant.settings : <code>Object</code>*
The interpolation settings.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
**Default**: <code>null</code>  
<a name="Interpolant+DefaultSettings_"></a>

### *interpolant.DefaultSettings\_ : <code>Object</code>*
The default settings object.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+evaluate"></a>

### *interpolant.evaluate(t) ⇒ <code>TypedArray</code>*
Evaluate the interpolant at position `t`.

**Kind**: instance method of [<code>Interpolant</code>](#Interpolant)  
**Returns**: <code>TypedArray</code> - The result buffer.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |

<a name="Interpolant+getSettings_"></a>

### *interpolant.getSettings\_() ⇒ <code>Object</code>*
Returns the interpolation settings.

**Kind**: instance method of [<code>Interpolant</code>](#Interpolant)  
**Returns**: <code>Object</code> - The interpolation settings.  
<a name="Interpolant+copySampleValue_"></a>

### *interpolant.copySampleValue\_(index) ⇒ <code>TypedArray</code>*
Copies a sample value to the result buffer.

**Kind**: instance method of [<code>Interpolant</code>](#Interpolant)  
**Returns**: <code>TypedArray</code> - The result buffer.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | An index into the sample value buffer. |

<a name="Interpolant+interpolate_"></a>

### **interpolant.interpolate\_(i1, t0, t, t1) ⇒ <code>TypedArray</code>**
Copies a sample value to the result buffer.

**Kind**: instance abstract method of [<code>Interpolant</code>](#Interpolant)  
**Returns**: <code>TypedArray</code> - The result buffer.  

| Param | Type | Description |
| --- | --- | --- |
| i1 | <code>number</code> | An index into the sample value buffer. |
| t0 | <code>number</code> | The previous interpolation factor. |
| t | <code>number</code> | The current interpolation factor. |
| t1 | <code>number</code> | The next interpolation factor. |

<a name="Interpolant+intervalChanged_"></a>

### *interpolant.intervalChanged\_(i1, t0, t)*
Optional method that is executed when the interval has changed.

**Kind**: instance method of [<code>Interpolant</code>](#Interpolant)  

| Param | Type | Description |
| --- | --- | --- |
| i1 | <code>number</code> | An index into the sample value buffer. |
| t0 | <code>number</code> | The previous interpolation factor. |
| t | <code>number</code> | The current interpolation factor. |

<a name="Line3"></a>

## Line3
An analytical line segment in 3D space represented by a start and end point.

**Kind**: global class  

* [Line3](#Line3)
    * [new Line3([start], [end])](#new_Line3_new)
    * [.start](#Line3+start) : <code>Vector3</code>
    * [.end](#Line3+end) : <code>Vector3</code>
    * [.set(start, end)](#Line3+set) ⇒ [<code>Line3</code>](#Line3)
    * [.copy(line)](#Line3+copy) ⇒ [<code>Line3</code>](#Line3)
    * [.getCenter(target)](#Line3+getCenter) ⇒ <code>Vector3</code>
    * [.delta(target)](#Line3+delta) ⇒ <code>Vector3</code>
    * [.distanceSq()](#Line3+distanceSq) ⇒ <code>number</code>
    * [.distance()](#Line3+distance) ⇒ <code>number</code>
    * [.at(t, target)](#Line3+at) ⇒ <code>Vector3</code>
    * [.closestPointToPointParameter(point, clampToLine)](#Line3+closestPointToPointParameter) ⇒ <code>number</code>
    * [.closestPointToPoint(point, clampToLine, target)](#Line3+closestPointToPoint) ⇒ <code>Vector3</code>
    * [.applyMatrix4(matrix)](#Line3+applyMatrix4) ⇒ [<code>Line3</code>](#Line3)
    * [.equals(line)](#Line3+equals) ⇒ <code>boolean</code>
    * [.clone()](#Line3+clone) ⇒ [<code>Line3</code>](#Line3)

<a name="new_Line3_new"></a>

### new Line3([start], [end])
Constructs a new line segment.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [start] | <code>Vector3</code> | <code>(0,0,0)</code> | Start of the line segment. |
| [end] | <code>Vector3</code> | <code>(0,0,0)</code> | End of the line segment. |

<a name="Line3+start"></a>

### line3.start : <code>Vector3</code>
Start of the line segment.

**Kind**: instance property of [<code>Line3</code>](#Line3)  
<a name="Line3+end"></a>

### line3.end : <code>Vector3</code>
End of the line segment.

**Kind**: instance property of [<code>Line3</code>](#Line3)  
<a name="Line3+set"></a>

### line3.set(start, end) ⇒ [<code>Line3</code>](#Line3)
Sets the start and end values by copying the given vectors.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: [<code>Line3</code>](#Line3) - A reference to this line segment.  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>Vector3</code> | The start point. |
| end | <code>Vector3</code> | The end point. |

<a name="Line3+copy"></a>

### line3.copy(line) ⇒ [<code>Line3</code>](#Line3)
Copies the values of the given line segment to this instance.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: [<code>Line3</code>](#Line3) - A reference to this line segment.  

| Param | Type | Description |
| --- | --- | --- |
| line | [<code>Line3</code>](#Line3) | The line segment to copy. |

<a name="Line3+getCenter"></a>

### line3.getCenter(target) ⇒ <code>Vector3</code>
Returns the center of the line segment.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>Vector3</code> - The center point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Line3+delta"></a>

### line3.delta(target) ⇒ <code>Vector3</code>
Returns the delta vector of the line segment's start and end point.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>Vector3</code> - The delta vector.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Line3+distanceSq"></a>

### line3.distanceSq() ⇒ <code>number</code>
Returns the squared Euclidean distance between the line' start and end point.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>number</code> - The squared Euclidean distance.  
<a name="Line3+distance"></a>

### line3.distance() ⇒ <code>number</code>
Returns the Euclidean distance between the line' start and end point.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>number</code> - The Euclidean distance.  
<a name="Line3+at"></a>

### line3.at(t, target) ⇒ <code>Vector3</code>
Returns a vector at a certain position along the line segment.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>Vector3</code> - The delta vector.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A value between `[0,1]` to represent a position along the line segment. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Line3+closestPointToPointParameter"></a>

### line3.closestPointToPointParameter(point, clampToLine) ⇒ <code>number</code>
Returns a point parameter based on the closest point as projected on the line segment.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>number</code> - The point parameter.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point for which to return a point parameter. |
| clampToLine | <code>boolean</code> | Whether to clamp the result to the range `[0,1]` or not. |

<a name="Line3+closestPointToPoint"></a>

### line3.closestPointToPoint(point, clampToLine, target) ⇒ <code>Vector3</code>
Returns the closets point on the line for a given point.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>Vector3</code> - The closest point on the line.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to compute the closest point on the line for. |
| clampToLine | <code>boolean</code> | Whether to clamp the result to the range `[0,1]` or not. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Line3+applyMatrix4"></a>

### line3.applyMatrix4(matrix) ⇒ [<code>Line3</code>](#Line3)
Applies a 4x4 transformation matrix to this line segment.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: [<code>Line3</code>](#Line3) - A reference to this line segment.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |

<a name="Line3+equals"></a>

### line3.equals(line) ⇒ <code>boolean</code>
Returns `true` if this line segment is equal with the given one.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>boolean</code> - Whether this line segment is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| line | [<code>Line3</code>](#Line3) | The line segment to test for equality. |

<a name="Line3+clone"></a>

### line3.clone() ⇒ [<code>Line3</code>](#Line3)
Returns a new line segment with copied values from this instance.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: [<code>Line3</code>](#Line3) - A clone of this instance.  
## Classes

<dl>
<dt><a href="#MathUtils">MathUtils</a></dt>
<dd><p>A collection of math utility functions.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#generateUUID">generateUUID()</a> ⇒ <code>string</code></dt>
<dd><p>Generate a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>
(universally unique identifier).</p>
</dd>
<dt><a href="#clamp">clamp(value, min, max)</a> ⇒ <code>number</code></dt>
<dd><p>Clamps the given value between min and max.</p>
</dd>
<dt><a href="#euclideanModulo">euclideanModulo(n, m)</a> ⇒ <code>number</code></dt>
<dd><p>Computes the Euclidean modulo of the given parameters that
is <code>( ( n % m ) + m ) % m</code>.</p>
</dd>
<dt><a href="#mapLinear">mapLinear(x, a1, a2, b1, b2)</a> ⇒ <code>number</code></dt>
<dd><p>Performs a linear mapping from range <code>&lt;a1, a2&gt;</code> to range <code>&lt;b1, b2&gt;</code>
for the given value.</p>
</dd>
<dt><a href="#inverseLerp">inverseLerp(x, y, value)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the percentage in the closed interval <code>[0, 1]</code> of the given value
between the start and end point.</p>
</dd>
<dt><a href="#lerp">lerp(x, y, t)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a value linearly interpolated from two known points based on the given interval -
<code>t = 0</code> will return <code>x</code> and <code>t = 1</code> will return <code>y</code>.</p>
</dd>
<dt><a href="#damp">damp(x, y, lambda, dt)</a> ⇒ <code>number</code></dt>
<dd><p>Smoothly interpolate a number from <code>x</code> to <code>y</code> in  a spring-like manner using a delta
time to maintain frame rate independent movement. For details, see
<a href="http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/">Frame rate independent damping using lerp</a>.</p>
</dd>
<dt><a href="#pingpong">pingpong(x, [length])</a> ⇒ <code>number</code></dt>
<dd><p>Returns a value that alternates between <code>0</code> and the given <code>length</code> parameter.</p>
</dd>
<dt><a href="#smoothstep">smoothstep(x, min, max)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a value in the range <code>[0,1]</code> that represents the percentage that <code>x</code> has
moved between <code>min</code> and <code>max</code>, but smoothed or slowed down the closer <code>x</code> is to
the <code>min</code> and <code>max</code>.</p>
<p>See <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> for more details.</p>
</dd>
<dt><a href="#smootherstep">smootherstep(x, min, max)</a> ⇒ <code>number</code></dt>
<dd><p>A <a href="https://en.wikipedia.org/wiki/Smoothstep#Variations">variation on smoothstep</a>
that has zero 1st and 2nd order derivatives at x=0 and x=1.</p>
</dd>
<dt><a href="#randInt">randInt(low, high)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a random integer from <code>&lt;low, high&gt;</code> interval.</p>
</dd>
<dt><a href="#randFloat">randFloat(low, high)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a random float from <code>&lt;low, high&gt;</code> interval.</p>
</dd>
<dt><a href="#randFloatSpread">randFloatSpread(range)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a random integer from <code>&lt;-range/2, range/2&gt;</code> interval.</p>
</dd>
<dt><a href="#seededRandom">seededRandom([s])</a> ⇒ <code>number</code></dt>
<dd><p>Returns a deterministic pseudo-random float in the interval <code>[0, 1]</code>.</p>
</dd>
<dt><a href="#degToRad">degToRad(degrees)</a> ⇒ <code>number</code></dt>
<dd><p>Converts degrees to radians.</p>
</dd>
<dt><a href="#radToDeg">radToDeg(radians)</a> ⇒ <code>number</code></dt>
<dd><p>Converts radians to degrees.</p>
</dd>
<dt><a href="#isPowerOfTwo">isPowerOfTwo(value)</a> ⇒ <code>boolean</code></dt>
<dd><p>Returns <code>true</code> if the given number is a power of two.</p>
</dd>
<dt><a href="#ceilPowerOfTwo">ceilPowerOfTwo(value)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the smallest power of two that is greater than or equal to the given number.</p>
</dd>
<dt><a href="#floorPowerOfTwo">floorPowerOfTwo(value)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the largest power of two that is less than or equal to the given number.</p>
</dd>
<dt><a href="#setQuaternionFromProperEuler">setQuaternionFromProperEuler(q, a, b, c, order)</a></dt>
<dd><p>Sets the given quaternion from the <a href="https://en.wikipedia.org/wiki/Euler_angles">Intrinsic Proper Euler Angles</a>
defined by the given angles and order.</p>
<p>Rotations are applied to the axes in the order specified by order:
rotation by angle <code>a</code> is applied first, then by angle <code>b</code>, then by angle <code>c</code>.</p>
</dd>
<dt><a href="#denormalize">denormalize(value, array)</a> ⇒ <code>number</code></dt>
<dd><p>Denormalizes the given value according to the given typed array.</p>
</dd>
<dt><a href="#normalize">normalize(value, array)</a> ⇒ <code>number</code></dt>
<dd><p>Normalizes the given value according to the given typed array.</p>
</dd>
</dl>

<a name="MathUtils"></a>

## MathUtils
A collection of math utility functions.

**Kind**: global class  

* [MathUtils](#MathUtils)
    * [.generateUUID()](#MathUtils.generateUUID) ⇒ <code>string</code>
    * [.clamp(value, min, max)](#MathUtils.clamp) ⇒ <code>number</code>
    * [.euclideanModulo(n, m)](#MathUtils.euclideanModulo) ⇒ <code>number</code>
    * [.mapLinear(x, a1, a2, b1, b2)](#MathUtils.mapLinear) ⇒ <code>number</code>
    * [.inverseLerp(x, y, value)](#MathUtils.inverseLerp) ⇒ <code>number</code>
    * [.lerp(x, y, t)](#MathUtils.lerp) ⇒ <code>number</code>
    * [.damp(x, y, lambda, dt)](#MathUtils.damp) ⇒ <code>number</code>
    * [.pingpong(x, [length])](#MathUtils.pingpong) ⇒ <code>number</code>
    * [.smoothstep(x, min, max)](#MathUtils.smoothstep) ⇒ <code>number</code>
    * [.smootherstep(x, min, max)](#MathUtils.smootherstep) ⇒ <code>number</code>
    * [.randInt(low, high)](#MathUtils.randInt) ⇒ <code>number</code>
    * [.randFloat(low, high)](#MathUtils.randFloat) ⇒ <code>number</code>
    * [.randFloatSpread(range)](#MathUtils.randFloatSpread) ⇒ <code>number</code>
    * [.seededRandom([s])](#MathUtils.seededRandom) ⇒ <code>number</code>
    * [.degToRad(degrees)](#MathUtils.degToRad) ⇒ <code>number</code>
    * [.radToDeg(radians)](#MathUtils.radToDeg) ⇒ <code>number</code>
    * [.isPowerOfTwo(value)](#MathUtils.isPowerOfTwo) ⇒ <code>boolean</code>
    * [.ceilPowerOfTwo(value)](#MathUtils.ceilPowerOfTwo) ⇒ <code>number</code>
    * [.floorPowerOfTwo(value)](#MathUtils.floorPowerOfTwo) ⇒ <code>number</code>
    * [.setQuaternionFromProperEuler(q, a, b, c, order)](#MathUtils.setQuaternionFromProperEuler)
    * [.normalize(value, array)](#MathUtils.normalize) ⇒ <code>number</code>
    * [.denormalize(value, array)](#MathUtils.denormalize) ⇒ <code>number</code>

<a name="MathUtils.generateUUID"></a>

### MathUtils.generateUUID() ⇒ <code>string</code>
Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
(universally unique identifier).

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>string</code> - The UUID.  
<a name="MathUtils.clamp"></a>

### MathUtils.clamp(value, min, max) ⇒ <code>number</code>
Clamps the given value between min and max.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The clamped value.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to clamp. |
| min | <code>number</code> | The min value. |
| max | <code>number</code> | The max value. |

<a name="MathUtils.euclideanModulo"></a>

### MathUtils.euclideanModulo(n, m) ⇒ <code>number</code>
Computes the Euclidean modulo of the given parameters that
is `( ( n % m ) + m ) % m`.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The Euclidean modulo.  

| Param | Type | Description |
| --- | --- | --- |
| n | <code>number</code> | The first parameter. |
| m | <code>number</code> | The second parameter. |

<a name="MathUtils.mapLinear"></a>

### MathUtils.mapLinear(x, a1, a2, b1, b2) ⇒ <code>number</code>
Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
for the given value.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The mapped value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to be mapped. |
| a1 | <code>number</code> | Minimum value for range A. |
| a2 | <code>number</code> | Maximum value for range A. |
| b1 | <code>number</code> | Minimum value for range B. |
| b2 | <code>number</code> | Maximum value for range B. |

<a name="MathUtils.inverseLerp"></a>

### MathUtils.inverseLerp(x, y, value) ⇒ <code>number</code>
Returns the percentage in the closed interval `[0, 1]` of the given value
between the start and end point.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The interpolation factor.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The start point |
| y | <code>number</code> | The end point. |
| value | <code>number</code> | A value between start and end. |

<a name="MathUtils.lerp"></a>

### MathUtils.lerp(x, y, t) ⇒ <code>number</code>
Returns a value linearly interpolated from two known points based on the given interval -
`t = 0` will return `x` and `t = 1` will return `y`.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The start point |
| y | <code>number</code> | The end point. |
| t | <code>number</code> | The interpolation factor in the closed interval `[0, 1]`. |

<a name="MathUtils.damp"></a>

### MathUtils.damp(x, y, lambda, dt) ⇒ <code>number</code>
Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
time to maintain frame rate independent movement. For details, see
[Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The current point. |
| y | <code>number</code> | The target point. |
| lambda | <code>number</code> | A higher lambda value will make the movement more sudden, and a lower value will make the movement more gradual. |
| dt | <code>number</code> | Delta time in seconds. |

<a name="MathUtils.pingpong"></a>

### MathUtils.pingpong(x, [length]) ⇒ <code>number</code>
Returns a value that alternates between `0` and the given `length` parameter.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| x | <code>number</code> |  | The value to pingpong. |
| [length] | <code>number</code> | <code>1</code> | The positive value the function will pingpong to. |

<a name="MathUtils.smoothstep"></a>

### MathUtils.smoothstep(x, min, max) ⇒ <code>number</code>
Returns a value in the range `[0,1]` that represents the percentage that `x` has
moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
the `min` and `max`.

See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to evaluate based on its position between min and max. |
| min | <code>number</code> | The min value. Any x value below min will be `0`. |
| max | <code>number</code> | The max value. Any x value above max will be `1`. |

<a name="MathUtils.smootherstep"></a>

### MathUtils.smootherstep(x, min, max) ⇒ <code>number</code>
A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
that has zero 1st and 2nd order derivatives at x=0 and x=1.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to evaluate based on its position between min and max. |
| min | <code>number</code> | The min value. Any x value below min will be `0`. |
| max | <code>number</code> | The max value. Any x value above max will be `1`. |

<a name="MathUtils.randInt"></a>

### MathUtils.randInt(low, high) ⇒ <code>number</code>
Returns a random integer from `<low, high>` interval.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - A random integer.  

| Param | Type | Description |
| --- | --- | --- |
| low | <code>number</code> | The lower value boundary. |
| high | <code>number</code> | The upper value boundary |

<a name="MathUtils.randFloat"></a>

### MathUtils.randFloat(low, high) ⇒ <code>number</code>
Returns a random float from `<low, high>` interval.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| low | <code>number</code> | The lower value boundary. |
| high | <code>number</code> | The upper value boundary |

<a name="MathUtils.randFloatSpread"></a>

### MathUtils.randFloatSpread(range) ⇒ <code>number</code>
Returns a random integer from `<-range/2, range/2>` interval.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| range | <code>number</code> | Defines the value range. |

<a name="MathUtils.seededRandom"></a>

### MathUtils.seededRandom([s]) ⇒ <code>number</code>
Returns a deterministic pseudo-random float in the interval `[0, 1]`.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| [s] | <code>number</code> | The integer seed. |

<a name="MathUtils.degToRad"></a>

### MathUtils.degToRad(degrees) ⇒ <code>number</code>
Converts degrees to radians.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The converted value in radians.  

| Param | Type | Description |
| --- | --- | --- |
| degrees | <code>number</code> | A value in degrees. |

<a name="MathUtils.radToDeg"></a>

### MathUtils.radToDeg(radians) ⇒ <code>number</code>
Converts radians to degrees.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The converted value in degrees.  

| Param | Type | Description |
| --- | --- | --- |
| radians | <code>number</code> | A value in radians. |

<a name="MathUtils.isPowerOfTwo"></a>

### MathUtils.isPowerOfTwo(value) ⇒ <code>boolean</code>
Returns `true` if the given number is a power of two.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>boolean</code> - Whether the given number is a power of two or not.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to check. |

<a name="MathUtils.ceilPowerOfTwo"></a>

### MathUtils.ceilPowerOfTwo(value) ⇒ <code>number</code>
Returns the smallest power of two that is greater than or equal to the given number.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The smallest power of two that is greater than or equal to the given number.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to find a POT for. |

<a name="MathUtils.floorPowerOfTwo"></a>

### MathUtils.floorPowerOfTwo(value) ⇒ <code>number</code>
Returns the largest power of two that is less than or equal to the given number.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The largest power of two that is less than or equal to the given number.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to find a POT for. |

<a name="MathUtils.setQuaternionFromProperEuler"></a>

### MathUtils.setQuaternionFromProperEuler(q, a, b, c, order)
Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
defined by the given angles and order.

Rotations are applied to the axes in the order specified by order:
rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The quaternion to set. |
| a | <code>number</code> | The rotation applied to the first axis, in radians. |
| b | <code>number</code> | The rotation applied to the second axis, in radians. |
| c | <code>number</code> | The rotation applied to the third axis, in radians. |
| order | <code>&#x27;XYX&#x27;</code> \| <code>&#x27;XZX&#x27;</code> \| <code>&#x27;YXY&#x27;</code> \| <code>&#x27;YZY&#x27;</code> \| <code>&#x27;ZXZ&#x27;</code> \| <code>&#x27;ZYZ&#x27;</code> | A string specifying the axes order. |

<a name="MathUtils.normalize"></a>

### MathUtils.normalize(value, array) ⇒ <code>number</code>
Normalizes the given value according to the given typed array.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The normalize value.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The float value in the range `[0,1]` to normalize. |
| array | <code>TypedArray</code> | The typed array that defines the data type of the value. |

<a name="MathUtils.denormalize"></a>

### MathUtils.denormalize(value, array) ⇒ <code>number</code>
Denormalizes the given value according to the given typed array.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The denormalize (float) value in the range `[0,1]`.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to denormalize. |
| array | <code>TypedArray</code> | The typed array that defines the data type of the value. |

<a name="generateUUID"></a>

## generateUUID() ⇒ <code>string</code>
Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
(universally unique identifier).

**Kind**: global function  
**Returns**: <code>string</code> - The UUID.  
<a name="clamp"></a>

## clamp(value, min, max) ⇒ <code>number</code>
Clamps the given value between min and max.

**Kind**: global function  
**Returns**: <code>number</code> - The clamped value.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to clamp. |
| min | <code>number</code> | The min value. |
| max | <code>number</code> | The max value. |

<a name="euclideanModulo"></a>

## euclideanModulo(n, m) ⇒ <code>number</code>
Computes the Euclidean modulo of the given parameters that
is `( ( n % m ) + m ) % m`.

**Kind**: global function  
**Returns**: <code>number</code> - The Euclidean modulo.  

| Param | Type | Description |
| --- | --- | --- |
| n | <code>number</code> | The first parameter. |
| m | <code>number</code> | The second parameter. |

<a name="mapLinear"></a>

## mapLinear(x, a1, a2, b1, b2) ⇒ <code>number</code>
Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
for the given value.

**Kind**: global function  
**Returns**: <code>number</code> - The mapped value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to be mapped. |
| a1 | <code>number</code> | Minimum value for range A. |
| a2 | <code>number</code> | Maximum value for range A. |
| b1 | <code>number</code> | Minimum value for range B. |
| b2 | <code>number</code> | Maximum value for range B. |

<a name="inverseLerp"></a>

## inverseLerp(x, y, value) ⇒ <code>number</code>
Returns the percentage in the closed interval `[0, 1]` of the given value
between the start and end point.

**Kind**: global function  
**Returns**: <code>number</code> - The interpolation factor.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The start point |
| y | <code>number</code> | The end point. |
| value | <code>number</code> | A value between start and end. |

<a name="lerp"></a>

## lerp(x, y, t) ⇒ <code>number</code>
Returns a value linearly interpolated from two known points based on the given interval -
`t = 0` will return `x` and `t = 1` will return `y`.

**Kind**: global function  
**Returns**: <code>number</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The start point |
| y | <code>number</code> | The end point. |
| t | <code>number</code> | The interpolation factor in the closed interval `[0, 1]`. |

<a name="damp"></a>

## damp(x, y, lambda, dt) ⇒ <code>number</code>
Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
time to maintain frame rate independent movement. For details, see
[Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).

**Kind**: global function  
**Returns**: <code>number</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The current point. |
| y | <code>number</code> | The target point. |
| lambda | <code>number</code> | A higher lambda value will make the movement more sudden, and a lower value will make the movement more gradual. |
| dt | <code>number</code> | Delta time in seconds. |

<a name="pingpong"></a>

## pingpong(x, [length]) ⇒ <code>number</code>
Returns a value that alternates between `0` and the given `length` parameter.

**Kind**: global function  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| x | <code>number</code> |  | The value to pingpong. |
| [length] | <code>number</code> | <code>1</code> | The positive value the function will pingpong to. |

<a name="smoothstep"></a>

## smoothstep(x, min, max) ⇒ <code>number</code>
Returns a value in the range `[0,1]` that represents the percentage that `x` has
moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
the `min` and `max`.

See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.

**Kind**: global function  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to evaluate based on its position between min and max. |
| min | <code>number</code> | The min value. Any x value below min will be `0`. |
| max | <code>number</code> | The max value. Any x value above max will be `1`. |

<a name="smootherstep"></a>

## smootherstep(x, min, max) ⇒ <code>number</code>
A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
that has zero 1st and 2nd order derivatives at x=0 and x=1.

**Kind**: global function  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to evaluate based on its position between min and max. |
| min | <code>number</code> | The min value. Any x value below min will be `0`. |
| max | <code>number</code> | The max value. Any x value above max will be `1`. |

<a name="randInt"></a>

## randInt(low, high) ⇒ <code>number</code>
Returns a random integer from `<low, high>` interval.

**Kind**: global function  
**Returns**: <code>number</code> - A random integer.  

| Param | Type | Description |
| --- | --- | --- |
| low | <code>number</code> | The lower value boundary. |
| high | <code>number</code> | The upper value boundary |

<a name="randFloat"></a>

## randFloat(low, high) ⇒ <code>number</code>
Returns a random float from `<low, high>` interval.

**Kind**: global function  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| low | <code>number</code> | The lower value boundary. |
| high | <code>number</code> | The upper value boundary |

<a name="randFloatSpread"></a>

## randFloatSpread(range) ⇒ <code>number</code>
Returns a random integer from `<-range/2, range/2>` interval.

**Kind**: global function  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| range | <code>number</code> | Defines the value range. |

<a name="seededRandom"></a>

## seededRandom([s]) ⇒ <code>number</code>
Returns a deterministic pseudo-random float in the interval `[0, 1]`.

**Kind**: global function  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| [s] | <code>number</code> | The integer seed. |

<a name="degToRad"></a>

## degToRad(degrees) ⇒ <code>number</code>
Converts degrees to radians.

**Kind**: global function  
**Returns**: <code>number</code> - The converted value in radians.  

| Param | Type | Description |
| --- | --- | --- |
| degrees | <code>number</code> | A value in degrees. |

<a name="radToDeg"></a>

## radToDeg(radians) ⇒ <code>number</code>
Converts radians to degrees.

**Kind**: global function  
**Returns**: <code>number</code> - The converted value in degrees.  

| Param | Type | Description |
| --- | --- | --- |
| radians | <code>number</code> | A value in radians. |

<a name="isPowerOfTwo"></a>

## isPowerOfTwo(value) ⇒ <code>boolean</code>
Returns `true` if the given number is a power of two.

**Kind**: global function  
**Returns**: <code>boolean</code> - Whether the given number is a power of two or not.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to check. |

<a name="ceilPowerOfTwo"></a>

## ceilPowerOfTwo(value) ⇒ <code>number</code>
Returns the smallest power of two that is greater than or equal to the given number.

**Kind**: global function  
**Returns**: <code>number</code> - The smallest power of two that is greater than or equal to the given number.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to find a POT for. |

<a name="floorPowerOfTwo"></a>

## floorPowerOfTwo(value) ⇒ <code>number</code>
Returns the largest power of two that is less than or equal to the given number.

**Kind**: global function  
**Returns**: <code>number</code> - The largest power of two that is less than or equal to the given number.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to find a POT for. |

<a name="setQuaternionFromProperEuler"></a>

## setQuaternionFromProperEuler(q, a, b, c, order)
Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
defined by the given angles and order.

Rotations are applied to the axes in the order specified by order:
rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The quaternion to set. |
| a | <code>number</code> | The rotation applied to the first axis, in radians. |
| b | <code>number</code> | The rotation applied to the second axis, in radians. |
| c | <code>number</code> | The rotation applied to the third axis, in radians. |
| order | <code>&#x27;XYX&#x27;</code> \| <code>&#x27;XZX&#x27;</code> \| <code>&#x27;YXY&#x27;</code> \| <code>&#x27;YZY&#x27;</code> \| <code>&#x27;ZXZ&#x27;</code> \| <code>&#x27;ZYZ&#x27;</code> | A string specifying the axes order. |

<a name="denormalize"></a>

## denormalize(value, array) ⇒ <code>number</code>
Denormalizes the given value according to the given typed array.

**Kind**: global function  
**Returns**: <code>number</code> - The denormalize (float) value in the range `[0,1]`.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to denormalize. |
| array | <code>TypedArray</code> | The typed array that defines the data type of the value. |

<a name="normalize"></a>

## normalize(value, array) ⇒ <code>number</code>
Normalizes the given value according to the given typed array.

**Kind**: global function  
**Returns**: <code>number</code> - The normalize value.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The float value in the range `[0,1]` to normalize. |
| array | <code>TypedArray</code> | The typed array that defines the data type of the value. |

<a name="Matrix3"></a>

## Matrix3
Represents a 3x3 matrix.

A Note on Row-Major and Column-Major Ordering:

The constructor and [set](#Matrix3+set) method take arguments in
[row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
order, while internally they are stored in the [elements](#Matrix3+elements) array in column-major order.
This means that calling:
```js
const m = new THREE.Matrix();
m.set( 11, 12, 13,
       21, 22, 23,
       31, 32, 33 );
```
will result in the elements array containing:
```js
m.elements = [ 11, 21, 31,
               12, 22, 32,
               13, 23, 33 ];
```
and internally all calculations are performed using column-major ordering.
However, as the actual ordering makes no difference mathematically and
most people are used to thinking about matrices in row-major order, the
three.js documentation shows matrices in row-major order. Just bear in
mind that if you are reading the source code, you'll have to take the
transpose of any matrices outlined here to make sense of the calculations.

**Kind**: global class  

* [Matrix3](#Matrix3)
    * [new Matrix3([n11], [n12], [n13], [n21], [n22], [n23], [n31], [n32], [n33])](#new_Matrix3_new)
    * [.isMatrix3](#Matrix3+isMatrix3) : <code>boolean</code>
    * [.elements](#Matrix3+elements) : <code>Array.&lt;number&gt;</code>
    * [.set([n11], [n12], [n13], [n21], [n22], [n23], [n31], [n32], [n33])](#Matrix3+set) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.identity()](#Matrix3+identity) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.copy(m)](#Matrix3+copy) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.extractBasis(xAxis, yAxis, zAxis)](#Matrix3+extractBasis) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.setFromMatrix4(m)](#Matrix3+setFromMatrix4) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.multiply(m)](#Matrix3+multiply) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.premultiply(m)](#Matrix3+premultiply) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.multiplyMatrices(a, b)](#Matrix3+multiplyMatrices) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.multiplyScalar(s)](#Matrix3+multiplyScalar) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.determinant()](#Matrix3+determinant) ⇒ <code>number</code>
    * [.invert()](#Matrix3+invert) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.transpose()](#Matrix3+transpose) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.getNormalMatrix(matrix4)](#Matrix3+getNormalMatrix) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.transposeIntoArray(r)](#Matrix3+transposeIntoArray) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.setUvTransform(tx, ty, sx, sy, rotation, cx, cy)](#Matrix3+setUvTransform) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.scale(sx, sy)](#Matrix3+scale) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.rotate(theta)](#Matrix3+rotate) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.translate(tx, ty)](#Matrix3+translate) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.makeTranslation(x, y)](#Matrix3+makeTranslation) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.makeRotation(theta)](#Matrix3+makeRotation) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.makeScale(x, y)](#Matrix3+makeScale) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.equals(matrix)](#Matrix3+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Matrix3+fromArray) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.toArray([array], [offset])](#Matrix3+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.clone()](#Matrix3+clone) ⇒ [<code>Matrix3</code>](#Matrix3)

<a name="new_Matrix3_new"></a>

### new Matrix3([n11], [n12], [n13], [n21], [n22], [n23], [n31], [n32], [n33])
Constructs a new 3x3 matrix. The arguments are supposed to be
in row-major order. If no arguments are provided, the constructor
initializes the matrix as an identity matrix.


| Param | Type | Description |
| --- | --- | --- |
| [n11] | <code>number</code> | 1-1 matrix element. |
| [n12] | <code>number</code> | 1-2 matrix element. |
| [n13] | <code>number</code> | 1-3 matrix element. |
| [n21] | <code>number</code> | 2-1 matrix element. |
| [n22] | <code>number</code> | 2-2 matrix element. |
| [n23] | <code>number</code> | 2-3 matrix element. |
| [n31] | <code>number</code> | 3-1 matrix element. |
| [n32] | <code>number</code> | 3-2 matrix element. |
| [n33] | <code>number</code> | 3-3 matrix element. |

<a name="Matrix3+isMatrix3"></a>

### matrix3.isMatrix3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Matrix3</code>](#Matrix3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Matrix3+elements"></a>

### matrix3.elements : <code>Array.&lt;number&gt;</code>
A column-major list of matrix values.

**Kind**: instance property of [<code>Matrix3</code>](#Matrix3)  
<a name="Matrix3+set"></a>

### matrix3.set([n11], [n12], [n13], [n21], [n22], [n23], [n31], [n32], [n33]) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets the elements of the matrix.The arguments are supposed to be
in row-major order.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| [n11] | <code>number</code> | 1-1 matrix element. |
| [n12] | <code>number</code> | 1-2 matrix element. |
| [n13] | <code>number</code> | 1-3 matrix element. |
| [n21] | <code>number</code> | 2-1 matrix element. |
| [n22] | <code>number</code> | 2-2 matrix element. |
| [n23] | <code>number</code> | 2-3 matrix element. |
| [n31] | <code>number</code> | 3-1 matrix element. |
| [n32] | <code>number</code> | 3-2 matrix element. |
| [n33] | <code>number</code> | 3-3 matrix element. |

<a name="Matrix3+identity"></a>

### matrix3.identity() ⇒ [<code>Matrix3</code>](#Matrix3)
Sets this matrix to the 3x3 identity matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  
<a name="Matrix3+copy"></a>

### matrix3.copy(m) ⇒ [<code>Matrix3</code>](#Matrix3)
Copies the values of the given matrix to this instance.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix3</code>](#Matrix3) | The matrix to copy. |

<a name="Matrix3+extractBasis"></a>

### matrix3.extractBasis(xAxis, yAxis, zAxis) ⇒ [<code>Matrix3</code>](#Matrix3)
Extracts the basis of this matrix into the three axis vectors provided.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| xAxis | <code>Vector3</code> | The basis's x axis. |
| yAxis | <code>Vector3</code> | The basis's y axis. |
| zAxis | <code>Vector3</code> | The basis's z axis. |

<a name="Matrix3+setFromMatrix4"></a>

### matrix3.setFromMatrix4(m) ⇒ [<code>Matrix3</code>](#Matrix3)
Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Matrix3+multiply"></a>

### matrix3.multiply(m) ⇒ [<code>Matrix3</code>](#Matrix3)
Post-multiplies this matrix by the given 3x3 matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix3</code>](#Matrix3) | The matrix to multiply with. |

<a name="Matrix3+premultiply"></a>

### matrix3.premultiply(m) ⇒ [<code>Matrix3</code>](#Matrix3)
Pre-multiplies this matrix by the given 3x3 matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix3</code>](#Matrix3) | The matrix to multiply with. |

<a name="Matrix3+multiplyMatrices"></a>

### matrix3.multiplyMatrices(a, b) ⇒ [<code>Matrix3</code>](#Matrix3)
Multiples the given 3x3 matrices and stores the result
in this matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Matrix3</code>](#Matrix3) | The first matrix. |
| b | [<code>Matrix3</code>](#Matrix3) | The second matrix. |

<a name="Matrix3+multiplyScalar"></a>

### matrix3.multiplyScalar(s) ⇒ [<code>Matrix3</code>](#Matrix3)
Multiplies every component of the matrix by the given scalar.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar. |

<a name="Matrix3+determinant"></a>

### matrix3.determinant() ⇒ <code>number</code>
Computes and returns the determinant of this matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: <code>number</code> - The determinant.  
<a name="Matrix3+invert"></a>

### matrix3.invert() ⇒ [<code>Matrix3</code>](#Matrix3)
Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
You can not invert with a determinant of zero. If you attempt this, the method produces
a zero matrix instead.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  
<a name="Matrix3+transpose"></a>

### matrix3.transpose() ⇒ [<code>Matrix3</code>](#Matrix3)
Transposes this matrix in place.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  
<a name="Matrix3+getNormalMatrix"></a>

### matrix3.getNormalMatrix(matrix4) ⇒ [<code>Matrix3</code>](#Matrix3)
Computes the normal matrix which is the inverse transpose of the upper
left 3x3 portion of the given 4x4 matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| matrix4 | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Matrix3+transposeIntoArray"></a>

### matrix3.transposeIntoArray(r) ⇒ [<code>Matrix3</code>](#Matrix3)
Transposes this matrix into the supplied array, and returns itself unchanged.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| r | <code>Array.&lt;number&gt;</code> | An array to store the transposed matrix elements. |

<a name="Matrix3+setUvTransform"></a>

### matrix3.setUvTransform(tx, ty, sx, sy, rotation, cx, cy) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets the UV transform matrix from offset, repeat, rotation, and center.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| tx | <code>number</code> | Offset x. |
| ty | <code>number</code> | Offset y. |
| sx | <code>number</code> | Repeat x. |
| sy | <code>number</code> | Repeat y. |
| rotation | <code>number</code> | Rotation, in radians. Positive values rotate counterclockwise. |
| cx | <code>number</code> | Center x of rotation. |
| cy | <code>number</code> | Center y of rotation |

<a name="Matrix3+scale"></a>

### matrix3.scale(sx, sy) ⇒ [<code>Matrix3</code>](#Matrix3)
Scales this matrix with the given scalar values.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| sx | <code>number</code> | The amount to scale in the X axis. |
| sy | <code>number</code> | The amount to scale in the Y axis. |

<a name="Matrix3+rotate"></a>

### matrix3.rotate(theta) ⇒ [<code>Matrix3</code>](#Matrix3)
Rotates this matrix by the given angle.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix3+translate"></a>

### matrix3.translate(tx, ty) ⇒ [<code>Matrix3</code>](#Matrix3)
Translates this matrix by the given scalar values.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| tx | <code>number</code> | The amount to translate in the X axis. |
| ty | <code>number</code> | The amount to translate in the Y axis. |

<a name="Matrix3+makeTranslation"></a>

### matrix3.makeTranslation(x, y) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets this matrix as a 2D translation transform.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector2</code> | The amount to translate in the X axis or alternatively a translation vector. |
| y | <code>number</code> | The amount to translate in the Y axis. |

<a name="Matrix3+makeRotation"></a>

### matrix3.makeRotation(theta) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets this matrix as a 2D rotational transformation.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix3+makeScale"></a>

### matrix3.makeScale(x, y) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets this matrix as a 2D scale transform.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The amount to scale in the X axis. |
| y | <code>number</code> | The amount to scale in the Y axis. |

<a name="Matrix3+equals"></a>

### matrix3.equals(matrix) ⇒ <code>boolean</code>
Returns `true` if this matrix is equal with the given one.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: <code>boolean</code> - Whether this matrix is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | [<code>Matrix3</code>](#Matrix3) | The matrix to test for equality. |

<a name="Matrix3+fromArray"></a>

### matrix3.fromArray(array, [offset]) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets the elements of the matrix from the given array.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | The matrix elements in column-major order. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Matrix3+toArray"></a>

### matrix3.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the elements of this matrix to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: <code>Array.&lt;number&gt;</code> - The matrix elements in column-major order.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the matrix elements in column-major order. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Matrix3+clone"></a>

### matrix3.clone() ⇒ [<code>Matrix3</code>](#Matrix3)
Returns a matrix with copied values from this instance.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A clone of this instance.  
<a name="Matrix4"></a>

## Matrix4
Represents a 4x4 matrix.

The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
For an introduction to transformation matrices as used in WebGL, check out [this tutorial](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices)

This allows a 3D vector representing a point in 3D space to undergo
transformations such as translation, rotation, shear, scale, reflection,
orthogonal or perspective projection and so on, by being multiplied by the
matrix. This is known as `applying` the matrix to the vector.

A Note on Row-Major and Column-Major Ordering:

The constructor and [Matrix3#set](Matrix3#set) method take arguments in
[row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
order, while internally they are stored in the [Matrix3#elements](Matrix3#elements) array in column-major order.
This means that calling:
```js
const m = new THREE.Matrix4();
m.set( 11, 12, 13, 14,
       21, 22, 23, 24,
       31, 32, 33, 34,
       41, 42, 43, 44 );
```
will result in the elements array containing:
```js
m.elements = [ 11, 21, 31, 41,
               12, 22, 32, 42,
               13, 23, 33, 43,
               14, 24, 34, 44 ];
```
and internally all calculations are performed using column-major ordering.
However, as the actual ordering makes no difference mathematically and
most people are used to thinking about matrices in row-major order, the
three.js documentation shows matrices in row-major order. Just bear in
mind that if you are reading the source code, you'll have to take the
transpose of any matrices outlined here to make sense of the calculations.

**Kind**: global class  

* [Matrix4](#Matrix4)
    * [new Matrix4([n11], [n12], [n13], [n14], [n21], [n22], [n23], [n24], [n31], [n32], [n33], [n34], [n41], [n42], [n43], [n44])](#new_Matrix4_new)
    * [.isMatrix4](#Matrix4+isMatrix4) : <code>boolean</code>
    * [.elements](#Matrix4+elements) : <code>Array.&lt;number&gt;</code>
    * [.set([n11], [n12], [n13], [n14], [n21], [n22], [n23], [n24], [n31], [n32], [n33], [n34], [n41], [n42], [n43], [n44])](#Matrix4+set) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.identity()](#Matrix4+identity) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.clone()](#Matrix4+clone) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.copy(m)](#Matrix4+copy) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.copyPosition(m)](#Matrix4+copyPosition) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.setFromMatrix3(m)](#Matrix4+setFromMatrix3) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.extractBasis(xAxis, yAxis, zAxis)](#Matrix4+extractBasis) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeBasis(xAxis, yAxis, zAxis)](#Matrix4+makeBasis) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.extractRotation(m)](#Matrix4+extractRotation) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationFromEuler(euler)](#Matrix4+makeRotationFromEuler) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationFromQuaternion(q)](#Matrix4+makeRotationFromQuaternion) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.lookAt(eye, target, up)](#Matrix4+lookAt) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.multiply(m)](#Matrix4+multiply) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.premultiply(m)](#Matrix4+premultiply) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.multiplyMatrices(a, b)](#Matrix4+multiplyMatrices) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.multiplyScalar(s)](#Matrix4+multiplyScalar) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.determinant()](#Matrix4+determinant) ⇒ <code>number</code>
    * [.transpose()](#Matrix4+transpose) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.setPosition(x, y, z)](#Matrix4+setPosition) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.invert()](#Matrix4+invert) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.scale(v)](#Matrix4+scale) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.getMaxScaleOnAxis()](#Matrix4+getMaxScaleOnAxis) ⇒ <code>number</code>
    * [.makeTranslation(x, y, z)](#Matrix4+makeTranslation) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationX(theta)](#Matrix4+makeRotationX) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationY(theta)](#Matrix4+makeRotationY) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationZ(theta)](#Matrix4+makeRotationZ) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationAxis(axis, angle)](#Matrix4+makeRotationAxis) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeScale(x, y, z)](#Matrix4+makeScale) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeShear(xy, xz, yx, yz, zx, zy)](#Matrix4+makeShear) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.compose(position, quaternion, scale)](#Matrix4+compose) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.decompose(position, quaternion, scale)](#Matrix4+decompose) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makePerspective(left, right, top, bottom, near, far, [coordinateSystem])](#Matrix4+makePerspective) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeOrthographic(left, right, top, bottom, near, far, [coordinateSystem])](#Matrix4+makeOrthographic) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.equals(matrix)](#Matrix4+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Matrix4+fromArray) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.toArray([array], [offset])](#Matrix4+toArray) ⇒ <code>Array.&lt;number&gt;</code>

<a name="new_Matrix4_new"></a>

### new Matrix4([n11], [n12], [n13], [n14], [n21], [n22], [n23], [n24], [n31], [n32], [n33], [n34], [n41], [n42], [n43], [n44])
Constructs a new 4x4 matrix. The arguments are supposed to be
in row-major order. If no arguments are provided, the constructor
initializes the matrix as an identity matrix.


| Param | Type | Description |
| --- | --- | --- |
| [n11] | <code>number</code> | 1-1 matrix element. |
| [n12] | <code>number</code> | 1-2 matrix element. |
| [n13] | <code>number</code> | 1-3 matrix element. |
| [n14] | <code>number</code> | 1-4 matrix element. |
| [n21] | <code>number</code> | 2-1 matrix element. |
| [n22] | <code>number</code> | 2-2 matrix element. |
| [n23] | <code>number</code> | 2-3 matrix element. |
| [n24] | <code>number</code> | 2-4 matrix element. |
| [n31] | <code>number</code> | 3-1 matrix element. |
| [n32] | <code>number</code> | 3-2 matrix element. |
| [n33] | <code>number</code> | 3-3 matrix element. |
| [n34] | <code>number</code> | 3-4 matrix element. |
| [n41] | <code>number</code> | 4-1 matrix element. |
| [n42] | <code>number</code> | 4-2 matrix element. |
| [n43] | <code>number</code> | 4-3 matrix element. |
| [n44] | <code>number</code> | 4-4 matrix element. |

<a name="Matrix4+isMatrix4"></a>

### matrix4.isMatrix4 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Matrix4</code>](#Matrix4)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Matrix4+elements"></a>

### matrix4.elements : <code>Array.&lt;number&gt;</code>
A column-major list of matrix values.

**Kind**: instance property of [<code>Matrix4</code>](#Matrix4)  
<a name="Matrix4+set"></a>

### matrix4.set([n11], [n12], [n13], [n14], [n21], [n22], [n23], [n24], [n31], [n32], [n33], [n34], [n41], [n42], [n43], [n44]) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the elements of the matrix.The arguments are supposed to be
in row-major order.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| [n11] | <code>number</code> | 1-1 matrix element. |
| [n12] | <code>number</code> | 1-2 matrix element. |
| [n13] | <code>number</code> | 1-3 matrix element. |
| [n14] | <code>number</code> | 1-4 matrix element. |
| [n21] | <code>number</code> | 2-1 matrix element. |
| [n22] | <code>number</code> | 2-2 matrix element. |
| [n23] | <code>number</code> | 2-3 matrix element. |
| [n24] | <code>number</code> | 2-4 matrix element. |
| [n31] | <code>number</code> | 3-1 matrix element. |
| [n32] | <code>number</code> | 3-2 matrix element. |
| [n33] | <code>number</code> | 3-3 matrix element. |
| [n34] | <code>number</code> | 3-4 matrix element. |
| [n41] | <code>number</code> | 4-1 matrix element. |
| [n42] | <code>number</code> | 4-2 matrix element. |
| [n43] | <code>number</code> | 4-3 matrix element. |
| [n44] | <code>number</code> | 4-4 matrix element. |

<a name="Matrix4+identity"></a>

### matrix4.identity() ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix to the 4x4 identity matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  
<a name="Matrix4+clone"></a>

### matrix4.clone() ⇒ [<code>Matrix4</code>](#Matrix4)
Returns a matrix with copied values from this instance.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A clone of this instance.  
<a name="Matrix4+copy"></a>

### matrix4.copy(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Copies the values of the given matrix to this instance.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix to copy. |

<a name="Matrix4+copyPosition"></a>

### matrix4.copyPosition(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Copies the translation component of the given matrix
into this matrix's translation component.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix to copy the translation component. |

<a name="Matrix4+setFromMatrix3"></a>

### matrix4.setFromMatrix3(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The 3x3 matrix. |

<a name="Matrix4+extractBasis"></a>

### matrix4.extractBasis(xAxis, yAxis, zAxis) ⇒ [<code>Matrix4</code>](#Matrix4)
Extracts the basis of this matrix into the three axis vectors provided.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| xAxis | <code>Vector3</code> | The basis's x axis. |
| yAxis | <code>Vector3</code> | The basis's y axis. |
| zAxis | <code>Vector3</code> | The basis's z axis. |

<a name="Matrix4+makeBasis"></a>

### matrix4.makeBasis(xAxis, yAxis, zAxis) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the given basis vectors to this matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| xAxis | <code>Vector3</code> | The basis's x axis. |
| yAxis | <code>Vector3</code> | The basis's y axis. |
| zAxis | <code>Vector3</code> | The basis's z axis. |

<a name="Matrix4+extractRotation"></a>

### matrix4.extractRotation(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Extracts the rotation component of the given matrix
into this matrix's rotation component.

Note: This method does not support reflection matrices.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix. |

<a name="Matrix4+makeRotationFromEuler"></a>

### matrix4.makeRotationFromEuler(euler) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the rotation component (the upper left 3x3 matrix) of this matrix to
the rotation specified by the given Euler angles. The rest of
the matrix is set to the identity. Depending on the [Euler#order](Euler#order),
there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
for a complete list.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| euler | <code>Euler</code> | The Euler angles. |

<a name="Matrix4+makeRotationFromQuaternion"></a>

### matrix4.makeRotationFromQuaternion(q) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the rotation component of this matrix to the rotation specified by
the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
The rest of the matrix is set to the identity.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The Quaternion. |

<a name="Matrix4+lookAt"></a>

### matrix4.lookAt(eye, target, up) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the rotation component of the transformation matrix, looking from `eye` towards
`target`, and oriented by the up-direction.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| eye | <code>Vector3</code> | The eye vector. |
| target | <code>Vector3</code> | The target vector. |
| up | <code>Vector3</code> | The up vector. |

<a name="Matrix4+multiply"></a>

### matrix4.multiply(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Post-multiplies this matrix by the given 4x4 matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix to multiply with. |

<a name="Matrix4+premultiply"></a>

### matrix4.premultiply(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Pre-multiplies this matrix by the given 4x4 matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix to multiply with. |

<a name="Matrix4+multiplyMatrices"></a>

### matrix4.multiplyMatrices(a, b) ⇒ [<code>Matrix4</code>](#Matrix4)
Multiples the given 4x4 matrices and stores the result
in this matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Matrix4</code>](#Matrix4) | The first matrix. |
| b | [<code>Matrix4</code>](#Matrix4) | The second matrix. |

<a name="Matrix4+multiplyScalar"></a>

### matrix4.multiplyScalar(s) ⇒ [<code>Matrix4</code>](#Matrix4)
Multiplies every component of the matrix by the given scalar.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar. |

<a name="Matrix4+determinant"></a>

### matrix4.determinant() ⇒ <code>number</code>
Computes and returns the determinant of this matrix.

Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: <code>number</code> - The determinant.  
<a name="Matrix4+transpose"></a>

### matrix4.transpose() ⇒ [<code>Matrix4</code>](#Matrix4)
Transposes this matrix in place.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  
<a name="Matrix4+setPosition"></a>

### matrix4.setPosition(x, y, z) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the position component for this matrix from the given vector,
without affecting the rest of the matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector3</code> | The x component of the vector or alternatively the vector object. |
| y | <code>number</code> | The y component of the vector. |
| z | <code>number</code> | The z component of the vector. |

<a name="Matrix4+invert"></a>

### matrix4.invert() ⇒ [<code>Matrix4</code>](#Matrix4)
Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
You can not invert with a determinant of zero. If you attempt this, the method produces
a zero matrix instead.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  
<a name="Matrix4+scale"></a>

### matrix4.scale(v) ⇒ [<code>Matrix4</code>](#Matrix4)
Multiplies the columns of this matrix by the given vector.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The scale vector. |

<a name="Matrix4+getMaxScaleOnAxis"></a>

### matrix4.getMaxScaleOnAxis() ⇒ <code>number</code>
Gets the maximum scale value of the three axes.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: <code>number</code> - The maximum scale.  
<a name="Matrix4+makeTranslation"></a>

### matrix4.makeTranslation(x, y, z) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a translation transform from the given vector.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector3</code> | The amount to translate in the X axis or alternatively a translation vector. |
| y | <code>number</code> | The amount to translate in the Y axis. |
| z | <code>number</code> | The amount to translate in the z axis. |

<a name="Matrix4+makeRotationX"></a>

### matrix4.makeRotationX(theta) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a rotational transformation around the X axis by
the given angle.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix4+makeRotationY"></a>

### matrix4.makeRotationY(theta) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a rotational transformation around the Y axis by
the given angle.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix4+makeRotationZ"></a>

### matrix4.makeRotationZ(theta) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a rotational transformation around the Z axis by
the given angle.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix4+makeRotationAxis"></a>

### matrix4.makeRotationAxis(axis, angle) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a rotational transformation around the given axis by
the given angle.

This is a somewhat controversial but mathematically sound alternative to
rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>Vector3</code> | The normalized rotation axis. |
| angle | <code>number</code> | The rotation in radians. |

<a name="Matrix4+makeScale"></a>

### matrix4.makeScale(x, y, z) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a scale transformation.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The amount to scale in the X axis. |
| y | <code>number</code> | The amount to scale in the Y axis. |
| z | <code>number</code> | The amount to scale in the Z axis. |

<a name="Matrix4+makeShear"></a>

### matrix4.makeShear(xy, xz, yx, yz, zx, zy) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a shear transformation.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| xy | <code>number</code> | The amount to shear X by Y. |
| xz | <code>number</code> | The amount to shear X by Z. |
| yx | <code>number</code> | The amount to shear Y by X. |
| yz | <code>number</code> | The amount to shear Y by Z. |
| zx | <code>number</code> | The amount to shear Z by X. |
| zy | <code>number</code> | The amount to shear Z by Y. |

<a name="Matrix4+compose"></a>

### matrix4.compose(position, quaternion, scale) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix to the transformation composed of the given position,
rotation (Quaternion) and scale.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Vector3</code> | The position vector. |
| quaternion | <code>Quaternion</code> | The rotation as a Quaternion. |
| scale | <code>Vector3</code> | The scale vector. |

<a name="Matrix4+decompose"></a>

### matrix4.decompose(position, quaternion, scale) ⇒ [<code>Matrix4</code>](#Matrix4)
Decomposes this matrix into its position, rotation and scale components
and provides the result in the given objects.

Note: Not all matrices are decomposable in this way. For example, if an
object has a non-uniformly scaled parent, then the object's world matrix
may not be decomposable, and this method may not be appropriate.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Vector3</code> | The position vector. |
| quaternion | <code>Quaternion</code> | The rotation as a Quaternion. |
| scale | <code>Vector3</code> | The scale vector. |

<a name="Matrix4+makePerspective"></a>

### matrix4.makePerspective(left, right, top, bottom, near, far, [coordinateSystem]) ⇒ [<code>Matrix4</code>](#Matrix4)
Creates a perspective projection matrix. This is used internally by
[PerspectiveCamera#updateProjectionMatrix](PerspectiveCamera#updateProjectionMatrix).

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| left | <code>number</code> |  | Left boundary of the viewing frustum at the near plane. |
| right | <code>number</code> |  | Right boundary of the viewing frustum at the near plane. |
| top | <code>number</code> |  | Top boundary of the viewing frustum at the near plane. |
| bottom | <code>number</code> |  | Bottom boundary of the viewing frustum at the near plane. |
| near | <code>number</code> |  | The distance from the camera to the near plane. |
| far | <code>number</code> |  | The distance from the camera to the far plane. |
| [coordinateSystem] | <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code> | <code>WebGLCoordinateSystem</code> | The coordinate system. |

<a name="Matrix4+makeOrthographic"></a>

### matrix4.makeOrthographic(left, right, top, bottom, near, far, [coordinateSystem]) ⇒ [<code>Matrix4</code>](#Matrix4)
Creates a orthographic projection matrix. This is used internally by
[OrthographicCamera#updateProjectionMatrix](OrthographicCamera#updateProjectionMatrix).

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| left | <code>number</code> |  | Left boundary of the viewing frustum at the near plane. |
| right | <code>number</code> |  | Right boundary of the viewing frustum at the near plane. |
| top | <code>number</code> |  | Top boundary of the viewing frustum at the near plane. |
| bottom | <code>number</code> |  | Bottom boundary of the viewing frustum at the near plane. |
| near | <code>number</code> |  | The distance from the camera to the near plane. |
| far | <code>number</code> |  | The distance from the camera to the far plane. |
| [coordinateSystem] | <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code> | <code>WebGLCoordinateSystem</code> | The coordinate system. |

<a name="Matrix4+equals"></a>

### matrix4.equals(matrix) ⇒ <code>boolean</code>
Returns `true` if this matrix is equal with the given one.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: <code>boolean</code> - Whether this matrix is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | [<code>Matrix4</code>](#Matrix4) | The matrix to test for equality. |

<a name="Matrix4+fromArray"></a>

### matrix4.fromArray(array, [offset]) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the elements of the matrix from the given array.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | The matrix elements in column-major order. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Matrix4+toArray"></a>

### matrix4.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the elements of this matrix to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: <code>Array.&lt;number&gt;</code> - The matrix elements in column-major order.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the matrix elements in column-major order. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Plane"></a>

## Plane
A two dimensional surface that extends infinitely in 3D space, represented
in [Hessian normal form](http://mathworld.wolfram.com/HessianNormalForm.html)
by a unit length normal vector and a constant.

**Kind**: global class  

* [Plane](#Plane)
    * [new Plane([normal], [constant])](#new_Plane_new)
    * [.isPlane](#Plane+isPlane) : <code>boolean</code>
    * [.normal](#Plane+normal) : <code>Vector3</code>
    * [.constant](#Plane+constant) : <code>number</code>
    * [.set(normal, constant)](#Plane+set) ⇒ [<code>Plane</code>](#Plane)
    * [.setComponents(x, y, z, w)](#Plane+setComponents) ⇒ [<code>Plane</code>](#Plane)
    * [.setFromNormalAndCoplanarPoint(normal, point)](#Plane+setFromNormalAndCoplanarPoint) ⇒ [<code>Plane</code>](#Plane)
    * [.setFromCoplanarPoints(a, b, c)](#Plane+setFromCoplanarPoints) ⇒ [<code>Plane</code>](#Plane)
    * [.copy(plane)](#Plane+copy) ⇒ [<code>Plane</code>](#Plane)
    * [.normalize()](#Plane+normalize) ⇒ [<code>Plane</code>](#Plane)
    * [.negate()](#Plane+negate) ⇒ [<code>Plane</code>](#Plane)
    * [.distanceToPoint(point)](#Plane+distanceToPoint) ⇒ <code>number</code>
    * [.distanceToSphere(sphere)](#Plane+distanceToSphere) ⇒ <code>number</code>
    * [.projectPoint(point, target)](#Plane+projectPoint) ⇒ <code>Vector3</code>
    * [.intersectLine(line, target)](#Plane+intersectLine) ⇒ <code>Vector3</code>
    * [.intersectsLine(line)](#Plane+intersectsLine) ⇒ <code>boolean</code>
    * [.intersectsBox(box)](#Plane+intersectsBox) ⇒ <code>boolean</code>
    * [.intersectsSphere(sphere)](#Plane+intersectsSphere) ⇒ <code>boolean</code>
    * [.coplanarPoint(target)](#Plane+coplanarPoint) ⇒ <code>Vector3</code>
    * [.applyMatrix4(matrix, [optionalNormalMatrix])](#Plane+applyMatrix4) ⇒ [<code>Plane</code>](#Plane)
    * [.translate(offset)](#Plane+translate) ⇒ [<code>Plane</code>](#Plane)
    * [.equals(plane)](#Plane+equals) ⇒ <code>boolean</code>
    * [.clone()](#Plane+clone) ⇒ [<code>Plane</code>](#Plane)

<a name="new_Plane_new"></a>

### new Plane([normal], [constant])
Constructs a new plane.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [normal] | <code>Vector3</code> | <code>(1,0,0)</code> | A unit length vector defining the normal of the plane. |
| [constant] | <code>number</code> | <code>0</code> | The signed distance from the origin to the plane. |

<a name="Plane+isPlane"></a>

### plane.isPlane : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Plane</code>](#Plane)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Plane+normal"></a>

### plane.normal : <code>Vector3</code>
A unit length vector defining the normal of the plane.

**Kind**: instance property of [<code>Plane</code>](#Plane)  
<a name="Plane+constant"></a>

### plane.constant : <code>number</code>
The signed distance from the origin to the plane.

**Kind**: instance property of [<code>Plane</code>](#Plane)  
**Default**: <code>0</code>  
<a name="Plane+set"></a>

### plane.set(normal, constant) ⇒ [<code>Plane</code>](#Plane)
Sets the plane components by copying the given values.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal. |
| constant | <code>number</code> | The constant. |

<a name="Plane+setComponents"></a>

### plane.setComponents(x, y, z, w) ⇒ [<code>Plane</code>](#Plane)
Sets the plane components by defining `x`, `y`, `z` as the
plane normal and `w` as the constant.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value for the normal's x component. |
| y | <code>number</code> | The value for the normal's y component. |
| z | <code>number</code> | The value for the normal's z component. |
| w | <code>number</code> | The constant value. |

<a name="Plane+setFromNormalAndCoplanarPoint"></a>

### plane.setFromNormalAndCoplanarPoint(normal, point) ⇒ [<code>Plane</code>](#Plane)
Sets the plane from the given normal and coplanar point (that is a point
that lies onto the plane).

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal. |
| point | <code>Vector3</code> | A coplanar point. |

<a name="Plane+setFromCoplanarPoints"></a>

### plane.setFromCoplanarPoints(a, b, c) ⇒ [<code>Plane</code>](#Plane)
Sets the plane from three coplanar points. The winding order is
assumed to be counter-clockwise, and determines the direction of
the plane normal.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first coplanar point. |
| b | <code>Vector3</code> | The second coplanar point. |
| c | <code>Vector3</code> | The third coplanar point. |

<a name="Plane+copy"></a>

### plane.copy(plane) ⇒ [<code>Plane</code>](#Plane)
Copies the values of the given plane to this instance.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| plane | [<code>Plane</code>](#Plane) | The plane to copy. |

<a name="Plane+normalize"></a>

### plane.normalize() ⇒ [<code>Plane</code>](#Plane)
Normalizes the plane normal and adjusts the constant accordingly.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  
<a name="Plane+negate"></a>

### plane.negate() ⇒ [<code>Plane</code>](#Plane)
Negates both the plane normal and the constant.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  
<a name="Plane+distanceToPoint"></a>

### plane.distanceToPoint(point) ⇒ <code>number</code>
Returns the signed distance from the given point to this plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>number</code> - The signed distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to compute the distance for. |

<a name="Plane+distanceToSphere"></a>

### plane.distanceToSphere(sphere) ⇒ <code>number</code>
Returns the signed distance from the given sphere to this plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>number</code> - The signed distance.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to compute the distance for. |

<a name="Plane+projectPoint"></a>

### plane.projectPoint(point, target) ⇒ <code>Vector3</code>
Projects a the given point onto the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>Vector3</code> - The projected point on the plane.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to project. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Plane+intersectLine"></a>

### plane.intersectLine(line, target) ⇒ <code>Vector3</code>
Returns the intersection point of the passed line and the plane. Returns
`null` if the line does not intersect. Returns the line's starting point if
the line is coplanar with the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| line | <code>Line3</code> | The line to compute the intersection for. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Plane+intersectsLine"></a>

### plane.intersectsLine(line) ⇒ <code>boolean</code>
Returns `true` if the given line segment intersects with (passes through) the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>boolean</code> - Whether the given line segment intersects with the plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| line | <code>Line3</code> | The line to test. |

<a name="Plane+intersectsBox"></a>

### plane.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box intersects with the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>boolean</code> - Whether the given bounding box intersects with the plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The bounding box to test. |

<a name="Plane+intersectsSphere"></a>

### plane.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if the given bounding sphere intersects with the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>boolean</code> - Whether the given bounding sphere intersects with the plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="Plane+coplanarPoint"></a>

### plane.coplanarPoint(target) ⇒ <code>Vector3</code>
Returns a coplanar vector to the plane, by calculating the
projection of the normal at the origin onto the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>Vector3</code> - The coplanar point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Plane+applyMatrix4"></a>

### plane.applyMatrix4(matrix, [optionalNormalMatrix]) ⇒ [<code>Plane</code>](#Plane)
Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.

The optional normal matrix can be pre-computed like so:
```js
const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
```

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |
| [optionalNormalMatrix] | <code>Matrix4</code> | A pre-computed normal matrix. |

<a name="Plane+translate"></a>

### plane.translate(offset) ⇒ [<code>Plane</code>](#Plane)
Translates the plane by the distance defined by the given offset vector.
Note that this only affects the plane constant and will not affect the normal vector.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| offset | <code>Vector3</code> | The offset vector. |

<a name="Plane+equals"></a>

### plane.equals(plane) ⇒ <code>boolean</code>
Returns `true` if this plane is equal with the given one.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>boolean</code> - Whether this plane is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| plane | [<code>Plane</code>](#Plane) | The plane to test for equality. |

<a name="Plane+clone"></a>

### plane.clone() ⇒ [<code>Plane</code>](#Plane)
Returns a new plane with copied values from this instance.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A clone of this instance.  
<a name="Quaternion"></a>

## Quaternion
Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.

Iterating through a vector instance will yield its components `(x, y, z, w)` in
the corresponding order.

Note that three.js expects Quaternions to be normalized.
```js
const quaternion = new THREE.Quaternion();
quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );

const vector = new THREE.Vector3( 1, 0, 0 );
vector.applyQuaternion( quaternion );
```

**Kind**: global class  

* [Quaternion](#Quaternion)
    * [new Quaternion([x], [y], [z], [w])](#new_Quaternion_new)
    * _instance_
        * [.isQuaternion](#Quaternion+isQuaternion) : <code>boolean</code>
        * [.x](#Quaternion+x) : <code>number</code>
        * [.y](#Quaternion+y) : <code>number</code>
        * [.z](#Quaternion+z) : <code>number</code>
        * [.w](#Quaternion+w) : <code>number</code>
        * [.set(x, y, z, w)](#Quaternion+set) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.clone()](#Quaternion+clone) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.copy(quaternion)](#Quaternion+copy) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.setFromEuler(euler, [update])](#Quaternion+setFromEuler) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.setFromAxisAngle(axis, angle)](#Quaternion+setFromAxisAngle) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.setFromRotationMatrix(m)](#Quaternion+setFromRotationMatrix) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.setFromUnitVectors(vFrom, vTo)](#Quaternion+setFromUnitVectors) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.angleTo(q)](#Quaternion+angleTo) ⇒ <code>number</code>
        * [.rotateTowards(q, step)](#Quaternion+rotateTowards) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.identity()](#Quaternion+identity) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.invert()](#Quaternion+invert) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.conjugate()](#Quaternion+conjugate) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.dot(v)](#Quaternion+dot) ⇒ <code>number</code>
        * [.lengthSq()](#Quaternion+lengthSq) ⇒ <code>number</code>
        * [.length()](#Quaternion+length) ⇒ <code>number</code>
        * [.normalize()](#Quaternion+normalize) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.multiply(q)](#Quaternion+multiply) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.premultiply(q)](#Quaternion+premultiply) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.multiplyQuaternions(a, b)](#Quaternion+multiplyQuaternions) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.slerp(qb, t)](#Quaternion+slerp) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.slerpQuaternions(qa, qb, t)](#Quaternion+slerpQuaternions) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.random()](#Quaternion+random) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.equals(quaternion)](#Quaternion+equals) ⇒ <code>boolean</code>
        * [.fromArray(array, [offset])](#Quaternion+fromArray) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.toArray([array], [offset])](#Quaternion+toArray) ⇒ <code>Array.&lt;number&gt;</code>
        * [.fromBufferAttribute(attribute, index)](#Quaternion+fromBufferAttribute) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.toJSON()](#Quaternion+toJSON) ⇒ <code>Array.&lt;number&gt;</code>
    * _static_
        * [.slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t)](#Quaternion.slerpFlat)
        * [.multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1)](#Quaternion.multiplyQuaternionsFlat) ⇒ <code>Array.&lt;number&gt;</code>

<a name="new_Quaternion_new"></a>

### new Quaternion([x], [y], [z], [w])
Constructs a new quaternion.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The x value of this quaternion. |
| [y] | <code>number</code> | <code>0</code> | The y value of this quaternion. |
| [z] | <code>number</code> | <code>0</code> | The z value of this quaternion. |
| [w] | <code>number</code> | <code>1</code> | The w value of this quaternion. |

<a name="Quaternion+isQuaternion"></a>

### quaternion.isQuaternion : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Quaternion+x"></a>

### quaternion.x : <code>number</code>
The x value of this quaternion.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>0</code>  
<a name="Quaternion+y"></a>

### quaternion.y : <code>number</code>
The y value of this quaternion.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>0</code>  
<a name="Quaternion+z"></a>

### quaternion.z : <code>number</code>
The z value of this quaternion.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>0</code>  
<a name="Quaternion+w"></a>

### quaternion.w : <code>number</code>
The w value of this quaternion.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>1</code>  
<a name="Quaternion+set"></a>

### quaternion.set(x, y, z, w) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets the quaternion components.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value of this quaternion. |
| y | <code>number</code> | The y value of this quaternion. |
| z | <code>number</code> | The z value of this quaternion. |
| w | <code>number</code> | The w value of this quaternion. |

<a name="Quaternion+clone"></a>

### quaternion.clone() ⇒ [<code>Quaternion</code>](#Quaternion)
Returns a new quaternion with copied values from this instance.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A clone of this instance.  
<a name="Quaternion+copy"></a>

### quaternion.copy(quaternion) ⇒ [<code>Quaternion</code>](#Quaternion)
Copies the values of the given quaternion to this instance.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| quaternion | [<code>Quaternion</code>](#Quaternion) | The quaternion to copy. |

<a name="Quaternion+setFromEuler"></a>

### quaternion.setFromEuler(euler, [update]) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion from the rotation specified by the given
Euler angles.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| euler | <code>Euler</code> |  | The Euler angles. |
| [update] | <code>boolean</code> | <code>true</code> | Whether the internal `onChange` callback should be executed or not. |

<a name="Quaternion+setFromAxisAngle"></a>

### quaternion.setFromAxisAngle(axis, angle) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion from the given axis and angle.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>Vector3</code> | The normalized axis. |
| angle | <code>number</code> | The angle in radians. |

<a name="Quaternion+setFromRotationMatrix"></a>

### quaternion.setFromRotationMatrix(m) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion from the given rotation matrix.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled). |

<a name="Quaternion+setFromUnitVectors"></a>

### quaternion.setFromUnitVectors(vFrom, vTo) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion to the rotation required to rotate the direction vector
`vFrom` to the direction vector `vTo`.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| vFrom | <code>Vector3</code> | The first (normalized) direction vector. |
| vTo | <code>Vector3</code> | The second (normalized) direction vector. |

<a name="Quaternion+angleTo"></a>

### quaternion.angleTo(q) ⇒ <code>number</code>
Returns the angle between this quaternion and the given one in radians.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>number</code> - The angle in radians.  

| Param | Type | Description |
| --- | --- | --- |
| q | [<code>Quaternion</code>](#Quaternion) | The quaternion to compute the angle with. |

<a name="Quaternion+rotateTowards"></a>

### quaternion.rotateTowards(q, step) ⇒ [<code>Quaternion</code>](#Quaternion)
Rotates this quaternion by a given angular step to the given quaternion.
The method ensures that the final quaternion will not overshoot `q`.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| q | [<code>Quaternion</code>](#Quaternion) | The target quaternion. |
| step | <code>number</code> | The angular step in radians. |

<a name="Quaternion+identity"></a>

### quaternion.identity() ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion to the identity quaternion; that is, to the
quaternion that represents "no rotation".

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+invert"></a>

### quaternion.invert() ⇒ [<code>Quaternion</code>](#Quaternion)
Inverts this quaternion via [conjugate](#Quaternion+conjugate). The
quaternion is assumed to have unit length.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+conjugate"></a>

### quaternion.conjugate() ⇒ [<code>Quaternion</code>](#Quaternion)
Returns the rotational conjugate of this quaternion. The conjugate of a
quaternion represents the same rotation in the opposite direction about
the rotational axis.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+dot"></a>

### quaternion.dot(v) ⇒ <code>number</code>
Calculates the dot product of this quaternion and the given one.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>number</code> - The result of the dot product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Quaternion</code>](#Quaternion) | The quaternion to compute the dot product with. |

<a name="Quaternion+lengthSq"></a>

### quaternion.lengthSq() ⇒ <code>number</code>
Computes the squared Euclidean length (straight-line length) of this quaternion,
considered as a 4 dimensional vector. This can be useful if you are comparing the
lengths of two quaternions, as this is a slightly more efficient calculation than
[length](#Quaternion+length).

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>number</code> - The squared Euclidean length.  
<a name="Quaternion+length"></a>

### quaternion.length() ⇒ <code>number</code>
Computes the Euclidean length (straight-line length) of this quaternion,
considered as a 4 dimensional vector.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>number</code> - The Euclidean length.  
<a name="Quaternion+normalize"></a>

### quaternion.normalize() ⇒ [<code>Quaternion</code>](#Quaternion)
Normalizes this quaternion - that is, calculated the quaternion that performs
the same rotation as this one, but has a length equal to `1`.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+multiply"></a>

### quaternion.multiply(q) ⇒ [<code>Quaternion</code>](#Quaternion)
Multiplies this quaternion by the given one.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| q | [<code>Quaternion</code>](#Quaternion) | The quaternion. |

<a name="Quaternion+premultiply"></a>

### quaternion.premultiply(q) ⇒ [<code>Quaternion</code>](#Quaternion)
Pre-multiplies this quaternion by the given one.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| q | [<code>Quaternion</code>](#Quaternion) | The quaternion. |

<a name="Quaternion+multiplyQuaternions"></a>

### quaternion.multiplyQuaternions(a, b) ⇒ [<code>Quaternion</code>](#Quaternion)
Multiplies the given quaternions and stores the result in this instance.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Quaternion</code>](#Quaternion) | The first quaternion. |
| b | [<code>Quaternion</code>](#Quaternion) | The second quaternion. |

<a name="Quaternion+slerp"></a>

### quaternion.slerp(qb, t) ⇒ [<code>Quaternion</code>](#Quaternion)
Performs a spherical linear interpolation between quaternions.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| qb | [<code>Quaternion</code>](#Quaternion) | The target quaternion. |
| t | <code>number</code> | The interpolation factor in the closed interval `[0, 1]`. |

<a name="Quaternion+slerpQuaternions"></a>

### quaternion.slerpQuaternions(qa, qb, t) ⇒ [<code>Quaternion</code>](#Quaternion)
Performs a spherical linear interpolation between the given quaternions
and stores the result in this quaternion.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| qa | [<code>Quaternion</code>](#Quaternion) | The source quaternion. |
| qb | [<code>Quaternion</code>](#Quaternion) | The target quaternion. |
| t | <code>number</code> | The interpolation factor in the closed interval `[0, 1]`. |

<a name="Quaternion+random"></a>

### quaternion.random() ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion to a uniformly random, normalized quaternion.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+equals"></a>

### quaternion.equals(quaternion) ⇒ <code>boolean</code>
Returns `true` if this quaternion is equal with the given one.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>boolean</code> - Whether this quaternion is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| quaternion | [<code>Quaternion</code>](#Quaternion) | The quaternion to test for equality. |

<a name="Quaternion+fromArray"></a>

### quaternion.fromArray(array, [offset]) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion's components from the given array.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the quaternion component values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Quaternion+toArray"></a>

### quaternion.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the components of this quaternion to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>Array.&lt;number&gt;</code> - The quaternion components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the quaternion components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Quaternion+fromBufferAttribute"></a>

### quaternion.fromBufferAttribute(attribute, index) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets the components of this quaternion from the given buffer attribute.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding quaternion data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Quaternion+toJSON"></a>

### quaternion.toJSON() ⇒ <code>Array.&lt;number&gt;</code>
This methods defines the serialization result of this class. Returns the
numerical elements of this quaternion in an array of format `[x, y, z, w]`.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>Array.&lt;number&gt;</code> - The serialized quaternion.  
<a name="Quaternion.slerpFlat"></a>

### Quaternion.slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t)
Interpolates between two quaternions via SLERP. This implementation assumes the
quaternion data are managed  in flat arrays.

**Kind**: static method of [<code>Quaternion</code>](#Quaternion)  
**See**: [slerp](#Quaternion+slerp)  

| Param | Type | Description |
| --- | --- | --- |
| dst | <code>Array.&lt;number&gt;</code> | The destination array. |
| dstOffset | <code>number</code> | An offset into the destination array. |
| src0 | <code>Array.&lt;number&gt;</code> | The source array of the first quaternion. |
| srcOffset0 | <code>number</code> | An offset into the first source array. |
| src1 | <code>Array.&lt;number&gt;</code> | The source array of the second quaternion. |
| srcOffset1 | <code>number</code> | An offset into the second source array. |
| t | <code>number</code> | The interpolation factor in the range `[0,1]`. |

<a name="Quaternion.multiplyQuaternionsFlat"></a>

### Quaternion.multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) ⇒ <code>Array.&lt;number&gt;</code>
Multiplies two quaternions. This implementation assumes the quaternion data are managed
in flat arrays.

**Kind**: static method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>Array.&lt;number&gt;</code> - The destination array.  
**See**: [multiplyQuaternions](#Quaternion+multiplyQuaternions).  

| Param | Type | Description |
| --- | --- | --- |
| dst | <code>Array.&lt;number&gt;</code> | The destination array. |
| dstOffset | <code>number</code> | An offset into the destination array. |
| src0 | <code>Array.&lt;number&gt;</code> | The source array of the first quaternion. |
| srcOffset0 | <code>number</code> | An offset into the first source array. |
| src1 | <code>Array.&lt;number&gt;</code> | The source array of the second quaternion. |
| srcOffset1 | <code>number</code> | An offset into the second source array. |

<a name="Ray"></a>

## Ray
A ray that emits from an origin in a certain direction. The class is used by
[Raycaster](Raycaster) to assist with raycasting. Raycasting is used for
mouse picking (working out what objects in the 3D space the mouse is over)
amongst other things.

**Kind**: global class  

* [Ray](#Ray)
    * [new Ray([origin], [direction])](#new_Ray_new)
    * [.origin](#Ray+origin) : <code>Vector3</code>
    * [.direction](#Ray+direction) : <code>Vector3</code>
    * [.set(origin, direction)](#Ray+set) ⇒ [<code>Ray</code>](#Ray)
    * [.copy(ray)](#Ray+copy) ⇒ [<code>Ray</code>](#Ray)
    * [.at(t, target)](#Ray+at) ⇒ <code>Vector3</code>
    * [.lookAt(v)](#Ray+lookAt) ⇒ [<code>Ray</code>](#Ray)
    * [.recast(t)](#Ray+recast) ⇒ [<code>Ray</code>](#Ray)
    * [.closestPointToPoint(point, target)](#Ray+closestPointToPoint) ⇒ <code>Vector3</code>
    * [.distanceToPoint(point)](#Ray+distanceToPoint) ⇒ <code>number</code>
    * [.distanceSqToPoint(point)](#Ray+distanceSqToPoint) ⇒ <code>number</code>
    * [.distanceSqToSegment(v0, v1, [optionalPointOnRay], [optionalPointOnSegment])](#Ray+distanceSqToSegment) ⇒ <code>number</code>
    * [.intersectSphere(sphere, target)](#Ray+intersectSphere) ⇒ <code>Vector3</code>
    * [.intersectsSphere(sphere)](#Ray+intersectsSphere) ⇒ <code>boolean</code>
    * [.distanceToPlane(plane)](#Ray+distanceToPlane) ⇒ <code>number</code>
    * [.intersectPlane(plane, target)](#Ray+intersectPlane) ⇒ <code>Vector3</code>
    * [.intersectsPlane(plane)](#Ray+intersectsPlane) ⇒ <code>boolean</code>
    * [.intersectBox(box, target)](#Ray+intersectBox) ⇒ <code>Vector3</code>
    * [.intersectsBox(box)](#Ray+intersectsBox) ⇒ <code>boolean</code>
    * [.intersectTriangle(a, b, c, backfaceCulling, target)](#Ray+intersectTriangle) ⇒ <code>Vector3</code>
    * [.applyMatrix4(matrix4)](#Ray+applyMatrix4) ⇒ [<code>Ray</code>](#Ray)
    * [.equals(ray)](#Ray+equals) ⇒ <code>boolean</code>
    * [.clone()](#Ray+clone) ⇒ [<code>Ray</code>](#Ray)

<a name="new_Ray_new"></a>

### new Ray([origin], [direction])
Constructs a new ray.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [origin] | <code>Vector3</code> | <code>(0,0,0)</code> | The origin of the ray. |
| [direction] | <code>Vector3</code> | <code>(0,0,-1)</code> | The (normalized) direction of the ray. |

<a name="Ray+origin"></a>

### ray.origin : <code>Vector3</code>
The origin of the ray.

**Kind**: instance property of [<code>Ray</code>](#Ray)  
<a name="Ray+direction"></a>

### ray.direction : <code>Vector3</code>
The (normalized) direction of the ray.

**Kind**: instance property of [<code>Ray</code>](#Ray)  
<a name="Ray+set"></a>

### ray.set(origin, direction) ⇒ [<code>Ray</code>](#Ray)
Sets the ray's components by copying the given values.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| origin | <code>Vector3</code> | The origin. |
| direction | <code>Vector3</code> | The direction. |

<a name="Ray+copy"></a>

### ray.copy(ray) ⇒ [<code>Ray</code>](#Ray)
Copies the values of the given ray to this instance.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| ray | [<code>Ray</code>](#Ray) | The ray to copy. |

<a name="Ray+at"></a>

### ray.at(t, target) ⇒ <code>Vector3</code>
Returns a vector that is located at a given distance along this ray.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - A position on the ray.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The distance along the ray to retrieve a position for. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+lookAt"></a>

### ray.lookAt(v) ⇒ [<code>Ray</code>](#Ray)
Adjusts the direction of the ray to point at the given vector in world space.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The target position. |

<a name="Ray+recast"></a>

### ray.recast(t) ⇒ [<code>Ray</code>](#Ray)
Shift the origin of this ray along its direction by the given distance.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The distance along the ray to interpolate. |

<a name="Ray+closestPointToPoint"></a>

### ray.closestPointToPoint(point, target) ⇒ <code>Vector3</code>
Returns the point along this ray that is closest to the given point.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The closest point on this ray.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space to get the closet location on the ray for. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+distanceToPoint"></a>

### ray.distanceToPoint(point) ⇒ <code>number</code>
Returns the distance of the closest approach between this ray and the given point.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>number</code> - The distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space to compute the distance to. |

<a name="Ray+distanceSqToPoint"></a>

### ray.distanceSqToPoint(point) ⇒ <code>number</code>
Returns the squared distance of the closest approach between this ray and the given point.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>number</code> - The squared distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space to compute the distance to. |

<a name="Ray+distanceSqToSegment"></a>

### ray.distanceSqToSegment(v0, v1, [optionalPointOnRay], [optionalPointOnSegment]) ⇒ <code>number</code>
Returns the squared distance between this ray and the given line segment.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>number</code> - The squared distance.  

| Param | Type | Description |
| --- | --- | --- |
| v0 | <code>Vector3</code> | The start point of the line segment. |
| v1 | <code>Vector3</code> | The end point of the line segment. |
| [optionalPointOnRay] | <code>Vector3</code> | When provided, it receives the point on this ray that is closest to the segment. |
| [optionalPointOnSegment] | <code>Vector3</code> | When provided, it receives the point on the line segment that is closest to this ray. |

<a name="Ray+intersectSphere"></a>

### ray.intersectSphere(sphere, target) ⇒ <code>Vector3</code>
Intersects this ray with the given sphere, returning the intersection
point or `null` if there is no intersection.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to intersect. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+intersectsSphere"></a>

### ray.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if this ray intersects with the given sphere.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>boolean</code> - Whether this ray intersects with the given sphere or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to intersect. |

<a name="Ray+distanceToPlane"></a>

### ray.distanceToPlane(plane) ⇒ <code>number</code>
Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
does not intersect with the plane.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>number</code> - Whether this ray intersects with the given sphere or not.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to compute the distance to. |

<a name="Ray+intersectPlane"></a>

### ray.intersectPlane(plane, target) ⇒ <code>Vector3</code>
Intersects this ray with the given plane, returning the intersection
point or `null` if there is no intersection.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to intersect. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+intersectsPlane"></a>

### ray.intersectsPlane(plane) ⇒ <code>boolean</code>
Returns `true` if this ray intersects with the given plane.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>boolean</code> - Whether this ray intersects with the given plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to intersect. |

<a name="Ray+intersectBox"></a>

### ray.intersectBox(box, target) ⇒ <code>Vector3</code>
Intersects this ray with the given bounding box, returning the intersection
point or `null` if there is no intersection.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The box to intersect. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+intersectsBox"></a>

### ray.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if this ray intersects with the given box.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>boolean</code> - Whether this ray intersects with the given box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The box to intersect. |

<a name="Ray+intersectTriangle"></a>

### ray.intersectTriangle(a, b, c, backfaceCulling, target) ⇒ <code>Vector3</code>
Intersects this ray with the given triangle, returning the intersection
point or `null` if there is no intersection.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first vertex of the triangle. |
| b | <code>Vector3</code> | The second vertex of the triangle. |
| c | <code>Vector3</code> | The third vertex of the triangle. |
| backfaceCulling | <code>boolean</code> | Whether to use backface culling or not. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+applyMatrix4"></a>

### ray.applyMatrix4(matrix4) ⇒ [<code>Ray</code>](#Ray)
Transforms this ray with the given 4x4 transformation matrix.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| matrix4 | <code>Matrix4</code> | The transformation matrix. |

<a name="Ray+equals"></a>

### ray.equals(ray) ⇒ <code>boolean</code>
Returns `true` if this ray is equal with the given one.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>boolean</code> - Whether this ray is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| ray | [<code>Ray</code>](#Ray) | The ray to test for equality. |

<a name="Ray+clone"></a>

### ray.clone() ⇒ [<code>Ray</code>](#Ray)
Returns a new ray with copied values from this instance.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A clone of this instance.  
<a name="Sphere"></a>

## Sphere
An analytical 3D sphere defined by a center and radius. This class is mainly
used as a Bounding Sphere for 3D objects.

**Kind**: global class  

* [Sphere](#Sphere)
    * [new Sphere([center], [radius])](#new_Sphere_new)
    * [.isSphere](#Sphere+isSphere) : <code>boolean</code>
    * [.center](#Sphere+center) : <code>Vector3</code>
    * [.radius](#Sphere+radius) : <code>number</code>
    * [.set(center, radius)](#Sphere+set) ⇒ [<code>Sphere</code>](#Sphere)
    * [.setFromPoints(points, [optionalCenter])](#Sphere+setFromPoints) ⇒ [<code>Sphere</code>](#Sphere)
    * [.copy(sphere)](#Sphere+copy) ⇒ [<code>Sphere</code>](#Sphere)
    * [.isEmpty()](#Sphere+isEmpty) ⇒ <code>boolean</code>
    * [.makeEmpty()](#Sphere+makeEmpty) ⇒ [<code>Sphere</code>](#Sphere)
    * [.containsPoint(point)](#Sphere+containsPoint) ⇒ <code>boolean</code>
    * [.distanceToPoint(point)](#Sphere+distanceToPoint) ⇒ <code>number</code>
    * [.intersectsSphere(sphere)](#Sphere+intersectsSphere) ⇒ <code>boolean</code>
    * [.intersectsBox(box)](#Sphere+intersectsBox) ⇒ <code>boolean</code>
    * [.intersectsPlane(plane)](#Sphere+intersectsPlane) ⇒ <code>boolean</code>
    * [.clampPoint(point, target)](#Sphere+clampPoint) ⇒ <code>Vector3</code>
    * [.getBoundingBox(target)](#Sphere+getBoundingBox) ⇒ <code>Box3</code>
    * [.applyMatrix4(matrix)](#Sphere+applyMatrix4) ⇒ [<code>Sphere</code>](#Sphere)
    * [.translate(offset)](#Sphere+translate) ⇒ [<code>Sphere</code>](#Sphere)
    * [.expandByPoint(point)](#Sphere+expandByPoint) ⇒ [<code>Sphere</code>](#Sphere)
    * [.union(sphere)](#Sphere+union) ⇒ [<code>Sphere</code>](#Sphere)
    * [.equals(sphere)](#Sphere+equals) ⇒ <code>boolean</code>
    * [.clone()](#Sphere+clone) ⇒ [<code>Sphere</code>](#Sphere)

<a name="new_Sphere_new"></a>

### new Sphere([center], [radius])
Constructs a new sphere.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [center] | <code>Vector3</code> | <code>(0,0,0)</code> | The center of the sphere |
| [radius] | <code>number</code> | <code>-1</code> | The radius of the sphere. |

<a name="Sphere+isSphere"></a>

### sphere.isSphere : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Sphere</code>](#Sphere)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Sphere+center"></a>

### sphere.center : <code>Vector3</code>
The center of the sphere

**Kind**: instance property of [<code>Sphere</code>](#Sphere)  
<a name="Sphere+radius"></a>

### sphere.radius : <code>number</code>
The radius of the sphere.

**Kind**: instance property of [<code>Sphere</code>](#Sphere)  
<a name="Sphere+set"></a>

### sphere.set(center, radius) ⇒ [<code>Sphere</code>](#Sphere)
Sets the sphere's components by copying the given values.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| center | <code>Vector3</code> | The center. |
| radius | <code>number</code> | The radius. |

<a name="Sphere+setFromPoints"></a>

### sphere.setFromPoints(points, [optionalCenter]) ⇒ [<code>Sphere</code>](#Sphere)
Computes the minimum bounding sphere for list of points.
If the optional center point is given, it is used as the sphere's
center. Otherwise, the center of the axis-aligned bounding box
encompassing the points is calculated.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | A list of points in 3D space. |
| [optionalCenter] | <code>Vector3</code> | The center of the sphere. |

<a name="Sphere+copy"></a>

### sphere.copy(sphere) ⇒ [<code>Sphere</code>](#Sphere)
Copies the values of the given sphere to this instance.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | [<code>Sphere</code>](#Sphere) | The sphere to copy. |

<a name="Sphere+isEmpty"></a>

### sphere.isEmpty() ⇒ <code>boolean</code>
Returns `true` if the sphere is empty (the radius set to a negative number).

Spheres with a radius of `0` contain only their center point and are not
considered to be empty.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere is empty or not.  
<a name="Sphere+makeEmpty"></a>

### sphere.makeEmpty() ⇒ [<code>Sphere</code>](#Sphere)
Makes this sphere empty which means in encloses a zero space in 3D.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  
<a name="Sphere+containsPoint"></a>

### sphere.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if this sphere contains the given point inclusive of
the surface of the sphere.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere contains the given point or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to check. |

<a name="Sphere+distanceToPoint"></a>

### sphere.distanceToPoint(point) ⇒ <code>number</code>
Returns the closest distance from the boundary of the sphere to the
given point. If the sphere contains the point, the distance will
be negative.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>number</code> - The distance to the point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to compute the distance to. |

<a name="Sphere+intersectsSphere"></a>

### sphere.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if this sphere intersects with the given one.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere intersects with the given one or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | [<code>Sphere</code>](#Sphere) | The sphere to test. |

<a name="Sphere+intersectsBox"></a>

### sphere.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if this sphere intersects with the given box.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere intersects with the given box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The box to test. |

<a name="Sphere+intersectsPlane"></a>

### sphere.intersectsPlane(plane) ⇒ <code>boolean</code>
Returns `true` if this sphere intersects with the given plane.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere intersects with the given plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to test. |

<a name="Sphere+clampPoint"></a>

### sphere.clampPoint(point, target) ⇒ <code>Vector3</code>
Clamps a point within the sphere. If the point is outside the sphere, it
will clamp it to the closest point on the edge of the sphere. Points
already inside the sphere will not be affected.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>Vector3</code> - The clamped point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The plane to clamp. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Sphere+getBoundingBox"></a>

### sphere.getBoundingBox(target) ⇒ <code>Box3</code>
Returns a bounding box that encloses this sphere.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>Box3</code> - The bounding box that encloses this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Box3</code> | The target box that is used to store the method's result. |

<a name="Sphere+applyMatrix4"></a>

### sphere.applyMatrix4(matrix) ⇒ [<code>Sphere</code>](#Sphere)
Transforms this sphere with the given 4x4 transformation matrix.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |

<a name="Sphere+translate"></a>

### sphere.translate(offset) ⇒ [<code>Sphere</code>](#Sphere)
Translates the sphere's center by the given offset.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| offset | <code>Vector3</code> | The offset. |

<a name="Sphere+expandByPoint"></a>

### sphere.expandByPoint(point) ⇒ [<code>Sphere</code>](#Sphere)
Expands the boundaries of this sphere to include the given point.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to include. |

<a name="Sphere+union"></a>

### sphere.union(sphere) ⇒ [<code>Sphere</code>](#Sphere)
Expands this sphere to enclose both the original sphere and the given sphere.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | [<code>Sphere</code>](#Sphere) | The sphere to include. |

<a name="Sphere+equals"></a>

### sphere.equals(sphere) ⇒ <code>boolean</code>
Returns `true` if this sphere is equal with the given one.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this bounding sphere is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | [<code>Sphere</code>](#Sphere) | The sphere to test for equality. |

<a name="Sphere+clone"></a>

### sphere.clone() ⇒ [<code>Sphere</code>](#Sphere)
Returns a new sphere with copied values from this instance.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A clone of this instance.  
<a name="Spherical"></a>

## Spherical
This class can be used to represent points in 3D space as
[Spherical coordinates](https://en.wikipedia.org/wiki/Spherical_coordinate_system).

**Kind**: global class  

* [Spherical](#Spherical)
    * [new Spherical([radius], [phi], [theta])](#new_Spherical_new)
    * [.radius](#Spherical+radius) : <code>number</code>
    * [.phi](#Spherical+phi) : <code>number</code>
    * [.theta](#Spherical+theta) : <code>number</code>
    * [.set(radius, phi, theta)](#Spherical+set) ⇒ [<code>Spherical</code>](#Spherical)
    * [.copy(other)](#Spherical+copy) ⇒ [<code>Spherical</code>](#Spherical)
    * [.makeSafe()](#Spherical+makeSafe) ⇒ [<code>Spherical</code>](#Spherical)
    * [.setFromVector3(v)](#Spherical+setFromVector3) ⇒ [<code>Spherical</code>](#Spherical)
    * [.setFromCartesianCoords(x, y, z)](#Spherical+setFromCartesianCoords) ⇒ [<code>Spherical</code>](#Spherical)
    * [.clone()](#Spherical+clone) ⇒ [<code>Spherical</code>](#Spherical)

<a name="new_Spherical_new"></a>

### new Spherical([radius], [phi], [theta])
Constructs a new spherical.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | The radius, or the Euclidean distance (straight-line distance) from the point to the origin. |
| [phi] | <code>number</code> | <code>0</code> | The polar angle in radians from the y (up) axis. |
| [theta] | <code>number</code> | <code>0</code> | The equator/azimuthal angle in radians around the y (up) axis. |

<a name="Spherical+radius"></a>

### spherical.radius : <code>number</code>
The radius, or the Euclidean distance (straight-line distance) from the point to the origin.

**Kind**: instance property of [<code>Spherical</code>](#Spherical)  
**Default**: <code>1</code>  
<a name="Spherical+phi"></a>

### spherical.phi : <code>number</code>
The polar angle in radians from the y (up) axis.

**Kind**: instance property of [<code>Spherical</code>](#Spherical)  
**Default**: <code>0</code>  
<a name="Spherical+theta"></a>

### spherical.theta : <code>number</code>
The equator/azimuthal angle in radians around the y (up) axis.

**Kind**: instance property of [<code>Spherical</code>](#Spherical)  
**Default**: <code>0</code>  
<a name="Spherical+set"></a>

### spherical.set(radius, phi, theta) ⇒ [<code>Spherical</code>](#Spherical)
Sets the spherical components by copying the given values.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  

| Param | Type | Description |
| --- | --- | --- |
| radius | <code>number</code> | The radius. |
| phi | <code>number</code> | The polar angle. |
| theta | <code>number</code> | The azimuthal angle. |

<a name="Spherical+copy"></a>

### spherical.copy(other) ⇒ [<code>Spherical</code>](#Spherical)
Copies the values of the given spherical to this instance.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  

| Param | Type | Description |
| --- | --- | --- |
| other | [<code>Spherical</code>](#Spherical) | The spherical to copy. |

<a name="Spherical+makeSafe"></a>

### spherical.makeSafe() ⇒ [<code>Spherical</code>](#Spherical)
Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
`0.000001`.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  
<a name="Spherical+setFromVector3"></a>

### spherical.setFromVector3(v) ⇒ [<code>Spherical</code>](#Spherical)
Sets the spherical components from the given vector which is assumed to hold
Cartesian coordinates.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The vector to set. |

<a name="Spherical+setFromCartesianCoords"></a>

### spherical.setFromCartesianCoords(x, y, z) ⇒ [<code>Spherical</code>](#Spherical)
Sets the spherical components from the given Cartesian coordinates.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value. |
| y | <code>number</code> | The x value. |
| z | <code>number</code> | The x value. |

<a name="Spherical+clone"></a>

### spherical.clone() ⇒ [<code>Spherical</code>](#Spherical)
Returns a new spherical with copied values from this instance.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A clone of this instance.  
<a name="SphericalHarmonics3"></a>

## SphericalHarmonics3
Represents a third-order spherical harmonics (SH). Light probes use this class
to encode lighting information.

- Primary reference: [https://graphics.stanford.edu/papers/envmap/envmap.pdf](https://graphics.stanford.edu/papers/envmap/envmap.pdf)
- Secondary reference: [https://www.ppsloan.org/publications/StupidSH36.pdf](https://www.ppsloan.org/publications/StupidSH36.pdf)

**Kind**: global class  

* [SphericalHarmonics3](#SphericalHarmonics3)
    * [new SphericalHarmonics3()](#new_SphericalHarmonics3_new)
    * _instance_
        * [.isSphericalHarmonics3](#SphericalHarmonics3+isSphericalHarmonics3) : <code>boolean</code>
        * [.coefficients](#SphericalHarmonics3+coefficients) : <code>Array.&lt;Vector3&gt;</code>
        * [.set(coefficients)](#SphericalHarmonics3+set) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.zero()](#SphericalHarmonics3+zero) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.getAt(normal, target)](#SphericalHarmonics3+getAt) ⇒ <code>Vector3</code>
        * [.getIrradianceAt(normal, target)](#SphericalHarmonics3+getIrradianceAt) ⇒ <code>Vector3</code>
        * [.add(sh)](#SphericalHarmonics3+add) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.addScaledSH(sh, s)](#SphericalHarmonics3+addScaledSH) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.scale(s)](#SphericalHarmonics3+scale) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.lerp(sh, alpha)](#SphericalHarmonics3+lerp) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.equals(sh)](#SphericalHarmonics3+equals) ⇒ <code>boolean</code>
        * [.copy(sh)](#SphericalHarmonics3+copy) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.clone()](#SphericalHarmonics3+clone) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.fromArray(array, [offset])](#SphericalHarmonics3+fromArray) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.toArray([array], [offset])](#SphericalHarmonics3+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * _static_
        * [.getBasisAt(normal, shBasis)](#SphericalHarmonics3.getBasisAt)

<a name="new_SphericalHarmonics3_new"></a>

### new SphericalHarmonics3()
Constructs a new spherical harmonics.

<a name="SphericalHarmonics3+isSphericalHarmonics3"></a>

### sphericalHarmonics3.isSphericalHarmonics3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SphericalHarmonics3+coefficients"></a>

### sphericalHarmonics3.coefficients : <code>Array.&lt;Vector3&gt;</code>
An array holding the (9) SH coefficients.

**Kind**: instance property of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
<a name="SphericalHarmonics3+set"></a>

### sphericalHarmonics3.set(coefficients) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Sets the given SH coefficients to this instance by copying
the values.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| coefficients | <code>Array.&lt;Vector3&gt;</code> | The SH coefficients. |

<a name="SphericalHarmonics3+zero"></a>

### sphericalHarmonics3.zero() ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Sets all SH coefficients to `0`.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  
<a name="SphericalHarmonics3+getAt"></a>

### sphericalHarmonics3.getAt(normal, target) ⇒ <code>Vector3</code>
Returns the radiance in the direction of the given normal.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: <code>Vector3</code> - The radiance.  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal vector (assumed to be unit length) |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="SphericalHarmonics3+getIrradianceAt"></a>

### sphericalHarmonics3.getIrradianceAt(normal, target) ⇒ <code>Vector3</code>
Returns the irradiance (radiance convolved with cosine lobe) in the
direction of the given normal.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: <code>Vector3</code> - The irradiance.  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal vector (assumed to be unit length) |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="SphericalHarmonics3+add"></a>

### sphericalHarmonics3.add(sh) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Adds the given SH to this instance.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The SH to add. |

<a name="SphericalHarmonics3+addScaledSH"></a>

### sphericalHarmonics3.addScaledSH(sh, s) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
A convenience method for performing [add](#SphericalHarmonics3+add) and
[scale](#SphericalHarmonics3+scale) at once.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The SH to add. |
| s | <code>number</code> | The scale factor. |

<a name="SphericalHarmonics3+scale"></a>

### sphericalHarmonics3.scale(s) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Scales this SH by the given scale factor.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scale factor. |

<a name="SphericalHarmonics3+lerp"></a>

### sphericalHarmonics3.lerp(sh, alpha) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Linear interpolates between the given SH and this instance by the given
alpha factor.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The SH to interpolate with. |
| alpha | <code>number</code> | The alpha factor. |

<a name="SphericalHarmonics3+equals"></a>

### sphericalHarmonics3.equals(sh) ⇒ <code>boolean</code>
Returns `true` if this spherical harmonics is equal with the given one.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: <code>boolean</code> - Whether this spherical harmonics is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The spherical harmonics to test for equality. |

<a name="SphericalHarmonics3+copy"></a>

### sphericalHarmonics3.copy(sh) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Copies the values of the given spherical harmonics to this instance.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The spherical harmonics to copy. |

<a name="SphericalHarmonics3+clone"></a>

### sphericalHarmonics3.clone() ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Returns a new spherical harmonics with copied values from this instance.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A clone of this instance.  
<a name="SphericalHarmonics3+fromArray"></a>

### sphericalHarmonics3.fromArray(array, [offset]) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Sets the SH coefficients of this instance from the given array.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A clone of this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the SH coefficients. |
| [offset] | <code>number</code> | <code>0</code> | The array offset where to start copying. |

<a name="SphericalHarmonics3+toArray"></a>

### sphericalHarmonics3.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Returns an array with the SH coefficients, or copies them into the provided
array. The coefficients are represented as numbers.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: <code>Array.&lt;number&gt;</code> - An array with flat SH coefficients.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array. |
| [offset] | <code>number</code> | <code>0</code> | The array offset where to start copying. |

<a name="SphericalHarmonics3.getBasisAt"></a>

### SphericalHarmonics3.getBasisAt(normal, shBasis)
Computes the SH basis for the given normal vector.

**Kind**: static method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal. |
| shBasis | <code>Array.&lt;number&gt;</code> | The target array holding the SH basis. |

<a name="Triangle"></a>

## Triangle
A geometric triangle as defined by three vectors representing its three corners.

**Kind**: global class  

* [Triangle](#Triangle)
    * [new Triangle([a], [b], [c])](#new_Triangle_new)
    * _instance_
        * [.a](#Triangle+a) : <code>Vector3</code>
        * [.b](#Triangle+b) : <code>Vector3</code>
        * [.c](#Triangle+c) : <code>Vector3</code>
        * [.set(a, b, c)](#Triangle+set) ⇒ [<code>Triangle</code>](#Triangle)
        * [.setFromPointsAndIndices(points, i0, i1, i2)](#Triangle+setFromPointsAndIndices) ⇒ [<code>Triangle</code>](#Triangle)
        * [.setFromAttributeAndIndices(attribute, i0, i1, i2)](#Triangle+setFromAttributeAndIndices) ⇒ [<code>Triangle</code>](#Triangle)
        * [.clone()](#Triangle+clone) ⇒ [<code>Triangle</code>](#Triangle)
        * [.copy(triangle)](#Triangle+copy) ⇒ [<code>Triangle</code>](#Triangle)
        * [.getArea()](#Triangle+getArea) ⇒ <code>number</code>
        * [.getMidpoint(target)](#Triangle+getMidpoint) ⇒ <code>Vector3</code>
        * [.getNormal(target)](#Triangle+getNormal) ⇒ <code>Vector3</code>
        * [.getPlane(target)](#Triangle+getPlane) ⇒ <code>Plane</code>
        * [.getBarycoord(point, target)](#Triangle+getBarycoord) ⇒ <code>Vector3</code>
        * [.getInterpolation(point, v1, v2, v3, target)](#Triangle+getInterpolation) ⇒ <code>Vector3</code>
        * [.containsPoint(point)](#Triangle+containsPoint) ⇒ <code>boolean</code>
        * [.isFrontFacing(direction)](#Triangle+isFrontFacing) ⇒ <code>boolean</code>
        * [.intersectsBox(box)](#Triangle+intersectsBox) ⇒ <code>boolean</code>
        * [.closestPointToPoint(p, target)](#Triangle+closestPointToPoint) ⇒ <code>Vector3</code>
        * [.equals(triangle)](#Triangle+equals) ⇒ <code>boolean</code>
    * _static_
        * [.getNormal(a, b, c, target)](#Triangle.getNormal) ⇒ <code>Vector3</code>
        * [.getBarycoord(point, a, b, c, target)](#Triangle.getBarycoord) ⇒ <code>Vector3</code>
        * [.containsPoint(point, a, b, c)](#Triangle.containsPoint) ⇒ <code>boolean</code>
        * [.getInterpolation(point, p1, p2, p3, v1, v2, v3, target)](#Triangle.getInterpolation) ⇒ <code>Vector3</code>
        * [.getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target)](#Triangle.getInterpolatedAttribute) ⇒ <code>Vector3</code>
        * [.isFrontFacing(a, b, c, direction)](#Triangle.isFrontFacing) ⇒ <code>boolean</code>

<a name="new_Triangle_new"></a>

### new Triangle([a], [b], [c])
Constructs a new triangle.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [a] | <code>Vector3</code> | <code>(0,0,0)</code> | The first corner of the triangle. |
| [b] | <code>Vector3</code> | <code>(0,0,0)</code> | The second corner of the triangle. |
| [c] | <code>Vector3</code> | <code>(0,0,0)</code> | The third corner of the triangle. |

<a name="Triangle+a"></a>

### triangle.a : <code>Vector3</code>
The first corner of the triangle.

**Kind**: instance property of [<code>Triangle</code>](#Triangle)  
<a name="Triangle+b"></a>

### triangle.b : <code>Vector3</code>
The second corner of the triangle.

**Kind**: instance property of [<code>Triangle</code>](#Triangle)  
<a name="Triangle+c"></a>

### triangle.c : <code>Vector3</code>
The third corner of the triangle.

**Kind**: instance property of [<code>Triangle</code>](#Triangle)  
<a name="Triangle+set"></a>

### triangle.set(a, b, c) ⇒ [<code>Triangle</code>](#Triangle)
Sets the triangle's vertices by copying the given values.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A reference to this triangle.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |

<a name="Triangle+setFromPointsAndIndices"></a>

### triangle.setFromPointsAndIndices(points, i0, i1, i2) ⇒ [<code>Triangle</code>](#Triangle)
Sets the triangle's vertices by copying the given array values.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A reference to this triangle.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | An array with 3D points. |
| i0 | <code>number</code> | The array index representing the first corner of the triangle. |
| i1 | <code>number</code> | The array index representing the second corner of the triangle. |
| i2 | <code>number</code> | The array index representing the third corner of the triangle. |

<a name="Triangle+setFromAttributeAndIndices"></a>

### triangle.setFromAttributeAndIndices(attribute, i0, i1, i2) ⇒ [<code>Triangle</code>](#Triangle)
Sets the triangle's vertices by copying the given attribute values.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A reference to this triangle.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | A buffer attribute with 3D points data. |
| i0 | <code>number</code> | The attribute index representing the first corner of the triangle. |
| i1 | <code>number</code> | The attribute index representing the second corner of the triangle. |
| i2 | <code>number</code> | The attribute index representing the third corner of the triangle. |

<a name="Triangle+clone"></a>

### triangle.clone() ⇒ [<code>Triangle</code>](#Triangle)
Returns a new triangle with copied values from this instance.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A clone of this instance.  
<a name="Triangle+copy"></a>

### triangle.copy(triangle) ⇒ [<code>Triangle</code>](#Triangle)
Copies the values of the given triangle to this instance.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A reference to this triangle.  

| Param | Type | Description |
| --- | --- | --- |
| triangle | [<code>Triangle</code>](#Triangle) | The triangle to copy. |

<a name="Triangle+getArea"></a>

### triangle.getArea() ⇒ <code>number</code>
Computes the area of the triangle.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>number</code> - The triangle's area.  
<a name="Triangle+getMidpoint"></a>

### triangle.getMidpoint(target) ⇒ <code>Vector3</code>
Computes the midpoint of the triangle.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The triangle's midpoint.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+getNormal"></a>

### triangle.getNormal(target) ⇒ <code>Vector3</code>
Computes the normal of the triangle.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The triangle's normal.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+getPlane"></a>

### triangle.getPlane(target) ⇒ <code>Plane</code>
Computes a plane the triangle lies within.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Plane</code> - The plane the triangle lies within.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Plane</code> | The target vector that is used to store the method's result. |

<a name="Triangle+getBarycoord"></a>

### triangle.getBarycoord(point, target) ⇒ <code>Vector3</code>
Computes a barycentric coordinates from the given vector.
Returns `null` if the triangle is degenerate.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The barycentric coordinates for the given point  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+getInterpolation"></a>

### triangle.getInterpolation(point, v1, v2, v3, target) ⇒ <code>Vector3</code>
Computes the value barycentrically interpolated for the given point on the
triangle. Returns `null` if the triangle is degenerate.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | Position of interpolated point. |
| v1 | <code>Vector3</code> | Value to interpolate of first vertex. |
| v2 | <code>Vector3</code> | Value to interpolate of second vertex. |
| v3 | <code>Vector3</code> | Value to interpolate of third vertex. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+containsPoint"></a>

### triangle.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point, when projected onto the plane of the
triangle, lies within the triangle.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether the given point, when projected onto the plane of the
triangle, lies within the triangle or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point in 3D space to test. |

<a name="Triangle+isFrontFacing"></a>

### triangle.isFrontFacing(direction) ⇒ <code>boolean</code>
Returns `true` if the triangle is oriented towards the given direction.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether the triangle is oriented towards the given direction or not.  

| Param | Type | Description |
| --- | --- | --- |
| direction | <code>Vector3</code> | The (normalized) direction vector. |

<a name="Triangle+intersectsBox"></a>

### triangle.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if this triangle intersects with the given box.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether this triangle intersects with the given box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The box to intersect. |

<a name="Triangle+closestPointToPoint"></a>

### triangle.closestPointToPoint(p, target) ⇒ <code>Vector3</code>
Returns the closest point on the triangle to the given point.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The closest point on the triangle.  

| Param | Type | Description |
| --- | --- | --- |
| p | <code>Vector3</code> | The point to compute the closest point for. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+equals"></a>

### triangle.equals(triangle) ⇒ <code>boolean</code>
Returns `true` if this triangle is equal with the given one.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether this triangle is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| triangle | [<code>Triangle</code>](#Triangle) | The triangle to test for equality. |

<a name="Triangle.getNormal"></a>

### Triangle.getNormal(a, b, c, target) ⇒ <code>Vector3</code>
Computes the normal vector of a triangle.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The triangle's normal.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle.getBarycoord"></a>

### Triangle.getBarycoord(point, a, b, c, target) ⇒ <code>Vector3</code>
Computes a barycentric coordinates from the given vector.
Returns `null` if the triangle is degenerate.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The barycentric coordinates for the given point  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space. |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle.containsPoint"></a>

### Triangle.containsPoint(point, a, b, c) ⇒ <code>boolean</code>
Returns `true` if the given point, when projected onto the plane of the
triangle, lies within the triangle.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether the given point, when projected onto the plane of the
triangle, lies within the triangle or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point in 3D space to test. |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |

<a name="Triangle.getInterpolation"></a>

### Triangle.getInterpolation(point, p1, p2, p3, v1, v2, v3, target) ⇒ <code>Vector3</code>
Computes the value barycentrically interpolated for the given point on the
triangle. Returns `null` if the triangle is degenerate.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | Position of interpolated point. |
| p1 | <code>Vector3</code> | The first corner of the triangle. |
| p2 | <code>Vector3</code> | The second corner of the triangle. |
| p3 | <code>Vector3</code> | The third corner of the triangle. |
| v1 | <code>Vector3</code> | Value to interpolate of first vertex. |
| v2 | <code>Vector3</code> | Value to interpolate of second vertex. |
| v3 | <code>Vector3</code> | Value to interpolate of third vertex. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle.getInterpolatedAttribute"></a>

### Triangle.getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) ⇒ <code>Vector3</code>
Computes the value barycentrically interpolated for the given attribute and indices.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The interpolated attribute value.  

| Param | Type | Description |
| --- | --- | --- |
| attr | <code>BufferAttribute</code> | The attribute to interpolate. |
| i1 | <code>number</code> | Index of first vertex. |
| i2 | <code>number</code> | Index of second vertex. |
| i3 | <code>number</code> | Index of third vertex. |
| barycoord | <code>Vector3</code> | The barycoordinate value to use to interpolate. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle.isFrontFacing"></a>

### Triangle.isFrontFacing(a, b, c, direction) ⇒ <code>boolean</code>
Returns `true` if the triangle is oriented towards the given direction.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether the triangle is oriented towards the given direction or not.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |
| direction | <code>Vector3</code> | The (normalized) direction vector. |

<a name="Vector2"></a>

## Vector2
Class representing a 2D vector. A 2D vector is an ordered pair of numbers
(labeled x and y), which can be used to represent a number of things, such as:

- A point in 2D space (i.e. a position on a plane).
- A direction and length across a plane. In three.js the length will
always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
and the direction is also measured from `(0, 0)` towards `(x, y)`.
- Any arbitrary ordered pair of numbers.

There are other things a 2D vector can be used to represent, such as
momentum vectors, complex numbers and so on, however these are the most
common uses in three.js.

Iterating through a vector instance will yield its components `(x, y)` in
the corresponding order.
```js
const a = new THREE.Vector2( 0, 1 );

//no arguments; will be initialised to (0, 0)
const b = new THREE.Vector2( );

const d = a.distanceTo( b );
```

**Kind**: global class  

* [Vector2](#Vector2)
    * [new Vector2([x], [y])](#new_Vector2_new)
    * [.isVector2](#Vector2+isVector2) : <code>boolean</code>
    * [.x](#Vector2+x) : <code>number</code>
    * [.y](#Vector2+y) : <code>number</code>
    * [.width](#Vector2+width) : <code>number</code>
    * [.height](#Vector2+height) : <code>number</code>
    * [.set(x, y)](#Vector2+set) ⇒ [<code>Vector2</code>](#Vector2)
    * [.setScalar(scalar)](#Vector2+setScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.setX(x)](#Vector2+setX) ⇒ [<code>Vector2</code>](#Vector2)
    * [.setY(y)](#Vector2+setY) ⇒ [<code>Vector2</code>](#Vector2)
    * [.setComponent(index, value)](#Vector2+setComponent) ⇒ [<code>Vector2</code>](#Vector2)
    * [.getComponent(index)](#Vector2+getComponent) ⇒ <code>number</code>
    * [.clone()](#Vector2+clone) ⇒ [<code>Vector2</code>](#Vector2)
    * [.copy(v)](#Vector2+copy) ⇒ [<code>Vector2</code>](#Vector2)
    * [.add(v)](#Vector2+add) ⇒ [<code>Vector2</code>](#Vector2)
    * [.addScalar(s)](#Vector2+addScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.addVectors(a, b)](#Vector2+addVectors) ⇒ [<code>Vector2</code>](#Vector2)
    * [.addScaledVector(v, s)](#Vector2+addScaledVector) ⇒ [<code>Vector2</code>](#Vector2)
    * [.sub(v)](#Vector2+sub) ⇒ [<code>Vector2</code>](#Vector2)
    * [.subScalar(s)](#Vector2+subScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.subVectors(a, b)](#Vector2+subVectors) ⇒ [<code>Vector2</code>](#Vector2)
    * [.multiply(v)](#Vector2+multiply) ⇒ [<code>Vector2</code>](#Vector2)
    * [.multiplyScalar(scalar)](#Vector2+multiplyScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.divide(v)](#Vector2+divide) ⇒ [<code>Vector2</code>](#Vector2)
    * [.divideScalar(scalar)](#Vector2+divideScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.applyMatrix3(m)](#Vector2+applyMatrix3) ⇒ [<code>Vector2</code>](#Vector2)
    * [.min(v)](#Vector2+min) ⇒ [<code>Vector2</code>](#Vector2)
    * [.max(v)](#Vector2+max) ⇒ [<code>Vector2</code>](#Vector2)
    * [.clamp(min, max)](#Vector2+clamp) ⇒ [<code>Vector2</code>](#Vector2)
    * [.clampScalar(minVal, maxVal)](#Vector2+clampScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.clampLength(min, max)](#Vector2+clampLength) ⇒ [<code>Vector2</code>](#Vector2)
    * [.floor()](#Vector2+floor) ⇒ [<code>Vector2</code>](#Vector2)
    * [.ceil()](#Vector2+ceil) ⇒ [<code>Vector2</code>](#Vector2)
    * [.round()](#Vector2+round) ⇒ [<code>Vector2</code>](#Vector2)
    * [.roundToZero()](#Vector2+roundToZero) ⇒ [<code>Vector2</code>](#Vector2)
    * [.negate()](#Vector2+negate) ⇒ [<code>Vector2</code>](#Vector2)
    * [.dot(v)](#Vector2+dot) ⇒ <code>number</code>
    * [.cross(v)](#Vector2+cross) ⇒ <code>number</code>
    * [.lengthSq()](#Vector2+lengthSq) ⇒ <code>number</code>
    * [.length()](#Vector2+length) ⇒ <code>number</code>
    * [.manhattanLength()](#Vector2+manhattanLength) ⇒ <code>number</code>
    * [.normalize()](#Vector2+normalize) ⇒ [<code>Vector2</code>](#Vector2)
    * [.angle()](#Vector2+angle) ⇒ <code>number</code>
    * [.angleTo(v)](#Vector2+angleTo) ⇒ <code>number</code>
    * [.distanceTo(v)](#Vector2+distanceTo) ⇒ <code>number</code>
    * [.distanceToSquared(v)](#Vector2+distanceToSquared) ⇒ <code>number</code>
    * [.manhattanDistanceTo(v)](#Vector2+manhattanDistanceTo) ⇒ <code>number</code>
    * [.setLength(length)](#Vector2+setLength) ⇒ [<code>Vector2</code>](#Vector2)
    * [.lerp(v, alpha)](#Vector2+lerp) ⇒ [<code>Vector2</code>](#Vector2)
    * [.lerpVectors(v1, v2, alpha)](#Vector2+lerpVectors) ⇒ [<code>Vector2</code>](#Vector2)
    * [.equals(v)](#Vector2+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Vector2+fromArray) ⇒ [<code>Vector2</code>](#Vector2)
    * [.toArray([array], [offset])](#Vector2+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.fromBufferAttribute(attribute, index)](#Vector2+fromBufferAttribute) ⇒ [<code>Vector2</code>](#Vector2)
    * [.rotateAround(center, angle)](#Vector2+rotateAround) ⇒ [<code>Vector2</code>](#Vector2)
    * [.random()](#Vector2+random) ⇒ [<code>Vector2</code>](#Vector2)

<a name="new_Vector2_new"></a>

### new Vector2([x], [y])
Constructs a new 2D vector.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The x value of this vector. |
| [y] | <code>number</code> | <code>0</code> | The y value of this vector. |

<a name="Vector2+isVector2"></a>

### vector2.isVector2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Vector2+x"></a>

### vector2.x : <code>number</code>
The x value of this vector.

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
<a name="Vector2+y"></a>

### vector2.y : <code>number</code>
The y value of this vector.

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
<a name="Vector2+width"></a>

### vector2.width : <code>number</code>
Alias for [x](#Vector2+x).

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
<a name="Vector2+height"></a>

### vector2.height : <code>number</code>
Alias for [y](#Vector2+y).

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
<a name="Vector2+set"></a>

### vector2.set(x, y) ⇒ [<code>Vector2</code>](#Vector2)
Sets the vector components.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value of the x component. |
| y | <code>number</code> | The value of the y component. |

<a name="Vector2+setScalar"></a>

### vector2.setScalar(scalar) ⇒ [<code>Vector2</code>](#Vector2)
Sets the vector components to the same value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The value to set for all vector components. |

<a name="Vector2+setX"></a>

### vector2.setX(x) ⇒ [<code>Vector2</code>](#Vector2)
Sets the vector's x component to the given value

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to set. |

<a name="Vector2+setY"></a>

### vector2.setY(y) ⇒ [<code>Vector2</code>](#Vector2)
Sets the vector's y component to the given value

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| y | <code>number</code> | The value to set. |

<a name="Vector2+setComponent"></a>

### vector2.setComponent(index, value) ⇒ [<code>Vector2</code>](#Vector2)
Allows to set a vector component with an index.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y. |
| value | <code>number</code> | The value to set. |

<a name="Vector2+getComponent"></a>

### vector2.getComponent(index) ⇒ <code>number</code>
Returns the value of the vector component which matches the given index.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - A vector component value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y. |

<a name="Vector2+clone"></a>

### vector2.clone() ⇒ [<code>Vector2</code>](#Vector2)
Returns a new vector with copied values from this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A clone of this instance.  
<a name="Vector2+copy"></a>

### vector2.copy(v) ⇒ [<code>Vector2</code>](#Vector2)
Copies the values of the given vector to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to copy. |

<a name="Vector2+add"></a>

### vector2.add(v) ⇒ [<code>Vector2</code>](#Vector2)
Adds the given vector to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to add. |

<a name="Vector2+addScalar"></a>

### vector2.addScalar(s) ⇒ [<code>Vector2</code>](#Vector2)
Adds the given scalar value to all components of this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to add. |

<a name="Vector2+addVectors"></a>

### vector2.addVectors(a, b) ⇒ [<code>Vector2</code>](#Vector2)
Adds the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector2</code>](#Vector2) | The first vector. |
| b | [<code>Vector2</code>](#Vector2) | The second vector. |

<a name="Vector2+addScaledVector"></a>

### vector2.addScaledVector(v, s) ⇒ [<code>Vector2</code>](#Vector2)
Adds the given vector scaled by the given factor to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector. |
| s | <code>number</code> | The factor that scales `v`. |

<a name="Vector2+sub"></a>

### vector2.sub(v) ⇒ [<code>Vector2</code>](#Vector2)
Subtracts the given vector from this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to subtract. |

<a name="Vector2+subScalar"></a>

### vector2.subScalar(s) ⇒ [<code>Vector2</code>](#Vector2)
Subtracts the given scalar value from all components of this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to subtract. |

<a name="Vector2+subVectors"></a>

### vector2.subVectors(a, b) ⇒ [<code>Vector2</code>](#Vector2)
Subtracts the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector2</code>](#Vector2) | The first vector. |
| b | [<code>Vector2</code>](#Vector2) | The second vector. |

<a name="Vector2+multiply"></a>

### vector2.multiply(v) ⇒ [<code>Vector2</code>](#Vector2)
Multiplies the given vector with this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to multiply. |

<a name="Vector2+multiplyScalar"></a>

### vector2.multiplyScalar(scalar) ⇒ [<code>Vector2</code>](#Vector2)
Multiplies the given scalar value with all components of this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to multiply. |

<a name="Vector2+divide"></a>

### vector2.divide(v) ⇒ [<code>Vector2</code>](#Vector2)
Divides this instance by the given vector.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to divide. |

<a name="Vector2+divideScalar"></a>

### vector2.divideScalar(scalar) ⇒ [<code>Vector2</code>](#Vector2)
Divides this vector by the given scalar.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to divide. |

<a name="Vector2+applyMatrix3"></a>

### vector2.applyMatrix3(m) ⇒ [<code>Vector2</code>](#Vector2)
Multiplies this vector (with an implicit 1 as the 3rd component) by
the given 3x3 matrix.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="Vector2+min"></a>

### vector2.min(v) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's x or y value is greater than the given vector's x or y
value, replace that value with the corresponding min value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector. |

<a name="Vector2+max"></a>

### vector2.max(v) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's x or y value is less than the given vector's x or y
value, replace that value with the corresponding max value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector. |

<a name="Vector2+clamp"></a>

### vector2.clamp(min, max) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's x or y value is greater than the max vector's x or y
value, it is replaced by the corresponding value.
If this vector's x or y value is less than the min vector's x or y value,
it is replaced by the corresponding value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | [<code>Vector2</code>](#Vector2) | The minimum x and y values. |
| max | [<code>Vector2</code>](#Vector2) | The maximum x and y values in the desired range. |

<a name="Vector2+clampScalar"></a>

### vector2.clampScalar(minVal, maxVal) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's x or y values are greater than the max value, they are
replaced by the max value.
If this vector's x or y values are less than the min value, they are
replaced by the min value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| minVal | <code>number</code> | The minimum value the components will be clamped to. |
| maxVal | <code>number</code> | The maximum value the components will be clamped to. |

<a name="Vector2+clampLength"></a>

### vector2.clampLength(min, max) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's length is greater than the max value, it is replaced by
the max value.
If this vector's length is less than the min value, it is replaced by the
min value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>number</code> | The minimum value the vector length will be clamped to. |
| max | <code>number</code> | The maximum value the vector length will be clamped to. |

<a name="Vector2+floor"></a>

### vector2.floor() ⇒ [<code>Vector2</code>](#Vector2)
The components of this vector are rounded down to the nearest integer value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+ceil"></a>

### vector2.ceil() ⇒ [<code>Vector2</code>](#Vector2)
The components of this vector are rounded up to the nearest integer value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+round"></a>

### vector2.round() ⇒ [<code>Vector2</code>](#Vector2)
The components of this vector are rounded to the nearest integer value

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+roundToZero"></a>

### vector2.roundToZero() ⇒ [<code>Vector2</code>](#Vector2)
The components of this vector are rounded towards zero (up if negative,
down if positive) to an integer value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+negate"></a>

### vector2.negate() ⇒ [<code>Vector2</code>](#Vector2)
Inverts this vector - i.e. sets x = -x and y = -y.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+dot"></a>

### vector2.dot(v) ⇒ <code>number</code>
Calculates the dot product of the given vector with this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The result of the dot product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the dot product with. |

<a name="Vector2+cross"></a>

### vector2.cross(v) ⇒ <code>number</code>
Calculates the cross product of the given vector with this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The result of the cross product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the cross product with. |

<a name="Vector2+lengthSq"></a>

### vector2.lengthSq() ⇒ <code>number</code>
Computes the square of the Euclidean length (straight-line length) from
(0, 0) to (x, y). If you are comparing the lengths of vectors, you should
compare the length squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The square length of this vector.  
<a name="Vector2+length"></a>

### vector2.length() ⇒ <code>number</code>
Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector2+manhattanLength"></a>

### vector2.manhattanLength() ⇒ <code>number</code>
Computes the Manhattan length of this vector.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector2+normalize"></a>

### vector2.normalize() ⇒ [<code>Vector2</code>](#Vector2)
Converts this vector to a unit vector - that is, sets it equal to a vector
with the same direction as this one, but with a vector length of `1`.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+angle"></a>

### vector2.angle() ⇒ <code>number</code>
Computes the angle in radians of this vector with respect to the positive x-axis.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The angle in radians.  
<a name="Vector2+angleTo"></a>

### vector2.angleTo(v) ⇒ <code>number</code>
Returns the angle between the given vector and this instance in radians.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The angle in radians.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the angle with. |

<a name="Vector2+distanceTo"></a>

### vector2.distanceTo(v) ⇒ <code>number</code>
Computes the distance from the given vector to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the distance to. |

<a name="Vector2+distanceToSquared"></a>

### vector2.distanceToSquared(v) ⇒ <code>number</code>
Computes the squared distance from the given vector to this instance.
If you are just comparing the distance with another distance, you should compare
the distance squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The squared distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the squared distance to. |

<a name="Vector2+manhattanDistanceTo"></a>

### vector2.manhattanDistanceTo(v) ⇒ <code>number</code>
Computes the Manhattan distance from the given vector to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The Manhattan distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the Manhattan distance to. |

<a name="Vector2+setLength"></a>

### vector2.setLength(length) ⇒ [<code>Vector2</code>](#Vector2)
Sets this vector to a vector with the same direction as this one, but
with the specified length.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| length | <code>number</code> | The new length of this vector. |

<a name="Vector2+lerp"></a>

### vector2.lerp(v, alpha) ⇒ [<code>Vector2</code>](#Vector2)
Linearly interpolates between the given vector and this instance, where
alpha is the percent distance along the line - alpha = 0 will be this
vector, and alpha = 1 will be the given one.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to interpolate towards. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector2+lerpVectors"></a>

### vector2.lerpVectors(v1, v2, alpha) ⇒ [<code>Vector2</code>](#Vector2)
Linearly interpolates between the given vectors, where alpha is the percent
distance along the line - alpha = 0 will be first vector, and alpha = 1 will
be the second one. The result is stored in this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v1 | [<code>Vector2</code>](#Vector2) | The first vector. |
| v2 | [<code>Vector2</code>](#Vector2) | The second vector. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector2+equals"></a>

### vector2.equals(v) ⇒ <code>boolean</code>
Returns `true` if this vector is equal with the given one.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>boolean</code> - Whether this vector is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to test for equality. |

<a name="Vector2+fromArray"></a>

### vector2.fromArray(array, [offset]) ⇒ [<code>Vector2</code>](#Vector2)
Sets this vector's x value to be `array[ offset ]` and y
value to be `array[ offset + 1 ]`.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the vector component values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Vector2+toArray"></a>

### vector2.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the components of this vector to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>Array.&lt;number&gt;</code> - The vector components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the vector components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Vector2+fromBufferAttribute"></a>

### vector2.fromBufferAttribute(attribute, index) ⇒ [<code>Vector2</code>](#Vector2)
Sets the components of this vector from the given buffer attribute.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding vector data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Vector2+rotateAround"></a>

### vector2.rotateAround(center, angle) ⇒ [<code>Vector2</code>](#Vector2)
Rotates this vector around the given center by the given angle.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| center | [<code>Vector2</code>](#Vector2) | The point around which to rotate. |
| angle | <code>number</code> | The angle to rotate, in radians. |

<a name="Vector2+random"></a>

### vector2.random() ⇒ [<code>Vector2</code>](#Vector2)
Sets each component of this vector to a pseudo-random value between `0` and
`1`, excluding `1`.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector3"></a>

## Vector3
Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
(labeled x, y and z), which can be used to represent a number of things, such as:

- A point in 3D space.
- A direction and length in 3D space. In three.js the length will
always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
- Any arbitrary ordered triplet of numbers.

There are other things a 3D vector can be used to represent, such as
momentum vectors and so on, however these are the most
common uses in three.js.

Iterating through a vector instance will yield its components `(x, y, z)` in
the corresponding order.
```js
const a = new THREE.Vector3( 0, 1, 0 );

//no arguments; will be initialised to (0, 0, 0)
const b = new THREE.Vector3( );

const d = a.distanceTo( b );
```

**Kind**: global class  

* [Vector3](#Vector3)
    * [new Vector3([x], [y], [z])](#new_Vector3_new)
    * [.isVector3](#Vector3+isVector3) : <code>boolean</code>
    * [.x](#Vector3+x) : <code>number</code>
    * [.y](#Vector3+y) : <code>number</code>
    * [.z](#Vector3+z) : <code>number</code>
    * [.set(x, y, z)](#Vector3+set) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setScalar(scalar)](#Vector3+setScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setX(x)](#Vector3+setX) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setY(y)](#Vector3+setY) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setZ(z)](#Vector3+setZ) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setComponent(index, value)](#Vector3+setComponent) ⇒ [<code>Vector3</code>](#Vector3)
    * [.getComponent(index)](#Vector3+getComponent) ⇒ <code>number</code>
    * [.clone()](#Vector3+clone) ⇒ [<code>Vector3</code>](#Vector3)
    * [.copy(v)](#Vector3+copy) ⇒ [<code>Vector3</code>](#Vector3)
    * [.add(v)](#Vector3+add) ⇒ [<code>Vector3</code>](#Vector3)
    * [.addScalar(s)](#Vector3+addScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.addVectors(a, b)](#Vector3+addVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.addScaledVector(v, s)](#Vector3+addScaledVector) ⇒ [<code>Vector3</code>](#Vector3)
    * [.sub(v)](#Vector3+sub) ⇒ [<code>Vector3</code>](#Vector3)
    * [.subScalar(s)](#Vector3+subScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.subVectors(a, b)](#Vector3+subVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.multiply(v)](#Vector3+multiply) ⇒ [<code>Vector3</code>](#Vector3)
    * [.multiplyScalar(scalar)](#Vector3+multiplyScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.multiplyVectors(a, b)](#Vector3+multiplyVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyEuler(euler)](#Vector3+applyEuler) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyAxisAngle(axis, angle)](#Vector3+applyAxisAngle) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyMatrix3(m)](#Vector3+applyMatrix3) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyNormalMatrix(m)](#Vector3+applyNormalMatrix) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyMatrix4(m)](#Vector3+applyMatrix4) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyQuaternion(q)](#Vector3+applyQuaternion) ⇒ [<code>Vector3</code>](#Vector3)
    * [.project(camera)](#Vector3+project) ⇒ [<code>Vector3</code>](#Vector3)
    * [.unproject(camera)](#Vector3+unproject) ⇒ [<code>Vector3</code>](#Vector3)
    * [.transformDirection(m)](#Vector3+transformDirection) ⇒ [<code>Vector3</code>](#Vector3)
    * [.divide(v)](#Vector3+divide) ⇒ [<code>Vector3</code>](#Vector3)
    * [.divideScalar(scalar)](#Vector3+divideScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.min(v)](#Vector3+min) ⇒ [<code>Vector3</code>](#Vector3)
    * [.max(v)](#Vector3+max) ⇒ [<code>Vector3</code>](#Vector3)
    * [.clamp(min, max)](#Vector3+clamp) ⇒ [<code>Vector3</code>](#Vector3)
    * [.clampScalar(minVal, maxVal)](#Vector3+clampScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.clampLength(min, max)](#Vector3+clampLength) ⇒ [<code>Vector3</code>](#Vector3)
    * [.floor()](#Vector3+floor) ⇒ [<code>Vector3</code>](#Vector3)
    * [.ceil()](#Vector3+ceil) ⇒ [<code>Vector3</code>](#Vector3)
    * [.round()](#Vector3+round) ⇒ [<code>Vector3</code>](#Vector3)
    * [.roundToZero()](#Vector3+roundToZero) ⇒ [<code>Vector3</code>](#Vector3)
    * [.negate()](#Vector3+negate) ⇒ [<code>Vector3</code>](#Vector3)
    * [.dot(v)](#Vector3+dot) ⇒ <code>number</code>
    * [.lengthSq()](#Vector3+lengthSq) ⇒ <code>number</code>
    * [.length()](#Vector3+length) ⇒ <code>number</code>
    * [.manhattanLength()](#Vector3+manhattanLength) ⇒ <code>number</code>
    * [.normalize()](#Vector3+normalize) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setLength(length)](#Vector3+setLength) ⇒ [<code>Vector3</code>](#Vector3)
    * [.lerp(v, alpha)](#Vector3+lerp) ⇒ [<code>Vector3</code>](#Vector3)
    * [.lerpVectors(v1, v2, alpha)](#Vector3+lerpVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.cross(v)](#Vector3+cross) ⇒ [<code>Vector3</code>](#Vector3)
    * [.crossVectors(a, b)](#Vector3+crossVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.projectOnVector(v)](#Vector3+projectOnVector) ⇒ [<code>Vector3</code>](#Vector3)
    * [.projectOnPlane(planeNormal)](#Vector3+projectOnPlane) ⇒ [<code>Vector3</code>](#Vector3)
    * [.reflect(normal)](#Vector3+reflect) ⇒ [<code>Vector3</code>](#Vector3)
    * [.angleTo(v)](#Vector3+angleTo) ⇒ <code>number</code>
    * [.distanceTo(v)](#Vector3+distanceTo) ⇒ <code>number</code>
    * [.distanceToSquared(v)](#Vector3+distanceToSquared) ⇒ <code>number</code>
    * [.manhattanDistanceTo(v)](#Vector3+manhattanDistanceTo) ⇒ <code>number</code>
    * [.setFromSpherical(s)](#Vector3+setFromSpherical) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromSphericalCoords(radius, phi, theta)](#Vector3+setFromSphericalCoords) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromCylindrical(c)](#Vector3+setFromCylindrical) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromCylindricalCoords(radius, theta, y)](#Vector3+setFromCylindricalCoords) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromMatrixPosition(m)](#Vector3+setFromMatrixPosition) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromMatrixScale(m)](#Vector3+setFromMatrixScale) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromMatrixColumn(m, index)](#Vector3+setFromMatrixColumn) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromMatrix3Column(m, index)](#Vector3+setFromMatrix3Column) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromEuler(e)](#Vector3+setFromEuler) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromColor(c)](#Vector3+setFromColor) ⇒ [<code>Vector3</code>](#Vector3)
    * [.equals(v)](#Vector3+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Vector3+fromArray) ⇒ [<code>Vector3</code>](#Vector3)
    * [.toArray([array], [offset])](#Vector3+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.fromBufferAttribute(attribute, index)](#Vector3+fromBufferAttribute) ⇒ [<code>Vector3</code>](#Vector3)
    * [.random()](#Vector3+random) ⇒ [<code>Vector3</code>](#Vector3)
    * [.randomDirection()](#Vector3+randomDirection) ⇒ [<code>Vector3</code>](#Vector3)

<a name="new_Vector3_new"></a>

### new Vector3([x], [y], [z])
Constructs a new 3D vector.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The x value of this vector. |
| [y] | <code>number</code> | <code>0</code> | The y value of this vector. |
| [z] | <code>number</code> | <code>0</code> | The z value of this vector. |

<a name="Vector3+isVector3"></a>

### vector3.isVector3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Vector3</code>](#Vector3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Vector3+x"></a>

### vector3.x : <code>number</code>
The x value of this vector.

**Kind**: instance property of [<code>Vector3</code>](#Vector3)  
<a name="Vector3+y"></a>

### vector3.y : <code>number</code>
The y value of this vector.

**Kind**: instance property of [<code>Vector3</code>](#Vector3)  
<a name="Vector3+z"></a>

### vector3.z : <code>number</code>
The z value of this vector.

**Kind**: instance property of [<code>Vector3</code>](#Vector3)  
<a name="Vector3+set"></a>

### vector3.set(x, y, z) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value of the x component. |
| y | <code>number</code> | The value of the y component. |
| z | <code>number</code> | The value of the z component. |

<a name="Vector3+setScalar"></a>

### vector3.setScalar(scalar) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components to the same value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The value to set for all vector components. |

<a name="Vector3+setX"></a>

### vector3.setX(x) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector's x component to the given value

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to set. |

<a name="Vector3+setY"></a>

### vector3.setY(y) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector's y component to the given value

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| y | <code>number</code> | The value to set. |

<a name="Vector3+setZ"></a>

### vector3.setZ(z) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector's z component to the given value

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| z | <code>number</code> | The value to set. |

<a name="Vector3+setComponent"></a>

### vector3.setComponent(index, value) ⇒ [<code>Vector3</code>](#Vector3)
Allows to set a vector component with an index.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y, `2` equals to z. |
| value | <code>number</code> | The value to set. |

<a name="Vector3+getComponent"></a>

### vector3.getComponent(index) ⇒ <code>number</code>
Returns the value of the vector component which matches the given index.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - A vector component value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y, `2` equals to z. |

<a name="Vector3+clone"></a>

### vector3.clone() ⇒ [<code>Vector3</code>](#Vector3)
Returns a new vector with copied values from this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A clone of this instance.  
<a name="Vector3+copy"></a>

### vector3.copy(v) ⇒ [<code>Vector3</code>](#Vector3)
Copies the values of the given vector to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to copy. |

<a name="Vector3+add"></a>

### vector3.add(v) ⇒ [<code>Vector3</code>](#Vector3)
Adds the given vector to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to add. |

<a name="Vector3+addScalar"></a>

### vector3.addScalar(s) ⇒ [<code>Vector3</code>](#Vector3)
Adds the given scalar value to all components of this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to add. |

<a name="Vector3+addVectors"></a>

### vector3.addVectors(a, b) ⇒ [<code>Vector3</code>](#Vector3)
Adds the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector3</code>](#Vector3) | The first vector. |
| b | [<code>Vector3</code>](#Vector3) | The second vector. |

<a name="Vector3+addScaledVector"></a>

### vector3.addScaledVector(v, s) ⇒ [<code>Vector3</code>](#Vector3)
Adds the given vector scaled by the given factor to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) \| <code>Vector4</code> | The vector. |
| s | <code>number</code> | The factor that scales `v`. |

<a name="Vector3+sub"></a>

### vector3.sub(v) ⇒ [<code>Vector3</code>](#Vector3)
Subtracts the given vector from this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to subtract. |

<a name="Vector3+subScalar"></a>

### vector3.subScalar(s) ⇒ [<code>Vector3</code>](#Vector3)
Subtracts the given scalar value from all components of this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to subtract. |

<a name="Vector3+subVectors"></a>

### vector3.subVectors(a, b) ⇒ [<code>Vector3</code>](#Vector3)
Subtracts the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector3</code>](#Vector3) | The first vector. |
| b | [<code>Vector3</code>](#Vector3) | The second vector. |

<a name="Vector3+multiply"></a>

### vector3.multiply(v) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies the given vector with this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to multiply. |

<a name="Vector3+multiplyScalar"></a>

### vector3.multiplyScalar(scalar) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies the given scalar value with all components of this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to multiply. |

<a name="Vector3+multiplyVectors"></a>

### vector3.multiplyVectors(a, b) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector3</code>](#Vector3) | The first vector. |
| b | [<code>Vector3</code>](#Vector3) | The second vector. |

<a name="Vector3+applyEuler"></a>

### vector3.applyEuler(euler) ⇒ [<code>Vector3</code>](#Vector3)
Applies the given Euler rotation to this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| euler | <code>Euler</code> | The Euler angles. |

<a name="Vector3+applyAxisAngle"></a>

### vector3.applyAxisAngle(axis, angle) ⇒ [<code>Vector3</code>](#Vector3)
Applies a rotation specified by an axis and an angle to this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| axis | [<code>Vector3</code>](#Vector3) | A normalized vector representing the rotation axis. |
| angle | <code>number</code> | The angle in radians. |

<a name="Vector3+applyMatrix3"></a>

### vector3.applyMatrix3(m) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies this vector with the given 3x3 matrix.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The 3x3 matrix. |

<a name="Vector3+applyNormalMatrix"></a>

### vector3.applyNormalMatrix(m) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies this vector by the given normal matrix and normalizes
the result.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix. |

<a name="Vector3+applyMatrix4"></a>

### vector3.applyMatrix4(m) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
divides by perspective.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="Vector3+applyQuaternion"></a>

### vector3.applyQuaternion(q) ⇒ [<code>Vector3</code>](#Vector3)
Applies the given Quaternion to this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The Quaternion. |

<a name="Vector3+project"></a>

### vector3.project(camera) ⇒ [<code>Vector3</code>](#Vector3)
Projects this vector from world space into the camera's normalized
device coordinate (NDC) space.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera. |

<a name="Vector3+unproject"></a>

### vector3.unproject(camera) ⇒ [<code>Vector3</code>](#Vector3)
Unprojects this vector from the camera's normalized device coordinate (NDC)
space into world space.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera. |

<a name="Vector3+transformDirection"></a>

### vector3.transformDirection(m) ⇒ [<code>Vector3</code>](#Vector3)
Transforms the direction of this vector by a matrix (the upper left 3 x 3
subset of the given 4x4 matrix and then normalizes the result.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix. |

<a name="Vector3+divide"></a>

### vector3.divide(v) ⇒ [<code>Vector3</code>](#Vector3)
Divides this instance by the given vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to divide. |

<a name="Vector3+divideScalar"></a>

### vector3.divideScalar(scalar) ⇒ [<code>Vector3</code>](#Vector3)
Divides this vector by the given scalar.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to divide. |

<a name="Vector3+min"></a>

### vector3.min(v) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's x, y or z value is greater than the given vector's x, y or z
value, replace that value with the corresponding min value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector. |

<a name="Vector3+max"></a>

### vector3.max(v) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's x, y or z value is less than the given vector's x, y or z
value, replace that value with the corresponding max value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector. |

<a name="Vector3+clamp"></a>

### vector3.clamp(min, max) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's x, y or z value is greater than the max vector's x, y or z
value, it is replaced by the corresponding value.
If this vector's x, y or z value is less than the min vector's x, y or z value,
it is replaced by the corresponding value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | [<code>Vector3</code>](#Vector3) | The minimum x, y and z values. |
| max | [<code>Vector3</code>](#Vector3) | The maximum x, y and z values in the desired range. |

<a name="Vector3+clampScalar"></a>

### vector3.clampScalar(minVal, maxVal) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's x, y or z values are greater than the max value, they are
replaced by the max value.
If this vector's x, y or z values are less than the min value, they are
replaced by the min value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| minVal | <code>number</code> | The minimum value the components will be clamped to. |
| maxVal | <code>number</code> | The maximum value the components will be clamped to. |

<a name="Vector3+clampLength"></a>

### vector3.clampLength(min, max) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's length is greater than the max value, it is replaced by
the max value.
If this vector's length is less than the min value, it is replaced by the
min value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>number</code> | The minimum value the vector length will be clamped to. |
| max | <code>number</code> | The maximum value the vector length will be clamped to. |

<a name="Vector3+floor"></a>

### vector3.floor() ⇒ [<code>Vector3</code>](#Vector3)
The components of this vector are rounded down to the nearest integer value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+ceil"></a>

### vector3.ceil() ⇒ [<code>Vector3</code>](#Vector3)
The components of this vector are rounded up to the nearest integer value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+round"></a>

### vector3.round() ⇒ [<code>Vector3</code>](#Vector3)
The components of this vector are rounded to the nearest integer value

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+roundToZero"></a>

### vector3.roundToZero() ⇒ [<code>Vector3</code>](#Vector3)
The components of this vector are rounded towards zero (up if negative,
down if positive) to an integer value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+negate"></a>

### vector3.negate() ⇒ [<code>Vector3</code>](#Vector3)
Inverts this vector - i.e. sets x = -x, y = -y and z = -z.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+dot"></a>

### vector3.dot(v) ⇒ <code>number</code>
Calculates the dot product of the given vector with this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The result of the dot product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the dot product with. |

<a name="Vector3+lengthSq"></a>

### vector3.lengthSq() ⇒ <code>number</code>
Computes the square of the Euclidean length (straight-line length) from
(0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
compare the length squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The square length of this vector.  
<a name="Vector3+length"></a>

### vector3.length() ⇒ <code>number</code>
Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector3+manhattanLength"></a>

### vector3.manhattanLength() ⇒ <code>number</code>
Computes the Manhattan length of this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector3+normalize"></a>

### vector3.normalize() ⇒ [<code>Vector3</code>](#Vector3)
Converts this vector to a unit vector - that is, sets it equal to a vector
with the same direction as this one, but with a vector length of `1`.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+setLength"></a>

### vector3.setLength(length) ⇒ [<code>Vector3</code>](#Vector3)
Sets this vector to a vector with the same direction as this one, but
with the specified length.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| length | <code>number</code> | The new length of this vector. |

<a name="Vector3+lerp"></a>

### vector3.lerp(v, alpha) ⇒ [<code>Vector3</code>](#Vector3)
Linearly interpolates between the given vector and this instance, where
alpha is the percent distance along the line - alpha = 0 will be this
vector, and alpha = 1 will be the given one.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to interpolate towards. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector3+lerpVectors"></a>

### vector3.lerpVectors(v1, v2, alpha) ⇒ [<code>Vector3</code>](#Vector3)
Linearly interpolates between the given vectors, where alpha is the percent
distance along the line - alpha = 0 will be first vector, and alpha = 1 will
be the second one. The result is stored in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v1 | [<code>Vector3</code>](#Vector3) | The first vector. |
| v2 | [<code>Vector3</code>](#Vector3) | The second vector. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector3+cross"></a>

### vector3.cross(v) ⇒ [<code>Vector3</code>](#Vector3)
Calculates the cross product of the given vector with this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - The result of the cross product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the cross product with. |

<a name="Vector3+crossVectors"></a>

### vector3.crossVectors(a, b) ⇒ [<code>Vector3</code>](#Vector3)
Calculates the cross product of the given vectors and stores the result
in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector3</code>](#Vector3) | The first vector. |
| b | [<code>Vector3</code>](#Vector3) | The second vector. |

<a name="Vector3+projectOnVector"></a>

### vector3.projectOnVector(v) ⇒ [<code>Vector3</code>](#Vector3)
Projects this vector onto the given one.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to project to. |

<a name="Vector3+projectOnPlane"></a>

### vector3.projectOnPlane(planeNormal) ⇒ [<code>Vector3</code>](#Vector3)
Projects this vector onto a plane by subtracting this
vector projected onto the plane's normal from this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| planeNormal | [<code>Vector3</code>](#Vector3) | The plane normal. |

<a name="Vector3+reflect"></a>

### vector3.reflect(normal) ⇒ [<code>Vector3</code>](#Vector3)
Reflects this vector off a plane orthogonal to the given normal vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| normal | [<code>Vector3</code>](#Vector3) | The (normalized) normal vector. |

<a name="Vector3+angleTo"></a>

### vector3.angleTo(v) ⇒ <code>number</code>
Returns the angle between the given vector and this instance in radians.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The angle in radians.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the angle with. |

<a name="Vector3+distanceTo"></a>

### vector3.distanceTo(v) ⇒ <code>number</code>
Computes the distance from the given vector to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the distance to. |

<a name="Vector3+distanceToSquared"></a>

### vector3.distanceToSquared(v) ⇒ <code>number</code>
Computes the squared distance from the given vector to this instance.
If you are just comparing the distance with another distance, you should compare
the distance squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The squared distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the squared distance to. |

<a name="Vector3+manhattanDistanceTo"></a>

### vector3.manhattanDistanceTo(v) ⇒ <code>number</code>
Computes the Manhattan distance from the given vector to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The Manhattan distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the Manhattan distance to. |

<a name="Vector3+setFromSpherical"></a>

### vector3.setFromSpherical(s) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given spherical coordinates.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>Spherical</code> | The spherical coordinates. |

<a name="Vector3+setFromSphericalCoords"></a>

### vector3.setFromSphericalCoords(radius, phi, theta) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given spherical coordinates.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| radius | <code>number</code> | The radius. |
| phi | <code>number</code> | The phi angle in radians. |
| theta | <code>number</code> | The theta angle in radians. |

<a name="Vector3+setFromCylindrical"></a>

### vector3.setFromCylindrical(c) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given cylindrical coordinates.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| c | <code>Cylindrical</code> | The cylindrical coordinates. |

<a name="Vector3+setFromCylindricalCoords"></a>

### vector3.setFromCylindricalCoords(radius, theta, y) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given cylindrical coordinates.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| radius | <code>number</code> | The radius. |
| theta | <code>number</code> | The theta angle in radians. |
| y | <code>number</code> | The y value. |

<a name="Vector3+setFromMatrixPosition"></a>

### vector3.setFromMatrixPosition(m) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components to the position elements of the
given transformation matrix.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Vector3+setFromMatrixScale"></a>

### vector3.setFromMatrixScale(m) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components to the scale elements of the
given transformation matrix.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Vector3+setFromMatrixColumn"></a>

### vector3.setFromMatrixColumn(m, index) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the specified matrix column.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |
| index | <code>number</code> | The column index. |

<a name="Vector3+setFromMatrix3Column"></a>

### vector3.setFromMatrix3Column(m, index) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the specified matrix column.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The 3x3 matrix. |
| index | <code>number</code> | The column index. |

<a name="Vector3+setFromEuler"></a>

### vector3.setFromEuler(e) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given Euler angles.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| e | <code>Euler</code> | The Euler angles to set. |

<a name="Vector3+setFromColor"></a>

### vector3.setFromColor(c) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the RGB components of the
given color.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| c | <code>Color</code> | The color to set. |

<a name="Vector3+equals"></a>

### vector3.equals(v) ⇒ <code>boolean</code>
Returns `true` if this vector is equal with the given one.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>boolean</code> - Whether this vector is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to test for equality. |

<a name="Vector3+fromArray"></a>

### vector3.fromArray(array, [offset]) ⇒ [<code>Vector3</code>](#Vector3)
Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
and z value to be `array[ offset + 2 ]`.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the vector component values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Vector3+toArray"></a>

### vector3.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the components of this vector to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>Array.&lt;number&gt;</code> - The vector components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the vector components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Vector3+fromBufferAttribute"></a>

### vector3.fromBufferAttribute(attribute, index) ⇒ [<code>Vector3</code>](#Vector3)
Sets the components of this vector from the given buffer attribute.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding vector data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Vector3+random"></a>

### vector3.random() ⇒ [<code>Vector3</code>](#Vector3)
Sets each component of this vector to a pseudo-random value between `0` and
`1`, excluding `1`.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+randomDirection"></a>

### vector3.randomDirection() ⇒ [<code>Vector3</code>](#Vector3)
Sets this vector to a uniformly random point on a unit sphere.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector4"></a>

## Vector4
Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
(labeled x, y, z and w), which can be used to represent a number of things, such as:

- A point in 4D space.
- A direction and length in 4D space. In three.js the length will
always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
- Any arbitrary ordered quadruplet of numbers.

There are other things a 4D vector can be used to represent, however these
are the most common uses in *three.js*.

Iterating through a vector instance will yield its components `(x, y, z, w)` in
the corresponding order.
```js
const a = new THREE.Vector4( 0, 1, 0, 0 );

//no arguments; will be initialised to (0, 0, 0, 1)
const b = new THREE.Vector4( );

const d = a.dot( b );
```

**Kind**: global class  

* [Vector4](#Vector4)
    * [new Vector4([x], [y], [z], [w])](#new_Vector4_new)
    * [.isVector4](#Vector4+isVector4) : <code>boolean</code>
    * [.x](#Vector4+x) : <code>number</code>
    * [.y](#Vector4+y) : <code>number</code>
    * [.z](#Vector4+z) : <code>number</code>
    * [.w](#Vector4+w) : <code>number</code>
    * [.width](#Vector4+width) : <code>number</code>
    * [.height](#Vector4+height) : <code>number</code>
    * [.set(x, y, z, w)](#Vector4+set) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setScalar(scalar)](#Vector4+setScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setX(x)](#Vector4+setX) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setY(y)](#Vector4+setY) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setZ(z)](#Vector4+setZ) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setW(w)](#Vector4+setW) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setComponent(index, value)](#Vector4+setComponent) ⇒ [<code>Vector4</code>](#Vector4)
    * [.getComponent(index)](#Vector4+getComponent) ⇒ <code>number</code>
    * [.clone()](#Vector4+clone) ⇒ [<code>Vector4</code>](#Vector4)
    * [.copy(v)](#Vector4+copy) ⇒ [<code>Vector4</code>](#Vector4)
    * [.add(v)](#Vector4+add) ⇒ [<code>Vector4</code>](#Vector4)
    * [.addScalar(s)](#Vector4+addScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.addVectors(a, b)](#Vector4+addVectors) ⇒ [<code>Vector4</code>](#Vector4)
    * [.addScaledVector(v, s)](#Vector4+addScaledVector) ⇒ [<code>Vector4</code>](#Vector4)
    * [.sub(v)](#Vector4+sub) ⇒ [<code>Vector4</code>](#Vector4)
    * [.subScalar(s)](#Vector4+subScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.subVectors(a, b)](#Vector4+subVectors) ⇒ [<code>Vector4</code>](#Vector4)
    * [.multiply(v)](#Vector4+multiply) ⇒ [<code>Vector4</code>](#Vector4)
    * [.multiplyScalar(scalar)](#Vector4+multiplyScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.applyMatrix4(m)](#Vector4+applyMatrix4) ⇒ [<code>Vector4</code>](#Vector4)
    * [.divide(v)](#Vector4+divide) ⇒ [<code>Vector4</code>](#Vector4)
    * [.divideScalar(scalar)](#Vector4+divideScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setAxisAngleFromQuaternion(q)](#Vector4+setAxisAngleFromQuaternion) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setAxisAngleFromRotationMatrix(m)](#Vector4+setAxisAngleFromRotationMatrix) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setFromMatrixPosition(m)](#Vector4+setFromMatrixPosition) ⇒ [<code>Vector4</code>](#Vector4)
    * [.min(v)](#Vector4+min) ⇒ [<code>Vector4</code>](#Vector4)
    * [.max(v)](#Vector4+max) ⇒ [<code>Vector4</code>](#Vector4)
    * [.clamp(min, max)](#Vector4+clamp) ⇒ [<code>Vector4</code>](#Vector4)
    * [.clampScalar(minVal, maxVal)](#Vector4+clampScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.clampLength(min, max)](#Vector4+clampLength) ⇒ [<code>Vector4</code>](#Vector4)
    * [.floor()](#Vector4+floor) ⇒ [<code>Vector4</code>](#Vector4)
    * [.ceil()](#Vector4+ceil) ⇒ [<code>Vector4</code>](#Vector4)
    * [.round()](#Vector4+round) ⇒ [<code>Vector4</code>](#Vector4)
    * [.roundToZero()](#Vector4+roundToZero) ⇒ [<code>Vector4</code>](#Vector4)
    * [.negate()](#Vector4+negate) ⇒ [<code>Vector4</code>](#Vector4)
    * [.dot(v)](#Vector4+dot) ⇒ <code>number</code>
    * [.lengthSq()](#Vector4+lengthSq) ⇒ <code>number</code>
    * [.length()](#Vector4+length) ⇒ <code>number</code>
    * [.manhattanLength()](#Vector4+manhattanLength) ⇒ <code>number</code>
    * [.normalize()](#Vector4+normalize) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setLength(length)](#Vector4+setLength) ⇒ [<code>Vector4</code>](#Vector4)
    * [.lerp(v, alpha)](#Vector4+lerp) ⇒ [<code>Vector4</code>](#Vector4)
    * [.lerpVectors(v1, v2, alpha)](#Vector4+lerpVectors) ⇒ [<code>Vector4</code>](#Vector4)
    * [.equals(v)](#Vector4+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Vector4+fromArray) ⇒ [<code>Vector4</code>](#Vector4)
    * [.toArray([array], [offset])](#Vector4+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.fromBufferAttribute(attribute, index)](#Vector4+fromBufferAttribute) ⇒ [<code>Vector4</code>](#Vector4)
    * [.random()](#Vector4+random) ⇒ [<code>Vector4</code>](#Vector4)

<a name="new_Vector4_new"></a>

### new Vector4([x], [y], [z], [w])
Constructs a new 4D vector.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The x value of this vector. |
| [y] | <code>number</code> | <code>0</code> | The y value of this vector. |
| [z] | <code>number</code> | <code>0</code> | The z value of this vector. |
| [w] | <code>number</code> | <code>1</code> | The w value of this vector. |

<a name="Vector4+isVector4"></a>

### vector4.isVector4 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Vector4+x"></a>

### vector4.x : <code>number</code>
The x value of this vector.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+y"></a>

### vector4.y : <code>number</code>
The y value of this vector.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+z"></a>

### vector4.z : <code>number</code>
The z value of this vector.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+w"></a>

### vector4.w : <code>number</code>
The w value of this vector.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+width"></a>

### vector4.width : <code>number</code>
Alias for [z](#Vector4+z).

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+height"></a>

### vector4.height : <code>number</code>
Alias for [w](#Vector4+w).

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+set"></a>

### vector4.set(x, y, z, w) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector components.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value of the x component. |
| y | <code>number</code> | The value of the y component. |
| z | <code>number</code> | The value of the z component. |
| w | <code>number</code> | The value of the w component. |

<a name="Vector4+setScalar"></a>

### vector4.setScalar(scalar) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector components to the same value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The value to set for all vector components. |

<a name="Vector4+setX"></a>

### vector4.setX(x) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector's x component to the given value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to set. |

<a name="Vector4+setY"></a>

### vector4.setY(y) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector's y component to the given value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| y | <code>number</code> | The value to set. |

<a name="Vector4+setZ"></a>

### vector4.setZ(z) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector's z component to the given value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| z | <code>number</code> | The value to set. |

<a name="Vector4+setW"></a>

### vector4.setW(w) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector's w component to the given value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| w | <code>number</code> | The value to set. |

<a name="Vector4+setComponent"></a>

### vector4.setComponent(index, value) ⇒ [<code>Vector4</code>](#Vector4)
Allows to set a vector component with an index.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y, `2` equals to z, `3` equals to w. |
| value | <code>number</code> | The value to set. |

<a name="Vector4+getComponent"></a>

### vector4.getComponent(index) ⇒ <code>number</code>
Returns the value of the vector component which matches the given index.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - A vector component value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y, `2` equals to z, `3` equals to w. |

<a name="Vector4+clone"></a>

### vector4.clone() ⇒ [<code>Vector4</code>](#Vector4)
Returns a new vector with copied values from this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A clone of this instance.  
<a name="Vector4+copy"></a>

### vector4.copy(v) ⇒ [<code>Vector4</code>](#Vector4)
Copies the values of the given vector to this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> \| [<code>Vector4</code>](#Vector4) | The vector to copy. |

<a name="Vector4+add"></a>

### vector4.add(v) ⇒ [<code>Vector4</code>](#Vector4)
Adds the given vector to this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to add. |

<a name="Vector4+addScalar"></a>

### vector4.addScalar(s) ⇒ [<code>Vector4</code>](#Vector4)
Adds the given scalar value to all components of this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to add. |

<a name="Vector4+addVectors"></a>

### vector4.addVectors(a, b) ⇒ [<code>Vector4</code>](#Vector4)
Adds the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector4</code>](#Vector4) | The first vector. |
| b | [<code>Vector4</code>](#Vector4) | The second vector. |

<a name="Vector4+addScaledVector"></a>

### vector4.addScaledVector(v, s) ⇒ [<code>Vector4</code>](#Vector4)
Adds the given vector scaled by the given factor to this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector. |
| s | <code>number</code> | The factor that scales `v`. |

<a name="Vector4+sub"></a>

### vector4.sub(v) ⇒ [<code>Vector4</code>](#Vector4)
Subtracts the given vector from this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to subtract. |

<a name="Vector4+subScalar"></a>

### vector4.subScalar(s) ⇒ [<code>Vector4</code>](#Vector4)
Subtracts the given scalar value from all components of this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to subtract. |

<a name="Vector4+subVectors"></a>

### vector4.subVectors(a, b) ⇒ [<code>Vector4</code>](#Vector4)
Subtracts the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector4</code>](#Vector4) | The first vector. |
| b | [<code>Vector4</code>](#Vector4) | The second vector. |

<a name="Vector4+multiply"></a>

### vector4.multiply(v) ⇒ [<code>Vector4</code>](#Vector4)
Multiplies the given vector with this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to multiply. |

<a name="Vector4+multiplyScalar"></a>

### vector4.multiplyScalar(scalar) ⇒ [<code>Vector4</code>](#Vector4)
Multiplies the given scalar value with all components of this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to multiply. |

<a name="Vector4+applyMatrix4"></a>

### vector4.applyMatrix4(m) ⇒ [<code>Vector4</code>](#Vector4)
Multiplies this vector with the given 4x4 matrix.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Vector4+divide"></a>

### vector4.divide(v) ⇒ [<code>Vector4</code>](#Vector4)
Divides this instance by the given vector.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to divide. |

<a name="Vector4+divideScalar"></a>

### vector4.divideScalar(scalar) ⇒ [<code>Vector4</code>](#Vector4)
Divides this vector by the given scalar.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to divide. |

<a name="Vector4+setAxisAngleFromQuaternion"></a>

### vector4.setAxisAngleFromQuaternion(q) ⇒ [<code>Vector4</code>](#Vector4)
Sets the x, y and z components of this
vector to the quaternion's axis and w to the angle.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The Quaternion to set. |

<a name="Vector4+setAxisAngleFromRotationMatrix"></a>

### vector4.setAxisAngleFromRotationMatrix(m) ⇒ [<code>Vector4</code>](#Vector4)
Sets the x, y and z components of this
vector to the axis of rotation and w to the angle.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix. |

<a name="Vector4+setFromMatrixPosition"></a>

### vector4.setFromMatrixPosition(m) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector components to the position elements of the
given transformation matrix.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Vector4+min"></a>

### vector4.min(v) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
value, replace that value with the corresponding min value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector. |

<a name="Vector4+max"></a>

### vector4.max(v) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's x, y, z or w value is less than the given vector's x, y, z or w
value, replace that value with the corresponding max value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector. |

<a name="Vector4+clamp"></a>

### vector4.clamp(min, max) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
value, it is replaced by the corresponding value.
If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
it is replaced by the corresponding value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | [<code>Vector4</code>](#Vector4) | The minimum x, y and z values. |
| max | [<code>Vector4</code>](#Vector4) | The maximum x, y and z values in the desired range. |

<a name="Vector4+clampScalar"></a>

### vector4.clampScalar(minVal, maxVal) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's x, y, z or w values are greater than the max value, they are
replaced by the max value.
If this vector's x, y, z or w values are less than the min value, they are
replaced by the min value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| minVal | <code>number</code> | The minimum value the components will be clamped to. |
| maxVal | <code>number</code> | The maximum value the components will be clamped to. |

<a name="Vector4+clampLength"></a>

### vector4.clampLength(min, max) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's length is greater than the max value, it is replaced by
the max value.
If this vector's length is less than the min value, it is replaced by the
min value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>number</code> | The minimum value the vector length will be clamped to. |
| max | <code>number</code> | The maximum value the vector length will be clamped to. |

<a name="Vector4+floor"></a>

### vector4.floor() ⇒ [<code>Vector4</code>](#Vector4)
The components of this vector are rounded down to the nearest integer value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+ceil"></a>

### vector4.ceil() ⇒ [<code>Vector4</code>](#Vector4)
The components of this vector are rounded up to the nearest integer value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+round"></a>

### vector4.round() ⇒ [<code>Vector4</code>](#Vector4)
The components of this vector are rounded to the nearest integer value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+roundToZero"></a>

### vector4.roundToZero() ⇒ [<code>Vector4</code>](#Vector4)
The components of this vector are rounded towards zero (up if negative,
down if positive) to an integer value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+negate"></a>

### vector4.negate() ⇒ [<code>Vector4</code>](#Vector4)
Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+dot"></a>

### vector4.dot(v) ⇒ <code>number</code>
Calculates the dot product of the given vector with this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - The result of the dot product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to compute the dot product with. |

<a name="Vector4+lengthSq"></a>

### vector4.lengthSq() ⇒ <code>number</code>
Computes the square of the Euclidean length (straight-line length) from
(0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
compare the length squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - The square length of this vector.  
<a name="Vector4+length"></a>

### vector4.length() ⇒ <code>number</code>
Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector4+manhattanLength"></a>

### vector4.manhattanLength() ⇒ <code>number</code>
Computes the Manhattan length of this vector.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector4+normalize"></a>

### vector4.normalize() ⇒ [<code>Vector4</code>](#Vector4)
Converts this vector to a unit vector - that is, sets it equal to a vector
with the same direction as this one, but with a vector length of `1`.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+setLength"></a>

### vector4.setLength(length) ⇒ [<code>Vector4</code>](#Vector4)
Sets this vector to a vector with the same direction as this one, but
with the specified length.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| length | <code>number</code> | The new length of this vector. |

<a name="Vector4+lerp"></a>

### vector4.lerp(v, alpha) ⇒ [<code>Vector4</code>](#Vector4)
Linearly interpolates between the given vector and this instance, where
alpha is the percent distance along the line - alpha = 0 will be this
vector, and alpha = 1 will be the given one.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to interpolate towards. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector4+lerpVectors"></a>

### vector4.lerpVectors(v1, v2, alpha) ⇒ [<code>Vector4</code>](#Vector4)
Linearly interpolates between the given vectors, where alpha is the percent
distance along the line - alpha = 0 will be first vector, and alpha = 1 will
be the second one. The result is stored in this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v1 | [<code>Vector4</code>](#Vector4) | The first vector. |
| v2 | [<code>Vector4</code>](#Vector4) | The second vector. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector4+equals"></a>

### vector4.equals(v) ⇒ <code>boolean</code>
Returns `true` if this vector is equal with the given one.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>boolean</code> - Whether this vector is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to test for equality. |

<a name="Vector4+fromArray"></a>

### vector4.fromArray(array, [offset]) ⇒ [<code>Vector4</code>](#Vector4)
Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the vector component values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Vector4+toArray"></a>

### vector4.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the components of this vector to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>Array.&lt;number&gt;</code> - The vector components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the vector components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Vector4+fromBufferAttribute"></a>

### vector4.fromBufferAttribute(attribute, index) ⇒ [<code>Vector4</code>](#Vector4)
Sets the components of this vector from the given buffer attribute.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding vector data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Vector4+random"></a>

### vector4.random() ⇒ [<code>Vector4</code>](#Vector4)
Sets each component of this vector to a pseudo-random value between `0` and
`1`, excluding `1`.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="CubicInterpolant"></a>

## CubicInterpolant ⇐ <code>Interpolant</code>
Fast and simple cubic spline interpolant.

It was derived from a Hermitian construction setting the first derivative
at each sample position to the linear slope between neighboring positions
over their parameter interval.

**Kind**: global class  
**Extends**: <code>Interpolant</code>  
<a name="new_CubicInterpolant_new"></a>

### new CubicInterpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])
Constructs a new cubic interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

<a name="DiscreteInterpolant"></a>

## DiscreteInterpolant ⇐ <code>Interpolant</code>
Interpolant that evaluates to the sample value at the position preceding
the parameter.

**Kind**: global class  
**Extends**: <code>Interpolant</code>  
<a name="new_DiscreteInterpolant_new"></a>

### new DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])
Constructs a new discrete interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

<a name="LinearInterpolant"></a>

## LinearInterpolant ⇐ <code>Interpolant</code>
A basic linear interpolant.

**Kind**: global class  
**Extends**: <code>Interpolant</code>  
<a name="new_LinearInterpolant_new"></a>

### new LinearInterpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])
Constructs a new linear interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

<a name="QuaternionLinearInterpolant"></a>

## QuaternionLinearInterpolant ⇐ <code>Interpolant</code>
Spherical linear unit quaternion interpolant.

**Kind**: global class  
**Extends**: <code>Interpolant</code>  
<a name="new_QuaternionLinearInterpolant_new"></a>

### new QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])
Constructs a new SLERP interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

## Constants

<dl>
<dt><a href="#TBNViewMatrix">TBNViewMatrix</a> : <code>Node.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the TBN matrix in view space.</p>
</dd>
<dt><a href="#parallaxDirection">parallaxDirection</a> : <code>Node.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the parallax direction.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#parallaxUV">parallaxUV(uv, scale)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>TSL function for computing parallax uv coordinates.</p>
</dd>
<dt><a href="#transformedBentNormalView">transformedBentNormalView()</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for computing bent normals.</p>
</dd>
</dl>

<a name="TBNViewMatrix"></a>

## TBNViewMatrix : <code>Node.&lt;mat3&gt;</code>
TSL object that represents the TBN matrix in view space.

**Kind**: global constant  
**Tsl**:   
<a name="parallaxDirection"></a>

## parallaxDirection : <code>Node.&lt;mat3&gt;</code>
TSL object that represents the parallax direction.

**Kind**: global constant  
**Tsl**:   
<a name="parallaxUV"></a>

## parallaxUV(uv, scale) ⇒ <code>Node.&lt;vec2&gt;</code>
TSL function for computing parallax uv coordinates.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - Parallax uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | A uv node. |
| scale | <code>Node.&lt;vec2&gt;</code> | A scale node. |

<a name="transformedBentNormalView"></a>

## transformedBentNormalView() ⇒ <code>Node.&lt;vec3&gt;</code>
TSL function for computing bent normals.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - Bent normals.  
**Tsl**:   
## Functions

<dl>
<dt><a href="#attributeArray">attributeArray(count, [type])</a> ⇒ <code>StorageBufferNode</code></dt>
<dd><p>TSL function for creating a storage buffer node with a configured <code>StorageBufferAttribute</code>.</p>
</dd>
<dt><a href="#instancedArray">instancedArray(count, [type])</a> ⇒ <code>StorageBufferNode</code></dt>
<dd><p>TSL function for creating a storage buffer node with a configured <code>StorageInstancedBufferAttribute</code>.</p>
</dd>
</dl>

<a name="attributeArray"></a>

## attributeArray(count, [type]) ⇒ <code>StorageBufferNode</code>
TSL function for creating a storage buffer node with a configured `StorageBufferAttribute`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> \| <code>TypedArray</code> |  | The data count. It is also valid to pass a typed array as an argument. |
| [type] | <code>string</code> \| <code>Struct</code> | <code>&quot;&#x27;float&#x27;&quot;</code> | The data type. |

<a name="instancedArray"></a>

## instancedArray(count, [type]) ⇒ <code>StorageBufferNode</code>
TSL function for creating a storage buffer node with a configured `StorageInstancedBufferAttribute`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> \| <code>TypedArray</code> |  | The data count. It is also valid to pass a typed array as an argument. |
| [type] | <code>string</code> \| <code>Struct</code> | <code>&quot;&#x27;float&#x27;&quot;</code> | The data type. |

## Classes

<dl>
<dt><a href="#BatchNode">BatchNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node implements the vertex shader logic which is required
when rendering 3D objects via batching. <code>BatchNode</code> must be used
with instances of <a href="BatchedMesh">BatchedMesh</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#batch">batch(batchMesh)</a> ⇒ <code><a href="#BatchNode">BatchNode</a></code></dt>
<dd><p>TSL function for creating a batch node.</p>
</dd>
</dl>

<a name="BatchNode"></a>

## BatchNode ⇐ <code>Node</code>
This node implements the vertex shader logic which is required
when rendering 3D objects via batching. `BatchNode` must be used
with instances of [BatchedMesh](BatchedMesh).

**Kind**: global class  
**Extends**: <code>Node</code>  

* [BatchNode](#BatchNode) ⇐ <code>Node</code>
    * [new BatchNode(batchMesh)](#new_BatchNode_new)
    * [.batchMesh](#BatchNode+batchMesh) : <code>BatchedMesh</code>
    * [.batchingIdNode](#BatchNode+batchingIdNode) : <code>IndexNode</code>
    * [.setup(builder)](#BatchNode+setup)

<a name="new_BatchNode_new"></a>

### new BatchNode(batchMesh)
Constructs a new batch node.


| Param | Type | Description |
| --- | --- | --- |
| batchMesh | <code>BatchedMesh</code> | A reference to batched mesh. |

<a name="BatchNode+batchMesh"></a>

### batchNode.batchMesh : <code>BatchedMesh</code>
A reference to batched mesh.

**Kind**: instance property of [<code>BatchNode</code>](#BatchNode)  
<a name="BatchNode+batchingIdNode"></a>

### batchNode.batchingIdNode : <code>IndexNode</code>
The batching index node.

**Kind**: instance property of [<code>BatchNode</code>](#BatchNode)  
**Default**: <code>null</code>  
<a name="BatchNode+setup"></a>

### batchNode.setup(builder)
Setups the internal buffers and nodes and assigns the transformed vertex data
to predefined node variables for accumulation. That follows the same patterns
like with morph and skinning nodes.

**Kind**: instance method of [<code>BatchNode</code>](#BatchNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="batch"></a>

## batch(batchMesh) ⇒ [<code>BatchNode</code>](#BatchNode)
TSL function for creating a batch node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| batchMesh | <code>BatchedMesh</code> | A reference to batched mesh. |

## Constants

<dl>
<dt><a href="#bitangentGeometry">bitangentGeometry</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the bitangent attribute of the current rendered object.</p>
</dd>
<dt><a href="#bitangentLocal">bitangentLocal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex bitangent in local space of the current rendered object.</p>
</dd>
<dt><a href="#bitangentView">bitangentView</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the vertex bitangent in view space of the current rendered object.</p>
</dd>
<dt><a href="#bitangentWorld">bitangentWorld</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the vertex bitangent in world space of the current rendered object.</p>
</dd>
<dt><a href="#transformedBitangentView">transformedBitangentView</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex bitangent in view space of the current rendered object.</p>
</dd>
<dt><a href="#transformedBitangentWorld">transformedBitangentWorld</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex bitangent in world space of the current rendered object.</p>
</dd>
</dl>

<a name="bitangentGeometry"></a>

## bitangentGeometry : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the bitangent attribute of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="bitangentLocal"></a>

## bitangentLocal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex bitangent in local space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="bitangentView"></a>

## bitangentView : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the vertex bitangent in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="bitangentWorld"></a>

## bitangentWorld : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the vertex bitangent in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedBitangentView"></a>

## transformedBitangentView : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the transformed vertex bitangent in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedBitangentWorld"></a>

## transformedBitangentWorld : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the transformed vertex bitangent in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#BufferAttributeNode">BufferAttributeNode</a> ⇐ <code>InputNode</code></dt>
<dd><p>In earlier <code>three.js</code> versions it was only possible to define attribute data
on geometry level. With <code>BufferAttributeNode</code>, it is also possible to do this
on the node level.</p>
<pre><code class="language-js">const geometry = new THREE.PlaneGeometry();
const positionAttribute = geometry.getAttribute( &#39;position&#39; );

const colors = [];
for ( let i = 0; i &lt; position.count; i ++ ) {
    colors.push( 1, 0, 0 );
}

material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );
</code></pre>
<p>This new approach is especially interesting when geometry data are generated via
compute shaders. The below line converts a storage buffer into an attribute node.</p>
<pre><code class="language-js">material.positionNode = positionBuffer.toAttribute();
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bufferAttribute">bufferAttribute(array, [type], [stride], [offset])</a> ⇒ <code><a href="#BufferAttributeNode">BufferAttributeNode</a></code></dt>
<dd><p>TSL function for creating a buffer attribute node.</p>
</dd>
<dt><a href="#dynamicBufferAttribute">dynamicBufferAttribute(array, [type], [stride], [offset])</a> ⇒ <code><a href="#BufferAttributeNode">BufferAttributeNode</a></code></dt>
<dd><p>TSL function for creating a buffer attribute node but with dynamic draw usage.
Use this function if attribute data are updated per frame.</p>
</dd>
<dt><a href="#instancedBufferAttribute">instancedBufferAttribute(array, [type], [stride], [offset])</a> ⇒ <code><a href="#BufferAttributeNode">BufferAttributeNode</a></code></dt>
<dd><p>TSL function for creating a buffer attribute node but with enabled instancing</p>
</dd>
<dt><a href="#instancedDynamicBufferAttribute">instancedDynamicBufferAttribute(array, [type], [stride], [offset])</a> ⇒ <code><a href="#BufferAttributeNode">BufferAttributeNode</a></code></dt>
<dd><p>TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing</p>
</dd>
</dl>

<a name="BufferAttributeNode"></a>

## BufferAttributeNode ⇐ <code>InputNode</code>
In earlier `three.js` versions it was only possible to define attribute data
on geometry level. With `BufferAttributeNode`, it is also possible to do this
on the node level.
```js
const geometry = new THREE.PlaneGeometry();
const positionAttribute = geometry.getAttribute( 'position' );

const colors = [];
for ( let i = 0; i < position.count; i ++ ) {
	colors.push( 1, 0, 0 );
}

material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );
```
This new approach is especially interesting when geometry data are generated via
compute shaders. The below line converts a storage buffer into an attribute node.
```js
material.positionNode = positionBuffer.toAttribute();
```

**Kind**: global class  
**Extends**: <code>InputNode</code>  

* [BufferAttributeNode](#BufferAttributeNode) ⇐ <code>InputNode</code>
    * [new BufferAttributeNode(value, [bufferType], [bufferStride], [bufferOffset])](#new_BufferAttributeNode_new)
    * [.isBufferNode](#BufferAttributeNode+isBufferNode) : <code>boolean</code>
    * [.bufferType](#BufferAttributeNode+bufferType) : <code>string</code>
    * [.bufferStride](#BufferAttributeNode+bufferStride) : <code>number</code>
    * [.bufferOffset](#BufferAttributeNode+bufferOffset) : <code>number</code>
    * [.usage](#BufferAttributeNode+usage) : <code>number</code>
    * [.instanced](#BufferAttributeNode+instanced) : <code>boolean</code>
    * [.attribute](#BufferAttributeNode+attribute) : <code>BufferAttribute</code>
    * [.global](#BufferAttributeNode+global) : <code>boolean</code>
    * [.getHash(builder)](#BufferAttributeNode+getHash) ⇒ <code>string</code>
    * [.getNodeType(builder)](#BufferAttributeNode+getNodeType) ⇒ <code>string</code>
    * [.setup(builder)](#BufferAttributeNode+setup)
    * [.generate(builder)](#BufferAttributeNode+generate) ⇒ <code>string</code>
    * [.getInputType(builder)](#BufferAttributeNode+getInputType) ⇒ <code>string</code>
    * [.setUsage(value)](#BufferAttributeNode+setUsage) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
    * [.setInstanced(value)](#BufferAttributeNode+setInstanced) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)

<a name="new_BufferAttributeNode_new"></a>

### new BufferAttributeNode(value, [bufferType], [bufferStride], [bufferOffset])
Constructs a new buffer attribute node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [bufferType] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [bufferStride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [bufferOffset] | <code>number</code> | <code>0</code> | The buffer offset. |

<a name="BufferAttributeNode+isBufferNode"></a>

### bufferAttributeNode.isBufferNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BufferAttributeNode+bufferType"></a>

### bufferAttributeNode.bufferType : <code>string</code>
The buffer type (e.g. `'vec3'`).

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="BufferAttributeNode+bufferStride"></a>

### bufferAttributeNode.bufferStride : <code>number</code>
The buffer stride.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>0</code>  
<a name="BufferAttributeNode+bufferOffset"></a>

### bufferAttributeNode.bufferOffset : <code>number</code>
The buffer offset.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>0</code>  
<a name="BufferAttributeNode+usage"></a>

### bufferAttributeNode.usage : <code>number</code>
The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,
if you are planning to update the attribute data per frame.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>StaticDrawUsage</code>  
<a name="BufferAttributeNode+instanced"></a>

### bufferAttributeNode.instanced : <code>boolean</code>
Whether the attribute is instanced or not.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>false</code>  
<a name="BufferAttributeNode+attribute"></a>

### bufferAttributeNode.attribute : <code>BufferAttribute</code>
A reference to the buffer attribute.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>null</code>  
<a name="BufferAttributeNode+global"></a>

### bufferAttributeNode.global : <code>boolean</code>
`BufferAttributeNode` sets this property to `true` by default.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>true</code>  
<a name="BufferAttributeNode+getHash"></a>

### bufferAttributeNode.getHash(builder) ⇒ <code>string</code>
This method is overwritten since the attribute data might be shared
and thus the hash should be shared as well.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: <code>string</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+getNodeType"></a>

### bufferAttributeNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the buffer attribute.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+setup"></a>

### bufferAttributeNode.setup(builder)
Depending on which value was passed to the node, `setup()` behaves
differently. If no instance of `BufferAttribute` was passed, the method
creates an internal attribute and configures it respectively.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+generate"></a>

### bufferAttributeNode.generate(builder) ⇒ <code>string</code>
Generates the code snippet of the buffer attribute node.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+getInputType"></a>

### bufferAttributeNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'bufferAttribute'`.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+setUsage"></a>

### bufferAttributeNode.setUsage(value) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
Sets the `usage` property to the given value.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: [<code>BufferAttributeNode</code>](#BufferAttributeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The usage to set. |

<a name="BufferAttributeNode+setInstanced"></a>

### bufferAttributeNode.setInstanced(value) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
Sets the `instanced` property to the given value.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: [<code>BufferAttributeNode</code>](#BufferAttributeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The value to set. |

<a name="bufferAttribute"></a>

## bufferAttribute(array, [type], [stride], [offset]) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
TSL function for creating a buffer attribute node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [type] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [stride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [offset] | <code>number</code> | <code>0</code> | The buffer offset. |

<a name="dynamicBufferAttribute"></a>

## dynamicBufferAttribute(array, [type], [stride], [offset]) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
TSL function for creating a buffer attribute node but with dynamic draw usage.
Use this function if attribute data are updated per frame.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [type] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [stride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [offset] | <code>number</code> | <code>0</code> | The buffer offset. |

<a name="instancedBufferAttribute"></a>

## instancedBufferAttribute(array, [type], [stride], [offset]) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
TSL function for creating a buffer attribute node but with enabled instancing

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [type] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [stride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [offset] | <code>number</code> | <code>0</code> | The buffer offset. |

<a name="instancedDynamicBufferAttribute"></a>

## instancedDynamicBufferAttribute(array, [type], [stride], [offset]) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [type] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [stride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [offset] | <code>number</code> | <code>0</code> | The buffer offset. |

## Classes

<dl>
<dt><a href="#BufferNode">BufferNode</a> ⇐ <code>UniformNode</code></dt>
<dd><p>A special type of uniform node which represents array-like data
as uniform buffers. The access usually happens via <code>element()</code>
which returns an instance of <a href="ArrayElementNode">ArrayElementNode</a>. For example:</p>
<pre><code class="language-js">const bufferNode = buffer( array, &#39;mat4&#39;, count );
const matrixNode = bufferNode.element( index ); // access a matrix from the buffer
</code></pre>
<p>In general, it is recommended to use the more managed <a href="UniformArrayNode">UniformArrayNode</a>
since it handles more input types and automatically cares about buffer paddings.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#buffer">buffer(value, type, count)</a> ⇒ <code><a href="#BufferNode">BufferNode</a></code></dt>
<dd><p>TSL function for creating a buffer node.</p>
</dd>
</dl>

<a name="BufferNode"></a>

## BufferNode ⇐ <code>UniformNode</code>
A special type of uniform node which represents array-like data
as uniform buffers. The access usually happens via `element()`
which returns an instance of [ArrayElementNode](ArrayElementNode). For example:

```js
const bufferNode = buffer( array, 'mat4', count );
const matrixNode = bufferNode.element( index ); // access a matrix from the buffer
```
In general, it is recommended to use the more managed [UniformArrayNode](UniformArrayNode)
since it handles more input types and automatically cares about buffer paddings.

**Kind**: global class  
**Extends**: <code>UniformNode</code>  

* [BufferNode](#BufferNode) ⇐ <code>UniformNode</code>
    * [new BufferNode(value, bufferType, [bufferCount])](#new_BufferNode_new)
    * [.isBufferNode](#BufferNode+isBufferNode) : <code>boolean</code>
    * [.bufferType](#BufferNode+bufferType) : <code>string</code>
    * [.bufferCount](#BufferNode+bufferCount) : <code>number</code>
    * [.getElementType(builder)](#BufferNode+getElementType) ⇒ <code>string</code>
    * [.getInputType(builder)](#BufferNode+getInputType) ⇒ <code>string</code>

<a name="new_BufferNode_new"></a>

### new BufferNode(value, bufferType, [bufferCount])
Constructs a new buffer node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Array.&lt;number&gt;</code> |  | Array-like buffer data. |
| bufferType | <code>string</code> |  | The data type of the buffer. |
| [bufferCount] | <code>number</code> | <code>0</code> | The count of buffer elements. |

<a name="BufferNode+isBufferNode"></a>

### bufferNode.isBufferNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BufferNode</code>](#BufferNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BufferNode+bufferType"></a>

### bufferNode.bufferType : <code>string</code>
The data type of the buffer.

**Kind**: instance property of [<code>BufferNode</code>](#BufferNode)  
<a name="BufferNode+bufferCount"></a>

### bufferNode.bufferCount : <code>number</code>
The uniform node that holds the value of the reference node.

**Kind**: instance property of [<code>BufferNode</code>](#BufferNode)  
**Default**: <code>0</code>  
<a name="BufferNode+getElementType"></a>

### bufferNode.getElementType(builder) ⇒ <code>string</code>
The data type of the buffer elements.

**Kind**: instance method of [<code>BufferNode</code>](#BufferNode)  
**Returns**: <code>string</code> - The element type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferNode+getInputType"></a>

### bufferNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'buffer'`.

**Kind**: instance method of [<code>BufferNode</code>](#BufferNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="buffer"></a>

## buffer(value, type, count) ⇒ [<code>BufferNode</code>](#BufferNode)
TSL function for creating a buffer node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Array</code> | Array-like buffer data. |
| type | <code>string</code> | The data type of a buffer element. |
| count | <code>number</code> | The count of buffer elements. |

## Classes

<dl>
<dt><a href="#BuiltinNode">BuiltinNode</a> ⇐ <code>Node</code></dt>
<dd><p>The node allows to set values for built-in shader variables. That is
required for features like hardware-accelerated vertex clipping.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#builtin">builtin(name)</a> ⇒ <code><a href="#BuiltinNode">BuiltinNode</a></code></dt>
<dd><p>TSL function for creating a builtin node.</p>
</dd>
</dl>

<a name="BuiltinNode"></a>

## BuiltinNode ⇐ <code>Node</code>
The node allows to set values for built-in shader variables. That is
required for features like hardware-accelerated vertex clipping.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [BuiltinNode](#BuiltinNode) ⇐ <code>Node</code>
    * [new BuiltinNode(name)](#new_BuiltinNode_new)
    * [.name](#BuiltinNode+name) : <code>string</code>
    * [.isBuiltinNode](#BuiltinNode+isBuiltinNode) : <code>boolean</code>
    * [.generate(builder)](#BuiltinNode+generate) ⇒ <code>string</code>

<a name="new_BuiltinNode_new"></a>

### new BuiltinNode(name)
Constructs a new builtin node.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the built-in shader variable. |

<a name="BuiltinNode+name"></a>

### builtinNode.name : <code>string</code>
The name of the built-in shader variable.

**Kind**: instance property of [<code>BuiltinNode</code>](#BuiltinNode)  
<a name="BuiltinNode+isBuiltinNode"></a>

### builtinNode.isBuiltinNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BuiltinNode</code>](#BuiltinNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BuiltinNode+generate"></a>

### builtinNode.generate(builder) ⇒ <code>string</code>
Generates the code snippet of the builtin node.

**Kind**: instance method of [<code>BuiltinNode</code>](#BuiltinNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="builtin"></a>

## builtin(name) ⇒ [<code>BuiltinNode</code>](#BuiltinNode)
TSL function for creating a builtin node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the built-in shader variable. |

## Constants

<dl>
<dt><a href="#cameraIndex">cameraIndex</a> : <code>UniformNode.&lt;uint&gt;</code></dt>
<dd><p>TSL object that represents the current <code>index</code> value of the camera if used ArrayCamera.</p>
</dd>
<dt><a href="#cameraNear">cameraNear</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the <code>near</code> value of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraFar">cameraFar</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the <code>far</code> value of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraProjectionMatrix">cameraProjectionMatrix</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the projection matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraProjectionMatrixInverse">cameraProjectionMatrixInverse</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the inverse projection matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraViewMatrix">cameraViewMatrix</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the view matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraWorldMatrix">cameraWorldMatrix</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the world matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraNormalMatrix">cameraNormalMatrix</a> : <code>UniformNode.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the normal matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraPosition">cameraPosition</a> : <code>UniformNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the position in world space of the camera used for the current render.</p>
</dd>
</dl>

<a name="cameraIndex"></a>

## cameraIndex : <code>UniformNode.&lt;uint&gt;</code>
TSL object that represents the current `index` value of the camera if used ArrayCamera.

**Kind**: global constant  
**Tsl**:   
<a name="cameraNear"></a>

## cameraNear : <code>UniformNode.&lt;float&gt;</code>
TSL object that represents the `near` value of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraFar"></a>

## cameraFar : <code>UniformNode.&lt;float&gt;</code>
TSL object that represents the `far` value of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraProjectionMatrix"></a>

## cameraProjectionMatrix : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the projection matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraProjectionMatrixInverse"></a>

## cameraProjectionMatrixInverse : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the inverse projection matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraViewMatrix"></a>

## cameraViewMatrix : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the view matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraWorldMatrix"></a>

## cameraWorldMatrix : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the world matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraNormalMatrix"></a>

## cameraNormalMatrix : <code>UniformNode.&lt;mat3&gt;</code>
TSL object that represents the normal matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraPosition"></a>

## cameraPosition : <code>UniformNode.&lt;vec3&gt;</code>
TSL object that represents the position in world space of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#ClippingNode">ClippingNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node is used in <a href="NodeMaterial">NodeMaterial</a> to setup the clipping
which can happen hardware-accelerated (if supported) and optionally
use alpha-to-coverage for anti-aliasing clipped edges.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#clipping">clipping()</a> ⇒ <code><a href="#ClippingNode">ClippingNode</a></code></dt>
<dd><p>TSL function for setting up the default clipping logic.</p>
</dd>
<dt><a href="#clippingAlpha">clippingAlpha()</a> ⇒ <code><a href="#ClippingNode">ClippingNode</a></code></dt>
<dd><p>TSL function for setting up alpha to coverage.</p>
</dd>
<dt><a href="#hardwareClipping">hardwareClipping()</a> ⇒ <code><a href="#ClippingNode">ClippingNode</a></code></dt>
<dd><p>TSL function for setting up hardware-based clipping.</p>
</dd>
</dl>

<a name="ClippingNode"></a>

## ClippingNode ⇐ <code>Node</code>
This node is used in [NodeMaterial](NodeMaterial) to setup the clipping
which can happen hardware-accelerated (if supported) and optionally
use alpha-to-coverage for anti-aliasing clipped edges.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ClippingNode](#ClippingNode) ⇐ <code>Node</code>
    * [new ClippingNode([scope])](#new_ClippingNode_new)
    * [.scope](#ClippingNode+scope) : <code>&#x27;default&#x27;</code> \| <code>&#x27;hardware&#x27;</code> \| <code>&#x27;alphaToCoverage&#x27;</code>
    * [.setup(builder)](#ClippingNode+setup) ⇒ <code>Node</code>
    * [.setupAlphaToCoverage(intersectionPlanes, unionPlanes)](#ClippingNode+setupAlphaToCoverage) ⇒ <code>Node</code>
    * [.setupDefault(intersectionPlanes, unionPlanes)](#ClippingNode+setupDefault) ⇒ <code>Node</code>
    * [.setupHardwareClipping(unionPlanes, builder)](#ClippingNode+setupHardwareClipping) ⇒ <code>Node</code>

<a name="new_ClippingNode_new"></a>

### new ClippingNode([scope])
Constructs a new clipping node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scope] | <code>&#x27;default&#x27;</code> \| <code>&#x27;hardware&#x27;</code> \| <code>&#x27;alphaToCoverage&#x27;</code> | <code>&#x27;default&#x27;</code> | The node's scope. Similar to other nodes, the selected scope influences the behavior of the node and what type of code is generated. |

<a name="ClippingNode+scope"></a>

### clippingNode.scope : <code>&#x27;default&#x27;</code> \| <code>&#x27;hardware&#x27;</code> \| <code>&#x27;alphaToCoverage&#x27;</code>
The node's scope. Similar to other nodes, the selected scope influences
the behavior of the node and what type of code is generated.

**Kind**: instance property of [<code>ClippingNode</code>](#ClippingNode)  
<a name="ClippingNode+setup"></a>

### clippingNode.setup(builder) ⇒ <code>Node</code>
Setups the node depending on the selected scope.

**Kind**: instance method of [<code>ClippingNode</code>](#ClippingNode)  
**Returns**: <code>Node</code> - The result node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ClippingNode+setupAlphaToCoverage"></a>

### clippingNode.setupAlphaToCoverage(intersectionPlanes, unionPlanes) ⇒ <code>Node</code>
Setups alpha to coverage.

**Kind**: instance method of [<code>ClippingNode</code>](#ClippingNode)  
**Returns**: <code>Node</code> - The result node.  

| Param | Type | Description |
| --- | --- | --- |
| intersectionPlanes | <code>Array.&lt;Vector4&gt;</code> | The intersection planes. |
| unionPlanes | <code>Array.&lt;Vector4&gt;</code> | The union planes. |

<a name="ClippingNode+setupDefault"></a>

### clippingNode.setupDefault(intersectionPlanes, unionPlanes) ⇒ <code>Node</code>
Setups the default clipping.

**Kind**: instance method of [<code>ClippingNode</code>](#ClippingNode)  
**Returns**: <code>Node</code> - The result node.  

| Param | Type | Description |
| --- | --- | --- |
| intersectionPlanes | <code>Array.&lt;Vector4&gt;</code> | The intersection planes. |
| unionPlanes | <code>Array.&lt;Vector4&gt;</code> | The union planes. |

<a name="ClippingNode+setupHardwareClipping"></a>

### clippingNode.setupHardwareClipping(unionPlanes, builder) ⇒ <code>Node</code>
Setups hardware clipping.

**Kind**: instance method of [<code>ClippingNode</code>](#ClippingNode)  
**Returns**: <code>Node</code> - The result node.  

| Param | Type | Description |
| --- | --- | --- |
| unionPlanes | <code>Array.&lt;Vector4&gt;</code> | The union planes. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="clipping"></a>

## clipping() ⇒ [<code>ClippingNode</code>](#ClippingNode)
TSL function for setting up the default clipping logic.

**Kind**: global function  
**Tsl**:   
<a name="clippingAlpha"></a>

## clippingAlpha() ⇒ [<code>ClippingNode</code>](#ClippingNode)
TSL function for setting up alpha to coverage.

**Kind**: global function  
**Tsl**:   
<a name="hardwareClipping"></a>

## hardwareClipping() ⇒ [<code>ClippingNode</code>](#ClippingNode)
TSL function for setting up hardware-based clipping.

**Kind**: global function  
**Tsl**:   
## Classes

<dl>
<dt><a href="#CubeTextureNode">CubeTextureNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>This type of uniform node represents a cube texture.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#cubeTexture">cubeTexture(value, [uvNode], [levelNode], [biasNode])</a> ⇒ <code><a href="#CubeTextureNode">CubeTextureNode</a></code></dt>
<dd><p>TSL function for creating a cube texture node.</p>
</dd>
</dl>

<a name="CubeTextureNode"></a>

## CubeTextureNode ⇐ <code>TextureNode</code>
This type of uniform node represents a cube texture.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [CubeTextureNode](#CubeTextureNode) ⇐ <code>TextureNode</code>
    * [new CubeTextureNode(value, [uvNode], [levelNode], [biasNode])](#new_CubeTextureNode_new)
    * [.isCubeTextureNode](#CubeTextureNode+isCubeTextureNode) : <code>boolean</code>
    * [.getInputType(builder)](#CubeTextureNode+getInputType) ⇒ <code>string</code>
    * [.getDefaultUV()](#CubeTextureNode+getDefaultUV) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setUpdateMatrix(value)](#CubeTextureNode+setUpdateMatrix)
    * [.setupUV(builder, uvNode)](#CubeTextureNode+setupUV) ⇒ <code>Node</code>
    * [.generateUV(builder, cubeUV)](#CubeTextureNode+generateUV) ⇒ <code>string</code>

<a name="new_CubeTextureNode_new"></a>

### new CubeTextureNode(value, [uvNode], [levelNode], [biasNode])
Constructs a new cube texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>CubeTexture</code> |  | The cube texture. |
| [uvNode] | <code>Node.&lt;vec3&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

<a name="CubeTextureNode+isCubeTextureNode"></a>

### cubeTextureNode.isCubeTextureNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubeTextureNode+getInputType"></a>

### cubeTextureNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'cubeTexture'`.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="CubeTextureNode+getDefaultUV"></a>

### cubeTextureNode.getDefaultUV() ⇒ <code>Node.&lt;vec3&gt;</code>
Returns a default uvs based on the mapping type of the cube texture.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The default uv attribute.  
<a name="CubeTextureNode+setUpdateMatrix"></a>

### cubeTextureNode.setUpdateMatrix(value)
Overwritten with an empty implementation since the `updateMatrix` flag is ignored
for cube textures. The uv transformation matrix is not applied to cube textures.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The update toggle. |

<a name="CubeTextureNode+setupUV"></a>

### cubeTextureNode.setupUV(builder, uvNode) ⇒ <code>Node</code>
Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
to modify the uv node for correct sampling.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Returns**: <code>Node</code> - The updated uv node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to setup. |

<a name="CubeTextureNode+generateUV"></a>

### cubeTextureNode.generateUV(builder, cubeUV) ⇒ <code>string</code>
Generates the uv code snippet.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| cubeUV | <code>Node</code> | The uv node to generate code for. |

<a name="cubeTexture"></a>

## cubeTexture(value, [uvNode], [levelNode], [biasNode]) ⇒ [<code>CubeTextureNode</code>](#CubeTextureNode)
TSL function for creating a cube texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>CubeTexture</code> |  | The cube texture. |
| [uvNode] | <code>Node.&lt;vec3&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

## Classes

<dl>
<dt><a href="#InstanceNode">InstanceNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node implements the vertex shader logic which is required
when rendering 3D objects via instancing. The code makes sure
vertex positions, normals and colors can be modified via instanced
data.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#instance">instance(count, instanceMatrix, instanceColor)</a> ⇒ <code><a href="#InstanceNode">InstanceNode</a></code></dt>
<dd><p>TSL function for creating an instance node.</p>
</dd>
</dl>

<a name="InstanceNode"></a>

## InstanceNode ⇐ <code>Node</code>
This node implements the vertex shader logic which is required
when rendering 3D objects via instancing. The code makes sure
vertex positions, normals and colors can be modified via instanced
data.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [InstanceNode](#InstanceNode) ⇐ <code>Node</code>
    * [new InstanceNode(count, instanceMatrix, instanceColor)](#new_InstanceNode_new)
    * [.count](#InstanceNode+count) : <code>number</code>
    * [.instanceMatrix](#InstanceNode+instanceMatrix) : <code>InstancedBufferAttribute</code>
    * [.instanceColor](#InstanceNode+instanceColor) : <code>InstancedBufferAttribute</code>
    * [.instanceMatrixNode](#InstanceNode+instanceMatrixNode) : <code>Node</code>
    * [.instanceColorNode](#InstanceNode+instanceColorNode) : <code>Node</code>
    * [.updateType](#InstanceNode+updateType) : <code>string</code>
    * [.buffer](#InstanceNode+buffer) : <code>InstancedInterleavedBuffer</code>
    * [.bufferColor](#InstanceNode+bufferColor) : <code>InstancedBufferAttribute</code>
    * [.setup(builder)](#InstanceNode+setup)
    * [.update(frame)](#InstanceNode+update)

<a name="new_InstanceNode_new"></a>

### new InstanceNode(count, instanceMatrix, instanceColor)
Constructs a new instance node.


| Param | Type | Description |
| --- | --- | --- |
| count | <code>number</code> | The number of instances. |
| instanceMatrix | <code>InstancedBufferAttribute</code> | Instanced buffer attribute representing the instance transformations. |
| instanceColor | <code>InstancedBufferAttribute</code> | Instanced buffer attribute representing the instance colors. |

<a name="InstanceNode+count"></a>

### instanceNode.count : <code>number</code>
The number of instances.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+instanceMatrix"></a>

### instanceNode.instanceMatrix : <code>InstancedBufferAttribute</code>
Instanced buffer attribute representing the transformation of instances.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+instanceColor"></a>

### instanceNode.instanceColor : <code>InstancedBufferAttribute</code>
Instanced buffer attribute representing the color of instances.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+instanceMatrixNode"></a>

### instanceNode.instanceMatrixNode : <code>Node</code>
The node that represents the instance matrix data.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+instanceColorNode"></a>

### instanceNode.instanceColorNode : <code>Node</code>
The node that represents the instance color data.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+updateType"></a>

### instanceNode.updateType : <code>string</code>
The update type is set to `frame` since an update
of instanced buffer data must be checked per frame.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="InstanceNode+buffer"></a>

### instanceNode.buffer : <code>InstancedInterleavedBuffer</code>
A reference to a buffer that is used by `instanceMatrixNode`.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+bufferColor"></a>

### instanceNode.bufferColor : <code>InstancedBufferAttribute</code>
A reference to a buffer that is used by `instanceColorNode`.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+setup"></a>

### instanceNode.setup(builder)
Setups the internal buffers and nodes and assigns the transformed vertex data
to predefined node variables for accumulation. That follows the same patterns
like with morph and skinning nodes.

**Kind**: instance method of [<code>InstanceNode</code>](#InstanceNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="InstanceNode+update"></a>

### instanceNode.update(frame)
Checks if the internal buffers required an update.

**Kind**: instance method of [<code>InstanceNode</code>](#InstanceNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="instance"></a>

## instance(count, instanceMatrix, instanceColor) ⇒ [<code>InstanceNode</code>](#InstanceNode)
TSL function for creating an instance node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| count | <code>number</code> | The number of instances. |
| instanceMatrix | <code>InstancedBufferAttribute</code> | Instanced buffer attribute representing the instance transformations. |
| instanceColor | <code>InstancedBufferAttribute</code> | Instanced buffer attribute representing the instance colors. |

## Classes

<dl>
<dt><a href="#InstancedMeshNode">InstancedMeshNode</a> ⇐ <code>InstanceNode</code></dt>
<dd><p>This is a special version of <code>InstanceNode</code> which requires the usage of <a href="InstancedMesh">InstancedMesh</a>.
It allows an easier setup of the instance node.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#instancedMesh">instancedMesh(instancedMesh)</a> ⇒ <code><a href="#InstancedMeshNode">InstancedMeshNode</a></code></dt>
<dd><p>TSL function for creating an instanced mesh node.</p>
</dd>
</dl>

<a name="InstancedMeshNode"></a>

## InstancedMeshNode ⇐ <code>InstanceNode</code>
This is a special version of `InstanceNode` which requires the usage of [InstancedMesh](InstancedMesh).
It allows an easier setup of the instance node.

**Kind**: global class  
**Extends**: <code>InstanceNode</code>  

* [InstancedMeshNode](#InstancedMeshNode) ⇐ <code>InstanceNode</code>
    * [new InstancedMeshNode(instancedMesh)](#new_InstancedMeshNode_new)
    * [.instancedMesh](#InstancedMeshNode+instancedMesh) : <code>InstancedMesh</code>

<a name="new_InstancedMeshNode_new"></a>

### new InstancedMeshNode(instancedMesh)
Constructs a new instanced mesh node.


| Param | Type | Description |
| --- | --- | --- |
| instancedMesh | <code>InstancedMesh</code> | The instanced mesh. |

<a name="InstancedMeshNode+instancedMesh"></a>

### instancedMeshNode.instancedMesh : <code>InstancedMesh</code>
A reference to the instanced mesh.

**Kind**: instance property of [<code>InstancedMeshNode</code>](#InstancedMeshNode)  
<a name="instancedMesh"></a>

## instancedMesh(instancedMesh) ⇒ [<code>InstancedMeshNode</code>](#InstancedMeshNode)
TSL function for creating an instanced mesh node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| instancedMesh | <code>InstancedMesh</code> | The instancedMesh. |

## Functions

<dl>
<dt><a href="#lightShadowMatrix">lightShadowMatrix(light)</a> ⇒ <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL function for getting a shadow matrix uniform node for the given light.</p>
</dd>
<dt><a href="#lightProjectionUV">lightProjectionUV(light, [position])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting projected uv coordinates for the given light.
Relevant when using maps with spot lights.</p>
</dd>
<dt><a href="#lightPosition">lightPosition(light)</a> ⇒ <code>UniformNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting the position in world space for the given light.</p>
</dd>
<dt><a href="#lightTargetPosition">lightTargetPosition(light)</a> ⇒ <code>UniformNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting the light target position in world space for the given light.</p>
</dd>
<dt><a href="#lightViewPosition">lightViewPosition(light)</a> ⇒ <code>UniformNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting the position in view space for the given light.</p>
</dd>
<dt><a href="#lightTargetDirection">lightTargetDirection(light)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting the light target direction for the given light.</p>
</dd>
</dl>

<a name="lightShadowMatrix"></a>

## lightShadowMatrix(light) ⇒ <code>UniformNode.&lt;mat4&gt;</code>
TSL function for getting a shadow matrix uniform node for the given light.

**Kind**: global function  
**Returns**: <code>UniformNode.&lt;mat4&gt;</code> - The shadow matrix uniform node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

<a name="lightProjectionUV"></a>

## lightProjectionUV(light, [position]) ⇒ <code>Node.&lt;vec3&gt;</code>
TSL function for getting projected uv coordinates for the given light.
Relevant when using maps with spot lights.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The projected uvs.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>Light</code> |  | The light source. |
| [position] | <code>Node.&lt;vec3&gt;</code> | <code>positionWorld</code> | The position to project. |

<a name="lightPosition"></a>

## lightPosition(light) ⇒ <code>UniformNode.&lt;vec3&gt;</code>
TSL function for getting the position in world space for the given light.

**Kind**: global function  
**Returns**: <code>UniformNode.&lt;vec3&gt;</code> - The light's position in world space.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

<a name="lightTargetPosition"></a>

## lightTargetPosition(light) ⇒ <code>UniformNode.&lt;vec3&gt;</code>
TSL function for getting the light target position in world space for the given light.

**Kind**: global function  
**Returns**: <code>UniformNode.&lt;vec3&gt;</code> - The light target position in world space.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

<a name="lightViewPosition"></a>

## lightViewPosition(light) ⇒ <code>UniformNode.&lt;vec3&gt;</code>
TSL function for getting the position in view space for the given light.

**Kind**: global function  
**Returns**: <code>UniformNode.&lt;vec3&gt;</code> - The light's position in view space.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

<a name="lightTargetDirection"></a>

## lightTargetDirection(light) ⇒ <code>Node.&lt;vec3&gt;</code>
TSL function for getting the light target direction for the given light.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The light's target direction.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

## Classes

<dl>
<dt><a href="#MaterialNode">MaterialNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class should simplify the node access to material properties.
It internal uses reference nodes to make sure  changes to material
properties are automatically reflected to predefined TSL objects
like e.g. <code>materialColor</code>.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#materialAlphaTest">materialAlphaTest</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents alpha test of the current material.</p>
</dd>
<dt><a href="#materialColor">materialColor</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the diffuse color of the current material.
The value is composed via <code>color</code> * <code>map</code>.</p>
</dd>
<dt><a href="#materialShininess">materialShininess</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shininess of the current material.</p>
</dd>
<dt><a href="#materialEmissive">materialEmissive</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the emissive color of the current material.
The value is composed via <code>emissive</code> * <code>emissiveIntensity</code> * <code>emissiveMap</code>.</p>
</dd>
<dt><a href="#materialOpacity">materialOpacity</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the opacity of the current material.
The value is composed via <code>opacity</code> * <code>alphaMap</code>.</p>
</dd>
<dt><a href="#materialSpecular">materialSpecular</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the specular of the current material.</p>
</dd>
<dt><a href="#materialSpecularIntensity">materialSpecularIntensity</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the specular intensity of the current material.
The value is composed via <code>specularIntensity</code> * <code>specularMap.a</code>.</p>
</dd>
<dt><a href="#materialSpecularColor">materialSpecularColor</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the specular color of the current material.
The value is composed via <code>specularColor</code> * <code>specularMap.rgb</code>.</p>
</dd>
<dt><a href="#materialSpecularStrength">materialSpecularStrength</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the specular strength of the current material.
The value is composed via <code>specularMap.r</code>.</p>
</dd>
<dt><a href="#materialReflectivity">materialReflectivity</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the reflectivity of the current material.</p>
</dd>
<dt><a href="#materialRoughness">materialRoughness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the roughness of the current material.
The value is composed via <code>roughness</code> * <code>roughnessMap.g</code>.</p>
</dd>
<dt><a href="#materialMetalness">materialMetalness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the metalness of the current material.
The value is composed via <code>metalness</code> * <code>metalnessMap.b</code>.</p>
</dd>
<dt><a href="#materialNormal">materialNormal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the normal of the current material.
The value will be either <code>normalMap</code> * <code>normalScale</code>, <code>bumpMap</code> * <code>bumpScale</code> or <code>normalView</code>.</p>
</dd>
<dt><a href="#materialClearcoat">materialClearcoat</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the clearcoat of the current material.
The value is composed via <code>clearcoat</code> * <code>clearcoatMap.r</code></p>
</dd>
<dt><a href="#materialClearcoatRoughness">materialClearcoatRoughness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the clearcoat roughness of the current material.
The value is composed via <code>clearcoatRoughness</code> * <code>clearcoatRoughnessMap.r</code>.</p>
</dd>
<dt><a href="#materialClearcoatNormal">materialClearcoatNormal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the clearcoat normal of the current material.
The value will be either <code>clearcoatNormalMap</code> or <code>normalView</code>.</p>
</dd>
<dt><a href="#materialRotation">materialRotation</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the rotation of the current sprite material.</p>
</dd>
<dt><a href="#materialSheen">materialSheen</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the sheen color of the current material.
The value is composed via <code>sheen</code> * <code>sheenColor</code> * <code>sheenColorMap</code>.</p>
</dd>
<dt><a href="#materialSheenRoughness">materialSheenRoughness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the sheen roughness of the current material.
The value is composed via <code>sheenRoughness</code> * <code>sheenRoughnessMap.a</code>.</p>
</dd>
<dt><a href="#materialAnisotropy">materialAnisotropy</a> : <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the anisotropy of the current material.</p>
</dd>
<dt><a href="#materialIridescence">materialIridescence</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the iridescence of the current material.</p>
</dd>
<dt><a href="#materialIridescenceIOR">materialIridescenceIOR</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the iridescence IOR of the current material.</p>
</dd>
<dt><a href="#materialIridescenceThickness">materialIridescenceThickness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the iridescence thickness of the current material.</p>
</dd>
<dt><a href="#materialTransmission">materialTransmission</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the transmission of the current material.
The value is composed via <code>transmission</code> * <code>transmissionMap.r</code>.</p>
</dd>
<dt><a href="#materialThickness">materialThickness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the thickness of the current material.
The value is composed via <code>thickness</code> * <code>thicknessMap.g</code>.</p>
</dd>
<dt><a href="#materialIOR">materialIOR</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the IOR of the current material.</p>
</dd>
<dt><a href="#materialAttenuationDistance">materialAttenuationDistance</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the attenuation distance of the current material.</p>
</dd>
<dt><a href="#materialAttenuationColor">materialAttenuationColor</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the attenuation color of the current material.</p>
</dd>
<dt><a href="#materialLineScale">materialLineScale</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the scale of the current dashed line material.</p>
</dd>
<dt><a href="#materialLineDashSize">materialLineDashSize</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the dash size of the current dashed line material.</p>
</dd>
<dt><a href="#materialLineGapSize">materialLineGapSize</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the gap size of the current dashed line material.</p>
</dd>
<dt><a href="#materialLineWidth">materialLineWidth</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the line width of the current line material.</p>
</dd>
<dt><a href="#materialLineDashOffset">materialLineDashOffset</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the dash offset of the current line material.</p>
</dd>
<dt><a href="#materialPointSize">materialPointSize</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the point size of the current points material.</p>
</dd>
<dt><a href="#materialDispersion">materialDispersion</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the dispersion of the current material.</p>
</dd>
<dt><a href="#materialLightMap">materialLightMap</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the light map of the current material.
The value is composed via <code>lightMapIntensity</code> * <code>lightMap.rgb</code>.</p>
</dd>
<dt><a href="#materialAO">materialAO</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the ambient occlusion map of the current material.
The value is composed via <code>aoMap.r</code> - 1 * <code>aoMapIntensity</code> + 1.</p>
</dd>
<dt><a href="#materialAnisotropyVector">materialAnisotropyVector</a> : <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the anisotropy vector of the current material.</p>
</dd>
</dl>

<a name="MaterialNode"></a>

## MaterialNode ⇐ <code>Node</code>
This class should simplify the node access to material properties.
It internal uses reference nodes to make sure  changes to material
properties are automatically reflected to predefined TSL objects
like e.g. `materialColor`.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [MaterialNode](#MaterialNode) ⇐ <code>Node</code>
    * [new MaterialNode(scope)](#new_MaterialNode_new)
    * [.scope](#MaterialNode+scope) : <code>string</code>
    * [.getCache(property, type)](#MaterialNode+getCache) ⇒ <code>MaterialReferenceNode</code>
    * [.getFloat(property)](#MaterialNode+getFloat) ⇒ <code>MaterialReferenceNode.&lt;float&gt;</code>
    * [.getColor(property)](#MaterialNode+getColor) ⇒ <code>MaterialReferenceNode.&lt;color&gt;</code>
    * [.getTexture(property)](#MaterialNode+getTexture) ⇒ <code>MaterialReferenceNode</code>
    * [.setup(builder)](#MaterialNode+setup) ⇒ <code>Node</code>

<a name="new_MaterialNode_new"></a>

### new MaterialNode(scope)
Constructs a new material node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>string</code> | The scope defines what kind of material property is referred by the node. |

<a name="MaterialNode+scope"></a>

### materialNode.scope : <code>string</code>
The scope defines what material property is referred by the node.

**Kind**: instance property of [<code>MaterialNode</code>](#MaterialNode)  
<a name="MaterialNode+getCache"></a>

### materialNode.getCache(property, type) ⇒ <code>MaterialReferenceNode</code>
Returns a cached reference node for the given property and type.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>MaterialReferenceNode</code> - A material reference node representing the property access.  

| Param | Type | Description |
| --- | --- | --- |
| property | <code>string</code> | The name of the material property. |
| type | <code>string</code> | The uniform type of the property. |

<a name="MaterialNode+getFloat"></a>

### materialNode.getFloat(property) ⇒ <code>MaterialReferenceNode.&lt;float&gt;</code>
Returns a float-typed material reference node for the given property name.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>MaterialReferenceNode.&lt;float&gt;</code> - A material reference node representing the property access.  

| Param | Type | Description |
| --- | --- | --- |
| property | <code>string</code> | The name of the material property. |

<a name="MaterialNode+getColor"></a>

### materialNode.getColor(property) ⇒ <code>MaterialReferenceNode.&lt;color&gt;</code>
Returns a color-typed material reference node for the given property name.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>MaterialReferenceNode.&lt;color&gt;</code> - A material reference node representing the property access.  

| Param | Type | Description |
| --- | --- | --- |
| property | <code>string</code> | The name of the material property. |

<a name="MaterialNode+getTexture"></a>

### materialNode.getTexture(property) ⇒ <code>MaterialReferenceNode</code>
Returns a texture-typed material reference node for the given property name.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>MaterialReferenceNode</code> - A material reference node representing the property access.  

| Param | Type | Description |
| --- | --- | --- |
| property | <code>string</code> | The name of the material property. |

<a name="MaterialNode+setup"></a>

### materialNode.setup(builder) ⇒ <code>Node</code>
The node setup is done depending on the selected scope. Multiple material properties
might be grouped into a single node composition if they logically belong together.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>Node</code> - The node representing the selected scope.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="materialAlphaTest"></a>

## materialAlphaTest : <code>Node.&lt;float&gt;</code>
TSL object that represents alpha test of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialColor"></a>

## materialColor : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the diffuse color of the current material.
The value is composed via `color` * `map`.

**Kind**: global constant  
**Tsl**:   
<a name="materialShininess"></a>

## materialShininess : <code>Node.&lt;float&gt;</code>
TSL object that represents the shininess of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialEmissive"></a>

## materialEmissive : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the emissive color of the current material.
The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.

**Kind**: global constant  
**Tsl**:   
<a name="materialOpacity"></a>

## materialOpacity : <code>Node.&lt;float&gt;</code>
TSL object that represents the opacity of the current material.
The value is composed via `opacity` * `alphaMap`.

**Kind**: global constant  
**Tsl**:   
<a name="materialSpecular"></a>

## materialSpecular : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the specular of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialSpecularIntensity"></a>

## materialSpecularIntensity : <code>Node.&lt;float&gt;</code>
TSL object that represents the specular intensity of the current material.
The value is composed via `specularIntensity` * `specularMap.a`.

**Kind**: global constant  
**Tsl**:   
<a name="materialSpecularColor"></a>

## materialSpecularColor : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the specular color of the current material.
The value is composed via `specularColor` * `specularMap.rgb`.

**Kind**: global constant  
**Tsl**:   
<a name="materialSpecularStrength"></a>

## materialSpecularStrength : <code>Node.&lt;float&gt;</code>
TSL object that represents the specular strength of the current material.
The value is composed via `specularMap.r`.

**Kind**: global constant  
**Tsl**:   
<a name="materialReflectivity"></a>

## materialReflectivity : <code>Node.&lt;float&gt;</code>
TSL object that represents the reflectivity of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialRoughness"></a>

## materialRoughness : <code>Node.&lt;float&gt;</code>
TSL object that represents the roughness of the current material.
The value is composed via `roughness` * `roughnessMap.g`.

**Kind**: global constant  
**Tsl**:   
<a name="materialMetalness"></a>

## materialMetalness : <code>Node.&lt;float&gt;</code>
TSL object that represents the metalness of the current material.
The value is composed via `metalness` * `metalnessMap.b`.

**Kind**: global constant  
**Tsl**:   
<a name="materialNormal"></a>

## materialNormal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the normal of the current material.
The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.

**Kind**: global constant  
**Tsl**:   
<a name="materialClearcoat"></a>

## materialClearcoat : <code>Node.&lt;float&gt;</code>
TSL object that represents the clearcoat of the current material.
The value is composed via `clearcoat` * `clearcoatMap.r`

**Kind**: global constant  
**Tsl**:   
<a name="materialClearcoatRoughness"></a>

## materialClearcoatRoughness : <code>Node.&lt;float&gt;</code>
TSL object that represents the clearcoat roughness of the current material.
The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`.

**Kind**: global constant  
**Tsl**:   
<a name="materialClearcoatNormal"></a>

## materialClearcoatNormal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the clearcoat normal of the current material.
The value will be either `clearcoatNormalMap` or `normalView`.

**Kind**: global constant  
**Tsl**:   
<a name="materialRotation"></a>

## materialRotation : <code>Node.&lt;float&gt;</code>
TSL object that represents the rotation of the current sprite material.

**Kind**: global constant  
**Tsl**:   
<a name="materialSheen"></a>

## materialSheen : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the sheen color of the current material.
The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.

**Kind**: global constant  
**Tsl**:   
<a name="materialSheenRoughness"></a>

## materialSheenRoughness : <code>Node.&lt;float&gt;</code>
TSL object that represents the sheen roughness of the current material.
The value is composed via `sheenRoughness` * `sheenRoughnessMap.a`.

**Kind**: global constant  
**Tsl**:   
<a name="materialAnisotropy"></a>

## materialAnisotropy : <code>Node.&lt;vec2&gt;</code>
TSL object that represents the anisotropy of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialIridescence"></a>

## materialIridescence : <code>Node.&lt;float&gt;</code>
TSL object that represents the iridescence of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialIridescenceIOR"></a>

## materialIridescenceIOR : <code>Node.&lt;float&gt;</code>
TSL object that represents the iridescence IOR of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialIridescenceThickness"></a>

## materialIridescenceThickness : <code>Node.&lt;float&gt;</code>
TSL object that represents the iridescence thickness of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialTransmission"></a>

## materialTransmission : <code>Node.&lt;float&gt;</code>
TSL object that represents the transmission of the current material.
The value is composed via `transmission` * `transmissionMap.r`.

**Kind**: global constant  
**Tsl**:   
<a name="materialThickness"></a>

## materialThickness : <code>Node.&lt;float&gt;</code>
TSL object that represents the thickness of the current material.
The value is composed via `thickness` * `thicknessMap.g`.

**Kind**: global constant  
**Tsl**:   
<a name="materialIOR"></a>

## materialIOR : <code>Node.&lt;float&gt;</code>
TSL object that represents the IOR of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialAttenuationDistance"></a>

## materialAttenuationDistance : <code>Node.&lt;float&gt;</code>
TSL object that represents the attenuation distance of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialAttenuationColor"></a>

## materialAttenuationColor : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the attenuation color of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineScale"></a>

## materialLineScale : <code>Node.&lt;float&gt;</code>
TSL object that represents the scale of the current dashed line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineDashSize"></a>

## materialLineDashSize : <code>Node.&lt;float&gt;</code>
TSL object that represents the dash size of the current dashed line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineGapSize"></a>

## materialLineGapSize : <code>Node.&lt;float&gt;</code>
TSL object that represents the gap size of the current dashed line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineWidth"></a>

## materialLineWidth : <code>Node.&lt;float&gt;</code>
TSL object that represents the line width of the current line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineDashOffset"></a>

## materialLineDashOffset : <code>Node.&lt;float&gt;</code>
TSL object that represents the dash offset of the current line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialPointSize"></a>

## materialPointSize : <code>Node.&lt;float&gt;</code>
TSL object that represents the point size of the current points material.

**Kind**: global constant  
**Tsl**:   
<a name="materialDispersion"></a>

## materialDispersion : <code>Node.&lt;float&gt;</code>
TSL object that represents the dispersion of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLightMap"></a>

## materialLightMap : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the light map of the current material.
The value is composed via `lightMapIntensity` * `lightMap.rgb`.

**Kind**: global constant  
**Tsl**:   
<a name="materialAO"></a>

## materialAO : <code>Node.&lt;float&gt;</code>
TSL object that represents the ambient occlusion map of the current material.
The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.

**Kind**: global constant  
**Tsl**:   
<a name="materialAnisotropyVector"></a>

## materialAnisotropyVector : <code>Node.&lt;vec2&gt;</code>
TSL object that represents the anisotropy vector of the current material.

**Kind**: global constant  
**Tsl**:   
## Constants

<dl>
<dt><a href="#materialRefractionRatio">materialRefractionRatio</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the refraction ratio of the material used for rendering the current object.</p>
</dd>
<dt><a href="#materialEnvIntensity">materialEnvIntensity</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the intensity of environment maps of PBR materials.
When <code>material.envMap</code> is set, the value is <code>material.envMapIntensity</code> otherwise <code>scene.environmentIntensity</code>.</p>
</dd>
<dt><a href="#materialEnvRotation">materialEnvRotation</a> : <code>Node.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the rotation of environment maps.
When <code>material.envMap</code> is set, the value is <code>material.envMapRotation</code>. <code>scene.environmentRotation</code> controls the
rotation of <code>scene.environment</code> instead.</p>
</dd>
</dl>

<a name="materialRefractionRatio"></a>

## materialRefractionRatio : <code>UniformNode.&lt;float&gt;</code>
TSL object that represents the refraction ratio of the material used for rendering the current object.

**Kind**: global constant  
**Tsl**:   
<a name="materialEnvIntensity"></a>

## materialEnvIntensity : <code>Node.&lt;float&gt;</code>
TSL object that represents the intensity of environment maps of PBR materials.
When `material.envMap` is set, the value is `material.envMapIntensity` otherwise `scene.environmentIntensity`.

**Kind**: global constant  
**Tsl**:   
<a name="materialEnvRotation"></a>

## materialEnvRotation : <code>Node.&lt;mat4&gt;</code>
TSL object that represents the rotation of environment maps.
When `material.envMap` is set, the value is `material.envMapRotation`. `scene.environmentRotation` controls the
rotation of `scene.environment` instead.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#MaterialReferenceNode">MaterialReferenceNode</a> ⇐ <code>ReferenceNode</code></dt>
<dd><p>This node is a special type of reference node which is intended
for linking material properties with node values.</p>
<pre><code class="language-js">const opacityNode = materialReference( &#39;opacity&#39;, &#39;float&#39;, material );
</code></pre>
<p>When changing <code>material.opacity</code>, the node value of <code>opacityNode</code> will
automatically be updated.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#materialReference">materialReference(name, type, [material])</a> ⇒ <code><a href="#MaterialReferenceNode">MaterialReferenceNode</a></code></dt>
<dd><p>TSL function for creating a material reference node.</p>
</dd>
</dl>

<a name="MaterialReferenceNode"></a>

## MaterialReferenceNode ⇐ <code>ReferenceNode</code>
This node is a special type of reference node which is intended
for linking material properties with node values.
```js
const opacityNode = materialReference( 'opacity', 'float', material );
```
When changing `material.opacity`, the node value of `opacityNode` will
automatically be updated.

**Kind**: global class  
**Extends**: <code>ReferenceNode</code>  

* [MaterialReferenceNode](#MaterialReferenceNode) ⇐ <code>ReferenceNode</code>
    * [new MaterialReferenceNode(property, inputType, [material])](#new_MaterialReferenceNode_new)
    * [.material](#MaterialReferenceNode+material) : <code>Material</code>
    * [.isMaterialReferenceNode](#MaterialReferenceNode+isMaterialReferenceNode) : <code>boolean</code>
    * [.updateReference(state)](#MaterialReferenceNode+updateReference) ⇒ <code>Object</code>

<a name="new_MaterialReferenceNode_new"></a>

### new MaterialReferenceNode(property, inputType, [material])
Constructs a new material reference node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The name of the property the node refers to. |
| inputType | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [material] | <code>Material</code> | <code></code> | The material the property belongs to. When no material is set, the node refers to the material of the current rendered object. |

<a name="MaterialReferenceNode+material"></a>

### materialReferenceNode.material : <code>Material</code>
The material the property belongs to. When no material is set,
the node refers to the material of the current rendered object.

**Kind**: instance property of [<code>MaterialReferenceNode</code>](#MaterialReferenceNode)  
**Default**: <code>null</code>  
<a name="MaterialReferenceNode+isMaterialReferenceNode"></a>

### materialReferenceNode.isMaterialReferenceNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MaterialReferenceNode</code>](#MaterialReferenceNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MaterialReferenceNode+updateReference"></a>

### materialReferenceNode.updateReference(state) ⇒ <code>Object</code>
Updates the reference based on the given state. The state is only evaluated
[material](#MaterialReferenceNode+material) is not set.

**Kind**: instance method of [<code>MaterialReferenceNode</code>](#MaterialReferenceNode)  
**Returns**: <code>Object</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state. |

<a name="materialReference"></a>

## materialReference(name, type, [material]) ⇒ [<code>MaterialReferenceNode</code>](#MaterialReferenceNode)
TSL function for creating a material reference node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the property the node refers to. |
| type | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [material] | <code>Material</code> | <code></code> | The material the property belongs to. When no material is set, the node refers to the material of the current rendered object. |

## Classes

<dl>
<dt><a href="#ModelNode">ModelNode</a> ⇐ <code>Object3DNode</code></dt>
<dd><p>This type of node is a specialized version of <code>Object3DNode</code>
with larger set of model related metrics. Unlike <code>Object3DNode</code>,
<code>ModelNode</code> extracts the reference to the 3D object from the
current node frame state.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#modelDirection">modelDirection</a> : <code>ModelNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s direction in world space.</p>
</dd>
<dt><a href="#modelWorldMatrix">modelWorldMatrix</a> : <code>ModelNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s world matrix.</p>
</dd>
<dt><a href="#modelPosition">modelPosition</a> : <code>ModelNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s position in world space.</p>
</dd>
<dt><a href="#modelScale">modelScale</a> : <code>ModelNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s scale in world space.</p>
</dd>
<dt><a href="#modelViewPosition">modelViewPosition</a> : <code>ModelNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s position in view/camera space.</p>
</dd>
<dt><a href="#modelRadius">modelRadius</a> : <code>ModelNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s radius.</p>
</dd>
<dt><a href="#modelNormalMatrix">modelNormalMatrix</a> : <code>UniformNode.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s normal matrix.</p>
</dd>
<dt><a href="#modelWorldMatrixInverse">modelWorldMatrixInverse</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s inverse world matrix.</p>
</dd>
<dt><a href="#modelViewMatrix">modelViewMatrix</a> : <code>Node.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s model view matrix.</p>
</dd>
<dt><a href="#mediumpModelViewMatrix">mediumpModelViewMatrix</a> : <code>Node.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s model view in <code>mediump</code> precision.</p>
</dd>
<dt><a href="#highpModelViewMatrix">highpModelViewMatrix</a> : <code>Node.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s model view in <code>highp</code> precision
which is achieved by computing the matrix in JS and not in the shader.</p>
</dd>
<dt><a href="#highpModelNormalViewMatrix">highpModelNormalViewMatrix</a> : <code>Node.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s model normal view in <code>highp</code> precision
which is achieved by computing the matrix in JS and not in the shader.</p>
</dd>
</dl>

<a name="ModelNode"></a>

## ModelNode ⇐ <code>Object3DNode</code>
This type of node is a specialized version of `Object3DNode`
with larger set of model related metrics. Unlike `Object3DNode`,
`ModelNode` extracts the reference to the 3D object from the
current node frame state.

**Kind**: global class  
**Extends**: <code>Object3DNode</code>  

* [ModelNode](#ModelNode) ⇐ <code>Object3DNode</code>
    * [new ModelNode(scope)](#new_ModelNode_new)
    * [.update(frame)](#ModelNode+update)

<a name="new_ModelNode_new"></a>

### new ModelNode(scope)
Constructs a new object model node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>&#x27;position&#x27;</code> \| <code>&#x27;viewPosition&#x27;</code> \| <code>&#x27;direction&#x27;</code> \| <code>&#x27;scale&#x27;</code> \| <code>&#x27;worldMatrix&#x27;</code> | The node represents a different type of transformation depending on the scope. |

<a name="ModelNode+update"></a>

### modelNode.update(frame)
Extracts the model reference from the frame state and then
updates the uniform value depending on the scope.

**Kind**: instance method of [<code>ModelNode</code>](#ModelNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="modelDirection"></a>

## modelDirection : <code>ModelNode.&lt;vec3&gt;</code>
TSL object that represents the object's direction in world space.

**Kind**: global constant  
**Tsl**:   
<a name="modelWorldMatrix"></a>

## modelWorldMatrix : <code>ModelNode.&lt;mat4&gt;</code>
TSL object that represents the object's world matrix.

**Kind**: global constant  
**Tsl**:   
<a name="modelPosition"></a>

## modelPosition : <code>ModelNode.&lt;vec3&gt;</code>
TSL object that represents the object's position in world space.

**Kind**: global constant  
**Tsl**:   
<a name="modelScale"></a>

## modelScale : <code>ModelNode.&lt;vec3&gt;</code>
TSL object that represents the object's scale in world space.

**Kind**: global constant  
**Tsl**:   
<a name="modelViewPosition"></a>

## modelViewPosition : <code>ModelNode.&lt;vec3&gt;</code>
TSL object that represents the object's position in view/camera space.

**Kind**: global constant  
**Tsl**:   
<a name="modelRadius"></a>

## modelRadius : <code>ModelNode.&lt;float&gt;</code>
TSL object that represents the object's radius.

**Kind**: global constant  
**Tsl**:   
<a name="modelNormalMatrix"></a>

## modelNormalMatrix : <code>UniformNode.&lt;mat3&gt;</code>
TSL object that represents the object's normal matrix.

**Kind**: global constant  
**Tsl**:   
<a name="modelWorldMatrixInverse"></a>

## modelWorldMatrixInverse : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the object's inverse world matrix.

**Kind**: global constant  
**Tsl**:   
<a name="modelViewMatrix"></a>

## modelViewMatrix : <code>Node.&lt;mat4&gt;</code>
TSL object that represents the object's model view matrix.

**Kind**: global constant  
**Tsl**:   
<a name="mediumpModelViewMatrix"></a>

## mediumpModelViewMatrix : <code>Node.&lt;mat4&gt;</code>
TSL object that represents the object's model view in `mediump` precision.

**Kind**: global constant  
**Tsl**:   
<a name="highpModelViewMatrix"></a>

## highpModelViewMatrix : <code>Node.&lt;mat4&gt;</code>
TSL object that represents the object's model view in `highp` precision
which is achieved by computing the matrix in JS and not in the shader.

**Kind**: global constant  
**Tsl**:   
<a name="highpModelNormalViewMatrix"></a>

## highpModelNormalViewMatrix : <code>Node.&lt;mat3&gt;</code>
TSL object that represents the object's model normal view in `highp` precision
which is achieved by computing the matrix in JS and not in the shader.

**Kind**: global constant  
**Tsl**:   
<a name="modelViewProjection"></a>

## modelViewProjection : <code>VaryingNode.&lt;vec4&gt;</code>
TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#MorphNode">MorphNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node implements the vertex transformation shader logic which is required
for morph target animation.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#morphReference">morphReference(mesh)</a> ⇒ <code><a href="#MorphNode">MorphNode</a></code></dt>
<dd><p>TSL function for creating a morph node.</p>
</dd>
</dl>

<a name="MorphNode"></a>

## MorphNode ⇐ <code>Node</code>
This node implements the vertex transformation shader logic which is required
for morph target animation.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [MorphNode](#MorphNode) ⇐ <code>Node</code>
    * [new MorphNode(mesh)](#new_MorphNode_new)
    * [.mesh](#MorphNode+mesh) : <code>Mesh</code>
    * [.morphBaseInfluence](#MorphNode+morphBaseInfluence) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateType](#MorphNode+updateType) : <code>string</code>
    * [.setup(builder)](#MorphNode+setup)
    * [.update(frame)](#MorphNode+update)

<a name="new_MorphNode_new"></a>

### new MorphNode(mesh)
Constructs a new morph node.


| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The mesh holding the morph targets. |

<a name="MorphNode+mesh"></a>

### morphNode.mesh : <code>Mesh</code>
The mesh holding the morph targets.

**Kind**: instance property of [<code>MorphNode</code>](#MorphNode)  
<a name="MorphNode+morphBaseInfluence"></a>

### morphNode.morphBaseInfluence : <code>UniformNode.&lt;float&gt;</code>
A uniform node which represents the morph base influence value.

**Kind**: instance property of [<code>MorphNode</code>](#MorphNode)  
<a name="MorphNode+updateType"></a>

### morphNode.updateType : <code>string</code>
The update type overwritten since morph nodes are updated per object.

**Kind**: instance property of [<code>MorphNode</code>](#MorphNode)  
<a name="MorphNode+setup"></a>

### morphNode.setup(builder)
Setups the morph node by assigning the transformed vertex data to predefined node variables.

**Kind**: instance method of [<code>MorphNode</code>](#MorphNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MorphNode+update"></a>

### morphNode.update(frame)
Updates the state of the morphed mesh by updating the base influence.

**Kind**: instance method of [<code>MorphNode</code>](#MorphNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="morphReference"></a>

## morphReference(mesh) ⇒ [<code>MorphNode</code>](#MorphNode)
TSL function for creating a morph node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The mesh holding the morph targets. |

## Constants

<dl>
<dt><a href="#normalGeometry">normalGeometry</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the normal attribute of the current rendered object.</p>
</dd>
<dt><a href="#normalLocal">normalLocal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex normal in local space of the current rendered object.</p>
</dd>
<dt><a href="#normalFlat">normalFlat</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the flat vertex normal in view space of the current rendered object.</p>
</dd>
<dt><a href="#normalView">normalView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex normal in view space of the current rendered object.</p>
</dd>
<dt><a href="#normalWorld">normalWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex normal in world space of the current rendered object.</p>
</dd>
<dt><a href="#transformedNormalView">transformedNormalView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex normal in view space of the current rendered object.</p>
</dd>
<dt><a href="#transformedNormalWorld">transformedNormalWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex normal in world space of the current rendered object.</p>
</dd>
<dt><a href="#transformedClearcoatNormalView">transformedClearcoatNormalView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#transformNormal">transformNormal(normal, [matrix])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Transforms the normal with the given matrix.</p>
</dd>
<dt><a href="#transformNormalToView">transformNormalToView(normal, builder)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Transforms the given normal from local to view space.</p>
</dd>
</dl>

<a name="normalGeometry"></a>

## normalGeometry : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the normal attribute of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="normalLocal"></a>

## normalLocal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex normal in local space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="normalFlat"></a>

## normalFlat : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the flat vertex normal in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="normalView"></a>

## normalView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex normal in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="normalWorld"></a>

## normalWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex normal in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedNormalView"></a>

## transformedNormalView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed vertex normal in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedNormalWorld"></a>

## transformedNormalWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed vertex normal in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedClearcoatNormalView"></a>

## transformedClearcoatNormalView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformNormal"></a>

## transformNormal(normal, [matrix]) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the normal with the given matrix.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed normal.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| normal | <code>Node.&lt;vec3&gt;</code> |  | The normal. |
| [matrix] | <code>Node.&lt;mat3&gt;</code> | <code>modelWorldMatrix</code> | The matrix. |

<a name="transformNormalToView"></a>

## transformNormalToView(normal, builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the given normal from local to view space.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed normal.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Node.&lt;vec3&gt;</code> | The normal. |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#Object3DNode">Object3DNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used to access transformation related metrics of 3D objects.
Depending on the selected scope, a different metric is represented as a uniform
in the shader. The following scopes are supported:</p>
<ul>
<li><code>POSITION</code>: The object&#39;s position in world space.</li>
<li><code>VIEW_POSITION</code>: The object&#39;s position in view/camera space.</li>
<li><code>DIRECTION</code>: The object&#39;s direction in world space.</li>
<li><code>SCALE</code>: The object&#39;s scale in world space.</li>
<li><code>WORLD_MATRIX</code>: The object&#39;s matrix in world space.</li>
</ul>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#objectDirection">objectDirection([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s direction in world space.</p>
</dd>
<dt><a href="#objectWorldMatrix">objectWorldMatrix([object3d])</a> ⇒ <code>Object3DNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s world matrix.</p>
</dd>
<dt><a href="#objectPosition">objectPosition([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s position in world space.</p>
</dd>
<dt><a href="#objectScale">objectScale([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s scale in world space.</p>
</dd>
<dt><a href="#objectViewPosition">objectViewPosition([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s position in view/camera space.</p>
</dd>
<dt><a href="#objectRadius">objectRadius([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s radius.</p>
</dd>
</dl>

<a name="Object3DNode"></a>

## Object3DNode ⇐ <code>Node</code>
This node can be used to access transformation related metrics of 3D objects.
Depending on the selected scope, a different metric is represented as a uniform
in the shader. The following scopes are supported:

- `POSITION`: The object's position in world space.
- `VIEW_POSITION`: The object's position in view/camera space.
- `DIRECTION`: The object's direction in world space.
- `SCALE`: The object's scale in world space.
- `WORLD_MATRIX`: The object's matrix in world space.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [Object3DNode](#Object3DNode) ⇐ <code>Node</code>
    * [new Object3DNode(scope, [object3d])](#new_Object3DNode_new)
    * [.scope](#Object3DNode+scope) : <code>&#x27;position&#x27;</code> \| <code>&#x27;viewPosition&#x27;</code> \| <code>&#x27;direction&#x27;</code> \| <code>&#x27;scale&#x27;</code> \| <code>&#x27;worldMatrix&#x27;</code>
    * [.object3d](#Object3DNode+object3d) : <code>Object3D</code>
    * [.updateType](#Object3DNode+updateType) : <code>string</code>
    * [.getNodeType()](#Object3DNode+getNodeType) ⇒ <code>string</code>
    * [.update(frame)](#Object3DNode+update)
    * [.generate(builder)](#Object3DNode+generate) ⇒ <code>string</code>

<a name="new_Object3DNode_new"></a>

### new Object3DNode(scope, [object3d])
Constructs a new object 3D node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scope | <code>&#x27;position&#x27;</code> \| <code>&#x27;viewPosition&#x27;</code> \| <code>&#x27;direction&#x27;</code> \| <code>&#x27;scale&#x27;</code> \| <code>&#x27;worldMatrix&#x27;</code> |  | The node represents a different type of transformation depending on the scope. |
| [object3d] | <code>Object3D</code> | <code></code> | The 3D object. |

<a name="Object3DNode+scope"></a>

### object3DNode.scope : <code>&#x27;position&#x27;</code> \| <code>&#x27;viewPosition&#x27;</code> \| <code>&#x27;direction&#x27;</code> \| <code>&#x27;scale&#x27;</code> \| <code>&#x27;worldMatrix&#x27;</code>
The node reports a different type of transformation depending on the scope.

**Kind**: instance property of [<code>Object3DNode</code>](#Object3DNode)  
<a name="Object3DNode+object3d"></a>

### object3DNode.object3d : <code>Object3D</code>
The 3D object.

**Kind**: instance property of [<code>Object3DNode</code>](#Object3DNode)  
**Default**: <code>null</code>  
<a name="Object3DNode+updateType"></a>

### object3DNode.updateType : <code>string</code>
Overwritten since this type of node is updated per object.

**Kind**: instance property of [<code>Object3DNode</code>](#Object3DNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="Object3DNode+getNodeType"></a>

### object3DNode.getNodeType() ⇒ <code>string</code>
Overwritten since the node type is inferred from the scope.

**Kind**: instance method of [<code>Object3DNode</code>](#Object3DNode)  
**Returns**: <code>string</code> - The node type.  
<a name="Object3DNode+update"></a>

### object3DNode.update(frame)
Updates the uniform value depending on the scope.

**Kind**: instance method of [<code>Object3DNode</code>](#Object3DNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="Object3DNode+generate"></a>

### object3DNode.generate(builder) ⇒ <code>string</code>
Generates the code snippet of the uniform node. The node type of the uniform
node also depends on the selected scope.

**Kind**: instance method of [<code>Object3DNode</code>](#Object3DNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="objectDirection"></a>

## objectDirection([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's direction in world space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectWorldMatrix"></a>

## objectWorldMatrix([object3d]) ⇒ <code>Object3DNode.&lt;mat4&gt;</code>
TSL function for creating an object 3D node that represents the object's world matrix.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectPosition"></a>

## objectPosition([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's position in world space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectScale"></a>

## objectScale([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's scale in world space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectViewPosition"></a>

## objectViewPosition([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's position in view/camera space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectRadius"></a>

## objectRadius([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's radius.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

## Classes

<dl>
<dt><a href="#PointUVNode">PointUVNode</a> ⇐ <code>Node</code></dt>
<dd><p>A node for representing the uv coordinates of points.</p>
<p>Can only be used with a WebGL backend. In WebGPU, point
primitives always have the size of one pixel and can thus
can&#39;t be used as sprite-like objects that display textures.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#pointUV">pointUV</a> : <code><a href="#PointUVNode">PointUVNode</a></code></dt>
<dd><p>TSL object that represents the uv coordinates of points.</p>
</dd>
</dl>

<a name="PointUVNode"></a>

## PointUVNode ⇐ <code>Node</code>
A node for representing the uv coordinates of points.

Can only be used with a WebGL backend. In WebGPU, point
primitives always have the size of one pixel and can thus
can't be used as sprite-like objects that display textures.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [PointUVNode](#PointUVNode) ⇐ <code>Node</code>
    * [new PointUVNode()](#new_PointUVNode_new)
    * [.isPointUVNode](#PointUVNode+isPointUVNode) : <code>boolean</code>

<a name="new_PointUVNode_new"></a>

### new PointUVNode()
Constructs a new point uv node.

<a name="PointUVNode+isPointUVNode"></a>

### pointUVNode.isPointUVNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointUVNode</code>](#PointUVNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="pointUV"></a>

## pointUV : [<code>PointUVNode</code>](#PointUVNode)
TSL object that represents the uv coordinates of points.

**Kind**: global constant  
**Tsl**:   
## Constants

<dl>
<dt><a href="#positionGeometry">positionGeometry</a> : <code>AttributeNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the position attribute of the current rendered object.</p>
</dd>
<dt><a href="#positionLocal">positionLocal</a> : <code>AttributeNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex position in local space of the current rendered object.</p>
</dd>
<dt><a href="#positionPrevious">positionPrevious</a> : <code>AttributeNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the previous vertex position in local space of the current rendered object.
Used in context of <a href="VelocityNode">VelocityNode</a> for rendering motion vectors.</p>
</dd>
<dt><a href="#positionWorld">positionWorld</a> : <code>VaryingNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex position in world space of the current rendered object.</p>
</dd>
<dt><a href="#positionWorldDirection">positionWorldDirection</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the position world direction of the current rendered object.</p>
</dd>
<dt><a href="#positionView">positionView</a> : <code>VaryingNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex position in view space of the current rendered object.</p>
</dd>
<dt><a href="#positionViewDirection">positionViewDirection</a> : <code>VaryingNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the position view direction of the current rendered object.</p>
</dd>
</dl>

<a name="positionGeometry"></a>

## positionGeometry : <code>AttributeNode.&lt;vec3&gt;</code>
TSL object that represents the position attribute of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionLocal"></a>

## positionLocal : <code>AttributeNode.&lt;vec3&gt;</code>
TSL object that represents the vertex position in local space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionPrevious"></a>

## positionPrevious : <code>AttributeNode.&lt;vec3&gt;</code>
TSL object that represents the previous vertex position in local space of the current rendered object.
Used in context of [VelocityNode](VelocityNode) for rendering motion vectors.

**Kind**: global constant  
**Tsl**:   
<a name="positionWorld"></a>

## positionWorld : <code>VaryingNode.&lt;vec3&gt;</code>
TSL object that represents the vertex position in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionWorldDirection"></a>

## positionWorldDirection : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the position world direction of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionView"></a>

## positionView : <code>VaryingNode.&lt;vec3&gt;</code>
TSL object that represents the vertex position in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionViewDirection"></a>

## positionViewDirection : <code>VaryingNode.&lt;vec3&gt;</code>
TSL object that represents the position view direction of the current rendered object.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#ReferenceElementNode">ReferenceElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>This class is only relevant if the referenced property is array-like.
In this case, <code>ReferenceElementNode</code> allows to refer to a specific
element inside the data structure via an index.</p>
</dd>
<dt><a href="#ReferenceBaseNode">ReferenceBaseNode</a> ⇐ <code>Node</code></dt>
<dd><p>Base class for nodes which establishes a reference to a property of another object.
In this way, the value of the node is automatically linked to the value of
referenced object. Reference nodes internally represent the linked value
as a uniform.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#reference">reference(name, type, object)</a> ⇒ <code><a href="#ReferenceBaseNode">ReferenceBaseNode</a></code></dt>
<dd><p>TSL function for creating a reference base node.</p>
</dd>
<dt><a href="#referenceBuffer">referenceBuffer(name, type, count, [object])</a> ⇒ <code><a href="#ReferenceBaseNode">ReferenceBaseNode</a></code></dt>
<dd><p>TSL function for creating a reference base node. Use this function if you want need a reference
to an array-like property that should be represented as a uniform buffer.</p>
</dd>
</dl>

<a name="ReferenceElementNode"></a>

## ReferenceElementNode ⇐ <code>ArrayElementNode</code>
This class is only relevant if the referenced property is array-like.
In this case, `ReferenceElementNode` allows to refer to a specific
element inside the data structure via an index.

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [ReferenceElementNode](#ReferenceElementNode) ⇐ <code>ArrayElementNode</code>
    * [new ReferenceElementNode(referenceNode, indexNode)](#new_ReferenceElementNode_new)
    * [.referenceNode](#ReferenceElementNode+referenceNode) : [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
    * [.isReferenceElementNode](#ReferenceElementNode+isReferenceElementNode) : <code>boolean</code>
    * [.getNodeType()](#ReferenceElementNode+getNodeType) ⇒ <code>string</code>

<a name="new_ReferenceElementNode_new"></a>

### new ReferenceElementNode(referenceNode, indexNode)
Constructs a new reference element node.


| Param | Type | Description |
| --- | --- | --- |
| referenceNode | [<code>ReferenceBaseNode</code>](#ReferenceBaseNode) | The reference node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="ReferenceElementNode+referenceNode"></a>

### referenceElementNode.referenceNode : [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
Similar to [reference](#ReferenceBaseNode+reference), an additional
property references to the current node.

**Kind**: instance property of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Default**: <code>null</code>  
<a name="ReferenceElementNode+isReferenceElementNode"></a>

### referenceElementNode.isReferenceElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ReferenceElementNode+getNodeType"></a>

### referenceElementNode.getNodeType() ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the uniform type of the reference node.

**Kind**: instance method of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Returns**: <code>string</code> - The node type.  
<a name="ReferenceBaseNode"></a>

## ReferenceBaseNode ⇐ <code>Node</code>
Base class for nodes which establishes a reference to a property of another object.
In this way, the value of the node is automatically linked to the value of
referenced object. Reference nodes internally represent the linked value
as a uniform.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ReferenceBaseNode](#ReferenceBaseNode) ⇐ <code>Node</code>
    * [new ReferenceBaseNode(property, uniformType, [object], [count])](#new_ReferenceBaseNode_new)
    * [.property](#ReferenceBaseNode+property) : <code>string</code>
    * [.uniformType](#ReferenceBaseNode+uniformType) : <code>string</code>
    * [.object](#ReferenceBaseNode+object) : <code>Object</code>
    * [.count](#ReferenceBaseNode+count) : <code>number</code>
    * [.properties](#ReferenceBaseNode+properties) : <code>Array.&lt;string&gt;</code>
    * [.reference](#ReferenceBaseNode+reference) : <code>Object</code>
    * [.node](#ReferenceBaseNode+node) : <code>UniformNode</code>
    * [.group](#ReferenceBaseNode+group) : <code>UniformGroupNode</code>
    * [.updateType](#ReferenceBaseNode+updateType) : <code>string</code>
    * [.setGroup(group)](#ReferenceBaseNode+setGroup) ⇒ [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
    * [.element(indexNode)](#ReferenceBaseNode+element) ⇒ [<code>ReferenceElementNode</code>](#ReferenceElementNode)
    * [.setNodeType(uniformType)](#ReferenceBaseNode+setNodeType)
    * [.getNodeType(builder)](#ReferenceBaseNode+getNodeType) ⇒ <code>string</code>
    * [.getValueFromReference([object])](#ReferenceBaseNode+getValueFromReference) ⇒ <code>any</code>
    * [.updateReference(state)](#ReferenceBaseNode+updateReference) ⇒ <code>Object</code>
    * [.setup()](#ReferenceBaseNode+setup) ⇒ <code>UniformNode</code>
    * [.update(frame)](#ReferenceBaseNode+update)
    * [.updateValue()](#ReferenceBaseNode+updateValue)

<a name="new_ReferenceBaseNode_new"></a>

### new ReferenceBaseNode(property, uniformType, [object], [count])
Constructs a new reference base node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The name of the property the node refers to. |
| uniformType | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [object] | <code>Object</code> | <code></code> | The object the property belongs to. |
| [count] | <code>number</code> | <code></code> | When the linked property is an array-like, this parameter defines its length. |

<a name="ReferenceBaseNode+property"></a>

### referenceBaseNode.property : <code>string</code>
The name of the property the node refers to.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
<a name="ReferenceBaseNode+uniformType"></a>

### referenceBaseNode.uniformType : <code>string</code>
The uniform type that should be used to represent the property value.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
<a name="ReferenceBaseNode+object"></a>

### referenceBaseNode.object : <code>Object</code>
The object the property belongs to.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+count"></a>

### referenceBaseNode.count : <code>number</code>
When the linked property is an array, this parameter defines its length.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+properties"></a>

### referenceBaseNode.properties : <code>Array.&lt;string&gt;</code>
The property name might have dots so nested properties can be referred.
The hierarchy of the names is stored inside this array.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
<a name="ReferenceBaseNode+reference"></a>

### referenceBaseNode.reference : <code>Object</code>
Points to the current referred object. This property exists next to [ReferenceNode#object](ReferenceNode#object)
since the final reference might be updated from calling code.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+node"></a>

### referenceBaseNode.node : <code>UniformNode</code>
The uniform node that holds the value of the reference node.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+group"></a>

### referenceBaseNode.group : <code>UniformGroupNode</code>
The uniform group of the internal uniform.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+updateType"></a>

### referenceBaseNode.updateType : <code>string</code>
Overwritten since reference nodes are updated per object.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="ReferenceBaseNode+setGroup"></a>

### referenceBaseNode.setGroup(group) ⇒ [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
Sets the uniform group for this reference node.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: [<code>ReferenceBaseNode</code>](#ReferenceBaseNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| group | <code>UniformGroupNode</code> | The uniform group to set. |

<a name="ReferenceBaseNode+element"></a>

### referenceBaseNode.element(indexNode) ⇒ [<code>ReferenceElementNode</code>](#ReferenceElementNode)
When the referred property is array-like, this method can be used
to access elements via an index node.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: [<code>ReferenceElementNode</code>](#ReferenceElementNode) - A reference to an element.  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | indexNode. |

<a name="ReferenceBaseNode+setNodeType"></a>

### referenceBaseNode.setNodeType(uniformType)
Sets the node type which automatically defines the internal
uniform type.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  

| Param | Type | Description |
| --- | --- | --- |
| uniformType | <code>string</code> | The type to set. |

<a name="ReferenceBaseNode+getNodeType"></a>

### referenceBaseNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the type of the reference node.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ReferenceBaseNode+getValueFromReference"></a>

### referenceBaseNode.getValueFromReference([object]) ⇒ <code>any</code>
Returns the property value from the given referred object.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: <code>any</code> - The value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [object] | <code>Object</code> | <code>this.reference</code> | The object to retrieve the property value from. |

<a name="ReferenceBaseNode+updateReference"></a>

### referenceBaseNode.updateReference(state) ⇒ <code>Object</code>
Allows to update the reference based on the given state. The state is only
evaluated [object](#ReferenceBaseNode+object) is not set.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: <code>Object</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state. |

<a name="ReferenceBaseNode+setup"></a>

### referenceBaseNode.setup() ⇒ <code>UniformNode</code>
The output of the reference node is the internal uniform node.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: <code>UniformNode</code> - The output node.  
<a name="ReferenceBaseNode+update"></a>

### referenceBaseNode.update(frame)
Overwritten to to update the internal uniform value.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="ReferenceBaseNode+updateValue"></a>

### referenceBaseNode.updateValue()
Retrieves the value from the referred object property and uses it
to updated the internal uniform.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
<a name="reference"></a>

## reference(name, type, object) ⇒ [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
TSL function for creating a reference base node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property the node refers to. |
| type | <code>string</code> | The uniform type that should be used to represent the property value. |
| object | <code>Object</code> | The object the property belongs to. |

<a name="referenceBuffer"></a>

## referenceBuffer(name, type, count, [object]) ⇒ [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
TSL function for creating a reference base node. Use this function if you want need a reference
to an array-like property that should be represented as a uniform buffer.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property the node refers to. |
| type | <code>string</code> | The uniform type that should be used to represent the property value. |
| count | <code>number</code> | The number of value inside the array-like object. |
| [object] | <code>Object</code> | An array-like object the property belongs to. |

## Classes

<dl>
<dt><a href="#ReferenceElementNode">ReferenceElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>This class is only relevant if the referenced property is array-like.
In this case, <code>ReferenceElementNode</code> allows to refer to a specific
element inside the data structure via an index.</p>
</dd>
<dt><a href="#ReferenceNode">ReferenceNode</a> ⇐ <code>Node</code></dt>
<dd><p>This type of node establishes a reference to a property of another object.
In this way, the value of the node is automatically linked to the value of
referenced object. Reference nodes internally represent the linked value
as a uniform.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#reference">reference(name, type, [object])</a> ⇒ <code><a href="#ReferenceNode">ReferenceNode</a></code></dt>
<dd><p>TSL function for creating a reference node.</p>
</dd>
<dt><a href="#referenceBuffer">referenceBuffer(name, type, count, object)</a> ⇒ <code><a href="#ReferenceNode">ReferenceNode</a></code></dt>
<dd><p>TSL function for creating a reference node. Use this function if you want need a reference
to an array-like property that should be represented as a uniform buffer.</p>
</dd>
</dl>

<a name="ReferenceElementNode"></a>

## ReferenceElementNode ⇐ <code>ArrayElementNode</code>
This class is only relevant if the referenced property is array-like.
In this case, `ReferenceElementNode` allows to refer to a specific
element inside the data structure via an index.

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [ReferenceElementNode](#ReferenceElementNode) ⇐ <code>ArrayElementNode</code>
    * [new ReferenceElementNode(referenceNode, indexNode)](#new_ReferenceElementNode_new)
    * [.referenceNode](#ReferenceElementNode+referenceNode) : [<code>ReferenceNode</code>](#ReferenceNode)
    * [.isReferenceElementNode](#ReferenceElementNode+isReferenceElementNode) : <code>boolean</code>
    * [.getNodeType()](#ReferenceElementNode+getNodeType) ⇒ <code>string</code>

<a name="new_ReferenceElementNode_new"></a>

### new ReferenceElementNode(referenceNode, indexNode)
Constructs a new reference element node.


| Param | Type | Description |
| --- | --- | --- |
| referenceNode | [<code>ReferenceNode</code>](#ReferenceNode) | The reference node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="ReferenceElementNode+referenceNode"></a>

### referenceElementNode.referenceNode : [<code>ReferenceNode</code>](#ReferenceNode)
Similar to [reference](#ReferenceNode+reference), an additional
property references to the current node.

**Kind**: instance property of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Default**: <code>null</code>  
<a name="ReferenceElementNode+isReferenceElementNode"></a>

### referenceElementNode.isReferenceElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ReferenceElementNode+getNodeType"></a>

### referenceElementNode.getNodeType() ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the uniform type of the reference node.

**Kind**: instance method of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Returns**: <code>string</code> - The node type.  
<a name="ReferenceNode"></a>

## ReferenceNode ⇐ <code>Node</code>
This type of node establishes a reference to a property of another object.
In this way, the value of the node is automatically linked to the value of
referenced object. Reference nodes internally represent the linked value
as a uniform.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ReferenceNode](#ReferenceNode) ⇐ <code>Node</code>
    * [new ReferenceNode(property, uniformType, [object], [count])](#new_ReferenceNode_new)
    * [.property](#ReferenceNode+property) : <code>string</code>
    * [.uniformType](#ReferenceNode+uniformType) : <code>string</code>
    * [.object](#ReferenceNode+object) : <code>Object</code>
    * [.count](#ReferenceNode+count) : <code>number</code>
    * [.properties](#ReferenceNode+properties) : <code>Array.&lt;string&gt;</code>
    * [.reference](#ReferenceNode+reference) : <code>Object</code>
    * [.node](#ReferenceNode+node) : <code>UniformNode</code>
    * [.group](#ReferenceNode+group) : <code>UniformGroupNode</code>
    * [.name](#ReferenceNode+name) : <code>string</code>
    * [.updateType](#ReferenceNode+updateType) : <code>string</code>
    * [.element(indexNode)](#ReferenceNode+element) ⇒ [<code>ReferenceElementNode</code>](#ReferenceElementNode)
    * [.setGroup(group)](#ReferenceNode+setGroup) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
    * [.label(name)](#ReferenceNode+label) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
    * [.setNodeType(uniformType)](#ReferenceNode+setNodeType)
    * [.getNodeType(builder)](#ReferenceNode+getNodeType) ⇒ <code>string</code>
    * [.getValueFromReference([object])](#ReferenceNode+getValueFromReference) ⇒ <code>any</code>
    * [.updateReference(state)](#ReferenceNode+updateReference) ⇒ <code>Object</code>
    * [.setup(builder)](#ReferenceNode+setup) ⇒ <code>UniformNode</code>
    * [.update(frame)](#ReferenceNode+update)
    * [.updateValue()](#ReferenceNode+updateValue)

<a name="new_ReferenceNode_new"></a>

### new ReferenceNode(property, uniformType, [object], [count])
Constructs a new reference node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The name of the property the node refers to. |
| uniformType | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [object] | <code>Object</code> | <code></code> | The object the property belongs to. |
| [count] | <code>number</code> | <code></code> | When the linked property is an array-like, this parameter defines its length. |

<a name="ReferenceNode+property"></a>

### referenceNode.property : <code>string</code>
The name of the property the node refers to.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
<a name="ReferenceNode+uniformType"></a>

### referenceNode.uniformType : <code>string</code>
The uniform type that should be used to represent the property value.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
<a name="ReferenceNode+object"></a>

### referenceNode.object : <code>Object</code>
The object the property belongs to.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+count"></a>

### referenceNode.count : <code>number</code>
When the linked property is an array, this parameter defines its length.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+properties"></a>

### referenceNode.properties : <code>Array.&lt;string&gt;</code>
The property name might have dots so nested properties can be referred.
The hierarchy of the names is stored inside this array.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
<a name="ReferenceNode+reference"></a>

### referenceNode.reference : <code>Object</code>
Points to the current referred object. This property exists next to [object](#ReferenceNode+object)
since the final reference might be updated from calling code.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+node"></a>

### referenceNode.node : <code>UniformNode</code>
The uniform node that holds the value of the reference node.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+group"></a>

### referenceNode.group : <code>UniformGroupNode</code>
The uniform group of the internal uniform.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+name"></a>

### referenceNode.name : <code>string</code>
An optional label of the internal uniform node.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="ReferenceNode+updateType"></a>

### referenceNode.updateType : <code>string</code>
Overwritten since reference nodes are updated per object.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="ReferenceNode+element"></a>

### referenceNode.element(indexNode) ⇒ [<code>ReferenceElementNode</code>](#ReferenceElementNode)
When the referred property is array-like, this method can be used
to access elements via an index node.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: [<code>ReferenceElementNode</code>](#ReferenceElementNode) - A reference to an element.  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | indexNode. |

<a name="ReferenceNode+setGroup"></a>

### referenceNode.setGroup(group) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
Sets the uniform group for this reference node.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: [<code>ReferenceNode</code>](#ReferenceNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| group | <code>UniformGroupNode</code> | The uniform group to set. |

<a name="ReferenceNode+label"></a>

### referenceNode.label(name) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
Sets the label for the internal uniform.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: [<code>ReferenceNode</code>](#ReferenceNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The label to set. |

<a name="ReferenceNode+setNodeType"></a>

### referenceNode.setNodeType(uniformType)
Sets the node type which automatically defines the internal
uniform type.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  

| Param | Type | Description |
| --- | --- | --- |
| uniformType | <code>string</code> | The type to set. |

<a name="ReferenceNode+getNodeType"></a>

### referenceNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the type of the reference node.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ReferenceNode+getValueFromReference"></a>

### referenceNode.getValueFromReference([object]) ⇒ <code>any</code>
Returns the property value from the given referred object.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: <code>any</code> - The value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [object] | <code>Object</code> | <code>this.reference</code> | The object to retrieve the property value from. |

<a name="ReferenceNode+updateReference"></a>

### referenceNode.updateReference(state) ⇒ <code>Object</code>
Allows to update the reference based on the given state. The state is only
evaluated [object](#ReferenceNode+object) is not set.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: <code>Object</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state. |

<a name="ReferenceNode+setup"></a>

### referenceNode.setup(builder) ⇒ <code>UniformNode</code>
The output of the reference node is the internal uniform node.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: <code>UniformNode</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ReferenceNode+update"></a>

### referenceNode.update(frame)
Overwritten to to update the internal uniform value.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="ReferenceNode+updateValue"></a>

### referenceNode.updateValue()
Retrieves the value from the referred object property and uses it
to updated the internal uniform.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
<a name="reference"></a>

## reference(name, type, [object]) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
TSL function for creating a reference node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property the node refers to. |
| type | <code>string</code> | The uniform type that should be used to represent the property value. |
| [object] | <code>Object</code> | The object the property belongs to. |

<a name="referenceBuffer"></a>

## referenceBuffer(name, type, count, object) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
TSL function for creating a reference node. Use this function if you want need a reference
to an array-like property that should be represented as a uniform buffer.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property the node refers to. |
| type | <code>string</code> | The uniform type that should be used to represent the property value. |
| count | <code>number</code> | The number of value inside the array-like object. |
| object | <code>Object</code> | An array-like object the property belongs to. |

## Constants

<dl>
<dt><a href="#reflectView">reflectView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>The reflect vector in view space.</p>
</dd>
<dt><a href="#refractView">refractView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>The refract vector in view space.</p>
</dd>
<dt><a href="#reflectVector">reflectVector</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Used for sampling cube maps when using cube reflection mapping.</p>
</dd>
<dt><a href="#refractVector">refractVector</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Used for sampling cube maps when using cube refraction mapping.</p>
</dd>
</dl>

<a name="reflectView"></a>

## reflectView : <code>Node.&lt;vec3&gt;</code>
The reflect vector in view space.

**Kind**: global constant  
**Tsl**:   
<a name="refractView"></a>

## refractView : <code>Node.&lt;vec3&gt;</code>
The refract vector in view space.

**Kind**: global constant  
**Tsl**:   
<a name="reflectVector"></a>

## reflectVector : <code>Node.&lt;vec3&gt;</code>
Used for sampling cube maps when using cube reflection mapping.

**Kind**: global constant  
**Tsl**:   
<a name="refractVector"></a>

## refractVector : <code>Node.&lt;vec3&gt;</code>
Used for sampling cube maps when using cube refraction mapping.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#RendererReferenceNode">RendererReferenceNode</a> ⇐ <code>ReferenceBaseNode</code></dt>
<dd><p>This node is a special type of reference node which is intended
for linking renderer properties with node values.</p>
<pre><code class="language-js">const exposureNode = rendererReference( &#39;toneMappingExposure&#39;, &#39;float&#39;, renderer );
</code></pre>
<p>When changing <code>renderer.toneMappingExposure</code>, the node value of <code>exposureNode</code> will
automatically be updated.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#rendererReference">rendererReference(name, type, [renderer])</a> ⇒ <code><a href="#RendererReferenceNode">RendererReferenceNode</a></code></dt>
<dd><p>TSL function for creating a renderer reference node.</p>
</dd>
</dl>

<a name="RendererReferenceNode"></a>

## RendererReferenceNode ⇐ <code>ReferenceBaseNode</code>
This node is a special type of reference node which is intended
for linking renderer properties with node values.
```js
const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );
```
When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will
automatically be updated.

**Kind**: global class  
**Extends**: <code>ReferenceBaseNode</code>  

* [RendererReferenceNode](#RendererReferenceNode) ⇐ <code>ReferenceBaseNode</code>
    * [new RendererReferenceNode(property, inputType, [renderer])](#new_RendererReferenceNode_new)
    * [.renderer](#RendererReferenceNode+renderer) : <code>Renderer</code>
    * [.updateReference(state)](#RendererReferenceNode+updateReference) ⇒ <code>Object</code>

<a name="new_RendererReferenceNode_new"></a>

### new RendererReferenceNode(property, inputType, [renderer])
Constructs a new renderer reference node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The name of the property the node refers to. |
| inputType | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [renderer] | <code>Renderer</code> | <code></code> | The renderer the property belongs to. When no renderer is set, the node refers to the renderer of the current state. |

<a name="RendererReferenceNode+renderer"></a>

### rendererReferenceNode.renderer : <code>Renderer</code>
The renderer the property belongs to. When no renderer is set,
the node refers to the renderer of the current state.

**Kind**: instance property of [<code>RendererReferenceNode</code>](#RendererReferenceNode)  
**Default**: <code>null</code>  
<a name="RendererReferenceNode+updateReference"></a>

### rendererReferenceNode.updateReference(state) ⇒ <code>Object</code>
Updates the reference based on the given state. The state is only evaluated
[renderer](#RendererReferenceNode+renderer) is not set.

**Kind**: instance method of [<code>RendererReferenceNode</code>](#RendererReferenceNode)  
**Returns**: <code>Object</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state. |

<a name="rendererReference"></a>

## rendererReference(name, type, [renderer]) ⇒ [<code>RendererReferenceNode</code>](#RendererReferenceNode)
TSL function for creating a renderer reference node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the property the node refers to. |
| type | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [renderer] | <code>Renderer</code> | <code></code> | The renderer the property belongs to. When no renderer is set, the node refers to the renderer of the current state. |

## Classes

<dl>
<dt><a href="#SceneNode">SceneNode</a> ⇐ <code>Node</code></dt>
<dd><p>This module allows access to a collection of scene properties. The following predefined TSL objects
are available for easier use:</p>
<ul>
<li><code>backgroundBlurriness</code>: A node that represents the scene&#39;s background blurriness.</li>
<li><code>backgroundIntensity</code>: A node that represents the scene&#39;s background intensity.</li>
<li><code>backgroundRotation</code>: A node that represents the scene&#39;s background rotation.</li>
</ul>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#backgroundBlurriness">backgroundBlurriness</a> : <code><a href="#SceneNode">SceneNode</a></code></dt>
<dd><p>TSL object that represents the scene&#39;s background blurriness.</p>
</dd>
<dt><a href="#backgroundIntensity">backgroundIntensity</a> : <code><a href="#SceneNode">SceneNode</a></code></dt>
<dd><p>TSL object that represents the scene&#39;s background intensity.</p>
</dd>
<dt><a href="#backgroundRotation">backgroundRotation</a> : <code><a href="#SceneNode">SceneNode</a></code></dt>
<dd><p>TSL object that represents the scene&#39;s background rotation.</p>
</dd>
</dl>

<a name="SceneNode"></a>

## SceneNode ⇐ <code>Node</code>
This module allows access to a collection of scene properties. The following predefined TSL objects
are available for easier use:

- `backgroundBlurriness`: A node that represents the scene's background blurriness.
- `backgroundIntensity`: A node that represents the scene's background intensity.
- `backgroundRotation`: A node that represents the scene's background rotation.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [SceneNode](#SceneNode) ⇐ <code>Node</code>
    * [new SceneNode(scope, [scene])](#new_SceneNode_new)
    * [.scope](#SceneNode+scope) : <code>&#x27;backgroundBlurriness&#x27;</code> \| <code>&#x27;backgroundIntensity&#x27;</code> \| <code>&#x27;backgroundRotation&#x27;</code>
    * [.scene](#SceneNode+scene) : <code>Scene</code>
    * [.setup(builder)](#SceneNode+setup) ⇒ <code>Node</code>

<a name="new_SceneNode_new"></a>

### new SceneNode(scope, [scene])
Constructs a new scene node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scope | <code>&#x27;backgroundBlurriness&#x27;</code> \| <code>&#x27;backgroundIntensity&#x27;</code> \| <code>&#x27;backgroundRotation&#x27;</code> |  | The scope defines the type of scene property that is accessed. |
| [scene] | <code>Scene</code> | <code></code> | A reference to the scene. |

<a name="SceneNode+scope"></a>

### sceneNode.scope : <code>&#x27;backgroundBlurriness&#x27;</code> \| <code>&#x27;backgroundIntensity&#x27;</code> \| <code>&#x27;backgroundRotation&#x27;</code>
The scope defines the type of scene property that is accessed.

**Kind**: instance property of [<code>SceneNode</code>](#SceneNode)  
<a name="SceneNode+scene"></a>

### sceneNode.scene : <code>Scene</code>
A reference to the scene that is going to be accessed.

**Kind**: instance property of [<code>SceneNode</code>](#SceneNode)  
**Default**: <code>null</code>  
<a name="SceneNode+setup"></a>

### sceneNode.setup(builder) ⇒ <code>Node</code>
Depending on the scope, the method returns a different type of node that represents
the respective scene property.

**Kind**: instance method of [<code>SceneNode</code>](#SceneNode)  
**Returns**: <code>Node</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="backgroundBlurriness"></a>

## backgroundBlurriness : [<code>SceneNode</code>](#SceneNode)
TSL object that represents the scene's background blurriness.

**Kind**: global constant  
**Tsl**:   
<a name="backgroundIntensity"></a>

## backgroundIntensity : [<code>SceneNode</code>](#SceneNode)
TSL object that represents the scene's background intensity.

**Kind**: global constant  
**Tsl**:   
<a name="backgroundRotation"></a>

## backgroundRotation : [<code>SceneNode</code>](#SceneNode)
TSL object that represents the scene's background rotation.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#SkinningNode">SkinningNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node implements the vertex transformation shader logic which is required
for skinning/skeletal animation.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#skinning">skinning(skinnedMesh)</a> ⇒ <code><a href="#SkinningNode">SkinningNode</a></code></dt>
<dd><p>TSL function for creating a skinning node.</p>
</dd>
<dt><a href="#computeSkinning">computeSkinning(skinnedMesh, [toPosition])</a> ⇒ <code><a href="#SkinningNode">SkinningNode</a></code></dt>
<dd><p>TSL function for computing skinning.</p>
</dd>
</dl>

<a name="SkinningNode"></a>

## SkinningNode ⇐ <code>Node</code>
This node implements the vertex transformation shader logic which is required
for skinning/skeletal animation.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [SkinningNode](#SkinningNode) ⇐ <code>Node</code>
    * [new SkinningNode(skinnedMesh)](#new_SkinningNode_new)
    * [.skinnedMesh](#SkinningNode+skinnedMesh) : <code>SkinnedMesh</code>
    * [.updateType](#SkinningNode+updateType) : <code>string</code>
    * [.skinIndexNode](#SkinningNode+skinIndexNode) : <code>AttributeNode</code>
    * [.skinWeightNode](#SkinningNode+skinWeightNode) : <code>AttributeNode</code>
    * [.bindMatrixNode](#SkinningNode+bindMatrixNode) : <code>Node.&lt;mat4&gt;</code>
    * [.bindMatrixInverseNode](#SkinningNode+bindMatrixInverseNode) : <code>Node.&lt;mat4&gt;</code>
    * [.boneMatricesNode](#SkinningNode+boneMatricesNode) : <code>Node</code>
    * [.positionNode](#SkinningNode+positionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.toPositionNode](#SkinningNode+toPositionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.previousBoneMatricesNode](#SkinningNode+previousBoneMatricesNode) : <code>Node</code>
    * [.getSkinnedPosition([boneMatrices], [position])](#SkinningNode+getSkinnedPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.getSkinnedNormal([boneMatrices], [normal])](#SkinningNode+getSkinnedNormal) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.getPreviousSkinnedPosition(builder)](#SkinningNode+getPreviousSkinnedPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.needsPreviousBoneMatrices(builder)](#SkinningNode+needsPreviousBoneMatrices) ⇒ <code>boolean</code>
    * [.setup(builder)](#SkinningNode+setup) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.generate(builder, output)](#SkinningNode+generate) ⇒ <code>string</code>
    * [.update(frame)](#SkinningNode+update)

<a name="new_SkinningNode_new"></a>

### new SkinningNode(skinnedMesh)
Constructs a new skinning node.


| Param | Type | Description |
| --- | --- | --- |
| skinnedMesh | <code>SkinnedMesh</code> | The skinned mesh. |

<a name="SkinningNode+skinnedMesh"></a>

### skinningNode.skinnedMesh : <code>SkinnedMesh</code>
The skinned mesh.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+updateType"></a>

### skinningNode.updateType : <code>string</code>
The update type overwritten since skinning nodes are updated per object.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+skinIndexNode"></a>

### skinningNode.skinIndexNode : <code>AttributeNode</code>
The skin index attribute.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+skinWeightNode"></a>

### skinningNode.skinWeightNode : <code>AttributeNode</code>
The skin weight attribute.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+bindMatrixNode"></a>

### skinningNode.bindMatrixNode : <code>Node.&lt;mat4&gt;</code>
The bind matrix node.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+bindMatrixInverseNode"></a>

### skinningNode.bindMatrixInverseNode : <code>Node.&lt;mat4&gt;</code>
The bind matrix inverse node.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+boneMatricesNode"></a>

### skinningNode.boneMatricesNode : <code>Node</code>
The bind matrices as a uniform buffer node.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+positionNode"></a>

### skinningNode.positionNode : <code>Node.&lt;vec3&gt;</code>
The current vertex position in local space.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+toPositionNode"></a>

### skinningNode.toPositionNode : <code>Node.&lt;vec3&gt;</code>
The result of vertex position in local space.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+previousBoneMatricesNode"></a>

### skinningNode.previousBoneMatricesNode : <code>Node</code>
The previous bind matrices as a uniform buffer node.
Required for computing motion vectors.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
**Default**: <code>null</code>  
<a name="SkinningNode+getSkinnedPosition"></a>

### skinningNode.getSkinnedPosition([boneMatrices], [position]) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the given vertex position via skinning.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed vertex position.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [boneMatrices] | <code>Node</code> | <code>this.boneMatricesNode</code> | The bone matrices |
| [position] | <code>Node.&lt;vec3&gt;</code> | <code>this.positionNode</code> | The vertex position in local space. |

<a name="SkinningNode+getSkinnedNormal"></a>

### skinningNode.getSkinnedNormal([boneMatrices], [normal]) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the given vertex normal via skinning.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed vertex normal.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [boneMatrices] | <code>Node</code> | <code>this.boneMatricesNode</code> | The bone matrices |
| [normal] | <code>Node.&lt;vec3&gt;</code> | <code>normalLocal</code> | The vertex normal in local space. |

<a name="SkinningNode+getPreviousSkinnedPosition"></a>

### skinningNode.getPreviousSkinnedPosition(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the given vertex normal via skinning.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The skinned position from the previous frame.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SkinningNode+needsPreviousBoneMatrices"></a>

### skinningNode.needsPreviousBoneMatrices(builder) ⇒ <code>boolean</code>
Returns `true` if bone matrices from the previous frame are required.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>boolean</code> - Whether bone matrices from the previous frame are required or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SkinningNode+setup"></a>

### skinningNode.setup(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the skinning node by assigning the transformed vertex data to predefined node variables.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed vertex position.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SkinningNode+generate"></a>

### skinningNode.generate(builder, output) ⇒ <code>string</code>
Generates the code snippet of the skinning node.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | The current output. |

<a name="SkinningNode+update"></a>

### skinningNode.update(frame)
Updates the state of the skinned mesh by updating the skeleton once per frame.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="skinning"></a>

## skinning(skinnedMesh) ⇒ [<code>SkinningNode</code>](#SkinningNode)
TSL function for creating a skinning node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| skinnedMesh | <code>SkinnedMesh</code> | The skinned mesh. |

<a name="computeSkinning"></a>

## computeSkinning(skinnedMesh, [toPosition]) ⇒ [<code>SkinningNode</code>](#SkinningNode)
TSL function for computing skinning.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| skinnedMesh | <code>SkinnedMesh</code> |  | The skinned mesh. |
| [toPosition] | <code>Node.&lt;vec3&gt;</code> | <code></code> | The target position. |

## Classes

<dl>
<dt><a href="#StorageBufferNode">StorageBufferNode</a> ⇐ <code>BufferNode</code></dt>
<dd><p>This node is used in context of compute shaders and allows to define a
storage buffer for data. A typical workflow is to create instances of
this node with the convenience functions <code>attributeArray()</code> or <code>instancedArray()</code>,
setup up a compute shader that writes into the buffers and then convert
the storage buffers to attribute nodes for rendering.</p>
<pre><code class="language-js">const positionBuffer = instancedArray( particleCount, &#39;vec3&#39; ); // the storage buffer node

const computeInit = Fn( () =&gt; { // the compute shader

    const position = positionBuffer.element( instanceIndex );

    // compute position data

    position.x = 1;
    position.y = 1;
    position.z = 1;

} )().compute( particleCount );

const particleMaterial = new THREE.SpriteNodeMaterial();
particleMaterial.positionNode = positionBuffer.toAttribute();

renderer.computeAsync( computeInit );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#storage">storage(value, [type], [count])</a> ⇒ <code><a href="#StorageBufferNode">StorageBufferNode</a></code></dt>
<dd><p>TSL function for creating a storage buffer node.</p>
</dd>
<dt><del><a href="#storageObject">storageObject(value, type, count)</a> ⇒ <code><a href="#StorageBufferNode">StorageBufferNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="StorageBufferNode"></a>

## StorageBufferNode ⇐ <code>BufferNode</code>
This node is used in context of compute shaders and allows to define a
storage buffer for data. A typical workflow is to create instances of
this node with the convenience functions `attributeArray()` or `instancedArray()`,
setup up a compute shader that writes into the buffers and then convert
the storage buffers to attribute nodes for rendering.

```js
const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node

const computeInit = Fn( () => { // the compute shader

	const position = positionBuffer.element( instanceIndex );

	// compute position data

	position.x = 1;
	position.y = 1;
	position.z = 1;

} )().compute( particleCount );

const particleMaterial = new THREE.SpriteNodeMaterial();
particleMaterial.positionNode = positionBuffer.toAttribute();

renderer.computeAsync( computeInit );

```

**Kind**: global class  
**Extends**: <code>BufferNode</code>  

* [StorageBufferNode](#StorageBufferNode) ⇐ <code>BufferNode</code>
    * [new StorageBufferNode(value, [bufferType], [bufferCount])](#new_StorageBufferNode_new)
    * [.isStorageBufferNode](#StorageBufferNode+isStorageBufferNode) : <code>boolean</code>
    * [.structTypeNode](#StorageBufferNode+structTypeNode) : <code>StructTypeNode</code>
    * [.access](#StorageBufferNode+access) : <code>string</code>
    * [.isAtomic](#StorageBufferNode+isAtomic) : <code>boolean</code>
    * [.isPBO](#StorageBufferNode+isPBO) : <code>boolean</code>
    * [._attribute](#StorageBufferNode+_attribute) : <code>BufferAttributeNode</code>
    * [._varying](#StorageBufferNode+_varying) : <code>VaryingNode</code>
    * [.global](#StorageBufferNode+global) : <code>boolean</code>
    * [.getHash(builder)](#StorageBufferNode+getHash) ⇒ <code>string</code>
    * [.getInputType(builder)](#StorageBufferNode+getInputType) ⇒ <code>string</code>
    * [.element(indexNode)](#StorageBufferNode+element) ⇒ <code>StorageArrayElementNode</code>
    * [.setPBO(value)](#StorageBufferNode+setPBO) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.getPBO()](#StorageBufferNode+getPBO) ⇒ <code>boolean</code>
    * [.setAccess(value)](#StorageBufferNode+setAccess) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.toReadOnly()](#StorageBufferNode+toReadOnly) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.setAtomic(value)](#StorageBufferNode+setAtomic) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.toAtomic()](#StorageBufferNode+toAtomic) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.getAttributeData()](#StorageBufferNode+getAttributeData) ⇒ <code>Object</code>
    * [.getNodeType(builder)](#StorageBufferNode+getNodeType) ⇒ <code>string</code>
    * [.generate(builder)](#StorageBufferNode+generate) ⇒ <code>string</code>

<a name="new_StorageBufferNode_new"></a>

### new StorageBufferNode(value, [bufferType], [bufferCount])
Constructs a new storage buffer node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageBufferAttribute</code> \| <code>StorageInstancedBufferAttribute</code> \| <code>BufferAttribute</code> |  | The buffer data. |
| [bufferType] | <code>string</code> \| <code>Struct</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [bufferCount] | <code>number</code> | <code>0</code> | The buffer count. |

<a name="StorageBufferNode+isStorageBufferNode"></a>

### storageBufferNode.isStorageBufferNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageBufferNode+structTypeNode"></a>

### storageBufferNode.structTypeNode : <code>StructTypeNode</code>
The buffer struct type.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>null</code>  
<a name="StorageBufferNode+access"></a>

### storageBufferNode.access : <code>string</code>
The access type of the texture node.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>&quot;&#x27;readWrite&#x27;&quot;</code>  
<a name="StorageBufferNode+isAtomic"></a>

### storageBufferNode.isAtomic : <code>boolean</code>
Whether the node is atomic or not.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>false</code>  
<a name="StorageBufferNode+isPBO"></a>

### storageBufferNode.isPBO : <code>boolean</code>
Whether the node represents a PBO or not.
Only relevant for WebGL.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>false</code>  
<a name="StorageBufferNode+_attribute"></a>

### storageBufferNode.\_attribute : <code>BufferAttributeNode</code>
A reference to the internal buffer attribute node.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>null</code>  
<a name="StorageBufferNode+_varying"></a>

### storageBufferNode.\_varying : <code>VaryingNode</code>
A reference to the internal varying node.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>null</code>  
<a name="StorageBufferNode+global"></a>

### storageBufferNode.global : <code>boolean</code>
`StorageBufferNode` sets this property to `true` by default.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>true</code>  
<a name="StorageBufferNode+getHash"></a>

### storageBufferNode.getHash(builder) ⇒ <code>string</code>
This method is overwritten since the buffer data might be shared
and thus the hash should be shared as well.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>string</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="StorageBufferNode+getInputType"></a>

### storageBufferNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="StorageBufferNode+element"></a>

### storageBufferNode.element(indexNode) ⇒ <code>StorageArrayElementNode</code>
Enables element access with the given index node.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>StorageArrayElementNode</code> - A node representing the element access.  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | The index node. |

<a name="StorageBufferNode+setPBO"></a>

### storageBufferNode.setPBO(value) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Defines whether this node is a PBO or not. Only relevant for WebGL.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The value so set. |

<a name="StorageBufferNode+getPBO"></a>

### storageBufferNode.getPBO() ⇒ <code>boolean</code>
Returns the `isPBO` value.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>boolean</code> - Whether the node represents a PBO or not.  
<a name="StorageBufferNode+setAccess"></a>

### storageBufferNode.setAccess(value) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Defines the node access.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>string</code> | The node access. |

<a name="StorageBufferNode+toReadOnly"></a>

### storageBufferNode.toReadOnly() ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Convenience method for configuring a read-only node access.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  
<a name="StorageBufferNode+setAtomic"></a>

### storageBufferNode.setAtomic(value) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Defines whether the node is atomic or not.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The atomic flag. |

<a name="StorageBufferNode+toAtomic"></a>

### storageBufferNode.toAtomic() ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Convenience method for making this node atomic.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  
<a name="StorageBufferNode+getAttributeData"></a>

### storageBufferNode.getAttributeData() ⇒ <code>Object</code>
Returns attribute data for this storage buffer node.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>Object</code> - The attribute data.  
<a name="StorageBufferNode+getNodeType"></a>

### storageBufferNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type from the availability of storage buffers
and the attribute data.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="StorageBufferNode+generate"></a>

### storageBufferNode.generate(builder) ⇒ <code>string</code>
Generates the code snippet of the storage buffer node.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="storage"></a>

## storage(value, [type], [count]) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
TSL function for creating a storage buffer node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageBufferAttribute</code> \| <code>StorageInstancedBufferAttribute</code> \| <code>BufferAttribute</code> |  | The buffer data. |
| [type] | <code>string</code> \| <code>Struct</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [count] | <code>number</code> | <code>0</code> | The buffer count. |

<a name="storageObject"></a>

## ~~storageObject(value, type, count) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)~~
***since r171. Use `storage().setPBO( true )` instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StorageBufferAttribute</code> \| <code>StorageInstancedBufferAttribute</code> \| <code>BufferAttribute</code> | The buffer data. |
| type | <code>string</code> | The buffer type (e.g. `'vec3'`). |
| count | <code>number</code> | The buffer count. |

## Classes

<dl>
<dt><a href="#StorageTextureNode">StorageTextureNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>This special version of a texture node can be used to
write data into a storage texture with a compute shader.</p>
<pre><code class="language-js">const storageTexture = new THREE.StorageTexture( width, height );

const computeTexture = Fn( ( { storageTexture } ) =&gt; {

    const posX = instanceIndex.mod( width );
    const posY = instanceIndex.div( width );
    const indexUV = uvec2( posX, posY );

    // generate RGB values

    const r = 1;
    const g = 1;
    const b = 1;

    textureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();

} );

const computeNode = computeTexture( { storageTexture } ).compute( width * height );
renderer.computeAsync( computeNode );
</code></pre>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#storageTexture">storageTexture(value, uvNode, [storeNode])</a> ⇒ <code><a href="#StorageTextureNode">StorageTextureNode</a></code></dt>
<dd><p>TSL function for creating a storage texture node.</p>
</dd>
<dt><a href="#textureStore">textureStore(value, uvNode, [storeNode])</a> ⇒ <code><a href="#StorageTextureNode">StorageTextureNode</a></code></dt>
<dd><p>TODO: Explain difference to <code>storageTexture()</code>.</p>
</dd>
</dl>

<a name="StorageTextureNode"></a>

## StorageTextureNode ⇐ <code>TextureNode</code>
This special version of a texture node can be used to
write data into a storage texture with a compute shader.

```js
const storageTexture = new THREE.StorageTexture( width, height );

const computeTexture = Fn( ( { storageTexture } ) => {

	const posX = instanceIndex.mod( width );
	const posY = instanceIndex.div( width );
	const indexUV = uvec2( posX, posY );

	// generate RGB values

	const r = 1;
	const g = 1;
	const b = 1;

	textureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();

} );

const computeNode = computeTexture( { storageTexture } ).compute( width * height );
renderer.computeAsync( computeNode );
```

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [StorageTextureNode](#StorageTextureNode) ⇐ <code>TextureNode</code>
    * [new StorageTextureNode(value, uvNode, [storeNode])](#new_StorageTextureNode_new)
    * [.storeNode](#StorageTextureNode+storeNode) : <code>Node</code>
    * [.isStorageTextureNode](#StorageTextureNode+isStorageTextureNode) : <code>boolean</code>
    * [.access](#StorageTextureNode+access) : <code>string</code>
    * [.getInputType(builder)](#StorageTextureNode+getInputType) ⇒ <code>string</code>
    * [.setAccess(value)](#StorageTextureNode+setAccess) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
    * [.generate(builder, output)](#StorageTextureNode+generate) ⇒ <code>string</code>
    * [.toReadWrite()](#StorageTextureNode+toReadWrite) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
    * [.toReadOnly()](#StorageTextureNode+toReadOnly) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
    * [.toWriteOnly()](#StorageTextureNode+toWriteOnly) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
    * [.generateStore(builder)](#StorageTextureNode+generateStore)

<a name="new_StorageTextureNode_new"></a>

### new StorageTextureNode(value, uvNode, [storeNode])
Constructs a new storage texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageTexture</code> |  | The storage texture. |
| uvNode | <code>Node.&lt;(vec2\|vec3)&gt;</code> |  | The uv node. |
| [storeNode] | <code>Node</code> | <code></code> | The value node that should be stored in the texture. |

<a name="StorageTextureNode+storeNode"></a>

### storageTextureNode.storeNode : <code>Node</code>
The value node that should be stored in the texture.

**Kind**: instance property of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Default**: <code>null</code>  
<a name="StorageTextureNode+isStorageTextureNode"></a>

### storageTextureNode.isStorageTextureNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageTextureNode+access"></a>

### storageTextureNode.access : <code>string</code>
The access type of the texture node.

**Kind**: instance property of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Default**: <code>&quot;&#x27;writeOnly&#x27;&quot;</code>  
<a name="StorageTextureNode+getInputType"></a>

### storageTextureNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'storageTexture'`.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="StorageTextureNode+setAccess"></a>

### storageTextureNode.setAccess(value) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
Defines the node access.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: [<code>StorageTextureNode</code>](#StorageTextureNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>string</code> | The node access. |

<a name="StorageTextureNode+generate"></a>

### storageTextureNode.generate(builder, output) ⇒ <code>string</code>
Generates the code snippet of the storage node. If no `storeNode`
is defined, the texture node is generated as normal texture.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | The current output. |

<a name="StorageTextureNode+toReadWrite"></a>

### storageTextureNode.toReadWrite() ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
Convenience method for configuring a read/write node access.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: [<code>StorageTextureNode</code>](#StorageTextureNode) - A reference to this node.  
<a name="StorageTextureNode+toReadOnly"></a>

### storageTextureNode.toReadOnly() ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
Convenience method for configuring a read-only node access.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: [<code>StorageTextureNode</code>](#StorageTextureNode) - A reference to this node.  
<a name="StorageTextureNode+toWriteOnly"></a>

### storageTextureNode.toWriteOnly() ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
Convenience method for configuring a write-only node access.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: [<code>StorageTextureNode</code>](#StorageTextureNode) - A reference to this node.  
<a name="StorageTextureNode+generateStore"></a>

### storageTextureNode.generateStore(builder)
Generates the code snippet of the storage texture node.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="storageTexture"></a>

## storageTexture(value, uvNode, [storeNode]) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
TSL function for creating a storage texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageTexture</code> |  | The storage texture. |
| uvNode | <code>Node.&lt;(vec2\|vec3)&gt;</code> |  | The uv node. |
| [storeNode] | <code>Node</code> | <code></code> | The value node that should be stored in the texture. |

<a name="textureStore"></a>

## textureStore(value, uvNode, [storeNode]) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
TODO: Explain difference to `storageTexture()`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageTexture</code> |  | The storage texture. |
| uvNode | <code>Node.&lt;(vec2\|vec3)&gt;</code> |  | The uv node. |
| [storeNode] | <code>Node</code> | <code></code> | The value node that should be stored in the texture. |

## Constants

<dl>
<dt><a href="#tangentGeometry">tangentGeometry</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the tangent attribute of the current rendered object.</p>
</dd>
<dt><a href="#tangentLocal">tangentLocal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex tangent in local space of the current rendered object.</p>
</dd>
<dt><a href="#tangentView">tangentView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex tangent in view space of the current rendered object.</p>
</dd>
<dt><a href="#tangentWorld">tangentWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex tangent in world space of the current rendered object.</p>
</dd>
<dt><a href="#transformedTangentView">transformedTangentView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex tangent in view space of the current rendered object.</p>
</dd>
<dt><a href="#transformedTangentWorld">transformedTangentWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex tangent in world space of the current rendered object.</p>
</dd>
</dl>

<a name="tangentGeometry"></a>

## tangentGeometry : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the tangent attribute of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="tangentLocal"></a>

## tangentLocal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex tangent in local space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="tangentView"></a>

## tangentView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex tangent in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="tangentWorld"></a>

## tangentWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex tangent in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedTangentView"></a>

## transformedTangentView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed vertex tangent in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedTangentWorld"></a>

## transformedTangentWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed vertex tangent in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#Texture3DNode">Texture3DNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>This type of uniform node represents a 3D texture.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#texture3D">texture3D(value, [uvNode], [levelNode])</a> ⇒ <code><a href="#Texture3DNode">Texture3DNode</a></code></dt>
<dd><p>TSL function for creating a 3D texture node.</p>
</dd>
</dl>

<a name="Texture3DNode"></a>

## Texture3DNode ⇐ <code>TextureNode</code>
This type of uniform node represents a 3D texture.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [Texture3DNode](#Texture3DNode) ⇐ <code>TextureNode</code>
    * [new Texture3DNode(value, [uvNode], [levelNode])](#new_Texture3DNode_new)
    * [.isTexture3DNode](#Texture3DNode+isTexture3DNode) : <code>boolean</code>
    * [.getInputType(builder)](#Texture3DNode+getInputType) ⇒ <code>string</code>
    * [.getDefaultUV()](#Texture3DNode+getDefaultUV) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setUpdateMatrix(value)](#Texture3DNode+setUpdateMatrix)
    * [.setupUV(builder, uvNode)](#Texture3DNode+setupUV) ⇒ <code>Node</code>
    * [.generateUV(builder, uvNode)](#Texture3DNode+generateUV) ⇒ <code>string</code>
    * [.normal(uvNode)](#Texture3DNode+normal) ⇒ <code>Node.&lt;vec3&gt;</code>

<a name="new_Texture3DNode_new"></a>

### new Texture3DNode(value, [uvNode], [levelNode])
Constructs a new 3D texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Data3DTexture</code> |  | The 3D texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |

<a name="Texture3DNode+isTexture3DNode"></a>

### texture3DNode.isTexture3DNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Texture3DNode</code>](#Texture3DNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Texture3DNode+getInputType"></a>

### texture3DNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'texture3D'`.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Texture3DNode+getDefaultUV"></a>

### texture3DNode.getDefaultUV() ⇒ <code>Node.&lt;vec3&gt;</code>
Returns a default uv node which is in context of 3D textures a three-dimensional
uv node.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The default uv node.  
<a name="Texture3DNode+setUpdateMatrix"></a>

### texture3DNode.setUpdateMatrix(value)
Overwritten with an empty implementation since the `updateMatrix` flag is ignored
for 3D textures. The uv transformation matrix is not applied to 3D textures.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The update toggle. |

<a name="Texture3DNode+setupUV"></a>

### texture3DNode.setupUV(builder, uvNode) ⇒ <code>Node</code>
Overwrites the default implementation to return the unmodified uv node.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>Node</code> - The unmodified uv node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to setup. |

<a name="Texture3DNode+generateUV"></a>

### texture3DNode.generateUV(builder, uvNode) ⇒ <code>string</code>
Generates the uv code snippet.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to generate code for. |

<a name="Texture3DNode+normal"></a>

### texture3DNode.normal(uvNode) ⇒ <code>Node.&lt;vec3&gt;</code>
TODO.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - TODO.  

| Param | Type | Description |
| --- | --- | --- |
| uvNode | <code>Node.&lt;vec3&gt;</code> | The uv node . |

<a name="texture3D"></a>

## texture3D(value, [uvNode], [levelNode]) ⇒ [<code>Texture3DNode</code>](#Texture3DNode)
TSL function for creating a 3D texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Data3DTexture</code> |  | The 3D texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |

<a name="textureBicubic"></a>

## textureBicubic(textureNode, [lodNode]) ⇒ <code>Node</code>
Applies mipped bicubic texture filtering to the given texture node.

**Kind**: global function  
**Returns**: <code>Node</code> - The filtered texture sample.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that should be filtered. |
| [lodNode] | <code>Node.&lt;float&gt;</code> | <code>float(3)</code> | Defines the LOD to sample from. |

## Classes

<dl>
<dt><a href="#TextureNode">TextureNode</a> ⇐ <code>UniformNode</code></dt>
<dd><p>This type of uniform node represents a 2D texture.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#texture">texture(value, [uvNode], [levelNode], [biasNode])</a> ⇒ <code><a href="#TextureNode">TextureNode</a></code></dt>
<dd><p>TSL function for creating a texture node.</p>
</dd>
<dt><a href="#textureLoad">textureLoad(value, [uvNode], [levelNode], [biasNode])</a> ⇒ <code><a href="#TextureNode">TextureNode</a></code></dt>
<dd><p>TSL function for creating a texture node that fetches/loads texels without interpolation.</p>
</dd>
<dt><a href="#sampler">sampler(value)</a> ⇒ <code>Node</code></dt>
<dd><p>Converts a texture or texture node to a sampler.</p>
</dd>
<dt><a href="#samplerComparison">samplerComparison(value)</a> ⇒ <code>Node</code></dt>
<dd><p>Converts a texture or texture node to a sampler comparison.</p>
</dd>
</dl>

<a name="TextureNode"></a>

## TextureNode ⇐ <code>UniformNode</code>
This type of uniform node represents a 2D texture.

**Kind**: global class  
**Extends**: <code>UniformNode</code>  

* [TextureNode](#TextureNode) ⇐ <code>UniformNode</code>
    * [new TextureNode(value, [uvNode], [levelNode], [biasNode])](#new_TextureNode_new)
    * [.isTextureNode](#TextureNode+isTextureNode) : <code>boolean</code>
    * [.uvNode](#TextureNode+uvNode) : <code>Node.&lt;(vec2\|vec3)&gt;</code>
    * [.levelNode](#TextureNode+levelNode) : <code>Node.&lt;int&gt;</code>
    * [.biasNode](#TextureNode+biasNode) : <code>Node.&lt;float&gt;</code>
    * [.compareNode](#TextureNode+compareNode) : <code>Node.&lt;float&gt;</code>
    * [.depthNode](#TextureNode+depthNode) : <code>Node.&lt;int&gt;</code>
    * [.gradNode](#TextureNode+gradNode) : <code>Array.&lt;Node.&lt;vec2&gt;&gt;</code>
    * [.sampler](#TextureNode+sampler) : <code>boolean</code>
    * [.updateMatrix](#TextureNode+updateMatrix) : <code>boolean</code>
    * [.updateType](#TextureNode+updateType) : <code>string</code>
    * [.referenceNode](#TextureNode+referenceNode) : <code>Node</code>
    * [.value](#TextureNode+value) : <code>Texture</code>
    * [.getUniformHash(builder)](#TextureNode+getUniformHash) ⇒ <code>string</code>
    * [.getNodeType(builder)](#TextureNode+getNodeType) ⇒ <code>string</code>
    * [.getInputType(builder)](#TextureNode+getInputType) ⇒ <code>string</code>
    * [.getDefaultUV()](#TextureNode+getDefaultUV) ⇒ <code>AttributeNode.&lt;vec2&gt;</code>
    * [.updateReference(state)](#TextureNode+updateReference) ⇒ <code>Texture</code>
    * [.getTransformedUV(uvNode)](#TextureNode+getTransformedUV) ⇒ <code>Node</code>
    * [.setUpdateMatrix(value)](#TextureNode+setUpdateMatrix) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.setupUV(builder, uvNode)](#TextureNode+setupUV) ⇒ <code>Node</code>
    * [.setup(builder)](#TextureNode+setup)
    * [.generateUV(builder, uvNode)](#TextureNode+generateUV) ⇒ <code>string</code>
    * [.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet)](#TextureNode+generateSnippet) ⇒ <code>string</code>
    * [.generate(builder, output)](#TextureNode+generate) ⇒ <code>string</code>
    * [.setSampler(value)](#TextureNode+setSampler) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.getSampler()](#TextureNode+getSampler) ⇒ <code>boolean</code>
    * ~~[.uv(uvNode)](#TextureNode+uv) ⇒ [<code>TextureNode</code>](#TextureNode)~~
    * [.sample(uvNode)](#TextureNode+sample) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.blur(amountNode)](#TextureNode+blur) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.level(levelNode)](#TextureNode+level) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.size(levelNode)](#TextureNode+size) ⇒ <code>TextureSizeNode</code>
    * [.bias(biasNode)](#TextureNode+bias) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.compare(compareNode)](#TextureNode+compare) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.grad(gradNodeX, gradNodeY)](#TextureNode+grad) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.depth(depthNode)](#TextureNode+depth) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.update()](#TextureNode+update)
    * [.clone()](#TextureNode+clone) ⇒ [<code>TextureNode</code>](#TextureNode)

<a name="new_TextureNode_new"></a>

### new TextureNode(value, [uvNode], [levelNode], [biasNode])
Constructs a new texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

<a name="TextureNode+isTextureNode"></a>

### textureNode.isTextureNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TextureNode+uvNode"></a>

### textureNode.uvNode : <code>Node.&lt;(vec2\|vec3)&gt;</code>
Represents the texture coordinates.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+levelNode"></a>

### textureNode.levelNode : <code>Node.&lt;int&gt;</code>
Represents the mip level that should be selected.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+biasNode"></a>

### textureNode.biasNode : <code>Node.&lt;float&gt;</code>
Represents the bias to be applied during level-of-detail computation.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+compareNode"></a>

### textureNode.compareNode : <code>Node.&lt;float&gt;</code>
Represents a reference value a texture sample is compared to.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+depthNode"></a>

### textureNode.depthNode : <code>Node.&lt;int&gt;</code>
When using texture arrays, the depth node defines the layer to select.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+gradNode"></a>

### textureNode.gradNode : <code>Array.&lt;Node.&lt;vec2&gt;&gt;</code>
When defined, a texture is sampled using explicit gradients.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+sampler"></a>

### textureNode.sampler : <code>boolean</code>
Whether texture values should be sampled or fetched.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>true</code>  
<a name="TextureNode+updateMatrix"></a>

### textureNode.updateMatrix : <code>boolean</code>
Whether the uv transformation matrix should be
automatically updated or not. Use `setUpdateMatrix()`
if you want to change the value of the property.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>false</code>  
<a name="TextureNode+updateType"></a>

### textureNode.updateType : <code>string</code>
By default the `update()` method is not executed. `setUpdateMatrix()`
sets the value to `frame` when the uv transformation matrix should
automatically be updated.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>&quot;&#x27;none&#x27;&quot;</code>  
<a name="TextureNode+referenceNode"></a>

### textureNode.referenceNode : <code>Node</code>
The reference node.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+value"></a>

### textureNode.value : <code>Texture</code>
The texture value.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
<a name="TextureNode+getUniformHash"></a>

### textureNode.getUniformHash(builder) ⇒ <code>string</code>
Overwritten since the uniform hash is defined by the texture's UUID.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The uniform hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TextureNode+getNodeType"></a>

### textureNode.getNodeType(builder) ⇒ <code>string</code>
Overwritten since the node type is inferred from the texture type.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TextureNode+getInputType"></a>

### textureNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'texture'`.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TextureNode+getDefaultUV"></a>

### textureNode.getDefaultUV() ⇒ <code>AttributeNode.&lt;vec2&gt;</code>
Returns a default uvs based on the current texture's channel.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>AttributeNode.&lt;vec2&gt;</code> - The default uvs.  
<a name="TextureNode+updateReference"></a>

### textureNode.updateReference(state) ⇒ <code>Texture</code>
Overwritten to always return the texture reference of the node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>Texture</code> - The texture reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>any</code> | This method can be invocated in different contexts so `state` can refer to any object type. |

<a name="TextureNode+getTransformedUV"></a>

### textureNode.getTransformedUV(uvNode) ⇒ <code>Node</code>
Transforms the given uv node with the texture transformation matrix.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>Node</code> - The transformed uv node.  

| Param | Type | Description |
| --- | --- | --- |
| uvNode | <code>Node</code> | The uv node to transform. |

<a name="TextureNode+setUpdateMatrix"></a>

### textureNode.setUpdateMatrix(value) ⇒ [<code>TextureNode</code>](#TextureNode)
Defines whether the uv transformation matrix should automatically be updated or not.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The update toggle. |

<a name="TextureNode+setupUV"></a>

### textureNode.setupUV(builder, uvNode) ⇒ <code>Node</code>
Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
to modify the uv node for correct sampling.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>Node</code> - The updated uv node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to setup. |

<a name="TextureNode+setup"></a>

### textureNode.setup(builder)
Setups texture node by preparing the internal nodes for code generation.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TextureNode+generateUV"></a>

### textureNode.generateUV(builder, uvNode) ⇒ <code>string</code>
Generates the uv code snippet.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to generate code for. |

<a name="TextureNode+generateSnippet"></a>

### textureNode.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet) ⇒ <code>string</code>
Generates the snippet for the texture sampling.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| textureProperty | <code>string</code> | The texture property. |
| uvSnippet | <code>string</code> | The uv snippet. |
| levelSnippet | <code>string</code> | The level snippet. |
| biasSnippet | <code>string</code> | The bias snippet. |
| depthSnippet | <code>string</code> | The depth snippet. |
| compareSnippet | <code>string</code> | The compare snippet. |
| gradSnippet | <code>Array.&lt;string&gt;</code> | The grad snippet. |

<a name="TextureNode+generate"></a>

### textureNode.generate(builder, output) ⇒ <code>string</code>
Generates the code snippet of the texture node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | The current output. |

<a name="TextureNode+setSampler"></a>

### textureNode.setSampler(value) ⇒ [<code>TextureNode</code>](#TextureNode)
Sets the sampler value.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A reference to this texture node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The sampler value to set. |

<a name="TextureNode+getSampler"></a>

### textureNode.getSampler() ⇒ <code>boolean</code>
Returns the sampler value.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>boolean</code> - The sampler value.  
<a name="TextureNode+uv"></a>

### ~~textureNode.uv(uvNode) ⇒ [<code>TextureNode</code>](#TextureNode)~~
***since r172. Use [sample](#TextureNode+sample) instead.***

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| uvNode | <code>Node</code> | The uv node. |

<a name="TextureNode+sample"></a>

### textureNode.sample(uvNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture with the given uv node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| uvNode | <code>Node</code> | The uv node. |

<a name="TextureNode+blur"></a>

### textureNode.blur(amountNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples a blurred version of the texture by defining an internal bias.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| amountNode | <code>Node.&lt;float&gt;</code> | How blurred the texture should be. |

<a name="TextureNode+level"></a>

### textureNode.level(levelNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples a specific mip of the texture.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| levelNode | <code>Node.&lt;int&gt;</code> | The mip level to sample. |

<a name="TextureNode+size"></a>

### textureNode.size(levelNode) ⇒ <code>TextureSizeNode</code>
Returns the texture size of the requested level.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>TextureSizeNode</code> - The texture size.  

| Param | Type | Description |
| --- | --- | --- |
| levelNode | <code>Node.&lt;int&gt;</code> | The level to compute the size for. |

<a name="TextureNode+bias"></a>

### textureNode.bias(biasNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture with the given bias.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| biasNode | <code>Node.&lt;float&gt;</code> | The bias node. |

<a name="TextureNode+compare"></a>

### textureNode.compare(compareNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture by executing a compare operation.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| compareNode | <code>Node.&lt;float&gt;</code> | The node that defines the compare value. |

<a name="TextureNode+grad"></a>

### textureNode.grad(gradNodeX, gradNodeY) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture using an explicit gradient.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| gradNodeX | <code>Node.&lt;vec2&gt;</code> | The gradX node. |
| gradNodeY | <code>Node.&lt;vec2&gt;</code> | The gradY node. |

<a name="TextureNode+depth"></a>

### textureNode.depth(depthNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture by defining a depth node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| depthNode | <code>Node.&lt;int&gt;</code> | The depth node. |

<a name="TextureNode+update"></a>

### textureNode.update()
The update is used to implement the update of the uv transformation matrix.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
<a name="TextureNode+clone"></a>

### textureNode.clone() ⇒ [<code>TextureNode</code>](#TextureNode)
Clones the texture node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - The cloned texture node.  
<a name="texture"></a>

## texture(value, [uvNode], [levelNode], [biasNode]) ⇒ [<code>TextureNode</code>](#TextureNode)
TSL function for creating a texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

<a name="textureLoad"></a>

## textureLoad(value, [uvNode], [levelNode], [biasNode]) ⇒ [<code>TextureNode</code>](#TextureNode)
TSL function for creating a texture node that fetches/loads texels without interpolation.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

<a name="sampler"></a>

## sampler(value) ⇒ <code>Node</code>
Converts a texture or texture node to a sampler.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>TextureNode</code>](#TextureNode) \| <code>Texture</code> | The texture or texture node to convert. |

<a name="samplerComparison"></a>

## samplerComparison(value) ⇒ <code>Node</code>
Converts a texture or texture node to a sampler comparison.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>TextureNode</code>](#TextureNode) \| <code>Texture</code> | The texture or texture node to convert. |

## Classes

<dl>
<dt><a href="#TextureSizeNode">TextureSizeNode</a> ⇐ <code>Node</code></dt>
<dd><p>A node that represents the dimensions of a texture. The texture size is
retrieved in the shader via built-in shader functions like <code>textureDimensions()</code>
or <code>textureSize()</code>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#textureSize">textureSize(textureNode, [levelNode])</a> ⇒ <code><a href="#TextureSizeNode">TextureSizeNode</a></code></dt>
<dd><p>TSL function for creating a texture size node.</p>
</dd>
</dl>

<a name="TextureSizeNode"></a>

## TextureSizeNode ⇐ <code>Node</code>
A node that represents the dimensions of a texture. The texture size is
retrieved in the shader via built-in shader functions like `textureDimensions()`
or `textureSize()`.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [TextureSizeNode](#TextureSizeNode) ⇐ <code>Node</code>
    * [new TextureSizeNode(textureNode, [levelNode])](#new_TextureSizeNode_new)
    * [.isTextureSizeNode](#TextureSizeNode+isTextureSizeNode) : <code>boolean</code>
    * [.textureNode](#TextureSizeNode+textureNode) : <code>TextureNode</code>
    * [.levelNode](#TextureSizeNode+levelNode) : <code>Node.&lt;int&gt;</code>

<a name="new_TextureSizeNode_new"></a>

### new TextureSizeNode(textureNode, [levelNode])
Constructs a new texture size node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | A texture node which size should be retrieved. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | A level node which defines the requested mip. |

<a name="TextureSizeNode+isTextureSizeNode"></a>

### textureSizeNode.isTextureSizeNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>TextureSizeNode</code>](#TextureSizeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TextureSizeNode+textureNode"></a>

### textureSizeNode.textureNode : <code>TextureNode</code>
A texture node which size should be retrieved.

**Kind**: instance property of [<code>TextureSizeNode</code>](#TextureSizeNode)  
<a name="TextureSizeNode+levelNode"></a>

### textureSizeNode.levelNode : <code>Node.&lt;int&gt;</code>
A level node which defines the requested mip.

**Kind**: instance property of [<code>TextureSizeNode</code>](#TextureSizeNode)  
**Default**: <code>null</code>  
<a name="textureSize"></a>

## textureSize(textureNode, [levelNode]) ⇒ [<code>TextureSizeNode</code>](#TextureSizeNode)
TSL function for creating a texture size node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | A texture node which size should be retrieved. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | A level node which defines the requested mip. |

<a name="uv"></a>

## uv([index]) ⇒ <code>AttributeNode.&lt;vec2&gt;</code>
TSL function for creating an uv attribute node with the given index.

**Kind**: global function  
**Returns**: <code>AttributeNode.&lt;vec2&gt;</code> - The uv attribute node.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [index] | <code>number</code> | <code>0</code> | The uv index. |

## Classes

<dl>
<dt><a href="#UniformArrayElementNode">UniformArrayElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>Represents the element access on uniform array nodes.</p>
</dd>
<dt><a href="#UniformArrayNode">UniformArrayNode</a> ⇐ <code>BufferNode</code></dt>
<dd><p>Similar to <a href="BufferNode">BufferNode</a> this module represents array-like data as
uniform buffers. Unlike <a href="BufferNode">BufferNode</a>, it can handle more common
data types in the array (e.g <code>three.js</code> primitives) and automatically
manage buffer padding. It should be the first choice when working with
uniforms buffers.</p>
<pre><code class="language-js">const tintColors = uniformArray( [
    new Color( 1, 0, 0 ),
    new Color( 0, 1, 0 ),
    new Color( 0, 0, 1 )
], &#39;color&#39; );

const redColor = tintColors.element( 0 );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#uniformArray">uniformArray(values, [nodeType])</a> ⇒ <code><a href="#UniformArrayNode">UniformArrayNode</a></code></dt>
<dd><p>TSL function for creating an uniform array node.</p>
</dd>
<dt><del><a href="#uniforms">uniforms(values, nodeType)</a> ⇒ <code><a href="#UniformArrayNode">UniformArrayNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="UniformArrayElementNode"></a>

## UniformArrayElementNode ⇐ <code>ArrayElementNode</code>
Represents the element access on uniform array nodes.

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [UniformArrayElementNode](#UniformArrayElementNode) ⇐ <code>ArrayElementNode</code>
    * [new UniformArrayElementNode(uniformArrayNode, indexNode)](#new_UniformArrayElementNode_new)
    * [.isArrayBufferElementNode](#UniformArrayElementNode+isArrayBufferElementNode) : <code>boolean</code>

<a name="new_UniformArrayElementNode_new"></a>

### new UniformArrayElementNode(uniformArrayNode, indexNode)
Constructs a new buffer node.


| Param | Type | Description |
| --- | --- | --- |
| uniformArrayNode | [<code>UniformArrayNode</code>](#UniformArrayNode) | The uniform array node to access. |
| indexNode | <code>IndexNode</code> | The index data that define the position of the accessed element in the array. |

<a name="UniformArrayElementNode+isArrayBufferElementNode"></a>

### uniformArrayElementNode.isArrayBufferElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformArrayElementNode</code>](#UniformArrayElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="UniformArrayNode"></a>

## UniformArrayNode ⇐ <code>BufferNode</code>
Similar to [BufferNode](BufferNode) this module represents array-like data as
uniform buffers. Unlike [BufferNode](BufferNode), it can handle more common
data types in the array (e.g `three.js` primitives) and automatically
manage buffer padding. It should be the first choice when working with
uniforms buffers.
```js
const tintColors = uniformArray( [
	new Color( 1, 0, 0 ),
	new Color( 0, 1, 0 ),
	new Color( 0, 0, 1 )
], 'color' );

const redColor = tintColors.element( 0 );

**Kind**: global class  
**Extends**: <code>BufferNode</code>  

* [UniformArrayNode](#UniformArrayNode) ⇐ <code>BufferNode</code>
    * [new UniformArrayNode(value, [elementType])](#new_UniformArrayNode_new)
    * [.array](#UniformArrayNode+array) : <code>Array.&lt;any&gt;</code>
    * [.elementType](#UniformArrayNode+elementType) : <code>string</code>
    * [.paddedType](#UniformArrayNode+paddedType) : <code>string</code>
    * [.updateType](#UniformArrayNode+updateType) : <code>string</code>
    * [.isArrayBufferNode](#UniformArrayNode+isArrayBufferNode) : <code>boolean</code>
    * [.getNodeType(builder)](#UniformArrayNode+getNodeType) ⇒ <code>string</code>
    * [.getElementType(builder)](#UniformArrayNode+getElementType) ⇒ <code>string</code>
    * [.getPaddedType()](#UniformArrayNode+getPaddedType) ⇒ <code>string</code>
    * [.update(frame)](#UniformArrayNode+update)
    * [.setup(builder)](#UniformArrayNode+setup) ⇒ <code>null</code>
    * [.element(indexNode)](#UniformArrayNode+element) ⇒ [<code>UniformArrayElementNode</code>](#UniformArrayElementNode)

<a name="new_UniformArrayNode_new"></a>

### new UniformArrayNode(value, [elementType])
Constructs a new uniform array node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Array.&lt;any&gt;</code> |  | Array holding the buffer data. |
| [elementType] | <code>string</code> | <code>null</code> | The data type of a buffer element. |

<a name="UniformArrayNode+array"></a>

### uniformArrayNode.array : <code>Array.&lt;any&gt;</code>
Array holding the buffer data. Unlike [BufferNode](BufferNode), the array can
hold number primitives as well as three.js objects like vectors, matrices
or colors.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
<a name="UniformArrayNode+elementType"></a>

### uniformArrayNode.elementType : <code>string</code>
The data type of an array element.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
<a name="UniformArrayNode+paddedType"></a>

### uniformArrayNode.paddedType : <code>string</code>
The padded type. Uniform buffers must conform to a certain buffer layout
so a separate type is computed to ensure correct buffer size.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
<a name="UniformArrayNode+updateType"></a>

### uniformArrayNode.updateType : <code>string</code>
Overwritten since uniform array nodes are updated per render.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="UniformArrayNode+isArrayBufferNode"></a>

### uniformArrayNode.isArrayBufferNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="UniformArrayNode+getNodeType"></a>

### uniformArrayNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the
[paddedType](#UniformArrayNode+paddedType).

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="UniformArrayNode+getElementType"></a>

### uniformArrayNode.getElementType(builder) ⇒ <code>string</code>
The data type of the array elements.

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Returns**: <code>string</code> - The element type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="UniformArrayNode+getPaddedType"></a>

### uniformArrayNode.getPaddedType() ⇒ <code>string</code>
Returns the padded type based on the element type.

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Returns**: <code>string</code> - The padded type.  
<a name="UniformArrayNode+update"></a>

### uniformArrayNode.update(frame)
The update makes sure to correctly transfer the data from the (complex) objects
in the array to the internal, correctly padded value buffer.

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="UniformArrayNode+setup"></a>

### uniformArrayNode.setup(builder) ⇒ <code>null</code>
Implement the value buffer creation based on the array data.

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="UniformArrayNode+element"></a>

### uniformArrayNode.element(indexNode) ⇒ [<code>UniformArrayElementNode</code>](#UniformArrayElementNode)
Overwrites the default `element()` method to provide element access
based on [UniformArrayNode](#UniformArrayNode).

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | The index node. |

<a name="uniformArray"></a>

## uniformArray(values, [nodeType]) ⇒ [<code>UniformArrayNode</code>](#UniformArrayNode)
TSL function for creating an uniform array node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| values | <code>Array.&lt;any&gt;</code> | Array-like data. |
| [nodeType] | <code>string</code> | The data type of the array elements. |

<a name="uniforms"></a>

## ~~uniforms(values, nodeType) ⇒ [<code>UniformArrayNode</code>](#UniformArrayNode)~~
***since r168. Use [uniformArray](#uniformArray) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| values | <code>Array.&lt;any&gt;</code> | Array-like data. |
| nodeType | <code>string</code> | The data type of the array elements. |

## Classes

<dl>
<dt><a href="#UserDataNode">UserDataNode</a> ⇐ <code>ReferenceNode</code></dt>
<dd><p>A special type of reference node that allows to link values in
<code>userData</code> fields to node objects.</p>
<pre><code class="language-js">sprite.userData.rotation = 1; // stores individual rotation per sprite

const material = new THREE.SpriteNodeMaterial();
material.rotationNode = userData( &#39;rotation&#39;, &#39;float&#39; );
</code></pre>
<p>Since <code>UserDataNode</code> is extended from <a href="ReferenceNode">ReferenceNode</a>, the node value
will automatically be updated when the <code>rotation</code> user data field changes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#userData">userData(name, inputType, userData)</a> ⇒ <code><a href="#UserDataNode">UserDataNode</a></code></dt>
<dd><p>TSL function for creating a user data node.</p>
</dd>
</dl>

<a name="UserDataNode"></a>

## UserDataNode ⇐ <code>ReferenceNode</code>
A special type of reference node that allows to link values in
`userData` fields to node objects.
```js
sprite.userData.rotation = 1; // stores individual rotation per sprite

const material = new THREE.SpriteNodeMaterial();
material.rotationNode = userData( 'rotation', 'float' );
```
Since `UserDataNode` is extended from [ReferenceNode](ReferenceNode), the node value
will automatically be updated when the `rotation` user data field changes.

**Kind**: global class  
**Extends**: <code>ReferenceNode</code>  

* [UserDataNode](#UserDataNode) ⇐ <code>ReferenceNode</code>
    * [new UserDataNode(property, inputType, [userData])](#new_UserDataNode_new)
    * [.userData](#UserDataNode+userData) : <code>Object</code>
    * [.updateReference(state)](#UserDataNode+updateReference) ⇒ <code>Object</code>

<a name="new_UserDataNode_new"></a>

### new UserDataNode(property, inputType, [userData])
Constructs a new user data node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The property name that should be referenced by the node. |
| inputType | <code>string</code> |  | The node data type of the reference. |
| [userData] | <code>Object</code> | <code></code> | A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated. |

<a name="UserDataNode+userData"></a>

### userDataNode.userData : <code>Object</code>
A reference to the `userData` object. If not provided, the `userData`
property of the 3D object that uses the node material is evaluated.

**Kind**: instance property of [<code>UserDataNode</code>](#UserDataNode)  
**Default**: <code>null</code>  
<a name="UserDataNode+updateReference"></a>

### userDataNode.updateReference(state) ⇒ <code>Object</code>
Overwritten to make sure [ReferenceNode#reference](ReferenceNode#reference) points to the correct
`userData` field.

**Kind**: instance method of [<code>UserDataNode</code>](#UserDataNode)  
**Returns**: <code>Object</code> - A reference to the `userData` field.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state to evaluate. |

<a name="userData"></a>

## userData(name, inputType, userData) ⇒ [<code>UserDataNode</code>](#UserDataNode)
TSL function for creating a user data node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The property name that should be referenced by the node. |
| inputType | <code>string</code> | The node data type of the reference. |
| userData | <code>Object</code> | A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated. |

## Classes

<dl>
<dt><a href="#VelocityNode">VelocityNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>A node for representing motion or velocity vectors. Foundation
for advanced post processing effects like motion blur or TRAA.</p>
<p>The node keeps track of the model, view and projection matrices
of the previous frame and uses them to compute offsets in NDC space.
These offsets represent the final velocity.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#velocity">velocity</a> : <code><a href="#VelocityNode">VelocityNode</a></code></dt>
<dd><p>TSL object that represents the velocity of a render pass.</p>
</dd>
</dl>

<a name="VelocityNode"></a>

## VelocityNode ⇐ <code>TempNode</code>
A node for representing motion or velocity vectors. Foundation
for advanced post processing effects like motion blur or TRAA.

The node keeps track of the model, view and projection matrices
of the previous frame and uses them to compute offsets in NDC space.
These offsets represent the final velocity.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [VelocityNode](#VelocityNode) ⇐ <code>TempNode</code>
    * [new VelocityNode()](#new_VelocityNode_new)
    * [.projectionMatrix](#VelocityNode+projectionMatrix) : <code>Matrix4</code>
    * [.updateType](#VelocityNode+updateType) : <code>string</code>
    * [.updateAfterType](#VelocityNode+updateAfterType) : <code>string</code>
    * [.previousModelWorldMatrix](#VelocityNode+previousModelWorldMatrix) : <code>UniformNode.&lt;mat4&gt;</code>
    * [.previousProjectionMatrix](#VelocityNode+previousProjectionMatrix) : <code>UniformNode.&lt;mat4&gt;</code>
    * [.previousCameraViewMatrix](#VelocityNode+previousCameraViewMatrix) : <code>UniformNode.&lt;mat4&gt;</code>
    * [.setProjectionMatrix(projectionMatrix)](#VelocityNode+setProjectionMatrix)
    * [.update(frame)](#VelocityNode+update)
    * [.updateAfter(frame)](#VelocityNode+updateAfter)
    * [.setup(builder)](#VelocityNode+setup) ⇒ <code>Node.&lt;vec2&gt;</code>

<a name="new_VelocityNode_new"></a>

### new VelocityNode()
Constructs a new vertex color node.

<a name="VelocityNode+projectionMatrix"></a>

### velocityNode.projectionMatrix : <code>Matrix4</code>
The current projection matrix.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>null</code>  
<a name="VelocityNode+updateType"></a>

### velocityNode.updateType : <code>string</code>
Overwritten since velocity nodes are updated per object.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="VelocityNode+updateAfterType"></a>

### velocityNode.updateAfterType : <code>string</code>
Overwritten since velocity nodes save data after the update.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="VelocityNode+previousModelWorldMatrix"></a>

### velocityNode.previousModelWorldMatrix : <code>UniformNode.&lt;mat4&gt;</code>
Uniform node representing the previous model matrix in world space.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>null</code>  
<a name="VelocityNode+previousProjectionMatrix"></a>

### velocityNode.previousProjectionMatrix : <code>UniformNode.&lt;mat4&gt;</code>
Uniform node representing the previous projection matrix.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>null</code>  
<a name="VelocityNode+previousCameraViewMatrix"></a>

### velocityNode.previousCameraViewMatrix : <code>UniformNode.&lt;mat4&gt;</code>
Uniform node representing the previous view matrix.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>null</code>  
<a name="VelocityNode+setProjectionMatrix"></a>

### velocityNode.setProjectionMatrix(projectionMatrix)
Sets the given projection matrix.

**Kind**: instance method of [<code>VelocityNode</code>](#VelocityNode)  

| Param | Type | Description |
| --- | --- | --- |
| projectionMatrix | <code>Matrix4</code> | The projection matrix to set. |

<a name="VelocityNode+update"></a>

### velocityNode.update(frame)
Updates velocity specific uniforms.

**Kind**: instance method of [<code>VelocityNode</code>](#VelocityNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="VelocityNode+updateAfter"></a>

### velocityNode.updateAfter(frame)
Overwritten to updated velocity specific uniforms.

**Kind**: instance method of [<code>VelocityNode</code>](#VelocityNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="VelocityNode+setup"></a>

### velocityNode.setup(builder) ⇒ <code>Node.&lt;vec2&gt;</code>
Implements the velocity computation based on the previous and current vertex data.

**Kind**: instance method of [<code>VelocityNode</code>](#VelocityNode)  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The motion vector.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="velocity"></a>

## velocity : [<code>VelocityNode</code>](#VelocityNode)
TSL object that represents the velocity of a render pass.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#VertexColorNode">VertexColorNode</a> ⇐ <code>AttributeNode</code></dt>
<dd><p>An attribute node for representing vertex colors.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#vertexColor">vertexColor(index)</a> ⇒ <code><a href="#VertexColorNode">VertexColorNode</a></code></dt>
<dd><p>TSL function for creating a reference node.</p>
</dd>
</dl>

<a name="VertexColorNode"></a>

## VertexColorNode ⇐ <code>AttributeNode</code>
An attribute node for representing vertex colors.

**Kind**: global class  
**Extends**: <code>AttributeNode</code>  

* [VertexColorNode](#VertexColorNode) ⇐ <code>AttributeNode</code>
    * [new VertexColorNode([index])](#new_VertexColorNode_new)
    * [.isVertexColorNode](#VertexColorNode+isVertexColorNode) : <code>boolean</code>
    * [.index](#VertexColorNode+index) : <code>number</code>
    * [.getAttributeName(builder)](#VertexColorNode+getAttributeName) ⇒ <code>string</code>

<a name="new_VertexColorNode_new"></a>

### new VertexColorNode([index])
Constructs a new vertex color node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [index] | <code>number</code> | <code>0</code> | The attribute index. |

<a name="VertexColorNode+isVertexColorNode"></a>

### vertexColorNode.isVertexColorNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VertexColorNode</code>](#VertexColorNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VertexColorNode+index"></a>

### vertexColorNode.index : <code>number</code>
The attribute index to enable more than one sets of vertex colors.

**Kind**: instance property of [<code>VertexColorNode</code>](#VertexColorNode)  
**Default**: <code>0</code>  
<a name="VertexColorNode+getAttributeName"></a>

### vertexColorNode.getAttributeName(builder) ⇒ <code>string</code>
Overwrites the default implementation by honoring the attribute index.

**Kind**: instance method of [<code>VertexColorNode</code>](#VertexColorNode)  
**Returns**: <code>string</code> - The attribute name.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="vertexColor"></a>

## vertexColor(index) ⇒ [<code>VertexColorNode</code>](#VertexColorNode)
TSL function for creating a reference node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The attribute index. |

## Classes

<dl>
<dt><a href="#CodeNode">CodeNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class represents native code sections. It is the base
class for modules like <a href="FunctionNode">FunctionNode</a> which allows to implement
functions with native shader languages.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#code">code([code], [includes], [language])</a> ⇒ <code><a href="#CodeNode">CodeNode</a></code></dt>
<dd><p>TSL function for creating a code node.</p>
</dd>
<dt><a href="#js">js(src, includes)</a> ⇒ <code><a href="#CodeNode">CodeNode</a></code></dt>
<dd><p>TSL function for creating a JS code node.</p>
</dd>
<dt><a href="#wgsl">wgsl(src, includes)</a> ⇒ <code><a href="#CodeNode">CodeNode</a></code></dt>
<dd><p>TSL function for creating a WGSL code node.</p>
</dd>
<dt><a href="#glsl">glsl(src, includes)</a> ⇒ <code><a href="#CodeNode">CodeNode</a></code></dt>
<dd><p>TSL function for creating a GLSL code node.</p>
</dd>
</dl>

<a name="CodeNode"></a>

## CodeNode ⇐ <code>Node</code>
This class represents native code sections. It is the base
class for modules like [FunctionNode](FunctionNode) which allows to implement
functions with native shader languages.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [CodeNode](#CodeNode) ⇐ <code>Node</code>
    * [new CodeNode([code], [includes], [language])](#new_CodeNode_new)
    * [.isCodeNode](#CodeNode+isCodeNode) : <code>boolean</code>
    * [.code](#CodeNode+code) : <code>string</code>
    * [.includes](#CodeNode+includes) : <code>Array.&lt;Node&gt;</code>
    * [.language](#CodeNode+language) : <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code>
    * [.isGlobal()](#CodeNode+isGlobal) ⇒ <code>boolean</code>
    * [.setIncludes(includes)](#CodeNode+setIncludes) ⇒ [<code>CodeNode</code>](#CodeNode)
    * [.getIncludes(builder)](#CodeNode+getIncludes) ⇒ <code>Array.&lt;Node&gt;</code>

<a name="new_CodeNode_new"></a>

### new CodeNode([code], [includes], [language])
Constructs a new code node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [code] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The native code. |
| [includes] | <code>Array.&lt;Node&gt;</code> | <code>[]</code> | An array of includes. |
| [language] | <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code> | <code>&#x27;&#x27;</code> | The used language. |

<a name="CodeNode+isCodeNode"></a>

### codeNode.isCodeNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CodeNode</code>](#CodeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CodeNode+code"></a>

### codeNode.code : <code>string</code>
The native code.

**Kind**: instance property of [<code>CodeNode</code>](#CodeNode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="CodeNode+includes"></a>

### codeNode.includes : <code>Array.&lt;Node&gt;</code>
An array of includes

**Kind**: instance property of [<code>CodeNode</code>](#CodeNode)  
**Default**: <code>[]</code>  
<a name="CodeNode+language"></a>

### codeNode.language : <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code>
The used language.

**Kind**: instance property of [<code>CodeNode</code>](#CodeNode)  
**Default**: <code>&#x27;&#x27;</code>  
<a name="CodeNode+isGlobal"></a>

### codeNode.isGlobal() ⇒ <code>boolean</code>
The method is overwritten so it always returns `true`.

**Kind**: instance method of [<code>CodeNode</code>](#CodeNode)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  
<a name="CodeNode+setIncludes"></a>

### codeNode.setIncludes(includes) ⇒ [<code>CodeNode</code>](#CodeNode)
Sets the includes of this code node.

**Kind**: instance method of [<code>CodeNode</code>](#CodeNode)  
**Returns**: [<code>CodeNode</code>](#CodeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| includes | <code>Array.&lt;Node&gt;</code> | The includes to set. |

<a name="CodeNode+getIncludes"></a>

### codeNode.getIncludes(builder) ⇒ <code>Array.&lt;Node&gt;</code>
Returns the includes of this code node.

**Kind**: instance method of [<code>CodeNode</code>](#CodeNode)  
**Returns**: <code>Array.&lt;Node&gt;</code> - The includes.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="code"></a>

## code([code], [includes], [language]) ⇒ [<code>CodeNode</code>](#CodeNode)
TSL function for creating a code node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [code] | <code>string</code> |  | The native code. |
| [includes] | <code>Array.&lt;Node&gt;</code> | <code>[]</code> | An array of includes. |
| [language] | <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code> | <code>&#x27;&#x27;</code> | The used language. |

<a name="js"></a>

## js(src, includes) ⇒ [<code>CodeNode</code>](#CodeNode)
TSL function for creating a JS code node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| src | <code>string</code> | The native code. |
| includes | <code>Array.&lt;Node&gt;</code> | An array of includes. |

<a name="wgsl"></a>

## wgsl(src, includes) ⇒ [<code>CodeNode</code>](#CodeNode)
TSL function for creating a WGSL code node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| src | <code>string</code> | The native code. |
| includes | <code>Array.&lt;Node&gt;</code> | An array of includes. |

<a name="glsl"></a>

## glsl(src, includes) ⇒ [<code>CodeNode</code>](#CodeNode)
TSL function for creating a GLSL code node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| src | <code>string</code> | The native code. |
| includes | <code>Array.&lt;Node&gt;</code> | An array of includes. |

## Classes

<dl>
<dt><a href="#ExpressionNode">ExpressionNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class can be used to implement basic expressions in shader code.
Basic examples for that are <code>return</code>, <code>continue</code> or <code>discard</code> statements.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#expression">expression([snippet], [nodeType])</a> ⇒ <code><a href="#ExpressionNode">ExpressionNode</a></code></dt>
<dd><p>TSL function for creating an expression node.</p>
</dd>
</dl>

<a name="ExpressionNode"></a>

## ExpressionNode ⇐ <code>Node</code>
This class can be used to implement basic expressions in shader code.
Basic examples for that are `return`, `continue` or `discard` statements.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ExpressionNode](#ExpressionNode) ⇐ <code>Node</code>
    * [new ExpressionNode([snippet], [nodeType])](#new_ExpressionNode_new)
    * [.snippet](#ExpressionNode+snippet) : <code>string</code>

<a name="new_ExpressionNode_new"></a>

### new ExpressionNode([snippet], [nodeType])
Constructs a new expression node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [snippet] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The native code snippet. |
| [nodeType] | <code>string</code> | <code>&quot;&#x27;void&#x27;&quot;</code> | The node type. |

<a name="ExpressionNode+snippet"></a>

### expressionNode.snippet : <code>string</code>
The native code snippet.

**Kind**: instance property of [<code>ExpressionNode</code>](#ExpressionNode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="expression"></a>

## expression([snippet], [nodeType]) ⇒ [<code>ExpressionNode</code>](#ExpressionNode)
TSL function for creating an expression node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [snippet] | <code>string</code> |  | The native code snippet. |
| [nodeType] | <code>string</code> | <code>&quot;&#x27;void&#x27;&quot;</code> | The node type. |

<a name="FunctionCallNode"></a>

## FunctionCallNode ⇐ <code>TempNode</code>
This module represents the call of a [FunctionNode](FunctionNode). Developers are usually not confronted
with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate
this logic.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [FunctionCallNode](#FunctionCallNode) ⇐ <code>TempNode</code>
    * [new FunctionCallNode(functionNode, [parameters])](#new_FunctionCallNode_new)
    * [.functionNode](#FunctionCallNode+functionNode) : <code>FunctionNode</code>
    * [.parameters](#FunctionCallNode+parameters) : <code>Object.&lt;string, Node&gt;</code>
    * [.setParameters(parameters)](#FunctionCallNode+setParameters) ⇒ [<code>FunctionCallNode</code>](#FunctionCallNode)
    * [.getParameters()](#FunctionCallNode+getParameters) ⇒ <code>Object.&lt;string, Node&gt;</code>

<a name="new_FunctionCallNode_new"></a>

### new FunctionCallNode(functionNode, [parameters])
Constructs a new function call node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| functionNode | <code>FunctionNode</code> | <code></code> | The function node. |
| [parameters] | <code>Object.&lt;string, Node&gt;</code> | <code>{}</code> | The parameters for the function call. |

<a name="FunctionCallNode+functionNode"></a>

### functionCallNode.functionNode : <code>FunctionNode</code>
The function node.

**Kind**: instance property of [<code>FunctionCallNode</code>](#FunctionCallNode)  
**Default**: <code>null</code>  
<a name="FunctionCallNode+parameters"></a>

### functionCallNode.parameters : <code>Object.&lt;string, Node&gt;</code>
The parameters of the function call.

**Kind**: instance property of [<code>FunctionCallNode</code>](#FunctionCallNode)  
**Default**: <code>{}</code>  
<a name="FunctionCallNode+setParameters"></a>

### functionCallNode.setParameters(parameters) ⇒ [<code>FunctionCallNode</code>](#FunctionCallNode)
Sets the parameters of the function call node.

**Kind**: instance method of [<code>FunctionCallNode</code>](#FunctionCallNode)  
**Returns**: [<code>FunctionCallNode</code>](#FunctionCallNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| parameters | <code>Object.&lt;string, Node&gt;</code> | The parameters to set. |

<a name="FunctionCallNode+getParameters"></a>

### functionCallNode.getParameters() ⇒ <code>Object.&lt;string, Node&gt;</code>
Returns the parameters of the function call node.

**Kind**: instance method of [<code>FunctionCallNode</code>](#FunctionCallNode)  
**Returns**: <code>Object.&lt;string, Node&gt;</code> - The parameters of this node.  
<a name="FunctionNode"></a>

## FunctionNode ⇐ <code>CodeNode</code>
This class represents a native shader function. It can be used to implement
certain aspects of a node material with native shader code. There are two predefined
TSL functions for easier usage.

- `wgslFn`: Creates a WGSL function node.
- `glslFn`: Creates a GLSL function node.

A basic example with one include looks like so:

```js
const desaturateWGSLFn = wgslFn( `
	fn desaturate( color:vec3<f32> ) -> vec3<f32> {
		let lum = vec3<f32>( 0.299, 0.587, 0.114 );
		return vec3<f32>( dot( lum, color ) );
	}`
);
const someWGSLFn = wgslFn( `
	fn someFn( color:vec3<f32> ) -> vec3<f32> {
		return desaturate( color );
	}
`, [ desaturateWGSLFn ] );
material.colorNode = someWGSLFn( { color: texture( map ) } );
```

**Kind**: global class  
**Extends**: <code>CodeNode</code>  

* [FunctionNode](#FunctionNode) ⇐ <code>CodeNode</code>
    * [new FunctionNode([code], [includes], [language])](#new_FunctionNode_new)
    * [.getInputs(builder)](#FunctionNode+getInputs) ⇒ <code>Array.&lt;NodeFunctionInput&gt;</code>
    * [.getNodeFunction(builder)](#FunctionNode+getNodeFunction) ⇒ <code>NodeFunction</code>

<a name="new_FunctionNode_new"></a>

### new FunctionNode([code], [includes], [language])
Constructs a new function node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [code] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The native code. |
| [includes] | <code>Array.&lt;Node&gt;</code> | <code>[]</code> | An array of includes. |
| [language] | <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code> | <code>&#x27;&#x27;</code> | The used language. |

<a name="FunctionNode+getInputs"></a>

### functionNode.getInputs(builder) ⇒ <code>Array.&lt;NodeFunctionInput&gt;</code>
Returns the inputs of this function node.

**Kind**: instance method of [<code>FunctionNode</code>](#FunctionNode)  
**Returns**: <code>Array.&lt;NodeFunctionInput&gt;</code> - The inputs.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="FunctionNode+getNodeFunction"></a>

### functionNode.getNodeFunction(builder) ⇒ <code>NodeFunction</code>
Returns the node function for this function node.

**Kind**: instance method of [<code>FunctionNode</code>](#FunctionNode)  
**Returns**: <code>NodeFunction</code> - The node function.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#Resources">Resources</a> ⇐ <code>Map</code></dt>
<dd><p>A Map-like data structure for managing resources of scriptable nodes.</p>
</dd>
<dt><a href="#ScriptableNode">ScriptableNode</a> ⇐ <code>Node</code></dt>
<dd><p>This type of node allows to implement nodes with custom scripts. The script
section is represented as an instance of <code>CodeNode</code> written with JavaScript.
The script itself must adhere to a specific structure.</p>
<ul>
<li>main(): Executed once by default and every time <code>node.needsUpdate</code> is set.</li>
<li>layout: The layout object defines the script&#39;s interface (inputs and outputs).</li>
</ul>
<pre><code class="language-js">ScriptableNodeResources.set( &#39;TSL&#39;, TSL );

const scriptableNode = scriptable( js( `
    layout = {
        outputType: &#39;node&#39;,
        elements: [
            { name: &#39;source&#39;, inputType: &#39;node&#39; },
        ]
    };

    const { mul, oscSine } = TSL;

    function main() {
        const source = parameters.get( &#39;source&#39; ) || float();
        return mul( source, oscSine() ) );
    }

` ) );

scriptableNode.setParameter( &#39;source&#39;, color( 1, 0, 0 ) );

const material = new THREE.MeshBasicNodeMaterial();
material.colorNode = scriptableNode;
</code></pre>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#ScriptableNodeResources">ScriptableNodeResources</a> : <code><a href="#Resources">Resources</a></code></dt>
<dd><p>Defines the resources (e.g. namespaces) of scriptable nodes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#scriptable">scriptable([codeNode], [parameters])</a> ⇒ <code><a href="#ScriptableNode">ScriptableNode</a></code></dt>
<dd><p>TSL function for creating a scriptable node.</p>
</dd>
</dl>

<a name="Resources"></a>

## Resources ⇐ <code>Map</code>
A Map-like data structure for managing resources of scriptable nodes.

**Kind**: global class  
**Extends**: <code>Map</code>  
<a name="ScriptableNode"></a>

## ScriptableNode ⇐ <code>Node</code>
This type of node allows to implement nodes with custom scripts. The script
section is represented as an instance of `CodeNode` written with JavaScript.
The script itself must adhere to a specific structure.

- main(): Executed once by default and every time `node.needsUpdate` is set.
- layout: The layout object defines the script's interface (inputs and outputs).

```js
ScriptableNodeResources.set( 'TSL', TSL );

const scriptableNode = scriptable( js( `
	layout = {
		outputType: 'node',
		elements: [
			{ name: 'source', inputType: 'node' },
		]
	};

	const { mul, oscSine } = TSL;

	function main() {
		const source = parameters.get( 'source' ) || float();
		return mul( source, oscSine() ) );
	}

` ) );

scriptableNode.setParameter( 'source', color( 1, 0, 0 ) );

const material = new THREE.MeshBasicNodeMaterial();
material.colorNode = scriptableNode;
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ScriptableNode](#ScriptableNode) ⇐ <code>Node</code>
    * [new ScriptableNode([codeNode], [parameters])](#new_ScriptableNode_new)
    * [.codeNode](#ScriptableNode+codeNode) : <code>CodeNode</code>
    * [.parameters](#ScriptableNode+parameters) : <code>Object</code>
    * [.isScriptableNode](#ScriptableNode+isScriptableNode) : <code>boolean</code>
    * [.source](#ScriptableNode+source) : <code>string</code>
    * [.setLocal(name, value)](#ScriptableNode+setLocal) ⇒ [<code>Resources</code>](#Resources)
    * [.getLocal(name)](#ScriptableNode+getLocal) ⇒ <code>Object</code>
    * [.onRefresh()](#ScriptableNode+onRefresh)
    * [.getInputLayout(id)](#ScriptableNode+getInputLayout) ⇒ <code>Object</code>
    * [.getOutputLayout(id)](#ScriptableNode+getOutputLayout) ⇒ <code>Object</code>
    * [.setOutput(name, value)](#ScriptableNode+setOutput) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
    * [.getOutput(name)](#ScriptableNode+getOutput) ⇒ <code>ScriptableValueNode</code>
    * [.getParameter(name)](#ScriptableNode+getParameter) ⇒ <code>ScriptableValueNode</code>
    * [.setParameter(name, value)](#ScriptableNode+setParameter) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
    * [.getValue()](#ScriptableNode+getValue) ⇒ <code>Node</code>
    * [.deleteParameter(name)](#ScriptableNode+deleteParameter) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
    * [.clearParameters()](#ScriptableNode+clearParameters) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
    * [.call(name, ...params)](#ScriptableNode+call) ⇒ <code>any</code>
    * [.callAsync(name, ...params)](#ScriptableNode+callAsync) ⇒ <code>Promise.&lt;any&gt;</code>
    * [.getNodeType(builder)](#ScriptableNode+getNodeType) ⇒ <code>string</code>
    * [.refresh([output])](#ScriptableNode+refresh)
    * [.getObject()](#ScriptableNode+getObject) ⇒ <code>Object</code>
    * [.getLayout()](#ScriptableNode+getLayout) ⇒ <code>Object</code>
    * [.getDefaultOutputNode()](#ScriptableNode+getDefaultOutputNode) ⇒ <code>Node</code>
    * [.getDefaultOutput()](#ScriptableNode+getDefaultOutput) ⇒ <code>ScriptableValueNode</code>
    * [.getMethod()](#ScriptableNode+getMethod) ⇒ <code>function</code>
    * [.dispose()](#ScriptableNode+dispose)

<a name="new_ScriptableNode_new"></a>

### new ScriptableNode([codeNode], [parameters])
Constructs a new scriptable node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [codeNode] | <code>CodeNode</code> | <code></code> | The code node. |
| [parameters] | <code>Object</code> | <code>{}</code> | The parameters definition. |

<a name="ScriptableNode+codeNode"></a>

### scriptableNode.codeNode : <code>CodeNode</code>
The code node.

**Kind**: instance property of [<code>ScriptableNode</code>](#ScriptableNode)  
**Default**: <code>null</code>  
<a name="ScriptableNode+parameters"></a>

### scriptableNode.parameters : <code>Object</code>
The parameters definition.

**Kind**: instance property of [<code>ScriptableNode</code>](#ScriptableNode)  
**Default**: <code>{}</code>  
<a name="ScriptableNode+isScriptableNode"></a>

### scriptableNode.isScriptableNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ScriptableNode</code>](#ScriptableNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ScriptableNode+source"></a>

### scriptableNode.source : <code>string</code>
The source code of the scriptable node.

**Kind**: instance property of [<code>ScriptableNode</code>](#ScriptableNode)  
<a name="ScriptableNode+setLocal"></a>

### scriptableNode.setLocal(name, value) ⇒ [<code>Resources</code>](#Resources)
Sets the reference of a local script variable.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>Resources</code>](#Resources) - The resource map  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The variable name. |
| value | <code>Object</code> | The reference to set. |

<a name="ScriptableNode+getLocal"></a>

### scriptableNode.getLocal(name) ⇒ <code>Object</code>
Gets the value of a local script variable.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The value.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The variable name. |

<a name="ScriptableNode+onRefresh"></a>

### scriptableNode.onRefresh()
Event listener for the `refresh` event.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
<a name="ScriptableNode+getInputLayout"></a>

### scriptableNode.getInputLayout(id) ⇒ <code>Object</code>
Returns an input from the layout with the given id/name.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The element entry.  

| Param | Type | Description |
| --- | --- | --- |
| id | <code>string</code> | The id/name of the input. |

<a name="ScriptableNode+getOutputLayout"></a>

### scriptableNode.getOutputLayout(id) ⇒ <code>Object</code>
Returns an output from the layout with the given id/name.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The element entry.  

| Param | Type | Description |
| --- | --- | --- |
| id | <code>string</code> | The id/name of the output. |

<a name="ScriptableNode+setOutput"></a>

### scriptableNode.setOutput(name, value) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
Defines a script output for the given name and value.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>ScriptableNode</code>](#ScriptableNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the output. |
| value | <code>Node</code> | The node value. |

<a name="ScriptableNode+getOutput"></a>

### scriptableNode.getOutput(name) ⇒ <code>ScriptableValueNode</code>
Returns a script output for the given name.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>ScriptableValueNode</code> - The node value.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the output. |

<a name="ScriptableNode+getParameter"></a>

### scriptableNode.getParameter(name) ⇒ <code>ScriptableValueNode</code>
Returns a parameter for the given name

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>ScriptableValueNode</code> - The node value.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the parameter. |

<a name="ScriptableNode+setParameter"></a>

### scriptableNode.setParameter(name, value) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
Sets a value for the given parameter name.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>ScriptableNode</code>](#ScriptableNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The parameter name. |
| value | <code>any</code> | The parameter value. |

<a name="ScriptableNode+getValue"></a>

### scriptableNode.getValue() ⇒ <code>Node</code>
Returns the value of this node which is the value of
the default output.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Node</code> - The value.  
<a name="ScriptableNode+deleteParameter"></a>

### scriptableNode.deleteParameter(name) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
Deletes a parameter from the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>ScriptableNode</code>](#ScriptableNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The parameter to remove. |

<a name="ScriptableNode+clearParameters"></a>

### scriptableNode.clearParameters() ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
Deletes all parameters from the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>ScriptableNode</code>](#ScriptableNode) - A reference to this node.  
<a name="ScriptableNode+call"></a>

### scriptableNode.call(name, ...params) ⇒ <code>any</code>
Calls a function from the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>any</code> - The result of the function call.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The function name. |
| ...params | <code>any</code> | A list of parameters. |

<a name="ScriptableNode+callAsync"></a>

### scriptableNode.callAsync(name, ...params) ⇒ <code>Promise.&lt;any&gt;</code>
Asynchronously calls a function from the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Promise.&lt;any&gt;</code> - The result of the function call.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The function name. |
| ...params | <code>any</code> | A list of parameters. |

<a name="ScriptableNode+getNodeType"></a>

### scriptableNode.getNodeType(builder) ⇒ <code>string</code>
Overwritten since the node types is inferred from the script's output.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder |

<a name="ScriptableNode+refresh"></a>

### scriptableNode.refresh([output])
Refreshes the script node.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [output] | <code>string</code> | <code>null</code> | An optional output. |

<a name="ScriptableNode+getObject"></a>

### scriptableNode.getObject() ⇒ <code>Object</code>
Returns an object representation of the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The result object.  
<a name="ScriptableNode+getLayout"></a>

### scriptableNode.getLayout() ⇒ <code>Object</code>
Returns the layout of the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The script's layout.  
<a name="ScriptableNode+getDefaultOutputNode"></a>

### scriptableNode.getDefaultOutputNode() ⇒ <code>Node</code>
Returns default node output of the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Node</code> - The default node output.  
<a name="ScriptableNode+getDefaultOutput"></a>

### scriptableNode.getDefaultOutput() ⇒ <code>ScriptableValueNode</code>
Returns default output of the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>ScriptableValueNode</code> - The default output.  
<a name="ScriptableNode+getMethod"></a>

### scriptableNode.getMethod() ⇒ <code>function</code>
Returns a function created from the node's script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>function</code> - The function representing the node's code.  
<a name="ScriptableNode+dispose"></a>

### scriptableNode.dispose()
Frees all internal resources.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
<a name="ScriptableNodeResources"></a>

## ScriptableNodeResources : [<code>Resources</code>](#Resources)
Defines the resources (e.g. namespaces) of scriptable nodes.

**Kind**: global constant  
<a name="scriptable"></a>

## scriptable([codeNode], [parameters]) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
TSL function for creating a scriptable node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [codeNode] | <code>CodeNode</code> |  | The code node. |
| [parameters] | <code>Object</code> | <code>{}</code> | The parameters definition. |

## Classes

<dl>
<dt><a href="#ScriptableValueNode">ScriptableValueNode</a> ⇐ <code>Node</code></dt>
<dd><p><code>ScriptableNode</code> uses this class to manage script inputs and outputs.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#scriptableValue">scriptableValue([value])</a> ⇒ <code><a href="#ScriptableValueNode">ScriptableValueNode</a></code></dt>
<dd><p>TSL function for creating a scriptable value node.</p>
</dd>
</dl>

<a name="ScriptableValueNode"></a>

## ScriptableValueNode ⇐ <code>Node</code>
`ScriptableNode` uses this class to manage script inputs and outputs.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ScriptableValueNode](#ScriptableValueNode) ⇐ <code>Node</code>
    * [new ScriptableValueNode([value])](#new_ScriptableValueNode_new)
    * [.inputType](#ScriptableValueNode+inputType) : <code>string</code>
    * [.outputType](#ScriptableValueNode+outputType) : <code>string</code>
    * [.events](#ScriptableValueNode+events) : <code>EventDispatcher</code>
    * [.isScriptableValueNode](#ScriptableValueNode+isScriptableValueNode) : <code>boolean</code>
    * [.isScriptableOutputNode](#ScriptableValueNode+isScriptableOutputNode) : <code>boolean</code>
    * [.value](#ScriptableValueNode+value) : <code>any</code>
    * [.refresh()](#ScriptableValueNode+refresh)
    * [.getValue()](#ScriptableValueNode+getValue) ⇒ <code>any</code>
    * [.getNodeType(builder)](#ScriptableValueNode+getNodeType) ⇒ <code>string</code>

<a name="new_ScriptableValueNode_new"></a>

### new ScriptableValueNode([value])
Constructs a new scriptable node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [value] | <code>any</code> | <code></code> | The value. |

<a name="ScriptableValueNode+inputType"></a>

### scriptableValueNode.inputType : <code>string</code>
If this node represents an input, this property represents the input type.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="ScriptableValueNode+outputType"></a>

### scriptableValueNode.outputType : <code>string</code>
If this node represents an output, this property represents the output type.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="ScriptableValueNode+events"></a>

### scriptableValueNode.events : <code>EventDispatcher</code>
An event dispatcher for managing events.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
<a name="ScriptableValueNode+isScriptableValueNode"></a>

### scriptableValueNode.isScriptableValueNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ScriptableValueNode+isScriptableOutputNode"></a>

### scriptableValueNode.isScriptableOutputNode : <code>boolean</code>
Whether this node represents an output or not.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ScriptableValueNode+value"></a>

### scriptableValueNode.value : <code>any</code>
The node's value.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
<a name="ScriptableValueNode+refresh"></a>

### scriptableValueNode.refresh()
Dispatches the `refresh` event.

**Kind**: instance method of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
<a name="ScriptableValueNode+getValue"></a>

### scriptableValueNode.getValue() ⇒ <code>any</code>
The `value` property usually represents a node or even binary data in form of array buffers.
In this case, this method tries to return the actual value behind the complex type.

**Kind**: instance method of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Returns**: <code>any</code> - The value.  
<a name="ScriptableValueNode+getNodeType"></a>

### scriptableValueNode.getNodeType(builder) ⇒ <code>string</code>
Overwritten since the node type is inferred from the value.

**Kind**: instance method of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="scriptableValue"></a>

## scriptableValue([value]) ⇒ [<code>ScriptableValueNode</code>](#ScriptableValueNode)
TSL function for creating a scriptable value node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [value] | <code>any</code> | The value. |

## Classes

<dl>
<dt><a href="#ArrayNode">ArrayNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>ArrayNode represents a collection of nodes, typically created using the <a href="#array">array</a> function.</p>
<pre><code class="language-js">const colors = array( [
    vec3( 1, 0, 0 ),
    vec3( 0, 1, 0 ),
    vec3( 0, 0, 1 )
] );

const redColor = tintColors.element( 0 );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#array">array(nodeTypeOrValues, [count])</a> ⇒ <code><a href="#ArrayNode">ArrayNode</a></code></dt>
<dd><p>TSL function for creating an array node.</p>
</dd>
</dl>

<a name="ArrayNode"></a>

## ArrayNode ⇐ <code>TempNode</code>
ArrayNode represents a collection of nodes, typically created using the [array](#array) function.
```js
const colors = array( [
	vec3( 1, 0, 0 ),
	vec3( 0, 1, 0 ),
	vec3( 0, 0, 1 )
] );

const redColor = tintColors.element( 0 );

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [ArrayNode](#ArrayNode) ⇐ <code>TempNode</code>
    * [new ArrayNode(nodeType, count, [values])](#new_ArrayNode_new)
    * [.count](#ArrayNode+count) : <code>number</code>
    * [.values](#ArrayNode+values) : <code>Array.&lt;Node&gt;</code>
    * [.isArrayNode](#ArrayNode+isArrayNode) : <code>boolean</code>
    * [.getNodeType(builder)](#ArrayNode+getNodeType) ⇒ <code>string</code>
    * [.getElementType(builder)](#ArrayNode+getElementType) ⇒ <code>string</code>
    * [.generate(builder)](#ArrayNode+generate) ⇒ <code>string</code>

<a name="new_ArrayNode_new"></a>

### new ArrayNode(nodeType, count, [values])
Constructs a new array node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> |  | The data type of the elements. |
| count | <code>number</code> |  | Size of the array. |
| [values] | <code>Array.&lt;Node&gt;</code> | <code></code> | Array default values. |

<a name="ArrayNode+count"></a>

### arrayNode.count : <code>number</code>
Array size.

**Kind**: instance property of [<code>ArrayNode</code>](#ArrayNode)  
<a name="ArrayNode+values"></a>

### arrayNode.values : <code>Array.&lt;Node&gt;</code>
Array default values.

**Kind**: instance property of [<code>ArrayNode</code>](#ArrayNode)  
<a name="ArrayNode+isArrayNode"></a>

### arrayNode.isArrayNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ArrayNode</code>](#ArrayNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ArrayNode+getNodeType"></a>

### arrayNode.getNodeType(builder) ⇒ <code>string</code>
Returns the node's type.

**Kind**: instance method of [<code>ArrayNode</code>](#ArrayNode)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ArrayNode+getElementType"></a>

### arrayNode.getElementType(builder) ⇒ <code>string</code>
Returns the node's type.

**Kind**: instance method of [<code>ArrayNode</code>](#ArrayNode)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ArrayNode+generate"></a>

### arrayNode.generate(builder) ⇒ <code>string</code>
This method builds the output node and returns the resulting array as a shader string.

**Kind**: instance method of [<code>ArrayNode</code>](#ArrayNode)  
**Returns**: <code>string</code> - The generated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="array"></a>

## array(nodeTypeOrValues, [count]) ⇒ [<code>ArrayNode</code>](#ArrayNode)
TSL function for creating an array node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| nodeTypeOrValues | <code>string</code> \| <code>Array.&lt;Node&gt;</code> | A string representing the element type (e.g., 'vec3') or an array containing the default values (e.g., [ vec3() ]). |
| [count] | <code>number</code> | Size of the array. |

## Classes

<dl>
<dt><a href="#AssignNode">AssignNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>These node represents an assign operation. Meaning a node is assigned
to another node.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#assign">assign(targetNode, sourceNode)</a> ⇒ <code><a href="#AssignNode">AssignNode</a></code></dt>
<dd><p>TSL function for creating an assign node.</p>
</dd>
</dl>

<a name="AssignNode"></a>

## AssignNode ⇐ <code>TempNode</code>
These node represents an assign operation. Meaning a node is assigned
to another node.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [AssignNode](#AssignNode) ⇐ <code>TempNode</code>
    * [new AssignNode(targetNode, sourceNode)](#new_AssignNode_new)
    * [.targetNode](#AssignNode+targetNode) : <code>Node</code>
    * [.sourceNode](#AssignNode+sourceNode) : <code>Node</code>
    * [.hasDependencies()](#AssignNode+hasDependencies) ⇒ <code>boolean</code>
    * [.needsSplitAssign(builder)](#AssignNode+needsSplitAssign) ⇒ <code>boolean</code>

<a name="new_AssignNode_new"></a>

### new AssignNode(targetNode, sourceNode)
Constructs a new assign node.


| Param | Type | Description |
| --- | --- | --- |
| targetNode | <code>Node</code> | The target node. |
| sourceNode | <code>Node</code> | The source type. |

<a name="AssignNode+targetNode"></a>

### assignNode.targetNode : <code>Node</code>
The target node.

**Kind**: instance property of [<code>AssignNode</code>](#AssignNode)  
<a name="AssignNode+sourceNode"></a>

### assignNode.sourceNode : <code>Node</code>
The source node.

**Kind**: instance property of [<code>AssignNode</code>](#AssignNode)  
<a name="AssignNode+hasDependencies"></a>

### assignNode.hasDependencies() ⇒ <code>boolean</code>
Whether this node is used more than once in context of other nodes. This method
is overwritten since it always returns `false` (assigns are unique).

**Kind**: instance method of [<code>AssignNode</code>](#AssignNode)  
**Returns**: <code>boolean</code> - A flag that indicates if there is more than one dependency to other nodes. Always `false`.  
<a name="AssignNode+needsSplitAssign"></a>

### assignNode.needsSplitAssign(builder) ⇒ <code>boolean</code>
Whether a split is required when assigning source to target. This can happen when the component length of
target and source data type does not match.

**Kind**: instance method of [<code>AssignNode</code>](#AssignNode)  
**Returns**: <code>boolean</code> - Whether a split is required when assigning source to target.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="assign"></a>

## assign(targetNode, sourceNode) ⇒ [<code>AssignNode</code>](#AssignNode)
TSL function for creating an assign node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| targetNode | <code>Node</code> | The target node. |
| sourceNode | <code>Node</code> | The source type. |

## Classes

<dl>
<dt><a href="#AttributeNode">AttributeNode</a> ⇐ <code>Node</code></dt>
<dd><p>Base class for representing shader attributes as nodes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#attribute">attribute(name, [nodeType])</a> ⇒ <code><a href="#AttributeNode">AttributeNode</a></code></dt>
<dd><p>TSL function for creating an attribute node.</p>
</dd>
</dl>

<a name="AttributeNode"></a>

## AttributeNode ⇐ <code>Node</code>
Base class for representing shader attributes as nodes.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [AttributeNode](#AttributeNode) ⇐ <code>Node</code>
    * [new AttributeNode(attributeName, nodeType)](#new_AttributeNode_new)
    * [.global](#AttributeNode+global) : <code>boolean</code>
    * [.setAttributeName(attributeName)](#AttributeNode+setAttributeName) ⇒ [<code>AttributeNode</code>](#AttributeNode)
    * [.getAttributeName(builder)](#AttributeNode+getAttributeName) ⇒ <code>string</code>

<a name="new_AttributeNode_new"></a>

### new AttributeNode(attributeName, nodeType)
Constructs a new attribute node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| attributeName | <code>string</code> |  | The name of the attribute. |
| nodeType | <code>string</code> | <code>null</code> | The node type. |

<a name="AttributeNode+global"></a>

### attributeNode.global : <code>boolean</code>
`AttributeNode` sets this property to `true` by default.

**Kind**: instance property of [<code>AttributeNode</code>](#AttributeNode)  
**Default**: <code>true</code>  
<a name="AttributeNode+setAttributeName"></a>

### attributeNode.setAttributeName(attributeName) ⇒ [<code>AttributeNode</code>](#AttributeNode)
Sets the attribute name to the given value. The method can be
overwritten in derived classes if the final name must be computed
analytically.

**Kind**: instance method of [<code>AttributeNode</code>](#AttributeNode)  
**Returns**: [<code>AttributeNode</code>](#AttributeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| attributeName | <code>string</code> | The name of the attribute. |

<a name="AttributeNode+getAttributeName"></a>

### attributeNode.getAttributeName(builder) ⇒ <code>string</code>
Returns the attribute name of this node. The method can be
overwritten in derived classes if the final name must be computed
analytically.

**Kind**: instance method of [<code>AttributeNode</code>](#AttributeNode)  
**Returns**: <code>string</code> - The attribute name.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="attribute"></a>

## attribute(name, [nodeType]) ⇒ [<code>AttributeNode</code>](#AttributeNode)
TSL function for creating an attribute node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the attribute. |
| [nodeType] | <code>string</code> | The node type. |

## Classes

<dl>
<dt><a href="#BypassNode">BypassNode</a> ⇐ <code>Node</code></dt>
<dd><p>The class generates the code of a given node but returns another node in the output.
This can be used to call a method or node that does not return a value, i.e.
type <code>void</code> on an input where returning a value is required. Example:</p>
<pre><code class="language-js">material.colorNode = myColor.bypass( runVoidFn() )
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bypass">bypass(outputNode, callNode)</a> ⇒ <code><a href="#BypassNode">BypassNode</a></code></dt>
<dd><p>TSL function for creating a bypass node.</p>
</dd>
</dl>

<a name="BypassNode"></a>

## BypassNode ⇐ <code>Node</code>
The class generates the code of a given node but returns another node in the output.
This can be used to call a method or node that does not return a value, i.e.
type `void` on an input where returning a value is required. Example:

```js
material.colorNode = myColor.bypass( runVoidFn() )
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [BypassNode](#BypassNode) ⇐ <code>Node</code>
    * [new BypassNode(outputNode, callNode)](#new_BypassNode_new)
    * [.isBypassNode](#BypassNode+isBypassNode) : <code>boolean</code>
    * [.outputNode](#BypassNode+outputNode) : <code>Node</code>
    * [.callNode](#BypassNode+callNode) : <code>Node</code>

<a name="new_BypassNode_new"></a>

### new BypassNode(outputNode, callNode)
Constructs a new bypass node.


| Param | Type | Description |
| --- | --- | --- |
| outputNode | <code>Node</code> | The output node. |
| callNode | <code>Node</code> | The call node. |

<a name="BypassNode+isBypassNode"></a>

### bypassNode.isBypassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BypassNode</code>](#BypassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BypassNode+outputNode"></a>

### bypassNode.outputNode : <code>Node</code>
The output node.

**Kind**: instance property of [<code>BypassNode</code>](#BypassNode)  
<a name="BypassNode+callNode"></a>

### bypassNode.callNode : <code>Node</code>
The call node.

**Kind**: instance property of [<code>BypassNode</code>](#BypassNode)  
<a name="bypass"></a>

## bypass(outputNode, callNode) ⇒ [<code>BypassNode</code>](#BypassNode)
TSL function for creating a bypass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| outputNode | <code>Node</code> | The output node. |
| callNode | <code>Node</code> | The call node. |

## Classes

<dl>
<dt><a href="#CacheNode">CacheNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used as a cache management component for another node.
Caching is in general used by default in <a href="NodeBuilder">NodeBuilder</a> but this node
allows the usage of a shared parent cache during the build process.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#cache">cache(node, [parent])</a> ⇒ <code><a href="#CacheNode">CacheNode</a></code></dt>
<dd><p>TSL function for creating a cache node.</p>
</dd>
</dl>

<a name="CacheNode"></a>

## CacheNode ⇐ <code>Node</code>
This node can be used as a cache management component for another node.
Caching is in general used by default in [NodeBuilder](NodeBuilder) but this node
allows the usage of a shared parent cache during the build process.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [CacheNode](#CacheNode) ⇐ <code>Node</code>
    * [new CacheNode(node, [parent])](#new_CacheNode_new)
    * [.node](#CacheNode+node) : <code>Node</code>
    * [.parent](#CacheNode+parent) : <code>boolean</code>
    * [.isCacheNode](#CacheNode+isCacheNode) : <code>boolean</code>

<a name="new_CacheNode_new"></a>

### new CacheNode(node, [parent])
Constructs a new cache node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be cached. |
| [parent] | <code>boolean</code> | <code>true</code> | Whether this node refers to a shared parent cache or not. |

<a name="CacheNode+node"></a>

### cacheNode.node : <code>Node</code>
The node that should be cached.

**Kind**: instance property of [<code>CacheNode</code>](#CacheNode)  
<a name="CacheNode+parent"></a>

### cacheNode.parent : <code>boolean</code>
Whether this node refers to a shared parent cache or not.

**Kind**: instance property of [<code>CacheNode</code>](#CacheNode)  
**Default**: <code>true</code>  
<a name="CacheNode+isCacheNode"></a>

### cacheNode.isCacheNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CacheNode</code>](#CacheNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="cache"></a>

## cache(node, [parent]) ⇒ [<code>CacheNode</code>](#CacheNode)
TSL function for creating a cache node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that should be cached. |
| [parent] | <code>boolean</code> | Whether this node refers to a shared parent cache or not. |

<a name="ConstNode"></a>

## ConstNode ⇐ <code>InputNode</code>
Class for representing a constant value in the shader.

**Kind**: global class  
**Extends**: <code>InputNode</code>  

* [ConstNode](#ConstNode) ⇐ <code>InputNode</code>
    * [new ConstNode(value, nodeType)](#new_ConstNode_new)
    * [.isConstNode](#ConstNode+isConstNode) : <code>boolean</code>
    * [.generateConst(builder)](#ConstNode+generateConst) ⇒ <code>string</code>

<a name="new_ConstNode_new"></a>

### new ConstNode(value, nodeType)
Constructs a new input node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>any</code> |  | The value of this node. Usually a JS primitive or three.js object (vector, matrix, color). |
| nodeType | <code>string</code> | <code>null</code> | The node type. If no explicit type is defined, the node tries to derive the type from its value. |

<a name="ConstNode+isConstNode"></a>

### constNode.isConstNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ConstNode</code>](#ConstNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ConstNode+generateConst"></a>

### constNode.generateConst(builder) ⇒ <code>string</code>
Generates the shader string of the value with the current node builder.

**Kind**: instance method of [<code>ConstNode</code>](#ConstNode)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#ContextNode">ContextNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used as a context management component for another node.
<a href="NodeBuilder">NodeBuilder</a> performs its node building process in a specific context and
this node allows the modify the context. A typical use case is to overwrite <code>getUV()</code> e.g.:</p>
<pre><code class="language-js">node.context( { getUV: () =&gt; customCoord } );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#context">context(node, [value])</a> ⇒ <code><a href="#ContextNode">ContextNode</a></code></dt>
<dd><p>TSL function for creating a context node.</p>
</dd>
<dt><a href="#label">label(node, name)</a> ⇒ <code><a href="#ContextNode">ContextNode</a></code></dt>
<dd><p>TSL function for defining a label context value for a given node.</p>
</dd>
</dl>

<a name="ContextNode"></a>

## ContextNode ⇐ <code>Node</code>
This node can be used as a context management component for another node.
[NodeBuilder](NodeBuilder) performs its node building process in a specific context and
this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:

```js
node.context( { getUV: () => customCoord } );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ContextNode](#ContextNode) ⇐ <code>Node</code>
    * [new ContextNode(node, [value])](#new_ContextNode_new)
    * [.isContextNode](#ContextNode+isContextNode) : <code>boolean</code>
    * [.node](#ContextNode+node) : <code>Node</code>
    * [.value](#ContextNode+value) : <code>Object</code>
    * [.getScope()](#ContextNode+getScope) ⇒ <code>Node</code>
    * [.getNodeType(builder)](#ContextNode+getNodeType) ⇒ <code>string</code>

<a name="new_ContextNode_new"></a>

### new ContextNode(node, [value])
Constructs a new context node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node whose context should be modified. |
| [value] | <code>Object</code> | <code>{}</code> | The modified context data. |

<a name="ContextNode+isContextNode"></a>

### contextNode.isContextNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ContextNode</code>](#ContextNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ContextNode+node"></a>

### contextNode.node : <code>Node</code>
The node whose context should be modified.

**Kind**: instance property of [<code>ContextNode</code>](#ContextNode)  
<a name="ContextNode+value"></a>

### contextNode.value : <code>Object</code>
The modified context data.

**Kind**: instance property of [<code>ContextNode</code>](#ContextNode)  
**Default**: <code>{}</code>  
<a name="ContextNode+getScope"></a>

### contextNode.getScope() ⇒ <code>Node</code>
This method is overwritten to ensure it returns the reference to [node](#ContextNode+node).

**Kind**: instance method of [<code>ContextNode</code>](#ContextNode)  
**Returns**: <code>Node</code> - A reference to [node](#ContextNode+node).  
<a name="ContextNode+getNodeType"></a>

### contextNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten to ensure it returns the type of [node](#ContextNode+node).

**Kind**: instance method of [<code>ContextNode</code>](#ContextNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="context"></a>

## context(node, [value]) ⇒ [<code>ContextNode</code>](#ContextNode)
TSL function for creating a context node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node whose context should be modified. |
| [value] | <code>Object</code> | <code>{}</code> | The modified context data. |

<a name="label"></a>

## label(node, name) ⇒ [<code>ContextNode</code>](#ContextNode)
TSL function for defining a label context value for a given node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node whose context should be modified. |
| name | <code>string</code> | The name/label to set. |

## Classes

<dl>
<dt><a href="#IndexNode">IndexNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class represents shader indices of different types. The following predefined node
objects cover frequent use cases:</p>
<ul>
<li><code>vertexIndex</code>: The index of a vertex within a mesh.</li>
<li><code>instanceIndex</code>: The index of either a mesh instance or an invocation of a compute shader.</li>
<li><code>drawIndex</code>: The index of a draw call.</li>
<li><code>invocationLocalIndex</code>: The index of a compute invocation within the scope of a workgroup load.</li>
<li><code>invocationSubgroupIndex</code>: The index of a compute invocation within the scope of a subgroup.</li>
<li><code>subgroupIndex</code>: The index of the subgroup the current compute invocation belongs to.</li>
</ul>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#vertexIndex">vertexIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of a vertex within a mesh.</p>
</dd>
<dt><a href="#instanceIndex">instanceIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of either a mesh instance or an invocation of a compute shader.</p>
</dd>
<dt><a href="#subgroupIndex">subgroupIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of the subgroup the current compute invocation belongs to.</p>
</dd>
<dt><a href="#invocationSubgroupIndex">invocationSubgroupIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of a compute invocation within the scope of a subgroup.</p>
</dd>
<dt><a href="#invocationLocalIndex">invocationLocalIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of a compute invocation within the scope of a workgroup load.</p>
</dd>
<dt><a href="#drawIndex">drawIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of a draw call.</p>
</dd>
</dl>

<a name="IndexNode"></a>

## IndexNode ⇐ <code>Node</code>
This class represents shader indices of different types. The following predefined node
objects cover frequent use cases:

- `vertexIndex`: The index of a vertex within a mesh.
- `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.
- `drawIndex`: The index of a draw call.
- `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.
- `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.
- `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [IndexNode](#IndexNode) ⇐ <code>Node</code>
    * [new IndexNode(scope)](#new_IndexNode_new)
    * [.scope](#IndexNode+scope) : <code>string</code>
    * [.isIndexNode](#IndexNode+isIndexNode) : <code>boolean</code>

<a name="new_IndexNode_new"></a>

### new IndexNode(scope)
Constructs a new index node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;instance&#x27;</code> \| <code>&#x27;subgroup&#x27;</code> \| <code>&#x27;invocationLocal&#x27;</code> \| <code>&#x27;invocationSubgroup&#x27;</code> \| <code>&#x27;draw&#x27;</code> | The scope of the index node. |

<a name="IndexNode+scope"></a>

### indexNode.scope : <code>string</code>
The scope of the index node.

**Kind**: instance property of [<code>IndexNode</code>](#IndexNode)  
<a name="IndexNode+isIndexNode"></a>

### indexNode.isIndexNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>IndexNode</code>](#IndexNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="vertexIndex"></a>

## vertexIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of a vertex within a mesh.

**Kind**: global constant  
**Tsl**:   
<a name="instanceIndex"></a>

## instanceIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of either a mesh instance or an invocation of a compute shader.

**Kind**: global constant  
**Tsl**:   
<a name="subgroupIndex"></a>

## subgroupIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of the subgroup the current compute invocation belongs to.

**Kind**: global constant  
**Tsl**:   
<a name="invocationSubgroupIndex"></a>

## invocationSubgroupIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of a compute invocation within the scope of a subgroup.

**Kind**: global constant  
**Tsl**:   
<a name="invocationLocalIndex"></a>

## invocationLocalIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of a compute invocation within the scope of a workgroup load.

**Kind**: global constant  
**Tsl**:   
<a name="drawIndex"></a>

## drawIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of a draw call.

**Kind**: global constant  
**Tsl**:   
<a name="InputNode"></a>

## InputNode ⇐ <code>Node</code>
Base class for representing data input nodes.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [InputNode](#InputNode) ⇐ <code>Node</code>
    * [new InputNode(value, nodeType)](#new_InputNode_new)
    * [.isInputNode](#InputNode+isInputNode) : <code>boolean</code>
    * [.value](#InputNode+value) : <code>any</code>
    * [.precision](#InputNode+precision) : <code>&#x27;low&#x27;</code> \| <code>&#x27;medium&#x27;</code> \| <code>&#x27;high&#x27;</code>
    * [.getInputType(builder)](#InputNode+getInputType) ⇒ <code>string</code>
    * [.setPrecision(precision)](#InputNode+setPrecision) ⇒ [<code>InputNode</code>](#InputNode)

<a name="new_InputNode_new"></a>

### new InputNode(value, nodeType)
Constructs a new input node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>any</code> |  | The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors). |
| nodeType | <code>string</code> | <code>null</code> | The node type. If no explicit type is defined, the node tries to derive the type from its value. |

<a name="InputNode+isInputNode"></a>

### inputNode.isInputNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InputNode</code>](#InputNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InputNode+value"></a>

### inputNode.value : <code>any</code>
The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).

**Kind**: instance property of [<code>InputNode</code>](#InputNode)  
<a name="InputNode+precision"></a>

### inputNode.precision : <code>&#x27;low&#x27;</code> \| <code>&#x27;medium&#x27;</code> \| <code>&#x27;high&#x27;</code>
The precision of the value in the shader.

**Kind**: instance property of [<code>InputNode</code>](#InputNode)  
**Default**: <code>null</code>  
<a name="InputNode+getInputType"></a>

### inputNode.getInputType(builder) ⇒ <code>string</code>
Returns the input type of the node which is by default the node type. Derived modules
might overwrite this method and use a fixed type or compute one analytically.

A typical example for different input and node types are textures. The input type of a
normal RGBA texture is `texture` whereas its node type is `vec4`.

**Kind**: instance method of [<code>InputNode</code>](#InputNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="InputNode+setPrecision"></a>

### inputNode.setPrecision(precision) ⇒ [<code>InputNode</code>](#InputNode)
Sets the precision to the given value. The method can be
overwritten in derived classes if the final precision must be computed
analytically.

**Kind**: instance method of [<code>InputNode</code>](#InputNode)  
**Returns**: [<code>InputNode</code>](#InputNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| precision | <code>&#x27;low&#x27;</code> \| <code>&#x27;medium&#x27;</code> \| <code>&#x27;high&#x27;</code> | The precision of the input value in the shader. |

<a name="LightingModel"></a>

## LightingModel
Abstract class for implementing lighting models. The module defines
multiple methods that concrete lighting models can implement. These
methods are executed at different points during the light evaluation
process.

**Kind**: global class  

* [LightingModel](#LightingModel)
    * *[.start(builder)](#LightingModel+start)*
    * *[.finish(builder)](#LightingModel+finish)*
    * *[.direct(lightData, builder)](#LightingModel+direct)*
    * *[.directRectArea(lightData, builder)](#LightingModel+directRectArea)*
    * *[.indirect(builder)](#LightingModel+indirect)*
    * *[.ambientOcclusion(builder)](#LightingModel+ambientOcclusion)*

<a name="LightingModel+start"></a>

### *lightingModel.start(builder)*
This method is intended for setting up lighting model and context data
which are later used in the evaluation process.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+finish"></a>

### *lightingModel.finish(builder)*
This method is intended for executing final tasks like final updates
to the outgoing light.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+direct"></a>

### *lightingModel.direct(lightData, builder)*
This method is intended for implementing the direct light term and
executed during the build process of directional, point and spot light nodes.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+directRectArea"></a>

### *lightingModel.directRectArea(lightData, builder)*
This method is intended for implementing the direct light term for
rect area light nodes.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+indirect"></a>

### *lightingModel.indirect(builder)*
This method is intended for implementing the indirect light term.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+ambientOcclusion"></a>

### *lightingModel.ambientOcclusion(builder)*
This method is intended for implementing the ambient occlusion term.
Unlike other methods, this method must be called manually by the lighting
model in its indirect term.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#MRTNode">MRTNode</a> ⇐ <code>OutputStructNode</code></dt>
<dd><p>This node can be used setup a MRT context for rendering. A typical MRT setup for
post-processing is shown below:</p>
<pre><code class="language-js">const mrtNode = mrt( {
  output: output,
  normal: normalView
} ) );
</code></pre>
<p>The MRT output is defined as a dictionary.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#getTextureIndex">getTextureIndex(textures, name)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the MRT texture index for the given name.</p>
</dd>
<dt><a href="#mrt">mrt(outputNodes)</a> ⇒ <code><a href="#MRTNode">MRTNode</a></code></dt>
<dd><p>TSL function for creating a MRT node.</p>
</dd>
</dl>

<a name="MRTNode"></a>

## MRTNode ⇐ <code>OutputStructNode</code>
This node can be used setup a MRT context for rendering. A typical MRT setup for
post-processing is shown below:
```js
const mrtNode = mrt( {
  output: output,
  normal: normalView
} ) );
```
The MRT output is defined as a dictionary.

**Kind**: global class  
**Extends**: <code>OutputStructNode</code>  

* [MRTNode](#MRTNode) ⇐ <code>OutputStructNode</code>
    * [new MRTNode(outputNodes)](#new_MRTNode_new)
    * [.outputNodes](#MRTNode+outputNodes) : <code>Object.&lt;string, Node&gt;</code>
    * [.isMRTNode](#MRTNode+isMRTNode) : <code>boolean</code>
    * [.has(name)](#MRTNode+has) ⇒ <code>NodeBuilder</code>
    * [.get(name)](#MRTNode+get) ⇒ <code>Node</code>
    * [.merge(mrtNode)](#MRTNode+merge) ⇒ [<code>MRTNode</code>](#MRTNode)

<a name="new_MRTNode_new"></a>

### new MRTNode(outputNodes)
Constructs a new output struct node.


| Param | Type | Description |
| --- | --- | --- |
| outputNodes | <code>Object.&lt;string, Node&gt;</code> | The MRT outputs. |

<a name="MRTNode+outputNodes"></a>

### mrtNode.outputNodes : <code>Object.&lt;string, Node&gt;</code>
A dictionary representing the MRT outputs. The key
is the name of the output, the value the node which produces
the output result.

**Kind**: instance property of [<code>MRTNode</code>](#MRTNode)  
<a name="MRTNode+isMRTNode"></a>

### mrtNode.isMRTNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MRTNode</code>](#MRTNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MRTNode+has"></a>

### mrtNode.has(name) ⇒ <code>NodeBuilder</code>
Returns `true` if the MRT node has an output with the given name.

**Kind**: instance method of [<code>MRTNode</code>](#MRTNode)  
**Returns**: <code>NodeBuilder</code> - Whether the MRT node has an output for the given name or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the output. |

<a name="MRTNode+get"></a>

### mrtNode.get(name) ⇒ <code>Node</code>
Returns the output node for the given name.

**Kind**: instance method of [<code>MRTNode</code>](#MRTNode)  
**Returns**: <code>Node</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the output. |

<a name="MRTNode+merge"></a>

### mrtNode.merge(mrtNode) ⇒ [<code>MRTNode</code>](#MRTNode)
Merges the outputs of the given MRT node with the outputs of this node.

**Kind**: instance method of [<code>MRTNode</code>](#MRTNode)  
**Returns**: [<code>MRTNode</code>](#MRTNode) - A new MRT node with merged outputs..  

| Param | Type | Description |
| --- | --- | --- |
| mrtNode | [<code>MRTNode</code>](#MRTNode) | The MRT to merge. |

<a name="getTextureIndex"></a>

## getTextureIndex(textures, name) ⇒ <code>number</code>
Returns the MRT texture index for the given name.

**Kind**: global function  
**Returns**: <code>number</code> - The texture index.  

| Param | Type | Description |
| --- | --- | --- |
| textures | <code>Array.&lt;Texture&gt;</code> | The textures of a MRT-configured render target. |
| name | <code>string</code> | The name of the MRT texture which index is requested. |

<a name="mrt"></a>

## mrt(outputNodes) ⇒ [<code>MRTNode</code>](#MRTNode)
TSL function for creating a MRT node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| outputNodes | <code>Object.&lt;string, Node&gt;</code> | The MRT outputs. |

## Classes

<dl>
<dt><a href="#Node">Node</a> ⇐ <code>EventDispatcher</code></dt>
<dd><p>Base class for all nodes.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#traverseCallback">traverseCallback</a> : <code>function</code></dt>
<dd><p>Callback for <a href="#Node+traverse">traverse</a>.</p>
</dd>
</dl>

<a name="Node"></a>

## Node ⇐ <code>EventDispatcher</code>
Base class for all nodes.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [Node](#Node) ⇐ <code>EventDispatcher</code>
    * [new Node(nodeType)](#new_Node_new)
    * [.nodeType](#Node+nodeType) : <code>string</code>
    * [.updateType](#Node+updateType) : <code>string</code>
    * [.updateBeforeType](#Node+updateBeforeType) : <code>string</code>
    * [.updateAfterType](#Node+updateAfterType) : <code>string</code>
    * [.uuid](#Node+uuid) : <code>string</code>
    * [.version](#Node+version) : <code>number</code>
    * [.global](#Node+global) : <code>boolean</code>
    * [.isNode](#Node+isNode) : <code>boolean</code>
    * [.needsUpdate](#Node+needsUpdate) : <code>boolean</code>
    * [.type](#Node+type) : <code>string</code>
    * [.onUpdate(callback, updateType)](#Node+onUpdate) ⇒ [<code>Node</code>](#Node)
    * [.onFrameUpdate(callback)](#Node+onFrameUpdate) ⇒ [<code>Node</code>](#Node)
    * [.onRenderUpdate(callback)](#Node+onRenderUpdate) ⇒ [<code>Node</code>](#Node)
    * [.onObjectUpdate(callback)](#Node+onObjectUpdate) ⇒ [<code>Node</code>](#Node)
    * [.onReference(callback)](#Node+onReference) ⇒ [<code>Node</code>](#Node)
    * [.getSelf()](#Node+getSelf) ⇒ [<code>Node</code>](#Node)
    * [.updateReference(state)](#Node+updateReference) ⇒ <code>any</code>
    * [.isGlobal(builder)](#Node+isGlobal) ⇒ <code>boolean</code>
    * [.getChildren()](#Node+getChildren)
    * [.dispose()](#Node+dispose)
    * [.traverse(callback)](#Node+traverse)
    * [.getCacheKey([force])](#Node+getCacheKey) ⇒ <code>number</code>
    * [.customCacheKey()](#Node+customCacheKey) ⇒ <code>number</code>
    * [.getScope()](#Node+getScope) ⇒ [<code>Node</code>](#Node)
    * [.getHash(builder)](#Node+getHash) ⇒ <code>string</code>
    * [.getUpdateType()](#Node+getUpdateType) ⇒ <code>NodeUpdateType</code>
    * [.getUpdateBeforeType()](#Node+getUpdateBeforeType) ⇒ <code>NodeUpdateType</code>
    * [.getUpdateAfterType()](#Node+getUpdateAfterType) ⇒ <code>NodeUpdateType</code>
    * [.getElementType(builder)](#Node+getElementType) ⇒ <code>string</code>
    * [.getMemberType(builder, name)](#Node+getMemberType) ⇒ <code>string</code>
    * [.getNodeType(builder)](#Node+getNodeType) ⇒ <code>string</code>
    * [.getShared(builder)](#Node+getShared) ⇒ [<code>Node</code>](#Node)
    * [.setup(builder)](#Node+setup) ⇒ [<code>Node</code>](#Node)
    * [.analyze(builder)](#Node+analyze)
    * [.generate(builder, output)](#Node+generate) ⇒ <code>string</code>
    * *[.updateBefore(frame)](#Node+updateBefore) ⇒ <code>boolean</code>*
    * *[.updateAfter(frame)](#Node+updateAfter) ⇒ <code>boolean</code>*
    * *[.update(frame)](#Node+update) ⇒ <code>boolean</code>*
    * [.build(builder, output)](#Node+build) ⇒ <code>string</code>
    * [.getSerializeChildren()](#Node+getSerializeChildren) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.serialize(json)](#Node+serialize)
    * [.deserialize(json)](#Node+deserialize)
    * [.toJSON(meta)](#Node+toJSON) ⇒ <code>Object</code>

<a name="new_Node_new"></a>

### new Node(nodeType)
Constructs a new node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> | <code>null</code> | The node type. |

<a name="Node+nodeType"></a>

### node.nodeType : <code>string</code>
The node type. This represents the result type of the node (e.g. `float` or `vec3`).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>&quot;null&quot;</code>  
<a name="Node+updateType"></a>

### node.updateType : <code>string</code>
The update type of the node's [update](#Node+update) method. Possible values are listed in [NodeUpdateType](NodeUpdateType).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>&quot;&#x27;none&#x27;&quot;</code>  
<a name="Node+updateBeforeType"></a>

### node.updateBeforeType : <code>string</code>
The update type of the node's [updateBefore](#Node+updateBefore) method. Possible values are listed in [NodeUpdateType](NodeUpdateType).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>&quot;&#x27;none&#x27;&quot;</code>  
<a name="Node+updateAfterType"></a>

### node.updateAfterType : <code>string</code>
The update type of the node's [updateAfter](#Node+updateAfter) method. Possible values are listed in [NodeUpdateType](NodeUpdateType).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>&quot;&#x27;none&#x27;&quot;</code>  
<a name="Node+uuid"></a>

### node.uuid : <code>string</code>
The UUID of the node.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Read only**: true  
<a name="Node+version"></a>

### node.version : <code>number</code>
The version of the node. The version automatically is increased when [needsUpdate](#Node+needsUpdate) is set to `true`.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Node+global"></a>

### node.global : <code>boolean</code>
Whether this node is global or not. This property is relevant for the internal
node caching system. All nodes which should be declared just once should
set this flag to `true` (a typical example is [AttributeNode](AttributeNode)).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>false</code>  
<a name="Node+isNode"></a>

### node.isNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Node+needsUpdate"></a>

### node.needsUpdate : <code>boolean</code>
Set this property to `true` when the node should be regenerated.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Node+type"></a>

### node.type : <code>string</code>
The type of the class. The value is usually the constructor name.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Read only**: true  
<a name="Node+onUpdate"></a>

### node.onUpdate(callback, updateType) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [update](#Node+update).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |
| updateType | <code>string</code> | The update type. |

<a name="Node+onFrameUpdate"></a>

### node.onFrameUpdate(callback) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [update](#Node+update). Similar to [onUpdate](#Node+onUpdate), but
this method automatically sets the update type to `FRAME`.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |

<a name="Node+onRenderUpdate"></a>

### node.onRenderUpdate(callback) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [update](#Node+update). Similar to [onUpdate](#Node+onUpdate), but
this method automatically sets the update type to `RENDER`.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |

<a name="Node+onObjectUpdate"></a>

### node.onObjectUpdate(callback) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [update](#Node+update). Similar to [onUpdate](#Node+onUpdate), but
this method automatically sets the update type to `OBJECT`.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |

<a name="Node+onReference"></a>

### node.onReference(callback) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [updateReference](#Node+updateReference).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |

<a name="Node+getSelf"></a>

### node.getSelf() ⇒ [<code>Node</code>](#Node)
The `this` reference might point to a Proxy so this method can be used
to get the reference to the actual node instance.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to the node.  
<a name="Node+updateReference"></a>

### node.updateReference(state) ⇒ <code>any</code>
Nodes might refer to other objects like materials. This method allows to dynamically update the reference
to such objects based on a given state (e.g. the current node frame or builder).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>any</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>any</code> | This method can be invocated in different contexts so `state` can refer to any object type. |

<a name="Node+isGlobal"></a>

### node.isGlobal(builder) ⇒ <code>boolean</code>
By default this method returns the value of the [global](#Node+global) flag. This method
can be overwritten in derived classes if an analytical way is required to determine the
global status.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+getChildren"></a>

### node.getChildren()
Generator function that can be used to iterate over the child nodes.

**Kind**: instance method of [<code>Node</code>](#Node)  
<a name="Node+dispose"></a>

### node.dispose()
Calling this method dispatches the `dispose` event. This event can be used
to register event listeners for clean up tasks.

**Kind**: instance method of [<code>Node</code>](#Node)  
<a name="Node+traverse"></a>

### node.traverse(callback)
Can be used to traverse through the node's hierarchy.

**Kind**: instance method of [<code>Node</code>](#Node)  

| Param | Type | Description |
| --- | --- | --- |
| callback | [<code>traverseCallback</code>](#traverseCallback) | A callback that is executed per node. |

<a name="Node+getCacheKey"></a>

### node.getCacheKey([force]) ⇒ <code>number</code>
Returns the cache key for this node.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>number</code> - The cache key of the node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of the cache key is forced. |

<a name="Node+customCacheKey"></a>

### node.customCacheKey() ⇒ <code>number</code>
Generate a custom cache key for this node.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>number</code> - The cache key of the node.  
<a name="Node+getScope"></a>

### node.getScope() ⇒ [<code>Node</code>](#Node)
Returns the references to this node which is by default `this`.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  
<a name="Node+getHash"></a>

### node.getHash(builder) ⇒ <code>string</code>
Returns the hash of the node which is used to identify the node. By default it's
the [uuid](#Node+uuid) however derived node classes might have to overwrite this method
depending on their implementation.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+getUpdateType"></a>

### node.getUpdateType() ⇒ <code>NodeUpdateType</code>
Returns the update type of [update](#Node+update).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>NodeUpdateType</code> - The update type.  
<a name="Node+getUpdateBeforeType"></a>

### node.getUpdateBeforeType() ⇒ <code>NodeUpdateType</code>
Returns the update type of [updateBefore](#Node+updateBefore).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>NodeUpdateType</code> - The update type.  
<a name="Node+getUpdateAfterType"></a>

### node.getUpdateAfterType() ⇒ <code>NodeUpdateType</code>
Returns the update type of [updateAfter](#Node+updateAfter).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>NodeUpdateType</code> - The update type.  
<a name="Node+getElementType"></a>

### node.getElementType(builder) ⇒ <code>string</code>
Certain types are composed of multiple elements. For example a `vec3`
is composed of three `float` values. This method returns the type of
these elements.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+getMemberType"></a>

### node.getMemberType(builder, name) ⇒ <code>string</code>
Returns the node member type for the given name.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| name | <code>string</code> | The name of the member. |

<a name="Node+getNodeType"></a>

### node.getNodeType(builder) ⇒ <code>string</code>
Returns the node's type.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+getShared"></a>

### node.getShared(builder) ⇒ [<code>Node</code>](#Node)
This method is used during the build process of a node and ensures
equal nodes are not built multiple times but just once. For example if
`attribute( 'uv' )` is used multiple times by the user, the build
process makes sure to process just the first node.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - The shared node if possible. Otherwise `this` is returned.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+setup"></a>

### node.setup(builder) ⇒ [<code>Node</code>](#Node)
Represents the setup stage which is the first step of the build process, see [build](#Node+build) method.
This method is often overwritten in derived modules to prepare the node which is used as the output/result.
The output node must be returned in the `return` statement.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+analyze"></a>

### node.analyze(builder)
Represents the analyze stage which is the second step of the build process, see [build](#Node+build) method.
This stage analyzes the node hierarchy and ensures descendent nodes are built.

**Kind**: instance method of [<code>Node</code>](#Node)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+generate"></a>

### node.generate(builder, output) ⇒ <code>string</code>
Represents the generate stage which is the third step of the build process, see [build](#Node+build) method.
This state builds the output node and returns the resulting shader string.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The generated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | Can be used to define the output type. |

<a name="Node+updateBefore"></a>

### *node.updateBefore(frame) ⇒ <code>boolean</code>*
The method can be implemented to update the node's internal state before it is used to render an object.
The [updateBeforeType](#Node+updateBeforeType) property defines how often the update is executed.

**Kind**: instance abstract method of [<code>Node</code>](#Node)  
**Returns**: <code>boolean</code> - An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="Node+updateAfter"></a>

### *node.updateAfter(frame) ⇒ <code>boolean</code>*
The method can be implemented to update the node's internal state after it was used to render an object.
The [updateAfterType](#Node+updateAfterType) property defines how often the update is executed.

**Kind**: instance abstract method of [<code>Node</code>](#Node)  
**Returns**: <code>boolean</code> - An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="Node+update"></a>

### *node.update(frame) ⇒ <code>boolean</code>*
The method can be implemented to update the node's internal state when it is used to render an object.
The [updateType](#Node+updateType) property defines how often the update is executed.

**Kind**: instance abstract method of [<code>Node</code>](#Node)  
**Returns**: <code>boolean</code> - An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="Node+build"></a>

### node.build(builder, output) ⇒ <code>string</code>
This method performs the build of a node. The behavior of this method as well as its return value depend
on the current build stage (setup, analyze or generate).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| builder | <code>NodeBuilder</code> |  | The current node builder. |
| output | <code>string</code> | <code>null</code> | Can be used to define the output type. |

<a name="Node+getSerializeChildren"></a>

### node.getSerializeChildren() ⇒ <code>Array.&lt;Object&gt;</code>
Returns the child nodes as a JSON object.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>Array.&lt;Object&gt;</code> - An iterable list of serialized child objects as JSON.  
<a name="Node+serialize"></a>

### node.serialize(json)
Serializes the node to JSON.

**Kind**: instance method of [<code>Node</code>](#Node)  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The output JSON object. |

<a name="Node+deserialize"></a>

### node.deserialize(json)
Deserializes the node from the given JSON.

**Kind**: instance method of [<code>Node</code>](#Node)  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON object. |

<a name="Node+toJSON"></a>

### node.toJSON(meta) ⇒ <code>Object</code>
Serializes the node into the three.js JSON Object/Scene format.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>Object</code> - The serialized node.  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> | An optional JSON object that already holds serialized data from other scene objects. |

<a name="traverseCallback"></a>

## traverseCallback : <code>function</code>
Callback for [traverse](#Node+traverse).

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| node | [<code>Node</code>](#Node) | The current node. |

<a name="NodeAttribute"></a>

## NodeAttribute
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent the final shader attributes that are going to be generated
by the builder. Arrays of node attributes is maintained in [NodeBuilder#attributes](NodeBuilder#attributes)
and [NodeBuilder#bufferAttributes](NodeBuilder#bufferAttributes) for this purpose.

**Kind**: global class  

* [NodeAttribute](#NodeAttribute)
    * [new NodeAttribute(name, type, node)](#new_NodeAttribute_new)
    * [.isNodeAttribute](#NodeAttribute+isNodeAttribute) : <code>boolean</code>
    * [.name](#NodeAttribute+name) : <code>string</code>
    * [.type](#NodeAttribute+type) : <code>string</code>
    * [.node](#NodeAttribute+node) : <code>Node</code>

<a name="new_NodeAttribute_new"></a>

### new NodeAttribute(name, type, node)
Constructs a new node attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the attribute. |
| type | <code>string</code> |  | The type of the attribute. |
| node | <code>Node</code> | <code></code> | An optional reference to the node. |

<a name="NodeAttribute+isNodeAttribute"></a>

### nodeAttribute.isNodeAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeAttribute</code>](#NodeAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="NodeAttribute+name"></a>

### nodeAttribute.name : <code>string</code>
The name of the attribute.

**Kind**: instance property of [<code>NodeAttribute</code>](#NodeAttribute)  
<a name="NodeAttribute+type"></a>

### nodeAttribute.type : <code>string</code>
The type of the attribute.

**Kind**: instance property of [<code>NodeAttribute</code>](#NodeAttribute)  
<a name="NodeAttribute+node"></a>

### nodeAttribute.node : <code>Node</code>
An optional reference to the node.

**Kind**: instance property of [<code>NodeAttribute</code>](#NodeAttribute)  
**Default**: <code>null</code>  
<a name="NodeBuilder"></a>

## NodeBuilder
Base class for builders which generate a shader program based
on a 3D object and its node material definition.

**Kind**: global class  

* [NodeBuilder](#NodeBuilder)
    * [new NodeBuilder(object, renderer, parser)](#new_NodeBuilder_new)
    * [.object](#NodeBuilder+object) : <code>Object3D</code>
    * [.material](#NodeBuilder+material) : <code>Material</code>
    * [.geometry](#NodeBuilder+geometry) : <code>BufferGeometry</code>
    * [.renderer](#NodeBuilder+renderer) : <code>Renderer</code>
    * [.parser](#NodeBuilder+parser) : <code>NodeParser</code>
    * [.scene](#NodeBuilder+scene) : <code>Scene</code>
    * [.camera](#NodeBuilder+camera) : <code>Camera</code>
    * [.nodes](#NodeBuilder+nodes) : <code>Array.&lt;Node&gt;</code>
    * [.sequentialNodes](#NodeBuilder+sequentialNodes) : <code>Array.&lt;Node&gt;</code>
    * [.updateNodes](#NodeBuilder+updateNodes) : <code>Array.&lt;Node&gt;</code>
    * [.updateBeforeNodes](#NodeBuilder+updateBeforeNodes) : <code>Array.&lt;Node&gt;</code>
    * [.updateAfterNodes](#NodeBuilder+updateAfterNodes) : <code>Array.&lt;Node&gt;</code>
    * [.hashNodes](#NodeBuilder+hashNodes) : <code>Object.&lt;number, Node&gt;</code>
    * [.observer](#NodeBuilder+observer) : <code>NodeMaterialObserver</code>
    * [.lightsNode](#NodeBuilder+lightsNode) : <code>LightsNode</code>
    * [.environmentNode](#NodeBuilder+environmentNode) : <code>Node</code>
    * [.fogNode](#NodeBuilder+fogNode) : <code>FogNode</code>
    * [.clippingContext](#NodeBuilder+clippingContext) : <code>ClippingContext</code>
    * [.vertexShader](#NodeBuilder+vertexShader) : <code>string</code>
    * [.fragmentShader](#NodeBuilder+fragmentShader) : <code>string</code>
    * [.computeShader](#NodeBuilder+computeShader) : <code>string</code>
    * [.flowNodes](#NodeBuilder+flowNodes) : <code>Object.&lt;string, Array.&lt;Node&gt;&gt;</code>
    * [.flowCode](#NodeBuilder+flowCode) : <code>Object.&lt;string, string&gt;</code>
    * [.uniforms](#NodeBuilder+uniforms) : <code>Object</code>
    * [.structs](#NodeBuilder+structs) : <code>Object</code>
    * [.bindings](#NodeBuilder+bindings) : <code>Object</code>
    * [.bindingsIndexes](#NodeBuilder+bindingsIndexes) : <code>Object</code>
    * [.bindGroups](#NodeBuilder+bindGroups) : <code>Array.&lt;BindGroup&gt;</code>
    * [.attributes](#NodeBuilder+attributes) : <code>Array.&lt;NodeAttribute&gt;</code>
    * [.bufferAttributes](#NodeBuilder+bufferAttributes) : <code>Array.&lt;NodeAttribute&gt;</code>
    * [.varyings](#NodeBuilder+varyings) : <code>Array.&lt;NodeVarying&gt;</code>
    * [.codes](#NodeBuilder+codes) : <code>Object.&lt;string, Array.&lt;NodeCode&gt;&gt;</code>
    * [.vars](#NodeBuilder+vars) : <code>Object.&lt;string, (Array.&lt;NodeVar&gt;\|number)&gt;</code>
    * [.declarations](#NodeBuilder+declarations) : <code>Object</code>
    * [.flow](#NodeBuilder+flow) : <code>Object</code>
    * [.chaining](#NodeBuilder+chaining) : <code>Array.&lt;Node&gt;</code>
    * [.stack](#NodeBuilder+stack) : <code>StackNode</code>
    * [.stacks](#NodeBuilder+stacks) : <code>Array.&lt;StackNode&gt;</code>
    * [.tab](#NodeBuilder+tab) : <code>string</code>
    * [.currentFunctionNode](#NodeBuilder+currentFunctionNode) : <code>FunctionNode</code>
    * [.context](#NodeBuilder+context) : <code>Object</code>
    * [.cache](#NodeBuilder+cache) : <code>NodeCache</code>
    * [.globalCache](#NodeBuilder+globalCache) : <code>NodeCache</code>
    * [.shaderStage](#NodeBuilder+shaderStage) : <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code>
    * [.buildStage](#NodeBuilder+buildStage) : <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code>
    * [.currentNode](#NodeBuilder+currentNode) : <code>Node</code>
    * [.getBindGroupsCache()](#NodeBuilder+getBindGroupsCache) ⇒ <code>ChainMap</code>
    * [.createRenderTarget(width, height, options)](#NodeBuilder+createRenderTarget) ⇒ <code>RenderTarget</code>
    * [.createCubeRenderTarget(size, options)](#NodeBuilder+createCubeRenderTarget) ⇒ <code>CubeRenderTarget</code>
    * [.includes(node)](#NodeBuilder+includes) ⇒ <code>boolean</code>
    * *[.getOutputStructName()](#NodeBuilder+getOutputStructName) ⇒ <code>string</code>*
    * [.getBindGroupArray(groupName, shaderStage)](#NodeBuilder+getBindGroupArray) ⇒ <code>Array.&lt;NodeUniformsGroup&gt;</code>
    * [.getBindings()](#NodeBuilder+getBindings) ⇒ <code>Array.&lt;BindGroup&gt;</code>
    * [.sortBindingGroups()](#NodeBuilder+sortBindingGroups)
    * [.setHashNode(node, hash)](#NodeBuilder+setHashNode)
    * [.addNode(node)](#NodeBuilder+addNode)
    * [.addSequentialNode(node)](#NodeBuilder+addSequentialNode)
    * [.buildUpdateNodes()](#NodeBuilder+buildUpdateNodes)
    * [.isFilteredTexture(texture)](#NodeBuilder+isFilteredTexture) ⇒ <code>boolean</code>
    * [.addChain(node)](#NodeBuilder+addChain)
    * [.removeChain(node)](#NodeBuilder+removeChain)
    * *[.getMethod(method)](#NodeBuilder+getMethod) ⇒ <code>string</code>*
    * [.getNodeFromHash(hash)](#NodeBuilder+getNodeFromHash) ⇒ <code>Node</code>
    * [.addFlow(shaderStage, node)](#NodeBuilder+addFlow) ⇒ <code>Node</code>
    * [.setContext(context)](#NodeBuilder+setContext)
    * [.getContext()](#NodeBuilder+getContext) ⇒ <code>Object</code>
    * [.getSharedContext()](#NodeBuilder+getSharedContext) ⇒ <code>Object</code>
    * [.setCache(cache)](#NodeBuilder+setCache)
    * [.getCache()](#NodeBuilder+getCache) ⇒ <code>NodeCache</code>
    * [.getCacheFromNode(node, [parent])](#NodeBuilder+getCacheFromNode) ⇒ <code>NodeCache</code>
    * *[.isAvailable(name)](#NodeBuilder+isAvailable) ⇒ <code>boolean</code>*
    * *[.getVertexIndex()](#NodeBuilder+getVertexIndex) ⇒ <code>string</code>*
    * *[.getInstanceIndex()](#NodeBuilder+getInstanceIndex) ⇒ <code>string</code>*
    * *[.getDrawIndex()](#NodeBuilder+getDrawIndex) ⇒ <code>string</code>*
    * *[.getFrontFacing()](#NodeBuilder+getFrontFacing) ⇒ <code>string</code>*
    * *[.getFragCoord()](#NodeBuilder+getFragCoord) ⇒ <code>string</code>*
    * *[.isFlipY()](#NodeBuilder+isFlipY) ⇒ <code>boolean</code>*
    * [.increaseUsage(node)](#NodeBuilder+increaseUsage) ⇒ <code>number</code>
    * *[.generateTexture(texture, textureProperty, uvSnippet)](#NodeBuilder+generateTexture) ⇒ <code>string</code>*
    * *[.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet)](#NodeBuilder+generateTextureLod) ⇒ <code>string</code>*
    * [.generateArrayDeclaration(type, [count])](#NodeBuilder+generateArrayDeclaration) ⇒ <code>string</code>
    * [.generateArray(type, [count], [values])](#NodeBuilder+generateArray) ⇒ <code>string</code>
    * [.generateStruct(type, [membersLayout], [values])](#NodeBuilder+generateStruct) ⇒ <code>string</code>
    * [.generateConst(type, [value])](#NodeBuilder+generateConst) ⇒ <code>string</code>
    * [.getType(type)](#NodeBuilder+getType) ⇒ <code>string</code>
    * [.hasGeometryAttribute(name)](#NodeBuilder+hasGeometryAttribute) ⇒ <code>boolean</code>
    * [.getAttribute(name, type)](#NodeBuilder+getAttribute) ⇒ <code>NodeAttribute</code>
    * [.getPropertyName(node, shaderStage)](#NodeBuilder+getPropertyName) ⇒ <code>string</code>
    * [.isVector(type)](#NodeBuilder+isVector) ⇒ <code>boolean</code>
    * [.isMatrix(type)](#NodeBuilder+isMatrix) ⇒ <code>boolean</code>
    * [.isReference(type)](#NodeBuilder+isReference) ⇒ <code>boolean</code>
    * *[.needsToWorkingColorSpace(texture)](#NodeBuilder+needsToWorkingColorSpace) ⇒ <code>boolean</code>*
    * [.getComponentTypeFromTexture(texture)](#NodeBuilder+getComponentTypeFromTexture) ⇒ <code>string</code>
    * [.getElementType(type)](#NodeBuilder+getElementType) ⇒ <code>string</code>
    * [.getComponentType(type)](#NodeBuilder+getComponentType) ⇒ <code>string</code>
    * [.getVectorType(type)](#NodeBuilder+getVectorType) ⇒ <code>string</code>
    * [.getTypeFromLength(length, [componentType])](#NodeBuilder+getTypeFromLength) ⇒ <code>string</code>
    * [.getTypeFromArray(array)](#NodeBuilder+getTypeFromArray) ⇒ <code>string</code>
    * [.isInteger(type)](#NodeBuilder+isInteger) ⇒ <code>boolean</code>
    * [.getTypeFromAttribute(attribute)](#NodeBuilder+getTypeFromAttribute) ⇒ <code>string</code>
    * [.getTypeLength(type)](#NodeBuilder+getTypeLength) ⇒ <code>number</code>
    * [.getVectorFromMatrix(type)](#NodeBuilder+getVectorFromMatrix) ⇒ <code>string</code>
    * [.changeComponentType(type, newComponentType)](#NodeBuilder+changeComponentType) ⇒ <code>string</code>
    * [.getIntegerType(type)](#NodeBuilder+getIntegerType) ⇒ <code>string</code>
    * [.addStack()](#NodeBuilder+addStack) ⇒ <code>StackNode</code>
    * [.removeStack()](#NodeBuilder+removeStack) ⇒ <code>StackNode</code>
    * [.getDataFromNode(node, [shaderStage], cache)](#NodeBuilder+getDataFromNode) ⇒ <code>Object</code>
    * [.getNodeProperties(node, [shaderStage])](#NodeBuilder+getNodeProperties) ⇒ <code>Object</code>
    * [.getBufferAttributeFromNode(node, type)](#NodeBuilder+getBufferAttributeFromNode) ⇒ <code>NodeAttribute</code>
    * [.getStructTypeFromNode(node, membersLayout, [name], [shaderStage])](#NodeBuilder+getStructTypeFromNode) ⇒ <code>StructType</code>
    * [.getOutputStructTypeFromNode(node, membersLayout)](#NodeBuilder+getOutputStructTypeFromNode) ⇒ <code>StructType</code>
    * [.getUniformFromNode(node, type, [shaderStage], name)](#NodeBuilder+getUniformFromNode) ⇒ <code>NodeUniform</code>
    * [.getArrayCount(node)](#NodeBuilder+getArrayCount) ⇒ <code>number</code>
    * [.getVarFromNode(node, name, [type], [shaderStage], [readOnly])](#NodeBuilder+getVarFromNode) ⇒ <code>NodeVar</code>
    * [.isDeterministic(node)](#NodeBuilder+isDeterministic) ⇒ <code>boolean</code>
    * [.getVaryingFromNode(node, name, [type])](#NodeBuilder+getVaryingFromNode) ⇒ <code>NodeVar</code>
    * [.registerDeclaration(node)](#NodeBuilder+registerDeclaration)
    * [.getCodeFromNode(node, type, [shaderStage])](#NodeBuilder+getCodeFromNode) ⇒ <code>NodeCode</code>
    * [.addFlowCodeHierarchy(node, nodeBlock)](#NodeBuilder+addFlowCodeHierarchy)
    * [.addLineFlowCodeBlock(node, code, nodeBlock)](#NodeBuilder+addLineFlowCodeBlock)
    * [.addLineFlowCode(code, [node])](#NodeBuilder+addLineFlowCode) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.addFlowCode(code)](#NodeBuilder+addFlowCode) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.addFlowTab()](#NodeBuilder+addFlowTab) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.removeFlowTab()](#NodeBuilder+removeFlowTab) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.getFlowData(node, shaderStage)](#NodeBuilder+getFlowData) ⇒ <code>Object</code>
    * [.flowNode(node)](#NodeBuilder+flowNode) ⇒ <code>Object</code>
    * [.addInclude(node)](#NodeBuilder+addInclude) ⇒ <code>void</code>
    * [.buildFunctionNode(shaderNode)](#NodeBuilder+buildFunctionNode) ⇒ <code>FunctionNode</code>
    * [.flowShaderNode(shaderNode)](#NodeBuilder+flowShaderNode) ⇒ <code>Object</code>
    * [.flowStagesNode(node, output)](#NodeBuilder+flowStagesNode) ⇒ <code>Object</code>
    * *[.getFunctionOperator(op)](#NodeBuilder+getFunctionOperator) ⇒ <code>string</code>*
    * *[.buildFunctionCode(shaderNode)](#NodeBuilder+buildFunctionCode) ⇒ <code>string</code>*
    * [.flowChildNode(node, output)](#NodeBuilder+flowChildNode) ⇒ <code>Object</code>
    * [.flowNodeFromShaderStage(shaderStage, node, output, propertyName)](#NodeBuilder+flowNodeFromShaderStage) ⇒ <code>Object</code>
    * [.getAttributesArray()](#NodeBuilder+getAttributesArray) ⇒ <code>Array.&lt;NodeAttribute&gt;</code>
    * *[.getAttributes(shaderStage)](#NodeBuilder+getAttributes) ⇒ <code>string</code>*
    * *[.getVaryings(shaderStage)](#NodeBuilder+getVaryings) ⇒ <code>string</code>*
    * [.getVar(type, name, [count])](#NodeBuilder+getVar) ⇒ <code>string</code>
    * [.getVars(shaderStage)](#NodeBuilder+getVars) ⇒ <code>string</code>
    * *[.getUniforms(shaderStage)](#NodeBuilder+getUniforms) ⇒ <code>string</code>*
    * [.getCodes(shaderStage)](#NodeBuilder+getCodes) ⇒ <code>string</code>
    * [.getHash()](#NodeBuilder+getHash) ⇒ <code>string</code>
    * [.setShaderStage(shaderStage)](#NodeBuilder+setShaderStage)
    * [.getShaderStage()](#NodeBuilder+getShaderStage) ⇒ <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code>
    * [.setBuildStage(buildStage)](#NodeBuilder+setBuildStage)
    * [.getBuildStage()](#NodeBuilder+getBuildStage) ⇒ <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code>
    * *[.buildCode()](#NodeBuilder+buildCode)*
    * [.build()](#NodeBuilder+build) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.getNodeUniform(uniformNode, type)](#NodeBuilder+getNodeUniform) ⇒ <code>Uniform</code>
    * [.format(snippet, fromType, toType)](#NodeBuilder+format) ⇒ <code>string</code>
    * [.getSignature()](#NodeBuilder+getSignature) ⇒ <code>string</code>
    * ~~[.createNodeMaterial([type])](#NodeBuilder+createNodeMaterial)~~

<a name="new_NodeBuilder_new"></a>

### new NodeBuilder(object, renderer, parser)
Constructs a new node builder.


| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object. |
| renderer | <code>Renderer</code> | The current renderer. |
| parser | <code>NodeParser</code> | A reference to a node parser. |

<a name="NodeBuilder+object"></a>

### nodeBuilder.object : <code>Object3D</code>
The 3D object.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+material"></a>

### nodeBuilder.material : <code>Material</code>
The material of the 3D object.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+geometry"></a>

### nodeBuilder.geometry : <code>BufferGeometry</code>
The geometry of the 3D object.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+renderer"></a>

### nodeBuilder.renderer : <code>Renderer</code>
The current renderer.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+parser"></a>

### nodeBuilder.parser : <code>NodeParser</code>
A reference to a node parser.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+scene"></a>

### nodeBuilder.scene : <code>Scene</code>
The scene the 3D object belongs to.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+camera"></a>

### nodeBuilder.camera : <code>Camera</code>
The camera the 3D object is rendered with.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+nodes"></a>

### nodeBuilder.nodes : <code>Array.&lt;Node&gt;</code>
A list of all nodes the builder is processing
for this 3D object.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+sequentialNodes"></a>

### nodeBuilder.sequentialNodes : <code>Array.&lt;Node&gt;</code>
A list of all sequential nodes.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+updateNodes"></a>

### nodeBuilder.updateNodes : <code>Array.&lt;Node&gt;</code>
A list of all nodes which [Node#update](Node#update) method should be executed.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+updateBeforeNodes"></a>

### nodeBuilder.updateBeforeNodes : <code>Array.&lt;Node&gt;</code>
A list of all nodes which [Node#updateBefore](Node#updateBefore) method should be executed.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+updateAfterNodes"></a>

### nodeBuilder.updateAfterNodes : <code>Array.&lt;Node&gt;</code>
A list of all nodes which [Node#updateAfter](Node#updateAfter) method should be executed.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+hashNodes"></a>

### nodeBuilder.hashNodes : <code>Object.&lt;number, Node&gt;</code>
A dictionary that assigns each node to a unique hash.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+observer"></a>

### nodeBuilder.observer : <code>NodeMaterialObserver</code>
A reference to a node material observer.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+lightsNode"></a>

### nodeBuilder.lightsNode : <code>LightsNode</code>
A reference to the current lights node.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+environmentNode"></a>

### nodeBuilder.environmentNode : <code>Node</code>
A reference to the current environment node.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+fogNode"></a>

### nodeBuilder.fogNode : <code>FogNode</code>
A reference to the current fog node.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+clippingContext"></a>

### nodeBuilder.clippingContext : <code>ClippingContext</code>
The current clipping context.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+vertexShader"></a>

### nodeBuilder.vertexShader : <code>string</code>
The generated vertex shader.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+fragmentShader"></a>

### nodeBuilder.fragmentShader : <code>string</code>
The generated fragment shader.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+computeShader"></a>

### nodeBuilder.computeShader : <code>string</code>
The generated compute shader.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+flowNodes"></a>

### nodeBuilder.flowNodes : <code>Object.&lt;string, Array.&lt;Node&gt;&gt;</code>
Nodes used in the primary flow of code generation.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+flowCode"></a>

### nodeBuilder.flowCode : <code>Object.&lt;string, string&gt;</code>
Nodes code from `.flowNodes`.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+uniforms"></a>

### nodeBuilder.uniforms : <code>Object</code>
This dictionary holds the node uniforms of the builder.
The uniforms are maintained in an array for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+structs"></a>

### nodeBuilder.structs : <code>Object</code>
This dictionary holds the output structs of the builder.
The structs are maintained in an array for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+bindings"></a>

### nodeBuilder.bindings : <code>Object</code>
This dictionary holds the bindings for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+bindingsIndexes"></a>

### nodeBuilder.bindingsIndexes : <code>Object</code>
This dictionary maintains the binding indices per bind group.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+bindGroups"></a>

### nodeBuilder.bindGroups : <code>Array.&lt;BindGroup&gt;</code>
Reference to the array of bind groups.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+attributes"></a>

### nodeBuilder.attributes : <code>Array.&lt;NodeAttribute&gt;</code>
This array holds the node attributes of this builder
created via [AttributeNode](AttributeNode).

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+bufferAttributes"></a>

### nodeBuilder.bufferAttributes : <code>Array.&lt;NodeAttribute&gt;</code>
This array holds the node attributes of this builder
created via [BufferAttributeNode](BufferAttributeNode).

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+varyings"></a>

### nodeBuilder.varyings : <code>Array.&lt;NodeVarying&gt;</code>
This array holds the node varyings of this builder.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+codes"></a>

### nodeBuilder.codes : <code>Object.&lt;string, Array.&lt;NodeCode&gt;&gt;</code>
This dictionary holds the (native) node codes of this builder.
The codes are maintained in an array for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+vars"></a>

### nodeBuilder.vars : <code>Object.&lt;string, (Array.&lt;NodeVar&gt;\|number)&gt;</code>
This dictionary holds the node variables of this builder.
The variables are maintained in an array for each shader stage.
This dictionary is also used to count the number of variables
according to their type (const, vars).

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+declarations"></a>

### nodeBuilder.declarations : <code>Object</code>
This dictionary holds the declarations for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+flow"></a>

### nodeBuilder.flow : <code>Object</code>
Current code flow.
All code generated in this stack will be stored in `.flow`.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+chaining"></a>

### nodeBuilder.chaining : <code>Array.&lt;Node&gt;</code>
A chain of nodes.
Used to check recursive calls in node-graph.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+stack"></a>

### nodeBuilder.stack : <code>StackNode</code>
The current stack.
This reflects the current process in the code block hierarchy,
it is useful to know if the current process is inside a conditional for example.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+stacks"></a>

### nodeBuilder.stacks : <code>Array.&lt;StackNode&gt;</code>
List of stack nodes.
The current stack hierarchy is stored in an array.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+tab"></a>

### nodeBuilder.tab : <code>string</code>
A tab value. Used for shader string generation.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>&quot;&#x27;\\t&#x27;&quot;</code>  
<a name="NodeBuilder+currentFunctionNode"></a>

### nodeBuilder.currentFunctionNode : <code>FunctionNode</code>
Reference to the current function node.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+context"></a>

### nodeBuilder.context : <code>Object</code>
The builder's context.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+cache"></a>

### nodeBuilder.cache : <code>NodeCache</code>
The builder's cache.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+globalCache"></a>

### nodeBuilder.globalCache : <code>NodeCache</code>
Since the [cache](#NodeBuilder+cache) might be temporarily
overwritten by other caches, this member retains the reference
to the builder's own cache.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>this.cache</code>  
<a name="NodeBuilder+shaderStage"></a>

### nodeBuilder.shaderStage : <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code>
The current shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+buildStage"></a>

### nodeBuilder.buildStage : <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code>
The current build stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+currentNode"></a>

### nodeBuilder.currentNode : <code>Node</code>
A reference the current node which is the
last node in the chain of nodes.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+getBindGroupsCache"></a>

### nodeBuilder.getBindGroupsCache() ⇒ <code>ChainMap</code>
Returns the bind groups of the current renderer.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>ChainMap</code> - The cache.  
<a name="NodeBuilder+createRenderTarget"></a>

### nodeBuilder.createRenderTarget(width, height, options) ⇒ <code>RenderTarget</code>
Factory method for creating an instance of [RenderTarget](RenderTarget) with the given
dimensions and options.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>RenderTarget</code> - The render target.  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the render target. |
| height | <code>number</code> | The height of the render target. |
| options | <code>Object</code> | The options of the render target. |

<a name="NodeBuilder+createCubeRenderTarget"></a>

### nodeBuilder.createCubeRenderTarget(size, options) ⇒ <code>CubeRenderTarget</code>
Factory method for creating an instance of [CubeRenderTarget](CubeRenderTarget) with the given
dimensions and options.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>CubeRenderTarget</code> - The cube render target.  

| Param | Type | Description |
| --- | --- | --- |
| size | <code>number</code> | The size of the cube render target. |
| options | <code>Object</code> | The options of the cube render target. |

<a name="NodeBuilder+includes"></a>

### nodeBuilder.includes(node) ⇒ <code>boolean</code>
Whether the given node is included in the internal array of nodes or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given node is included in the internal array of nodes or not.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to test. |

<a name="NodeBuilder+getOutputStructName"></a>

### *nodeBuilder.getOutputStructName() ⇒ <code>string</code>*
Returns the output struct name which is required by
[OutputStructNode](OutputStructNode).

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The name of the output struct.  
<a name="NodeBuilder+getBindGroupArray"></a>

### nodeBuilder.getBindGroupArray(groupName, shaderStage) ⇒ <code>Array.&lt;NodeUniformsGroup&gt;</code>
Returns an array of node uniform groups for the given group name and shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Array.&lt;NodeUniformsGroup&gt;</code> - The array of node uniform groups.  

| Param | Type | Description |
| --- | --- | --- |
| groupName | <code>string</code> | The group name. |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getBindings"></a>

### nodeBuilder.getBindings() ⇒ <code>Array.&lt;BindGroup&gt;</code>
Returns a list bindings of all shader stages separated by groups.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Array.&lt;BindGroup&gt;</code> - The list of bindings.  
<a name="NodeBuilder+sortBindingGroups"></a>

### nodeBuilder.sortBindingGroups()
Sorts the bind groups and updates [bindingsIndexes](#NodeBuilder+bindingsIndexes).

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+setHashNode"></a>

### nodeBuilder.setHashNode(node, hash)
The builder maintains each node in a hash-based dictionary.
This method sets the given node (value) with the given hash (key) into this dictionary.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |
| hash | <code>number</code> | The hash of the node. |

<a name="NodeBuilder+addNode"></a>

### nodeBuilder.addNode(node)
Adds a node to this builder.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |

<a name="NodeBuilder+addSequentialNode"></a>

### nodeBuilder.addSequentialNode(node)
It is used to add Nodes that will be used as FRAME and RENDER events,
and need to follow a certain sequence in the calls to work correctly.
This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |

<a name="NodeBuilder+buildUpdateNodes"></a>

### nodeBuilder.buildUpdateNodes()
Checks the update types of nodes

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+isFilteredTexture"></a>

### nodeBuilder.isFilteredTexture(texture) ⇒ <code>boolean</code>
Whether the given texture is filtered or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture is filtered or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to check. |

<a name="NodeBuilder+addChain"></a>

### nodeBuilder.addChain(node)
Adds the given node to the internal node chain.
This is used to check recursive calls in node-graph.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |

<a name="NodeBuilder+removeChain"></a>

### nodeBuilder.removeChain(node)
Removes the given node from the internal node chain.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to remove. |

<a name="NodeBuilder+getMethod"></a>

### *nodeBuilder.getMethod(method) ⇒ <code>string</code>*
Returns the native shader method name for a given generic name. E.g.
the method name `textureDimensions` matches the WGSL name but must be
resolved to `textureSize` in GLSL.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The resolved method name.  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The method name to resolve. |

<a name="NodeBuilder+getNodeFromHash"></a>

### nodeBuilder.getNodeFromHash(hash) ⇒ <code>Node</code>
Returns a node for the given hash, see [setHashNode](#NodeBuilder+setHashNode).

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Node</code> - The found node.  

| Param | Type | Description |
| --- | --- | --- |
| hash | <code>number</code> | The hash of the node. |

<a name="NodeBuilder+addFlow"></a>

### nodeBuilder.addFlow(shaderStage, node) ⇒ <code>Node</code>
Adds the Node to a target flow so that it can generate code in the 'generate' process.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Node</code> - The node.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> | The shader stage. |
| node | <code>Node</code> | The node to add. |

<a name="NodeBuilder+setContext"></a>

### nodeBuilder.setContext(context)
Sets builder's context.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| context | <code>Object</code> | The context to set. |

<a name="NodeBuilder+getContext"></a>

### nodeBuilder.getContext() ⇒ <code>Object</code>
Returns the builder's current context.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The builder's current context.  
<a name="NodeBuilder+getSharedContext"></a>

### nodeBuilder.getSharedContext() ⇒ <code>Object</code>
Gets a context used in shader construction that can be shared across different materials.
This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The builder's current context without material.  
<a name="NodeBuilder+setCache"></a>

### nodeBuilder.setCache(cache)
Sets builder's cache.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| cache | <code>NodeCache</code> | The cache to set. |

<a name="NodeBuilder+getCache"></a>

### nodeBuilder.getCache() ⇒ <code>NodeCache</code>
Returns the builder's current cache.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeCache</code> - The builder's current cache.  
<a name="NodeBuilder+getCacheFromNode"></a>

### nodeBuilder.getCacheFromNode(node, [parent]) ⇒ <code>NodeCache</code>
Returns a cache for the given node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeCache</code> - The cache.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node. |
| [parent] | <code>boolean</code> | <code>true</code> | Whether this node refers to a shared parent cache or not. |

<a name="NodeBuilder+isAvailable"></a>

### *nodeBuilder.isAvailable(name) ⇒ <code>boolean</code>*
Whether the requested feature is available or not.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the requested feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The requested feature. |

<a name="NodeBuilder+getVertexIndex"></a>

### *nodeBuilder.getVertexIndex() ⇒ <code>string</code>*
Returns the vertexIndex input variable as a native shader string.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The instanceIndex shader string.  
<a name="NodeBuilder+getInstanceIndex"></a>

### *nodeBuilder.getInstanceIndex() ⇒ <code>string</code>*
Returns the instanceIndex input variable as a native shader string.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The instanceIndex shader string.  
<a name="NodeBuilder+getDrawIndex"></a>

### *nodeBuilder.getDrawIndex() ⇒ <code>string</code>*
Returns the drawIndex input variable as a native shader string.
Only relevant for WebGL and its `WEBGL_multi_draw` extension.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The drawIndex shader string.  
<a name="NodeBuilder+getFrontFacing"></a>

### *nodeBuilder.getFrontFacing() ⇒ <code>string</code>*
Returns the frontFacing input variable as a native shader string.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The frontFacing shader string.  
<a name="NodeBuilder+getFragCoord"></a>

### *nodeBuilder.getFragCoord() ⇒ <code>string</code>*
Returns the fragCoord input variable as a native shader string.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The fragCoord shader string.  
<a name="NodeBuilder+isFlipY"></a>

### *nodeBuilder.isFlipY() ⇒ <code>boolean</code>*
Whether to flip texture data along its vertical axis or not. WebGL needs
this method evaluate to `true`, WebGPU to `false`.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether to flip texture data along its vertical axis or not.  
<a name="NodeBuilder+increaseUsage"></a>

### nodeBuilder.increaseUsage(node) ⇒ <code>number</code>
Calling this method increases the usage count for the given node by one.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>number</code> - The updated usage count.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to increase the usage count for. |

<a name="NodeBuilder+generateTexture"></a>

### *nodeBuilder.generateTexture(texture, textureProperty, uvSnippet) ⇒ <code>string</code>*
Generates a texture sample shader string for the given texture data.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The texture property name. |
| uvSnippet | <code>string</code> | Snippet defining the texture coordinates. |

<a name="NodeBuilder+generateTextureLod"></a>

### *nodeBuilder.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet) ⇒ <code>string</code>*
Generates a texture LOD shader string for the given texture data.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The texture property name. |
| uvSnippet | <code>string</code> | Snippet defining the texture coordinates. |
| depthSnippet | <code>string</code> | Snippet defining the 0-based texture array index to sample. |
| levelSnippet | <code>string</code> | Snippet defining the mip level. |

<a name="NodeBuilder+generateArrayDeclaration"></a>

### nodeBuilder.generateArrayDeclaration(type, [count]) ⇒ <code>string</code>
Generates the array declaration string.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |
| [count] | <code>number</code> | The count. |

<a name="NodeBuilder+generateArray"></a>

### nodeBuilder.generateArray(type, [count], [values]) ⇒ <code>string</code>
Generates the array shader string for the given type and value.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type. |
| [count] | <code>number</code> |  | The count. |
| [values] | <code>Array.&lt;Node&gt;</code> | <code></code> | The default values. |

<a name="NodeBuilder+generateStruct"></a>

### nodeBuilder.generateStruct(type, [membersLayout], [values]) ⇒ <code>string</code>
Generates the struct shader string.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type. |
| [membersLayout] | <code>Array.&lt;Object&gt;</code> |  | The count. |
| [values] | <code>Array.&lt;Node&gt;</code> | <code></code> | The default values. |

<a name="NodeBuilder+generateConst"></a>

### nodeBuilder.generateConst(type, [value]) ⇒ <code>string</code>
Generates the shader string for the given type and value.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type. |
| [value] | <code>any</code> | <code></code> | The value. |

<a name="NodeBuilder+getType"></a>

### nodeBuilder.getType(type) ⇒ <code>string</code>
It might be necessary to convert certain data types to different ones
so this method can be used to hide the conversion.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The updated type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+hasGeometryAttribute"></a>

### nodeBuilder.hasGeometryAttribute(name) ⇒ <code>boolean</code>
Whether the given attribute name is defined in the geometry or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given attribute name is defined in the geometry.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute name. |

<a name="NodeBuilder+getAttribute"></a>

### nodeBuilder.getAttribute(name, type) ⇒ <code>NodeAttribute</code>
Returns a node attribute for the given name and type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeAttribute</code> - The node attribute.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute's name. |
| type | <code>string</code> | The attribute's type. |

<a name="NodeBuilder+getPropertyName"></a>

### nodeBuilder.getPropertyName(node, shaderStage) ⇒ <code>string</code>
Returns for the given node and shader stage the property name for the shader.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node. |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+isVector"></a>

### nodeBuilder.isVector(type) ⇒ <code>boolean</code>
Whether the given type is a vector type or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given type is a vector type or not.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type to check. |

<a name="NodeBuilder+isMatrix"></a>

### nodeBuilder.isMatrix(type) ⇒ <code>boolean</code>
Whether the given type is a matrix type or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given type is a matrix type or not.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type to check. |

<a name="NodeBuilder+isReference"></a>

### nodeBuilder.isReference(type) ⇒ <code>boolean</code>
Whether the given type is a reference type or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given type is a reference type or not.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type to check. |

<a name="NodeBuilder+needsToWorkingColorSpace"></a>

### *nodeBuilder.needsToWorkingColorSpace(texture) ⇒ <code>boolean</code>*
Checks if the given texture requires a manual conversion to the working color space.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture requires a conversion to working color space or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to check. |

<a name="NodeBuilder+getComponentTypeFromTexture"></a>

### nodeBuilder.getComponentTypeFromTexture(texture) ⇒ <code>string</code>
Returns the component type of a given texture.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The component type.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="NodeBuilder+getElementType"></a>

### nodeBuilder.getElementType(type) ⇒ <code>string</code>
Returns the element type for a given type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The element type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+getComponentType"></a>

### nodeBuilder.getComponentType(type) ⇒ <code>string</code>
Returns the component type for a given type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The component type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+getVectorType"></a>

### nodeBuilder.getVectorType(type) ⇒ <code>string</code>
Returns the vector type for a given type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The vector type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+getTypeFromLength"></a>

### nodeBuilder.getTypeFromLength(length, [componentType]) ⇒ <code>string</code>
Returns the data type for the given the length and component type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The type.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| length | <code>number</code> |  | The length. |
| [componentType] | <code>string</code> | <code>&quot;&#x27;float&#x27;&quot;</code> | The component type. |

<a name="NodeBuilder+getTypeFromArray"></a>

### nodeBuilder.getTypeFromArray(array) ⇒ <code>string</code>
Returns the type for a given typed array.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The type.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> | The typed array. |

<a name="NodeBuilder+isInteger"></a>

### nodeBuilder.isInteger(type) ⇒ <code>boolean</code>
Returns the type is an integer type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the type is an integer type or not.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+getTypeFromAttribute"></a>

### nodeBuilder.getTypeFromAttribute(attribute) ⇒ <code>string</code>
Returns the type for a given buffer attribute.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The type.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute. |

<a name="NodeBuilder+getTypeLength"></a>

### nodeBuilder.getTypeLength(type) ⇒ <code>number</code>
Returns the length for the given data type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>number</code> - The length.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The data type. |

<a name="NodeBuilder+getVectorFromMatrix"></a>

### nodeBuilder.getVectorFromMatrix(type) ⇒ <code>string</code>
Returns the vector type for a given matrix type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The vector type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The matrix type. |

<a name="NodeBuilder+changeComponentType"></a>

### nodeBuilder.changeComponentType(type, newComponentType) ⇒ <code>string</code>
For a given type this method changes the component type to the
given value. E.g. `vec4` should be changed to the new component type
`uint` which results in `uvec4`.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The new type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |
| newComponentType | <code>string</code> | The new component type. |

<a name="NodeBuilder+getIntegerType"></a>

### nodeBuilder.getIntegerType(type) ⇒ <code>string</code>
Returns the integer type pendant for the given type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The integer type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+addStack"></a>

### nodeBuilder.addStack() ⇒ <code>StackNode</code>
Adds a stack node to the internal stack.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>StackNode</code> - The added stack node.  
<a name="NodeBuilder+removeStack"></a>

### nodeBuilder.removeStack() ⇒ <code>StackNode</code>
Removes the last stack node from the internal stack.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>StackNode</code> - The removed stack node.  
<a name="NodeBuilder+getDataFromNode"></a>

### nodeBuilder.getDataFromNode(node, [shaderStage], cache) ⇒ <code>Object</code>
The builder maintains (cached) data for each node during the building process. This method
can be used to get these data for a specific shader stage and cache.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The node data.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to get the data for. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |
| cache | <code>NodeCache</code> | <code></code> | An optional cache. |

<a name="NodeBuilder+getNodeProperties"></a>

### nodeBuilder.getNodeProperties(node, [shaderStage]) ⇒ <code>Object</code>
Returns the properties for the given node and shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The node properties.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to get the properties for. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getBufferAttributeFromNode"></a>

### nodeBuilder.getBufferAttributeFromNode(node, type) ⇒ <code>NodeAttribute</code>
Returns an instance of [NodeAttribute](NodeAttribute) for the given buffer attribute node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeAttribute</code> - The node attribute.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>BufferAttributeNode</code> | The buffer attribute node. |
| type | <code>string</code> | The node type. |

<a name="NodeBuilder+getStructTypeFromNode"></a>

### nodeBuilder.getStructTypeFromNode(node, membersLayout, [name], [shaderStage]) ⇒ <code>StructType</code>
Returns an instance of [StructType](StructType) for the given output struct node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>StructType</code> - The struct type attribute.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>OutputStructNode</code> |  | The output struct node. |
| membersLayout | <code>Array.&lt;Object&gt;</code> |  | The output struct types. |
| [name] | <code>string</code> | <code>null</code> | The name of the struct. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |

<a name="NodeBuilder+getOutputStructTypeFromNode"></a>

### nodeBuilder.getOutputStructTypeFromNode(node, membersLayout) ⇒ <code>StructType</code>
Returns an instance of [StructType](StructType) for the given output struct node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>StructType</code> - The struct type attribute.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>OutputStructNode</code> | The output struct node. |
| membersLayout | <code>Array.&lt;Object&gt;</code> | The output struct types. |

<a name="NodeBuilder+getUniformFromNode"></a>

### nodeBuilder.getUniformFromNode(node, type, [shaderStage], name) ⇒ <code>NodeUniform</code>
Returns an instance of [NodeUniform](NodeUniform) for the given uniform node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeUniform</code> - The node uniform.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>UniformNode</code> |  | The uniform node. |
| type | <code>string</code> |  | The uniform type. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |
| name | <code>string</code> | <code>null</code> | The name of the uniform. |

<a name="NodeBuilder+getArrayCount"></a>

### nodeBuilder.getArrayCount(node) ⇒ <code>number</code>
Returns the array length.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>number</code> - The array length.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node. |

<a name="NodeBuilder+getVarFromNode"></a>

### nodeBuilder.getVarFromNode(node, name, [type], [shaderStage], [readOnly]) ⇒ <code>NodeVar</code>
Returns an instance of [NodeVar](NodeVar) for the given variable node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeVar</code> - The node variable.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>VarNode</code> |  | The variable node. |
| name | <code>string</code> | <code>null</code> | The variable's name. |
| [type] | <code>string</code> | <code>&quot;node.getNodeType( this )&quot;</code> | The variable's type. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |
| [readOnly] | <code>boolean</code> | <code>false</code> | Whether the variable is read-only or not. |

<a name="NodeBuilder+isDeterministic"></a>

### nodeBuilder.isDeterministic(node) ⇒ <code>boolean</code>
Returns whether a Node or its flow is deterministic, useful for use in `const`.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Returns true if deterministic.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The varying node. |

<a name="NodeBuilder+getVaryingFromNode"></a>

### nodeBuilder.getVaryingFromNode(node, name, [type]) ⇒ <code>NodeVar</code>
Returns an instance of [NodeVarying](NodeVarying) for the given varying node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeVar</code> - The node varying.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>VaryingNode</code> \| <code>PropertyNode</code> |  | The varying node. |
| name | <code>string</code> | <code>null</code> | The varying's name. |
| [type] | <code>string</code> | <code>&quot;node.getNodeType( this )&quot;</code> | The varying's type. |

<a name="NodeBuilder+registerDeclaration"></a>

### nodeBuilder.registerDeclaration(node)
Registers a node declaration in the current shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Object</code> | The node to be registered. |

<a name="NodeBuilder+getCodeFromNode"></a>

### nodeBuilder.getCodeFromNode(node, type, [shaderStage]) ⇒ <code>NodeCode</code>
Returns an instance of [NodeCode](NodeCode) for the given code node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeCode</code> - The node code.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>CodeNode</code> |  | The code node. |
| type | <code>string</code> |  | The node type. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |

<a name="NodeBuilder+addFlowCodeHierarchy"></a>

### nodeBuilder.addFlowCodeHierarchy(node, nodeBlock)
Adds a code flow based on the code-block hierarchy.
This is used so that code-blocks like If,Else create their variables locally if the Node
is only used inside one of these conditionals in the current shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |
| nodeBlock | <code>Node</code> | Node-based code-block. Usually 'ConditionalNode'. |

<a name="NodeBuilder+addLineFlowCodeBlock"></a>

### nodeBuilder.addLineFlowCodeBlock(node, code, nodeBlock)
Add a inline-code to the current flow code-block.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |
| code | <code>string</code> | The code to add. |
| nodeBlock | <code>Node</code> | Current ConditionalNode |

<a name="NodeBuilder+addLineFlowCode"></a>

### nodeBuilder.addLineFlowCode(code, [node]) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Add a inline-code to the current flow.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| code | <code>string</code> |  | The code to add. |
| [node] | <code>Node</code> | <code></code> | Optional Node, can help the system understand if the Node is part of a code-block. |

<a name="NodeBuilder+addFlowCode"></a>

### nodeBuilder.addFlowCode(code) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Adds a code to the current code flow.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | Shader code. |

<a name="NodeBuilder+addFlowTab"></a>

### nodeBuilder.addFlowTab() ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Add tab in the code that will be generated so that other snippets respect the current tabulation.
Typically used in codes with If,Else.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  
<a name="NodeBuilder+removeFlowTab"></a>

### nodeBuilder.removeFlowTab() ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Removes a tab.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  
<a name="NodeBuilder+getFlowData"></a>

### nodeBuilder.getFlowData(node, shaderStage) ⇒ <code>Object</code>
Gets the current flow data based on a Node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The flow data.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Node that the flow was started. |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+flowNode"></a>

### nodeBuilder.flowNode(node) ⇒ <code>Object</code>
Executes the node flow based on a root node to generate the final shader code.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The code flow.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to execute. |

<a name="NodeBuilder+addInclude"></a>

### nodeBuilder.addInclude(node) ⇒ <code>void</code>
Includes a node in the current function node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to include. |

<a name="NodeBuilder+buildFunctionNode"></a>

### nodeBuilder.buildFunctionNode(shaderNode) ⇒ <code>FunctionNode</code>
Returns the native shader operator name for a given generic name.
It is a similar type of method like [getMethod](#NodeBuilder+getMethod).

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>FunctionNode</code> - The build function node.  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | The shader node to build the function node with. |

<a name="NodeBuilder+flowShaderNode"></a>

### nodeBuilder.flowShaderNode(shaderNode) ⇒ <code>Object</code>
Generates a code flow based on a TSL function: Fn().

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | A function code will be generated based on the input. |

<a name="NodeBuilder+flowStagesNode"></a>

### nodeBuilder.flowStagesNode(node, output) ⇒ <code>Object</code>
Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to execute. |
| output | <code>string</code> | <code>null</code> | Expected output type. For example 'vec3'. |

<a name="NodeBuilder+getFunctionOperator"></a>

### *nodeBuilder.getFunctionOperator(op) ⇒ <code>string</code>*
Returns the native shader operator name for a given generic name.
It is a similar type of method like [getMethod](#NodeBuilder+getMethod).

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The resolved operator name.  

| Param | Type | Description |
| --- | --- | --- |
| op | <code>string</code> | The operator name to resolve. |

<a name="NodeBuilder+buildFunctionCode"></a>

### *nodeBuilder.buildFunctionCode(shaderNode) ⇒ <code>string</code>*
Builds the given shader node.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The function code.  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | The shader node. |

<a name="NodeBuilder+flowChildNode"></a>

### nodeBuilder.flowChildNode(node, output) ⇒ <code>Object</code>
Generates a code flow based on a child Node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The code flow.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to execute. |
| output | <code>string</code> | <code>null</code> | Expected output type. For example 'vec3'. |

<a name="NodeBuilder+flowNodeFromShaderStage"></a>

### nodeBuilder.flowNodeFromShaderStage(shaderStage, node, output, propertyName) ⇒ <code>Object</code>
Executes a flow of code in a different stage.

Some nodes like `varying()` have the ability to compute code in vertex-stage and
return the value in fragment-stage even if it is being executed in an input fragment.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> |  | The shader stage. |
| node | <code>Node</code> |  | The node to execute. |
| output | <code>string</code> | <code>null</code> | Expected output type. For example 'vec3'. |
| propertyName | <code>string</code> | <code>null</code> | The property name to assign the result. |

<a name="NodeBuilder+getAttributesArray"></a>

### nodeBuilder.getAttributesArray() ⇒ <code>Array.&lt;NodeAttribute&gt;</code>
Returns an array holding all node attributes of this node builder.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Array.&lt;NodeAttribute&gt;</code> - The node attributes of this builder.  
<a name="NodeBuilder+getAttributes"></a>

### *nodeBuilder.getAttributes(shaderStage) ⇒ <code>string</code>*
Returns the attribute definitions as a shader string for the given shader stage.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The attribute code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getVaryings"></a>

### *nodeBuilder.getVaryings(shaderStage) ⇒ <code>string</code>*
Returns the varying definitions as a shader string for the given shader stage.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The varying code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getVar"></a>

### nodeBuilder.getVar(type, name, [count]) ⇒ <code>string</code>
Returns a single variable definition as a shader string for the given variable type and name.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The variable's type. |
| name | <code>string</code> |  | The variable's name. |
| [count] | <code>number</code> | <code></code> | The array length. |

<a name="NodeBuilder+getVars"></a>

### nodeBuilder.getVars(shaderStage) ⇒ <code>string</code>
Returns the variable definitions as a shader string for the given shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The variable code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getUniforms"></a>

### *nodeBuilder.getUniforms(shaderStage) ⇒ <code>string</code>*
Returns the uniform definitions as a shader string for the given shader stage.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The uniform code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getCodes"></a>

### nodeBuilder.getCodes(shaderStage) ⇒ <code>string</code>
Returns the native code definitions as a shader string for the given shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The native code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getHash"></a>

### nodeBuilder.getHash() ⇒ <code>string</code>
Returns the hash of this node builder.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The hash.  
<a name="NodeBuilder+setShaderStage"></a>

### nodeBuilder.setShaderStage(shaderStage)
Sets the current shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage to set. |

<a name="NodeBuilder+getShaderStage"></a>

### nodeBuilder.getShaderStage() ⇒ <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code>
Returns the current shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> - The current shader stage.  
<a name="NodeBuilder+setBuildStage"></a>

### nodeBuilder.setBuildStage(buildStage)
Sets the current build stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| buildStage | <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code> | The build stage to set. |

<a name="NodeBuilder+getBuildStage"></a>

### nodeBuilder.getBuildStage() ⇒ <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code>
Returns the current build stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code> - The current build stage.  
<a name="NodeBuilder+buildCode"></a>

### *nodeBuilder.buildCode()*
Controls the code build of the shader stages.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+build"></a>

### nodeBuilder.build() ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Central build method which controls the build for the given object.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  
<a name="NodeBuilder+getNodeUniform"></a>

### nodeBuilder.getNodeUniform(uniformNode, type) ⇒ <code>Uniform</code>
Returns a uniform representation which is later used for UBO generation and rendering.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Uniform</code> - The uniform.  

| Param | Type | Description |
| --- | --- | --- |
| uniformNode | <code>NodeUniform</code> | The uniform node. |
| type | <code>string</code> | The requested type. |

<a name="NodeBuilder+format"></a>

### nodeBuilder.format(snippet, fromType, toType) ⇒ <code>string</code>
Formats the given shader snippet from a given type into another one. E.g.
this method might be used to convert a simple float string `"1.0"` into a
`vec3` representation: `"vec3<f32>( 1.0 )"`.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The updated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| snippet | <code>string</code> | The shader snippet. |
| fromType | <code>string</code> | The source type. |
| toType | <code>string</code> | The target type. |

<a name="NodeBuilder+getSignature"></a>

### nodeBuilder.getSignature() ⇒ <code>string</code>
Returns a signature with the engine's current revision.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The signature.  
<a name="NodeBuilder+createNodeMaterial"></a>

### ~~nodeBuilder.createNodeMaterial([type])~~
***since r168. Use `new NodeMaterial()` instead, with targeted node material name.***

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Throws**:

- <code>Error</code> 


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [type] | <code>string</code> | <code>&quot;&#x27;NodeMaterial&#x27;&quot;</code> | The node material type. |

<a name="NodeCache"></a>

## NodeCache
This utility class is used in [NodeBuilder](NodeBuilder) as an internal
cache data structure for node data.

**Kind**: global class  

* [NodeCache](#NodeCache)
    * [new NodeCache(parent)](#new_NodeCache_new)
    * [.id](#NodeCache+id) : <code>number</code>
    * [.nodesData](#NodeCache+nodesData) : <code>WeakMap.&lt;Node, Object&gt;</code>
    * [.parent](#NodeCache+parent) : [<code>NodeCache</code>](#NodeCache)
    * [.getData(node)](#NodeCache+getData) ⇒ <code>Object</code>
    * [.setData(node, data)](#NodeCache+setData)

<a name="new_NodeCache_new"></a>

### new NodeCache(parent)
Constructs a new node cache.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| parent | [<code>NodeCache</code>](#NodeCache) | <code></code> | A reference to a parent cache. |

<a name="NodeCache+id"></a>

### nodeCache.id : <code>number</code>
The id of the cache.

**Kind**: instance property of [<code>NodeCache</code>](#NodeCache)  
**Read only**: true  
<a name="NodeCache+nodesData"></a>

### nodeCache.nodesData : <code>WeakMap.&lt;Node, Object&gt;</code>
A weak map for managing node data.

**Kind**: instance property of [<code>NodeCache</code>](#NodeCache)  
<a name="NodeCache+parent"></a>

### nodeCache.parent : [<code>NodeCache</code>](#NodeCache)
Reference to a parent node cache.

**Kind**: instance property of [<code>NodeCache</code>](#NodeCache)  
**Default**: <code>null</code>  
<a name="NodeCache+getData"></a>

### nodeCache.getData(node) ⇒ <code>Object</code>
Returns the data for the given node.

**Kind**: instance method of [<code>NodeCache</code>](#NodeCache)  
**Returns**: <code>Object</code> - The data for the node.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node. |

<a name="NodeCache+setData"></a>

### nodeCache.setData(node, data)
Sets the data for a given node.

**Kind**: instance method of [<code>NodeCache</code>](#NodeCache)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node. |
| data | <code>Object</code> | The data that should be cached. |

<a name="NodeCode"></a>

## NodeCode
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent user-defined, native shader code portions that are going to be
injected by the builder. A dictionary of node codes is maintained in [NodeBuilder#codes](NodeBuilder#codes)
for this purpose.

**Kind**: global class  

* [NodeCode](#NodeCode)
    * [new NodeCode(name, type, [code])](#new_NodeCode_new)
    * [.name](#NodeCode+name) : <code>string</code>
    * [.type](#NodeCode+type) : <code>string</code>
    * [.code](#NodeCode+code) : <code>string</code>

<a name="new_NodeCode_new"></a>

### new NodeCode(name, type, [code])
Constructs a new code node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the code. |
| type | <code>string</code> |  | The node type. |
| [code] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The native shader code. |

<a name="NodeCode+name"></a>

### nodeCode.name : <code>string</code>
The name of the code.

**Kind**: instance property of [<code>NodeCode</code>](#NodeCode)  
<a name="NodeCode+type"></a>

### nodeCode.type : <code>string</code>
The node type.

**Kind**: instance property of [<code>NodeCode</code>](#NodeCode)  
<a name="NodeCode+code"></a>

### nodeCode.code : <code>string</code>
The native shader code.

**Kind**: instance property of [<code>NodeCode</code>](#NodeCode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="NodeFrame"></a>

## NodeFrame
Management class for updating nodes. The module tracks metrics like
the elapsed time, delta time, the render and frame ID to correctly
call the node update methods [Node#updateBefore](Node#updateBefore), [Node#update](Node#update)
and [Node#updateAfter](Node#updateAfter) depending on the node's configuration.

**Kind**: global class  

* [NodeFrame](#NodeFrame)
    * [new NodeFrame()](#new_NodeFrame_new)
    * [.time](#NodeFrame+time) : <code>number</code>
    * [.deltaTime](#NodeFrame+deltaTime) : <code>number</code>
    * [.frameId](#NodeFrame+frameId) : <code>number</code>
    * [.renderId](#NodeFrame+renderId) : <code>number</code>
    * [.updateMap](#NodeFrame+updateMap) : <code>WeakMap.&lt;Node, Object&gt;</code>
    * [.updateBeforeMap](#NodeFrame+updateBeforeMap) : <code>WeakMap.&lt;Node, Object&gt;</code>
    * [.updateAfterMap](#NodeFrame+updateAfterMap) : <code>WeakMap.&lt;Node, Object&gt;</code>
    * [.renderer](#NodeFrame+renderer) : <code>Renderer</code>
    * [.material](#NodeFrame+material) : <code>Material</code>
    * [.camera](#NodeFrame+camera) : <code>Camera</code>
    * [.object](#NodeFrame+object) : <code>Object3D</code>
    * [.scene](#NodeFrame+scene) : <code>Scene</code>
    * [.updateBeforeNode(node)](#NodeFrame+updateBeforeNode)
    * [.updateAfterNode(node)](#NodeFrame+updateAfterNode)
    * [.updateNode(node)](#NodeFrame+updateNode)
    * [.update()](#NodeFrame+update)

<a name="new_NodeFrame_new"></a>

### new NodeFrame()
Constructs a new node fame.

<a name="NodeFrame+time"></a>

### nodeFrame.time : <code>number</code>
The elapsed time in seconds.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>0</code>  
<a name="NodeFrame+deltaTime"></a>

### nodeFrame.deltaTime : <code>number</code>
The delta time in seconds.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>0</code>  
<a name="NodeFrame+frameId"></a>

### nodeFrame.frameId : <code>number</code>
The frame ID.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>0</code>  
<a name="NodeFrame+renderId"></a>

### nodeFrame.renderId : <code>number</code>
The render ID.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>0</code>  
<a name="NodeFrame+updateMap"></a>

### nodeFrame.updateMap : <code>WeakMap.&lt;Node, Object&gt;</code>
Used to control the [Node#update](Node#update) call.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
<a name="NodeFrame+updateBeforeMap"></a>

### nodeFrame.updateBeforeMap : <code>WeakMap.&lt;Node, Object&gt;</code>
Used to control the [Node#updateBefore](Node#updateBefore) call.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
<a name="NodeFrame+updateAfterMap"></a>

### nodeFrame.updateAfterMap : <code>WeakMap.&lt;Node, Object&gt;</code>
Used to control the [Node#updateAfter](Node#updateAfter) call.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
<a name="NodeFrame+renderer"></a>

### nodeFrame.renderer : <code>Renderer</code>
A reference to the current renderer.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+material"></a>

### nodeFrame.material : <code>Material</code>
A reference to the current material.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+camera"></a>

### nodeFrame.camera : <code>Camera</code>
A reference to the current camera.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+object"></a>

### nodeFrame.object : <code>Object3D</code>
A reference to the current 3D object.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+scene"></a>

### nodeFrame.scene : <code>Scene</code>
A reference to the current scene.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+updateBeforeNode"></a>

### nodeFrame.updateBeforeNode(node)
This method executes the [Node#updateBefore](Node#updateBefore) for the given node.
It makes sure [Node#updateBeforeType](Node#updateBeforeType) is honored meaning the update
is only executed once per frame, render or object depending on the update
type.

**Kind**: instance method of [<code>NodeFrame</code>](#NodeFrame)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that should be updated. |

<a name="NodeFrame+updateAfterNode"></a>

### nodeFrame.updateAfterNode(node)
This method executes the [Node#updateAfter](Node#updateAfter) for the given node.
It makes sure [Node#updateAfterType](Node#updateAfterType) is honored meaning the update
is only executed once per frame, render or object depending on the update
type.

**Kind**: instance method of [<code>NodeFrame</code>](#NodeFrame)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that should be updated. |

<a name="NodeFrame+updateNode"></a>

### nodeFrame.updateNode(node)
This method executes the [Node#update](Node#update) for the given node.
It makes sure [Node#updateType](Node#updateType) is honored meaning the update
is only executed once per frame, render or object depending on the update
type.

**Kind**: instance method of [<code>NodeFrame</code>](#NodeFrame)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that should be updated. |

<a name="NodeFrame+update"></a>

### nodeFrame.update()
Updates the internal state of the node frame. This method is
called by the renderer in its internal animation loop.

**Kind**: instance method of [<code>NodeFrame</code>](#NodeFrame)  
<a name="NodeFunction"></a>

## NodeFunction
Base class for node functions. A derived module must be implemented
for each supported native shader language. Similar to other `Node*` modules,
this class is only relevant during the building process and not used
in user-level code.

**Kind**: global class  

* [NodeFunction](#NodeFunction)
    * [new NodeFunction(type, inputs, [name], [precision])](#new_NodeFunction_new)
    * [.type](#NodeFunction+type) : <code>string</code>
    * [.inputs](#NodeFunction+inputs) : <code>Array.&lt;NodeFunctionInput&gt;</code>
    * [.name](#NodeFunction+name) : <code>string</code>
    * [.precision](#NodeFunction+precision) : <code>string</code>
    * *[.getCode(name)](#NodeFunction+getCode) ⇒ <code>string</code>*

<a name="new_NodeFunction_new"></a>

### new NodeFunction(type, inputs, [name], [precision])
Constructs a new node function.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The node type. This type is the return type of the node function. |
| inputs | <code>Array.&lt;NodeFunctionInput&gt;</code> |  | The function's inputs. |
| [name] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The function's name. |
| [precision] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The precision qualifier. |

<a name="NodeFunction+type"></a>

### nodeFunction.type : <code>string</code>
The node type. This type is the return type of the node function.

**Kind**: instance property of [<code>NodeFunction</code>](#NodeFunction)  
<a name="NodeFunction+inputs"></a>

### nodeFunction.inputs : <code>Array.&lt;NodeFunctionInput&gt;</code>
The function's inputs.

**Kind**: instance property of [<code>NodeFunction</code>](#NodeFunction)  
<a name="NodeFunction+name"></a>

### nodeFunction.name : <code>string</code>
The name of the uniform.

**Kind**: instance property of [<code>NodeFunction</code>](#NodeFunction)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="NodeFunction+precision"></a>

### nodeFunction.precision : <code>string</code>
The precision qualifier.

**Kind**: instance property of [<code>NodeFunction</code>](#NodeFunction)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="NodeFunction+getCode"></a>

### *nodeFunction.getCode(name) ⇒ <code>string</code>*
This method returns the native code of the node function.

**Kind**: instance abstract method of [<code>NodeFunction</code>](#NodeFunction)  
**Returns**: <code>string</code> - A shader code.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The function's name. |

<a name="NodeFunctionInput"></a>

## NodeFunctionInput
Describes the input of a [NodeFunction](NodeFunction).

**Kind**: global class  

* [NodeFunctionInput](#NodeFunctionInput)
    * [new NodeFunctionInput(type, name, [count], [qualifier], [isConst])](#new_NodeFunctionInput_new)
    * [.type](#NodeFunctionInput+type) : <code>string</code>
    * [.name](#NodeFunctionInput+name) : <code>string</code>
    * [.count](#NodeFunctionInput+count) : <code>number</code>
    * [.qualifier](#NodeFunctionInput+qualifier) : <code>&#x27;in&#x27;</code> \| <code>&#x27;out&#x27;</code> \| <code>&#x27;inout&#x27;</code>
    * [.isConst](#NodeFunctionInput+isConst) : <code>boolean</code>

<a name="new_NodeFunctionInput_new"></a>

### new NodeFunctionInput(type, name, [count], [qualifier], [isConst])
Constructs a new node function input.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The input type. |
| name | <code>string</code> |  | The input name. |
| [count] | <code>number</code> | <code></code> | If the input is an Array, count will be the length. |
| [qualifier] | <code>&#x27;in&#x27;</code> \| <code>&#x27;out&#x27;</code> \| <code>&#x27;inout&#x27;</code> | <code>&#x27;&#x27;</code> | The parameter qualifier (only relevant for GLSL). |
| [isConst] | <code>boolean</code> | <code>false</code> | Whether the input uses a const qualifier or not (only relevant for GLSL). |

<a name="NodeFunctionInput+type"></a>

### nodeFunctionInput.type : <code>string</code>
The input type.

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
<a name="NodeFunctionInput+name"></a>

### nodeFunctionInput.name : <code>string</code>
The input name.

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
<a name="NodeFunctionInput+count"></a>

### nodeFunctionInput.count : <code>number</code>
If the input is an Array, count will be the length.

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
**Default**: <code>null</code>  
<a name="NodeFunctionInput+qualifier"></a>

### nodeFunctionInput.qualifier : <code>&#x27;in&#x27;</code> \| <code>&#x27;out&#x27;</code> \| <code>&#x27;inout&#x27;</code>
The parameter qualifier (only relevant for GLSL).

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
**Default**: <code>&#x27;&#x27;</code>  
<a name="NodeFunctionInput+isConst"></a>

### nodeFunctionInput.isConst : <code>boolean</code>
Whether the input uses a const qualifier or not (only relevant for GLSL).

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
**Default**: <code>false</code>  
<a name="NodeParser"></a>

## NodeParser
Base class for node parsers. A derived parser must be implemented
for each supported native shader language.

**Kind**: global class  
<a name="NodeParser+parseFunction"></a>

### *nodeParser.parseFunction(source) ⇒ <code>NodeFunction</code>*
The method parses the given native code an returns a node function.

**Kind**: instance abstract method of [<code>NodeParser</code>](#NodeParser)  
**Returns**: <code>NodeFunction</code> - A node function.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The native shader code. |

<a name="NodeUniform"></a>

## NodeUniform
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent the final shader uniforms that are going to be generated
by the builder. A dictionary of node uniforms is maintained in [NodeBuilder#uniforms](NodeBuilder#uniforms)
for this purpose.

**Kind**: global class  

* [NodeUniform](#NodeUniform)
    * [new NodeUniform(name, type, node)](#new_NodeUniform_new)
    * [.isNodeUniform](#NodeUniform+isNodeUniform) : <code>boolean</code>
    * [.name](#NodeUniform+name) : <code>string</code>
    * [.type](#NodeUniform+type) : <code>string</code>
    * [.node](#NodeUniform+node) : <code>UniformNode</code>
    * [.value](#NodeUniform+value) : <code>any</code>
    * [.id](#NodeUniform+id) : <code>number</code>
    * [.groupNode](#NodeUniform+groupNode) : <code>UniformGroupNode</code>

<a name="new_NodeUniform_new"></a>

### new NodeUniform(name, type, node)
Constructs a new node uniform.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the uniform. |
| type | <code>string</code> | The type of the uniform. |
| node | <code>UniformNode</code> | An reference to the node. |

<a name="NodeUniform+isNodeUniform"></a>

### nodeUniform.isNodeUniform : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="NodeUniform+name"></a>

### nodeUniform.name : <code>string</code>
The name of the uniform.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+type"></a>

### nodeUniform.type : <code>string</code>
The type of the uniform.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+node"></a>

### nodeUniform.node : <code>UniformNode</code>
An reference to the node.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+value"></a>

### nodeUniform.value : <code>any</code>
The value of the uniform node.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+id"></a>

### nodeUniform.id : <code>number</code>
The id of the uniform node.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+groupNode"></a>

### nodeUniform.groupNode : <code>UniformGroupNode</code>
The uniform node's group.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
## Functions

<dl>
<dt><a href="#hashString">hashString(str)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a hash for the given string.</p>
</dd>
<dt><a href="#hashArray">hashArray(array)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a hash for the given array.</p>
</dd>
<dt><a href="#hash">hash(...params)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a hash for the given list of parameters.</p>
</dd>
<dt><a href="#getCacheKey">getCacheKey(object, [force])</a> ⇒ <code>number</code></dt>
<dd><p>Computes a cache key for the given node.</p>
</dd>
<dt><a href="#getNodeChildren">getNodeChildren(node, [toJSON])</a></dt>
<dd><p>This generator function can be used to iterate over the node children
of the given object.</p>
</dd>
<dt><a href="#getTypeFromLength">getTypeFromLength(length)</a> ⇒ <code>string</code></dt>
<dd><p>Returns the data type for the given the length.</p>
</dd>
<dt><a href="#getTypedArrayFromType">getTypedArrayFromType(type)</a> ⇒ <code>TypedArray</code></dt>
<dd><p>Returns the typed array for the given data type.</p>
</dd>
<dt><a href="#getLengthFromType">getLengthFromType(type)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the length for the given data type.</p>
</dd>
<dt><a href="#getValueType">getValueType(value)</a> ⇒ <code>string</code></dt>
<dd><p>Returns the data type for the given value.</p>
</dd>
<dt><a href="#getValueFromType">getValueFromType(type, ...params)</a> ⇒ <code>any</code></dt>
<dd><p>Returns the value/object for the given data type and parameters.</p>
</dd>
<dt><a href="#getDataFromObject">getDataFromObject(object)</a> ⇒ <code>Object</code></dt>
<dd><p>Gets the object data that can be shared between different rendering steps.</p>
</dd>
<dt><a href="#arrayBufferToBase64">arrayBufferToBase64(arrayBuffer)</a> ⇒ <code>string</code></dt>
<dd><p>Converts the given array buffer to a Base64 string.</p>
</dd>
<dt><a href="#base64ToArrayBuffer">base64ToArrayBuffer(base64)</a> ⇒ <code>ArrayBuffer</code></dt>
<dd><p>Converts the given Base64 string to an array buffer.</p>
</dd>
</dl>

<a name="hashString"></a>

## hashString(str) ⇒ <code>number</code>
Computes a hash for the given string.

**Kind**: global function  
**Returns**: <code>number</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>string</code> | The string to be hashed. |

<a name="hashArray"></a>

## hashArray(array) ⇒ <code>number</code>
Computes a hash for the given array.

**Kind**: global function  
**Returns**: <code>number</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> | The array to be hashed. |

<a name="hash"></a>

## hash(...params) ⇒ <code>number</code>
Computes a hash for the given list of parameters.

**Kind**: global function  
**Returns**: <code>number</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| ...params | <code>number</code> | A list of parameters. |

<a name="getCacheKey"></a>

## getCacheKey(object, [force]) ⇒ <code>number</code>
Computes a cache key for the given node.

**Kind**: global function  
**Returns**: <code>number</code> - The hash.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object</code> \| <code>Node</code> |  | The object to be hashed. |
| [force] | <code>boolean</code> | <code>false</code> | Whether to force a cache key computation or not. |

<a name="getNodeChildren"></a>

## getNodeChildren(node, [toJSON])
This generator function can be used to iterate over the node children
of the given object.

**Kind**: global function  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Object</code> |  | The object to be hashed. |
| [toJSON] | <code>boolean</code> | <code>false</code> | Whether to return JSON or not. |

<a name="getTypeFromLength"></a>

## getTypeFromLength(length) ⇒ <code>string</code>
Returns the data type for the given the length.

**Kind**: global function  
**Returns**: <code>string</code> - The data type.  

| Param | Type | Description |
| --- | --- | --- |
| length | <code>number</code> | The length. |

<a name="getTypedArrayFromType"></a>

## getTypedArrayFromType(type) ⇒ <code>TypedArray</code>
Returns the typed array for the given data type.

**Kind**: global function  
**Returns**: <code>TypedArray</code> - The typed array.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The data type. |

<a name="getLengthFromType"></a>

## getLengthFromType(type) ⇒ <code>number</code>
Returns the length for the given data type.

**Kind**: global function  
**Returns**: <code>number</code> - The length.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The data type. |

<a name="getValueType"></a>

## getValueType(value) ⇒ <code>string</code>
Returns the data type for the given value.

**Kind**: global function  
**Returns**: <code>string</code> - The data type.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>any</code> | The value. |

<a name="getValueFromType"></a>

## getValueFromType(type, ...params) ⇒ <code>any</code>
Returns the value/object for the given data type and parameters.

**Kind**: global function  
**Returns**: <code>any</code> - The value/object.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The given type. |
| ...params | <code>any</code> | A parameter list. |

<a name="getDataFromObject"></a>

## getDataFromObject(object) ⇒ <code>Object</code>
Gets the object data that can be shared between different rendering steps.

**Kind**: global function  
**Returns**: <code>Object</code> - The object data.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object</code> | The object to get the data for. |

<a name="arrayBufferToBase64"></a>

## arrayBufferToBase64(arrayBuffer) ⇒ <code>string</code>
Converts the given array buffer to a Base64 string.

**Kind**: global function  
**Returns**: <code>string</code> - The Base64 string.  

| Param | Type | Description |
| --- | --- | --- |
| arrayBuffer | <code>ArrayBuffer</code> | The array buffer. |

<a name="base64ToArrayBuffer"></a>

## base64ToArrayBuffer(base64) ⇒ <code>ArrayBuffer</code>
Converts the given Base64 string to an array buffer.

**Kind**: global function  
**Returns**: <code>ArrayBuffer</code> - The array buffer.  

| Param | Type | Description |
| --- | --- | --- |
| base64 | <code>string</code> | The Base64 string. |

<a name="NodeVar"></a>

## NodeVar
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent the final shader variables that are going to be generated
by the builder. A dictionary of node variables is maintained in [NodeBuilder#vars](NodeBuilder#vars) for
this purpose.

**Kind**: global class  

* [NodeVar](#NodeVar)
    * [new NodeVar(name, type, [readOnly], [count])](#new_NodeVar_new)
    * [.isNodeVar](#NodeVar+isNodeVar) : <code>boolean</code>
    * [.name](#NodeVar+name) : <code>string</code>
    * [.type](#NodeVar+type) : <code>string</code>
    * [.readOnly](#NodeVar+readOnly) : <code>boolean</code>
    * [.count](#NodeVar+count) : <code>number</code>

<a name="new_NodeVar_new"></a>

### new NodeVar(name, type, [readOnly], [count])
Constructs a new node variable.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the variable. |
| type | <code>string</code> |  | The type of the variable. |
| [readOnly] | <code>boolean</code> | <code>false</code> | The read-only flag. |
| [count] | <code>number</code> | <code></code> | The size. |

<a name="NodeVar+isNodeVar"></a>

### nodeVar.isNodeVar : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="NodeVar+name"></a>

### nodeVar.name : <code>string</code>
The name of the variable.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
<a name="NodeVar+type"></a>

### nodeVar.type : <code>string</code>
The type of the variable.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
<a name="NodeVar+readOnly"></a>

### nodeVar.readOnly : <code>boolean</code>
The read-only flag.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
<a name="NodeVar+count"></a>

### nodeVar.count : <code>number</code>
The size.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
<a name="NodeVarying"></a>

## NodeVarying ⇐ <code>NodeVar</code>
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent the final shader varyings that are going to be generated
by the builder. An array of node varyings is maintained in [NodeBuilder#varyings](NodeBuilder#varyings) for
this purpose.

**Kind**: global class  
**Extends**: <code>NodeVar</code>  

* [NodeVarying](#NodeVarying) ⇐ <code>NodeVar</code>
    * [new NodeVarying(name, type)](#new_NodeVarying_new)
    * [.needsInterpolation](#NodeVarying+needsInterpolation) : <code>boolean</code>
    * [.isNodeVarying](#NodeVarying+isNodeVarying) : <code>boolean</code>

<a name="new_NodeVarying_new"></a>

### new NodeVarying(name, type)
Constructs a new node varying.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the varying. |
| type | <code>string</code> | The type of the varying. |

<a name="NodeVarying+needsInterpolation"></a>

### nodeVarying.needsInterpolation : <code>boolean</code>
Whether this varying requires interpolation or not. This property can be used
to check if the varying can be optimized for a variable.

**Kind**: instance property of [<code>NodeVarying</code>](#NodeVarying)  
**Default**: <code>false</code>  
<a name="NodeVarying+isNodeVarying"></a>

### nodeVarying.isNodeVarying : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeVarying</code>](#NodeVarying)  
**Default**: <code>true</code>  
**Read only**: true  
## Classes

<dl>
<dt><a href="#OutputStructNode">OutputStructNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used to define multiple outputs in a shader programs.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#outputStruct">outputStruct(...members)</a> ⇒ <code><a href="#OutputStructNode">OutputStructNode</a></code></dt>
<dd><p>TSL function for creating an output struct node.</p>
</dd>
</dl>

<a name="OutputStructNode"></a>

## OutputStructNode ⇐ <code>Node</code>
This node can be used to define multiple outputs in a shader programs.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [OutputStructNode](#OutputStructNode) ⇐ <code>Node</code>
    * [new OutputStructNode(...members)](#new_OutputStructNode_new)
    * [.members](#OutputStructNode+members) : <code>Array.&lt;Node&gt;</code>
    * [.isOutputStructNode](#OutputStructNode+isOutputStructNode) : <code>boolean</code>

<a name="new_OutputStructNode_new"></a>

### new OutputStructNode(...members)
Constructs a new output struct node. The constructor can be invoked with an
arbitrary number of nodes representing the members.


| Param | Type | Description |
| --- | --- | --- |
| ...members | <code>Node</code> | A parameter list of nodes. |

<a name="OutputStructNode+members"></a>

### outputStructNode.members : <code>Array.&lt;Node&gt;</code>
An array of nodes which defines the output.

**Kind**: instance property of [<code>OutputStructNode</code>](#OutputStructNode)  
<a name="OutputStructNode+isOutputStructNode"></a>

### outputStructNode.isOutputStructNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>OutputStructNode</code>](#OutputStructNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="outputStruct"></a>

## outputStruct(...members) ⇒ [<code>OutputStructNode</code>](#OutputStructNode)
TSL function for creating an output struct node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...members | <code>Node</code> | A parameter list of nodes. |

## Classes

<dl>
<dt><a href="#ParameterNode">ParameterNode</a> ⇐ <code>PropertyNode</code></dt>
<dd><p>Special version of <a href="PropertyNode">PropertyNode</a> which is used for parameters.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#parameter">parameter(type, name)</a> ⇒ <code><a href="#ParameterNode">ParameterNode</a></code></dt>
<dd><p>TSL function for creating a parameter node.</p>
</dd>
</dl>

<a name="ParameterNode"></a>

## ParameterNode ⇐ <code>PropertyNode</code>
Special version of [PropertyNode](PropertyNode) which is used for parameters.

**Kind**: global class  
**Extends**: <code>PropertyNode</code>  

* [ParameterNode](#ParameterNode) ⇐ <code>PropertyNode</code>
    * [new ParameterNode(nodeType, [name])](#new_ParameterNode_new)
    * [.isParameterNode](#ParameterNode+isParameterNode) : <code>boolean</code>

<a name="new_ParameterNode_new"></a>

### new ParameterNode(nodeType, [name])
Constructs a new parameter node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> |  | The type of the node. |
| [name] | <code>string</code> | <code>null</code> | The name of the parameter in the shader. |

<a name="ParameterNode+isParameterNode"></a>

### parameterNode.isParameterNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ParameterNode</code>](#ParameterNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="parameter"></a>

## parameter(type, name) ⇒ [<code>ParameterNode</code>](#ParameterNode)
TSL function for creating a parameter node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type of the node. |
| name | <code>string</code> | The name of the parameter in the shader. |

## Classes

<dl>
<dt><a href="#PropertyNode">PropertyNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class represents a shader property. It can be used
to explicitly define a property and assign a value to it.</p>
<pre><code class="language-js">const threshold = property( &#39;float&#39;, &#39;threshold&#39; ).assign( THRESHOLD );
</code></pre>
<p><code>PropertyNode</code> is used by the engine to predefined common material properties
for TSL code.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#diffuseColor">diffuseColor</a> : <code>PropertyNode.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>DiffuseColor</code>.</p>
</dd>
<dt><a href="#emissive">emissive</a> : <code>PropertyNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>EmissiveColor</code>.</p>
</dd>
<dt><a href="#roughness">roughness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Roughness</code>.</p>
</dd>
<dt><a href="#metalness">metalness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Metalness</code>.</p>
</dd>
<dt><a href="#clearcoat">clearcoat</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Clearcoat</code>.</p>
</dd>
<dt><a href="#clearcoatRoughness">clearcoatRoughness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>ClearcoatRoughness</code>.</p>
</dd>
<dt><a href="#sheen">sheen</a> : <code>PropertyNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Sheen</code>.</p>
</dd>
<dt><a href="#sheenRoughness">sheenRoughness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>SheenRoughness</code>.</p>
</dd>
<dt><a href="#iridescence">iridescence</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Iridescence</code>.</p>
</dd>
<dt><a href="#iridescenceIOR">iridescenceIOR</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>IridescenceIOR</code>.</p>
</dd>
<dt><a href="#iridescenceThickness">iridescenceThickness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>IridescenceThickness</code>.</p>
</dd>
<dt><a href="#alphaT">alphaT</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AlphaT</code>.</p>
</dd>
<dt><a href="#anisotropy">anisotropy</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Anisotropy</code>.</p>
</dd>
<dt><a href="#anisotropyT">anisotropyT</a> : <code>PropertyNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AnisotropyT</code>.</p>
</dd>
<dt><a href="#anisotropyB">anisotropyB</a> : <code>PropertyNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AnisotropyB</code>.</p>
</dd>
<dt><a href="#specularColor">specularColor</a> : <code>PropertyNode.&lt;color&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>SpecularColor</code>.</p>
</dd>
<dt><a href="#specularF90">specularF90</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>SpecularF90</code>.</p>
</dd>
<dt><a href="#shininess">shininess</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Shininess</code>.</p>
</dd>
<dt><a href="#output">output</a> : <code>PropertyNode.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Output</code>.</p>
</dd>
<dt><a href="#dashSize">dashSize</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>dashSize</code>.</p>
</dd>
<dt><a href="#gapSize">gapSize</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>gapSize</code>.</p>
</dd>
<dt><a href="#pointWidth">pointWidth</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>pointWidth</code>.</p>
</dd>
<dt><a href="#ior">ior</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>IOR</code>.</p>
</dd>
<dt><a href="#transmission">transmission</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Transmission</code>.</p>
</dd>
<dt><a href="#thickness">thickness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Thickness</code>.</p>
</dd>
<dt><a href="#attenuationDistance">attenuationDistance</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AttenuationDistance</code>.</p>
</dd>
<dt><a href="#attenuationColor">attenuationColor</a> : <code>PropertyNode.&lt;color&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AttenuationColor</code>.</p>
</dd>
<dt><a href="#dispersion">dispersion</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Dispersion</code>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#property">property(type, [name])</a> ⇒ <code><a href="#PropertyNode">PropertyNode</a></code></dt>
<dd><p>TSL function for creating a property node.</p>
</dd>
<dt><a href="#varyingProperty">varyingProperty(type, [name])</a> ⇒ <code><a href="#PropertyNode">PropertyNode</a></code></dt>
<dd><p>TSL function for creating a varying property node.</p>
</dd>
</dl>

<a name="PropertyNode"></a>

## PropertyNode ⇐ <code>Node</code>
This class represents a shader property. It can be used
to explicitly define a property and assign a value to it.

```js
const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );
```
`PropertyNode` is used by the engine to predefined common material properties
for TSL code.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [PropertyNode](#PropertyNode) ⇐ <code>Node</code>
    * [new PropertyNode(nodeType, [name], [varying])](#new_PropertyNode_new)
    * [.name](#PropertyNode+name) : <code>string</code>
    * [.varying](#PropertyNode+varying) : <code>boolean</code>
    * [.isPropertyNode](#PropertyNode+isPropertyNode) : <code>boolean</code>
    * [.isGlobal(builder)](#PropertyNode+isGlobal) ⇒ <code>boolean</code>

<a name="new_PropertyNode_new"></a>

### new PropertyNode(nodeType, [name], [varying])
Constructs a new property node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> |  | The type of the node. |
| [name] | <code>string</code> | <code>null</code> | The name of the property in the shader. |
| [varying] | <code>boolean</code> | <code>false</code> | Whether this property is a varying or not. |

<a name="PropertyNode+name"></a>

### propertyNode.name : <code>string</code>
The name of the property in the shader. If no name is defined,
the node system auto-generates one.

**Kind**: instance property of [<code>PropertyNode</code>](#PropertyNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="PropertyNode+varying"></a>

### propertyNode.varying : <code>boolean</code>
Whether this property is a varying or not.

**Kind**: instance property of [<code>PropertyNode</code>](#PropertyNode)  
**Default**: <code>false</code>  
<a name="PropertyNode+isPropertyNode"></a>

### propertyNode.isPropertyNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PropertyNode</code>](#PropertyNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PropertyNode+isGlobal"></a>

### propertyNode.isGlobal(builder) ⇒ <code>boolean</code>
The method is overwritten so it always returns `true`.

**Kind**: instance method of [<code>PropertyNode</code>](#PropertyNode)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="diffuseColor"></a>

## diffuseColor : <code>PropertyNode.&lt;vec4&gt;</code>
TSL object that represents the shader variable `DiffuseColor`.

**Kind**: global constant  
**Tsl**:   
<a name="emissive"></a>

## emissive : <code>PropertyNode.&lt;vec3&gt;</code>
TSL object that represents the shader variable `EmissiveColor`.

**Kind**: global constant  
**Tsl**:   
<a name="roughness"></a>

## roughness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Roughness`.

**Kind**: global constant  
**Tsl**:   
<a name="metalness"></a>

## metalness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Metalness`.

**Kind**: global constant  
**Tsl**:   
<a name="clearcoat"></a>

## clearcoat : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Clearcoat`.

**Kind**: global constant  
**Tsl**:   
<a name="clearcoatRoughness"></a>

## clearcoatRoughness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `ClearcoatRoughness`.

**Kind**: global constant  
**Tsl**:   
<a name="sheen"></a>

## sheen : <code>PropertyNode.&lt;vec3&gt;</code>
TSL object that represents the shader variable `Sheen`.

**Kind**: global constant  
**Tsl**:   
<a name="sheenRoughness"></a>

## sheenRoughness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `SheenRoughness`.

**Kind**: global constant  
**Tsl**:   
<a name="iridescence"></a>

## iridescence : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Iridescence`.

**Kind**: global constant  
**Tsl**:   
<a name="iridescenceIOR"></a>

## iridescenceIOR : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `IridescenceIOR`.

**Kind**: global constant  
**Tsl**:   
<a name="iridescenceThickness"></a>

## iridescenceThickness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `IridescenceThickness`.

**Kind**: global constant  
**Tsl**:   
<a name="alphaT"></a>

## alphaT : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `AlphaT`.

**Kind**: global constant  
**Tsl**:   
<a name="anisotropy"></a>

## anisotropy : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Anisotropy`.

**Kind**: global constant  
**Tsl**:   
<a name="anisotropyT"></a>

## anisotropyT : <code>PropertyNode.&lt;vec3&gt;</code>
TSL object that represents the shader variable `AnisotropyT`.

**Kind**: global constant  
**Tsl**:   
<a name="anisotropyB"></a>

## anisotropyB : <code>PropertyNode.&lt;vec3&gt;</code>
TSL object that represents the shader variable `AnisotropyB`.

**Kind**: global constant  
**Tsl**:   
<a name="specularColor"></a>

## specularColor : <code>PropertyNode.&lt;color&gt;</code>
TSL object that represents the shader variable `SpecularColor`.

**Kind**: global constant  
**Tsl**:   
<a name="specularF90"></a>

## specularF90 : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `SpecularF90`.

**Kind**: global constant  
**Tsl**:   
<a name="shininess"></a>

## shininess : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Shininess`.

**Kind**: global constant  
**Tsl**:   
<a name="output"></a>

## output : <code>PropertyNode.&lt;vec4&gt;</code>
TSL object that represents the shader variable `Output`.

**Kind**: global constant  
**Tsl**:   
<a name="dashSize"></a>

## dashSize : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `dashSize`.

**Kind**: global constant  
**Tsl**:   
<a name="gapSize"></a>

## gapSize : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `gapSize`.

**Kind**: global constant  
**Tsl**:   
<a name="pointWidth"></a>

## pointWidth : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `pointWidth`.

**Kind**: global constant  
**Tsl**:   
<a name="ior"></a>

## ior : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `IOR`.

**Kind**: global constant  
**Tsl**:   
<a name="transmission"></a>

## transmission : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Transmission`.

**Kind**: global constant  
**Tsl**:   
<a name="thickness"></a>

## thickness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Thickness`.

**Kind**: global constant  
**Tsl**:   
<a name="attenuationDistance"></a>

## attenuationDistance : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `AttenuationDistance`.

**Kind**: global constant  
**Tsl**:   
<a name="attenuationColor"></a>

## attenuationColor : <code>PropertyNode.&lt;color&gt;</code>
TSL object that represents the shader variable `AttenuationColor`.

**Kind**: global constant  
**Tsl**:   
<a name="dispersion"></a>

## dispersion : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Dispersion`.

**Kind**: global constant  
**Tsl**:   
<a name="property"></a>

## property(type, [name]) ⇒ [<code>PropertyNode</code>](#PropertyNode)
TSL function for creating a property node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type of the node. |
| [name] | <code>string</code> | <code>null</code> | The name of the property in the shader. |

<a name="varyingProperty"></a>

## varyingProperty(type, [name]) ⇒ [<code>PropertyNode</code>](#PropertyNode)
TSL function for creating a varying property node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type of the node. |
| [name] | <code>string</code> | <code>null</code> | The name of the varying in the shader. |

## Classes

<dl>
<dt><a href="#StackNode">StackNode</a> ⇐ <code>Node</code></dt>
<dd><p>Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
They are usually needed in cases like <code>If</code>, <code>Else</code>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#stack">stack([parent])</a> ⇒ <code><a href="#StackNode">StackNode</a></code></dt>
<dd><p>TSL function for creating a stack node.</p>
</dd>
</dl>

<a name="StackNode"></a>

## StackNode ⇐ <code>Node</code>
Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
They are usually needed in cases like `If`, `Else`.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [StackNode](#StackNode) ⇐ <code>Node</code>
    * [new StackNode([parent])](#new_StackNode_new)
    * [.nodes](#StackNode+nodes) : <code>Array.&lt;Node&gt;</code>
    * [.outputNode](#StackNode+outputNode) : <code>Node</code>
    * [.parent](#StackNode+parent) : [<code>StackNode</code>](#StackNode)
    * [.isStackNode](#StackNode+isStackNode) : <code>boolean</code>
    * [.add(node)](#StackNode+add) ⇒ [<code>StackNode</code>](#StackNode)
    * [.If(boolNode, method)](#StackNode+If) ⇒ [<code>StackNode</code>](#StackNode)
    * [.ElseIf(boolNode, method)](#StackNode+ElseIf) ⇒ [<code>StackNode</code>](#StackNode)
    * [.Else(method)](#StackNode+Else) ⇒ [<code>StackNode</code>](#StackNode)
    * ~~[.else(...params)](#StackNode+else) ⇒ [<code>StackNode</code>](#StackNode)~~
    * ~~[.elseif(...params)](#StackNode+elseif) ⇒ [<code>StackNode</code>](#StackNode)~~

<a name="new_StackNode_new"></a>

### new StackNode([parent])
Constructs a new stack node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parent] | [<code>StackNode</code>](#StackNode) | <code></code> | The parent stack node. |

<a name="StackNode+nodes"></a>

### stackNode.nodes : <code>Array.&lt;Node&gt;</code>
List of nodes.

**Kind**: instance property of [<code>StackNode</code>](#StackNode)  
<a name="StackNode+outputNode"></a>

### stackNode.outputNode : <code>Node</code>
The output node.

**Kind**: instance property of [<code>StackNode</code>](#StackNode)  
**Default**: <code>null</code>  
<a name="StackNode+parent"></a>

### stackNode.parent : [<code>StackNode</code>](#StackNode)
The parent stack node.

**Kind**: instance property of [<code>StackNode</code>](#StackNode)  
**Default**: <code>null</code>  
<a name="StackNode+isStackNode"></a>

### stackNode.isStackNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StackNode</code>](#StackNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StackNode+add"></a>

### stackNode.add(node) ⇒ [<code>StackNode</code>](#StackNode)
Adds a node to this stack.

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  
**Returns**: [<code>StackNode</code>](#StackNode) - A reference to this stack node.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |

<a name="StackNode+If"></a>

### stackNode.If(boolNode, method) ⇒ [<code>StackNode</code>](#StackNode)
Represent an `if` statement in TSL.

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  
**Returns**: [<code>StackNode</code>](#StackNode) - A reference to this stack node.  

| Param | Type | Description |
| --- | --- | --- |
| boolNode | <code>Node</code> | Represents the condition. |
| method | <code>function</code> | TSL code which is executed if the condition evaluates to `true`. |

<a name="StackNode+ElseIf"></a>

### stackNode.ElseIf(boolNode, method) ⇒ [<code>StackNode</code>](#StackNode)
Represent an `elseif` statement in TSL.

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  
**Returns**: [<code>StackNode</code>](#StackNode) - A reference to this stack node.  

| Param | Type | Description |
| --- | --- | --- |
| boolNode | <code>Node</code> | Represents the condition. |
| method | <code>function</code> | TSL code which is executed if the condition evaluates to `true`. |

<a name="StackNode+Else"></a>

### stackNode.Else(method) ⇒ [<code>StackNode</code>](#StackNode)
Represent an `else` statement in TSL.

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  
**Returns**: [<code>StackNode</code>](#StackNode) - A reference to this stack node.  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | TSL code which is executed in the `else` case. |

<a name="StackNode+else"></a>

### ~~stackNode.else(...params) ⇒ [<code>StackNode</code>](#StackNode)~~
***since r168. Use [Else](#StackNode+Else) instead.***

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="StackNode+elseif"></a>

### ~~stackNode.elseif(...params) ⇒ [<code>StackNode</code>](#StackNode)~~
***since r168. Use [ElseIf](#StackNode+ElseIf) instead.***

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="stack"></a>

## stack([parent]) ⇒ [<code>StackNode</code>](#StackNode)
TSL function for creating a stack node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parent] | [<code>StackNode</code>](#StackNode) | <code></code> | The parent stack node. |

## Classes

<dl>
<dt><a href="#StructNode">StructNode</a> ⇐ <code>Node</code></dt>
<dd><p>StructNode allows to create custom structures with multiple members.
This can also be used to define structures in attribute and uniform data.</p>
<pre><code class="language-js">// Define a custom struct
const BoundingBox = struct( { min: &#39;vec3&#39;, max: &#39;vec3&#39; } );

// Create a new instance of the struct
const bb = BoundingBox( vec3( 0 ), vec3( 1 ) ); // style 1
const bb = BoundingBox( { min: vec3( 0 ), max: vec3( 1 ) } ); // style 2

// Access the struct members
const min = bb.get( &#39;min&#39; );

// Assign a new value to a member
min.assign( vec3() );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#struct">struct(membersLayout, [name])</a> ⇒ <code>function</code></dt>
<dd><p>TSL function for creating a struct node.</p>
</dd>
</dl>

<a name="StructNode"></a>

## StructNode ⇐ <code>Node</code>
StructNode allows to create custom structures with multiple members.
This can also be used to define structures in attribute and uniform data.

```js
// Define a custom struct
const BoundingBox = struct( { min: 'vec3', max: 'vec3' } );

// Create a new instance of the struct
const bb = BoundingBox( vec3( 0 ), vec3( 1 ) ); // style 1
const bb = BoundingBox( { min: vec3( 0 ), max: vec3( 1 ) } ); // style 2

// Access the struct members
const min = bb.get( 'min' );

// Assign a new value to a member
min.assign( vec3() );
```

**Kind**: global class  
**Extends**: <code>Node</code>  
<a name="struct"></a>

## struct(membersLayout, [name]) ⇒ <code>function</code>
TSL function for creating a struct node.

**Kind**: global function  
**Returns**: <code>function</code> - The struct function.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| membersLayout | <code>Object</code> |  | The layout of the struct members. |
| [name] | <code>string</code> | <code>null</code> | The name of the struct. |

## Classes

<dl>
<dt><a href="#StructTypeNode">StructTypeNode</a> ⇐ <code>Node</code></dt>
<dd><p>Represents a struct type node in the node-based system.
This class is used to define and manage the layout and types of struct members.
It extends the base Node class and provides methods to get the length of the struct,
retrieve member types, and generate the struct type for a builder.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#getMembersLayout">getMembersLayout(members)</a> ⇒ <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code></dt>
<dd><p>Generates a layout for struct members.
This function takes an object representing struct members and returns an array of member layouts.
Each member layout includes the member&#39;s name, type, and whether it is atomic.</p>
</dd>
</dl>

<a name="StructTypeNode"></a>

## StructTypeNode ⇐ <code>Node</code>
Represents a struct type node in the node-based system.
This class is used to define and manage the layout and types of struct members.
It extends the base Node class and provides methods to get the length of the struct,
retrieve member types, and generate the struct type for a builder.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [StructTypeNode](#StructTypeNode) ⇐ <code>Node</code>
    * [new StructTypeNode(membersLayout, [name])](#new_StructTypeNode_new)
    * [.membersLayout](#StructTypeNode+membersLayout) : <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code>
    * [.name](#StructTypeNode+name) : <code>string</code>
    * [.isStructLayoutNode](#StructTypeNode+isStructLayoutNode) : <code>boolean</code>
    * [.getLength()](#StructTypeNode+getLength) ⇒ <code>number</code>

<a name="new_StructTypeNode_new"></a>

### new StructTypeNode(membersLayout, [name])
Creates an instance of StructTypeNode.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| membersLayout | <code>Object</code> |  | The layout of the members for the struct. |
| [name] | <code>string</code> | <code>null</code> | The optional name of the struct. |

<a name="StructTypeNode+membersLayout"></a>

### structTypeNode.membersLayout : <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code>
The layout of the members for the struct

**Kind**: instance property of [<code>StructTypeNode</code>](#StructTypeNode)  
<a name="StructTypeNode+name"></a>

### structTypeNode.name : <code>string</code>
The name of the struct.

**Kind**: instance property of [<code>StructTypeNode</code>](#StructTypeNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="StructTypeNode+isStructLayoutNode"></a>

### structTypeNode.isStructLayoutNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StructTypeNode</code>](#StructTypeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StructTypeNode+getLength"></a>

### structTypeNode.getLength() ⇒ <code>number</code>
Returns the length of the struct.
The length is calculated by summing the lengths of the struct's members.

**Kind**: instance method of [<code>StructTypeNode</code>](#StructTypeNode)  
**Returns**: <code>number</code> - The length of the struct.  
<a name="getMembersLayout"></a>

## getMembersLayout(members) ⇒ <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code>
Generates a layout for struct members.
This function takes an object representing struct members and returns an array of member layouts.
Each member layout includes the member's name, type, and whether it is atomic.

**Kind**: global function  
**Returns**: <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code> - An array of member layouts.  

| Param | Type | Description |
| --- | --- | --- |
| members | <code>Object.&lt;string, (string\|Object)&gt;</code> | An object where keys are member names and values are either types (as strings) or objects with type and atomic properties. |

<a name="TempNode"></a>

## TempNode ⇐ <code>Node</code>
This module uses cache management to create temporary variables
if the node is used more than once to prevent duplicate calculations.

The class acts as a base class for many other nodes types.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [TempNode](#TempNode) ⇐ <code>Node</code>
    * [new TempNode(nodeType)](#new_TempNode_new)
    * [.isTempNode](#TempNode+isTempNode) : <code>boolean</code>
    * [.hasDependencies(builder)](#TempNode+hasDependencies) ⇒ <code>boolean</code>

<a name="new_TempNode_new"></a>

### new TempNode(nodeType)
Constructs a temp node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> | <code>null</code> | The node type. |

<a name="TempNode+isTempNode"></a>

### tempNode.isTempNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>TempNode</code>](#TempNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TempNode+hasDependencies"></a>

### tempNode.hasDependencies(builder) ⇒ <code>boolean</code>
Whether this node is used more than once in context of other nodes.

**Kind**: instance method of [<code>TempNode</code>](#TempNode)  
**Returns**: <code>boolean</code> - A flag that indicates if there is more than one dependency to other nodes.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The node builder. |

## Classes

<dl>
<dt><a href="#UniformGroupNode">UniformGroupNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used to group single instances of <a href="UniformNode">UniformNode</a>
and manage them as a uniform buffer.</p>
<p>In most cases, the predefined nodes <code>objectGroup</code>, <code>renderGroup</code> and <code>frameGroup</code>
will be used when defining the <a href="UniformNode#groupNode">UniformNode#groupNode</a> property.</p>
<ul>
<li><code>objectGroup</code>: Uniform buffer per object.</li>
<li><code>renderGroup</code>: Shared uniform buffer, updated once per render call.</li>
<li><code>frameGroup</code>: Shared uniform buffer, updated once per frame.</li>
</ul>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#frameGroup">frameGroup</a> : <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL object that represents a shared uniform group node which is updated once per frame.</p>
</dd>
<dt><a href="#renderGroup">renderGroup</a> : <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL object that represents a shared uniform group node which is updated once per render.</p>
</dd>
<dt><a href="#objectGroup">objectGroup</a> : <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL object that represents a uniform group node which is updated once per object.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#uniformGroup">uniformGroup(name)</a> ⇒ <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL function for creating a uniform group node with the given name.</p>
</dd>
<dt><a href="#sharedUniformGroup">sharedUniformGroup(name, [order])</a> ⇒ <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL function for creating a shared uniform group node with the given name and order.</p>
</dd>
</dl>

<a name="UniformGroupNode"></a>

## UniformGroupNode ⇐ <code>Node</code>
This node can be used to group single instances of [UniformNode](UniformNode)
and manage them as a uniform buffer.

In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`
will be used when defining the [UniformNode#groupNode](UniformNode#groupNode) property.

- `objectGroup`: Uniform buffer per object.
- `renderGroup`: Shared uniform buffer, updated once per render call.
- `frameGroup`: Shared uniform buffer, updated once per frame.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [UniformGroupNode](#UniformGroupNode) ⇐ <code>Node</code>
    * [new UniformGroupNode(name, [shared], [order])](#new_UniformGroupNode_new)
    * [.name](#UniformGroupNode+name) : <code>string</code>
    * [.shared](#UniformGroupNode+shared) : <code>boolean</code>
    * [.order](#UniformGroupNode+order) : <code>number</code>
    * [.isUniformGroup](#UniformGroupNode+isUniformGroup) : <code>boolean</code>

<a name="new_UniformGroupNode_new"></a>

### new UniformGroupNode(name, [shared], [order])
Constructs a new uniform group node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the uniform group node. |
| [shared] | <code>boolean</code> | <code>false</code> | Whether this uniform group node is shared or not. |
| [order] | <code>number</code> | <code>1</code> | Influences the internal sorting. |

<a name="UniformGroupNode+name"></a>

### uniformGroupNode.name : <code>string</code>
The name of the uniform group node.

**Kind**: instance property of [<code>UniformGroupNode</code>](#UniformGroupNode)  
<a name="UniformGroupNode+shared"></a>

### uniformGroupNode.shared : <code>boolean</code>
Whether this uniform group node is shared or not.

**Kind**: instance property of [<code>UniformGroupNode</code>](#UniformGroupNode)  
**Default**: <code>false</code>  
<a name="UniformGroupNode+order"></a>

### uniformGroupNode.order : <code>number</code>
Influences the internal sorting.
TODO: Add details when this property should be changed.

**Kind**: instance property of [<code>UniformGroupNode</code>](#UniformGroupNode)  
**Default**: <code>1</code>  
<a name="UniformGroupNode+isUniformGroup"></a>

### uniformGroupNode.isUniformGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformGroupNode</code>](#UniformGroupNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="frameGroup"></a>

## frameGroup : [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL object that represents a shared uniform group node which is updated once per frame.

**Kind**: global constant  
**Tsl**:   
<a name="renderGroup"></a>

## renderGroup : [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL object that represents a shared uniform group node which is updated once per render.

**Kind**: global constant  
**Tsl**:   
<a name="objectGroup"></a>

## objectGroup : [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL object that represents a uniform group node which is updated once per object.

**Kind**: global constant  
**Tsl**:   
<a name="uniformGroup"></a>

## uniformGroup(name) ⇒ [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL function for creating a uniform group node with the given name.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the uniform group node. |

<a name="sharedUniformGroup"></a>

## sharedUniformGroup(name, [order]) ⇒ [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL function for creating a shared uniform group node with the given name and order.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the uniform group node. |
| [order] | <code>number</code> | <code>0</code> | Influences the internal sorting. |

## Classes

<dl>
<dt><a href="#UniformNode">UniformNode</a> ⇐ <code>InputNode</code></dt>
<dd><p>Class for representing a uniform.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#uniform">uniform(arg1, [arg2])</a> ⇒ <code><a href="#UniformNode">UniformNode</a></code></dt>
<dd><p>TSL function for creating a uniform node.</p>
</dd>
</dl>

<a name="UniformNode"></a>

## UniformNode ⇐ <code>InputNode</code>
Class for representing a uniform.

**Kind**: global class  
**Extends**: <code>InputNode</code>  

* [UniformNode](#UniformNode) ⇐ <code>InputNode</code>
    * [new UniformNode(value, nodeType)](#new_UniformNode_new)
    * [.isUniformNode](#UniformNode+isUniformNode) : <code>boolean</code>
    * [.name](#UniformNode+name) : <code>string</code>
    * [.groupNode](#UniformNode+groupNode) : <code>UniformGroupNode</code>
    * [.label(name)](#UniformNode+label) ⇒ [<code>UniformNode</code>](#UniformNode)
    * [.setGroup(group)](#UniformNode+setGroup) ⇒ [<code>UniformNode</code>](#UniformNode)
    * [.getGroup()](#UniformNode+getGroup) ⇒ <code>UniformGroupNode</code>
    * [.getUniformHash(builder)](#UniformNode+getUniformHash) ⇒ <code>string</code>

<a name="new_UniformNode_new"></a>

### new UniformNode(value, nodeType)
Constructs a new uniform node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>any</code> |  | The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture). |
| nodeType | <code>string</code> | <code>null</code> | The node type. If no explicit type is defined, the node tries to derive the type from its value. |

<a name="UniformNode+isUniformNode"></a>

### uniformNode.isUniformNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformNode</code>](#UniformNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="UniformNode+name"></a>

### uniformNode.name : <code>string</code>
The name or label of the uniform.

**Kind**: instance property of [<code>UniformNode</code>](#UniformNode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="UniformNode+groupNode"></a>

### uniformNode.groupNode : <code>UniformGroupNode</code>
The uniform group of this uniform. By default, uniforms are
managed per object but they might belong to a shared group
which is updated per frame or render call.

**Kind**: instance property of [<code>UniformNode</code>](#UniformNode)  
<a name="UniformNode+label"></a>

### uniformNode.label(name) ⇒ [<code>UniformNode</code>](#UniformNode)
Sets the [name](#UniformNode+name) property.

**Kind**: instance method of [<code>UniformNode</code>](#UniformNode)  
**Returns**: [<code>UniformNode</code>](#UniformNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the uniform. |

<a name="UniformNode+setGroup"></a>

### uniformNode.setGroup(group) ⇒ [<code>UniformNode</code>](#UniformNode)
Sets the [groupNode](#UniformNode+groupNode) property.

**Kind**: instance method of [<code>UniformNode</code>](#UniformNode)  
**Returns**: [<code>UniformNode</code>](#UniformNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| group | <code>UniformGroupNode</code> | The uniform group. |

<a name="UniformNode+getGroup"></a>

### uniformNode.getGroup() ⇒ <code>UniformGroupNode</code>
Returns the [groupNode](#UniformNode+groupNode).

**Kind**: instance method of [<code>UniformNode</code>](#UniformNode)  
**Returns**: <code>UniformGroupNode</code> - The uniform group.  
<a name="UniformNode+getUniformHash"></a>

### uniformNode.getUniformHash(builder) ⇒ <code>string</code>
By default, this method returns the result of [Node#getHash](Node#getHash) but derived
classes might overwrite this method with a different implementation.

**Kind**: instance method of [<code>UniformNode</code>](#UniformNode)  
**Returns**: <code>string</code> - The uniform hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="uniform"></a>

## uniform(arg1, [arg2]) ⇒ [<code>UniformNode</code>](#UniformNode)
TSL function for creating a uniform node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| arg1 | <code>any</code> | The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture). |
| [arg2] | <code>string</code> | The node type. If no explicit type is defined, the node tries to derive the type from its value. |

## Classes

<dl>
<dt><a href="#VarNode">VarNode</a> ⇐ <code>Node</code></dt>
<dd><p>Class for representing shader variables as nodes. Variables are created from
existing nodes like the following:</p>
<pre><code class="language-js">const depth = sampleDepth( uvNode ).toVar( &#39;depth&#39; );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#createVar">createVar(node, name)</a> ⇒ <code><a href="#VarNode">VarNode</a></code></dt>
<dd><p>TSL function for creating a var node.</p>
</dd>
<dt><a href="#Var">Var(node, name)</a> ⇒ <code><a href="#VarNode">VarNode</a></code></dt>
<dd><p>TSL function for creating a var node.</p>
</dd>
<dt><a href="#Const">Const(node, name)</a> ⇒ <code><a href="#VarNode">VarNode</a></code></dt>
<dd><p>TSL function for creating a const node.</p>
</dd>
<dt><del><a href="#temp">temp(node)</a> ⇒ <code><a href="#VarNode">VarNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="VarNode"></a>

## VarNode ⇐ <code>Node</code>
Class for representing shader variables as nodes. Variables are created from
existing nodes like the following:

```js
const depth = sampleDepth( uvNode ).toVar( 'depth' );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [VarNode](#VarNode) ⇐ <code>Node</code>
    * [new VarNode(node, [name], [readOnly])](#new_VarNode_new)
    * [.node](#VarNode+node) : <code>Node</code>
    * [.name](#VarNode+name) : <code>string</code>
    * [.global](#VarNode+global) : <code>boolean</code>
    * [.isVarNode](#VarNode+isVarNode) : <code>boolean</code>
    * [.readOnly](#VarNode+readOnly) : <code>boolean</code>

<a name="new_VarNode_new"></a>

### new VarNode(node, [name], [readOnly])
Constructs a new variable node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node for which a variable should be created. |
| [name] | <code>string</code> | <code>null</code> | The name of the variable in the shader. |
| [readOnly] | <code>boolean</code> | <code>false</code> | The read-only flag. |

<a name="VarNode+node"></a>

### varNode.node : <code>Node</code>
The node for which a variable should be created.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
<a name="VarNode+name"></a>

### varNode.name : <code>string</code>
The name of the variable in the shader. If no name is defined,
the node system auto-generates one.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="VarNode+global"></a>

### varNode.global : <code>boolean</code>
`VarNode` sets this property to `true` by default.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
**Default**: <code>true</code>  
<a name="VarNode+isVarNode"></a>

### varNode.isVarNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VarNode+readOnly"></a>

### varNode.readOnly : <code>boolean</code>
The read-only flag.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
**Default**: <code>false</code>  
<a name="createVar"></a>

## createVar(node, name) ⇒ [<code>VarNode</code>](#VarNode)
TSL function for creating a var node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node for which a variable should be created. |
| name | <code>string</code> | The name of the variable in the shader. |

<a name="Var"></a>

## Var(node, name) ⇒ [<code>VarNode</code>](#VarNode)
TSL function for creating a var node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node for which a variable should be created. |
| name | <code>string</code> | The name of the variable in the shader. |

<a name="Const"></a>

## Const(node, name) ⇒ [<code>VarNode</code>](#VarNode)
TSL function for creating a const node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node for which a constant should be created. |
| name | <code>string</code> | The name of the constant in the shader. |

<a name="temp"></a>

## ~~temp(node) ⇒ [<code>VarNode</code>](#VarNode)~~
***since r170. Use `Var( node )` or `node.toVar()` instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| node | <code>any</code> | 

## Classes

<dl>
<dt><a href="#VaryingNode">VaryingNode</a> ⇐ <code>Node</code></dt>
<dd><p>Class for representing shader varyings as nodes. Varyings are create from
existing nodes like the following:</p>
<pre><code class="language-js">const positionLocal = positionGeometry.toVarying( &#39;vPositionLocal&#39; );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#varying">varying(node, name)</a> ⇒ <code><a href="#VaryingNode">VaryingNode</a></code></dt>
<dd><p>TSL function for creating a varying node.</p>
</dd>
<dt><a href="#vertexStage">vertexStage(node)</a> ⇒ <code><a href="#VaryingNode">VaryingNode</a></code></dt>
<dd><p>Computes a node in the vertex stage.</p>
</dd>
</dl>

<a name="VaryingNode"></a>

## VaryingNode ⇐ <code>Node</code>
Class for representing shader varyings as nodes. Varyings are create from
existing nodes like the following:

```js
const positionLocal = positionGeometry.toVarying( 'vPositionLocal' );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [VaryingNode](#VaryingNode) ⇐ <code>Node</code>
    * [new VaryingNode(node, name)](#new_VaryingNode_new)
    * [.node](#VaryingNode+node) : <code>Node</code>
    * [.name](#VaryingNode+name) : <code>string</code>
    * [.isVaryingNode](#VaryingNode+isVaryingNode) : <code>boolean</code>
    * [.isGlobal(builder)](#VaryingNode+isGlobal) ⇒ <code>boolean</code>
    * [.setupVarying(builder)](#VaryingNode+setupVarying) ⇒ <code>NodeVarying</code>

<a name="new_VaryingNode_new"></a>

### new VaryingNode(node, name)
Constructs a new varying node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node for which a varying should be created. |
| name | <code>string</code> | <code>null</code> | The name of the varying in the shader. |

<a name="VaryingNode+node"></a>

### varyingNode.node : <code>Node</code>
The node for which a varying should be created.

**Kind**: instance property of [<code>VaryingNode</code>](#VaryingNode)  
<a name="VaryingNode+name"></a>

### varyingNode.name : <code>string</code>
The name of the varying in the shader. If no name is defined,
the node system auto-generates one.

**Kind**: instance property of [<code>VaryingNode</code>](#VaryingNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="VaryingNode+isVaryingNode"></a>

### varyingNode.isVaryingNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VaryingNode</code>](#VaryingNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VaryingNode+isGlobal"></a>

### varyingNode.isGlobal(builder) ⇒ <code>boolean</code>
The method is overwritten so it always returns `true`.

**Kind**: instance method of [<code>VaryingNode</code>](#VaryingNode)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="VaryingNode+setupVarying"></a>

### varyingNode.setupVarying(builder) ⇒ <code>NodeVarying</code>
This method performs the setup of a varying node with the current node builder.

**Kind**: instance method of [<code>VaryingNode</code>](#VaryingNode)  
**Returns**: <code>NodeVarying</code> - The node varying from the node builder.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="varying"></a>

## varying(node, name) ⇒ [<code>VaryingNode</code>](#VaryingNode)
TSL function for creating a varying node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node for which a varying should be created. |
| name | <code>string</code> | The name of the varying in the shader. |

<a name="vertexStage"></a>

## vertexStage(node) ⇒ [<code>VaryingNode</code>](#VaryingNode)
Computes a node in the vertex stage.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node which should be executed in the vertex stage. |

## Constants

<dl>
<dt><a href="#NodeShaderStage">NodeShaderStage</a></dt>
<dd><p>Possible shader stages.</p>
</dd>
<dt><a href="#NodeUpdateType">NodeUpdateType</a></dt>
<dd><p>Update types of a node.</p>
</dd>
<dt><a href="#NodeType">NodeType</a></dt>
<dd><p>Data types of a node.</p>
</dd>
<dt><a href="#NodeAccess">NodeAccess</a></dt>
<dd><p>Access types of a node. These are relevant for compute and storage usage.</p>
</dd>
</dl>

<a name="NodeShaderStage"></a>

## NodeShaderStage
Possible shader stages.

**Kind**: global constant  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| VERTEX | <code>string</code> | The vertex shader stage. |
| FRAGMENT | <code>string</code> | The fragment shader stage. |

<a name="NodeUpdateType"></a>

## NodeUpdateType
Update types of a node.

**Kind**: global constant  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| NONE | <code>string</code> | The update method is not executed. |
| FRAME | <code>string</code> | The update method is executed per frame. |
| RENDER | <code>string</code> | The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME. |
| OBJECT | <code>string</code> | The update method is executed per [Object3D](Object3D) that uses the node for rendering. |

<a name="NodeType"></a>

## NodeType
Data types of a node.

**Kind**: global constant  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| BOOLEAN | <code>string</code> | Boolean type. |
| INTEGER | <code>string</code> | Integer type. |
| FLOAT | <code>string</code> | Float type. |
| VECTOR2 | <code>string</code> | Two-dimensional vector type. |
| VECTOR3 | <code>string</code> | Three-dimensional vector type. |
| VECTOR4 | <code>string</code> | Four-dimensional vector type. |
| MATRIX2 | <code>string</code> | 2x2 matrix type. |
| MATRIX3 | <code>string</code> | 3x3 matrix type. |
| MATRIX4 | <code>string</code> | 4x4 matrix type. |

<a name="NodeAccess"></a>

## NodeAccess
Access types of a node. These are relevant for compute and storage usage.

**Kind**: global constant  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| READ_ONLY | <code>string</code> | Read-only access |
| WRITE_ONLY | <code>string</code> | Write-only access. |
| READ_WRITE | <code>string</code> | Read and write access. |

## Functions

<dl>
<dt><a href="#blendBurn">blendBurn(base, blend)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Represents a &quot;Color Burn&quot; blend mode.</p>
<p>It&#39;s designed to darken the base layer&#39;s colors based on the color of the blend layer.
It significantly increases the contrast of the base layer, making the colors more vibrant and saturated.
The darker the color in the blend layer, the stronger the darkening and contrast effect on the base layer.</p>
</dd>
<dt><a href="#blendDodge">blendDodge(base, blend)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Represents a &quot;Color Dodge&quot; blend mode.</p>
<p>It&#39;s designed to lighten the base layer&#39;s colors based on the color of the blend layer.
It significantly increases the brightness of the base layer, making the colors lighter and more vibrant.
The brighter the color in the blend layer, the stronger the lightening and contrast effect on the base layer.</p>
</dd>
<dt><a href="#blendScreen">blendScreen(base, blend)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Represents a &quot;Screen&quot; blend mode.</p>
<p>Similar to <code>blendDodge()</code>, this mode also lightens the base layer&#39;s colors based on the color of the blend layer.
The &quot;Screen&quot; blend mode is better for general brightening whereas the &quot;Dodge&quot; results in more subtle and nuanced
effects.</p>
</dd>
<dt><a href="#blendOverlay">blendOverlay(base, blend)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Represents a &quot;Overlay&quot; blend mode.</p>
<p>It&#39;s designed to increase the contrast of the base layer based on the color of the blend layer.
It amplifies the existing colors and contrast in the base layer, making lighter areas lighter and darker areas darker.
The color of the blend layer significantly influences the resulting contrast and color shift in the base layer.</p>
</dd>
<dt><a href="#blendColor">blendColor(base, blend)</a> ⇒ <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>This function blends two color based on their alpha values by replicating the behavior of <code>THREE.NormalBlending</code>.
It assumes both input colors have non-premultiplied alpha.</p>
</dd>
<dt><del><a href="#burn">burn(...params)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
<dt><del><a href="#dodge">dodge(...params)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
<dt><del><a href="#screen">screen(...params)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
<dt><del><a href="#overlay">overlay(...params)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
</dl>

<a name="blendBurn"></a>

## blendBurn(base, blend) ⇒ <code>Node.&lt;vec3&gt;</code>
Represents a "Color Burn" blend mode.

It's designed to darken the base layer's colors based on the color of the blend layer.
It significantly increases the contrast of the base layer, making the colors more vibrant and saturated.
The darker the color in the blend layer, the stronger the darkening and contrast effect on the base layer.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec3&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec3&gt;</code> | The blend color. A white (#ffffff) blend color does not alter the base color. |

<a name="blendDodge"></a>

## blendDodge(base, blend) ⇒ <code>Node.&lt;vec3&gt;</code>
Represents a "Color Dodge" blend mode.

It's designed to lighten the base layer's colors based on the color of the blend layer.
It significantly increases the brightness of the base layer, making the colors lighter and more vibrant.
The brighter the color in the blend layer, the stronger the lightening and contrast effect on the base layer.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec3&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec3&gt;</code> | The blend color. A black (#000000) blend color does not alter the base color. |

<a name="blendScreen"></a>

## blendScreen(base, blend) ⇒ <code>Node.&lt;vec3&gt;</code>
Represents a "Screen" blend mode.

Similar to `blendDodge()`, this mode also lightens the base layer's colors based on the color of the blend layer.
The "Screen" blend mode is better for general brightening whereas the "Dodge" results in more subtle and nuanced
effects.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec3&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec3&gt;</code> | The blend color. A black (#000000) blend color does not alter the base color. |

<a name="blendOverlay"></a>

## blendOverlay(base, blend) ⇒ <code>Node.&lt;vec3&gt;</code>
Represents a "Overlay" blend mode.

It's designed to increase the contrast of the base layer based on the color of the blend layer.
It amplifies the existing colors and contrast in the base layer, making lighter areas lighter and darker areas darker.
The color of the blend layer significantly influences the resulting contrast and color shift in the base layer.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec3&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec3&gt;</code> | The blend color |

<a name="blendColor"></a>

## blendColor(base, blend) ⇒ <code>Node.&lt;vec4&gt;</code>
This function blends two color based on their alpha values by replicating the behavior of `THREE.NormalBlending`.
It assumes both input colors have non-premultiplied alpha.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec4&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec4&gt;</code> | The blend color |

<a name="burn"></a>

## ~~burn(...params) ⇒ <code>function</code>~~
***since r171. Use [blendBurn](#blendBurn) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="dodge"></a>

## ~~dodge(...params) ⇒ <code>function</code>~~
***since r171. Use [blendDodge](#blendDodge) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="screen"></a>

## ~~screen(...params) ⇒ <code>function</code>~~
***since r171. Use [blendScreen](#blendScreen) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="overlay"></a>

## ~~overlay(...params) ⇒ <code>function</code>~~
***since r171. Use [blendOverlay](#blendOverlay) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

## Classes

<dl>
<dt><a href="#BumpMapNode">BumpMapNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This class can be used for applying bump maps to materials.</p>
<pre><code class="language-js">material.normalNode = bumpMap( texture( bumpTex ) );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bumpMap">bumpMap(textureNode, [scaleNode])</a> ⇒ <code><a href="#BumpMapNode">BumpMapNode</a></code></dt>
<dd><p>TSL function for creating a bump map node.</p>
</dd>
</dl>

<a name="BumpMapNode"></a>

## BumpMapNode ⇐ <code>TempNode</code>
This class can be used for applying bump maps to materials.

```js
material.normalNode = bumpMap( texture( bumpTex ) );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [BumpMapNode](#BumpMapNode) ⇐ <code>TempNode</code>
    * [new BumpMapNode(textureNode, [scaleNode])](#new_BumpMapNode_new)
    * [.textureNode](#BumpMapNode+textureNode) : <code>Node.&lt;float&gt;</code>
    * [.scaleNode](#BumpMapNode+scaleNode) : <code>Node.&lt;float&gt;</code>

<a name="new_BumpMapNode_new"></a>

### new BumpMapNode(textureNode, [scaleNode])
Constructs a new bump map node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>Node.&lt;float&gt;</code> |  | Represents the bump map data. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code></code> | Controls the intensity of the bump effect. |

<a name="BumpMapNode+textureNode"></a>

### bumpMapNode.textureNode : <code>Node.&lt;float&gt;</code>
Represents the bump map data.

**Kind**: instance property of [<code>BumpMapNode</code>](#BumpMapNode)  
<a name="BumpMapNode+scaleNode"></a>

### bumpMapNode.scaleNode : <code>Node.&lt;float&gt;</code>
Controls the intensity of the bump effect.

**Kind**: instance property of [<code>BumpMapNode</code>](#BumpMapNode)  
**Default**: <code>null</code>  
<a name="bumpMap"></a>

## bumpMap(textureNode, [scaleNode]) ⇒ [<code>BumpMapNode</code>](#BumpMapNode)
TSL function for creating a bump map node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>Node.&lt;float&gt;</code> |  | Represents the bump map data. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code></code> | Controls the intensity of the bump effect. |

## Functions

<dl>
<dt><a href="#grayscale">grayscale(color)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Computes a grayscale value for the given RGB color value.</p>
</dd>
<dt><a href="#saturation">saturation(color, [adjustment])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Super-saturates or desaturates the given RGB color.</p>
</dd>
<dt><a href="#vibrance">vibrance(color, [adjustment])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Selectively enhance the intensity of less saturated RGB colors. Can result
in a more natural and visually appealing image with enhanced color depth
compared to <a href="ColorAdjustment#saturation">ColorAdjustment#saturation</a>.</p>
</dd>
<dt><a href="#hue">hue(color, [adjustment])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Updates the hue component of the given RGB color while preserving its luminance and saturation.</p>
</dd>
<dt><a href="#luminance">luminance(color, luminanceCoefficients)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Computes the luminance for the given RGB color value.</p>
</dd>
<dt><a href="#cdl">cdl(color, slope, offset, power, saturation, luminanceCoefficients)</a> ⇒ <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>Color Decision List (CDL) v1.2</p>
<p>Compact representation of color grading information, defined by slope, offset, power, and
saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
or AgX Log), and will return output in the same space. Output may require clamping &gt;=0.</p>
</dd>
</dl>

<a name="grayscale"></a>

## grayscale(color) ⇒ <code>Node.&lt;vec3&gt;</code>
Computes a grayscale value for the given RGB color value.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The grayscale color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color value to compute the grayscale for. |

<a name="saturation"></a>

## saturation(color, [adjustment]) ⇒ <code>Node.&lt;vec3&gt;</code>
Super-saturates or desaturates the given RGB color.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The saturated color.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> |  | The input color. |
| [adjustment] | <code>Node.&lt;float&gt;</code> | <code>1</code> | Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it. |

<a name="vibrance"></a>

## vibrance(color, [adjustment]) ⇒ <code>Node.&lt;vec3&gt;</code>
Selectively enhance the intensity of less saturated RGB colors. Can result
in a more natural and visually appealing image with enhanced color depth
compared to [ColorAdjustment#saturation](ColorAdjustment#saturation).

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The updated color.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> |  | The input color. |
| [adjustment] | <code>Node.&lt;float&gt;</code> | <code>1</code> | Controls the intensity of the vibrance effect. |

<a name="hue"></a>

## hue(color, [adjustment]) ⇒ <code>Node.&lt;vec3&gt;</code>
Updates the hue component of the given RGB color while preserving its luminance and saturation.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The updated color.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> |  | The input color. |
| [adjustment] | <code>Node.&lt;float&gt;</code> | <code>1</code> | Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise. |

<a name="luminance"></a>

## luminance(color, luminanceCoefficients) ⇒ <code>Node.&lt;vec3&gt;</code>
Computes the luminance for the given RGB color value.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The luminance.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color value to compute the luminance for. |
| luminanceCoefficients | <code>Node.&lt;vec3&gt;</code> | The luminance coefficients. By default predefined values of the current working color space are used. |

<a name="cdl"></a>

## cdl(color, slope, offset, power, saturation, luminanceCoefficients) ⇒ <code>Node.&lt;vec4&gt;</code>
Color Decision List (CDL) v1.2

Compact representation of color grading information, defined by slope, offset, power, and
saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
or AgX Log), and will return output in the same space. Output may require clamping >=0.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - Output, -Infinity < output < +Infinity

References:
- ASC CDL v1.2
- [https://blender.stackexchange.com/a/55239/43930](https://blender.stackexchange.com/a/55239/43930)
- [https://docs.acescentral.com/specifications/acescc/](https://docs.acescentral.com/specifications/acescc/)  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec4&gt;</code> | Input (-Infinity < input < +Infinity) |
| slope | <code>Node.&lt;vec3&gt;</code> | Slope (0 ≤ slope < +Infinity) |
| offset | <code>Node.&lt;vec3&gt;</code> | Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1) |
| power | <code>Node.&lt;vec3&gt;</code> | Power (0 < power < +Infinity) |
| saturation | <code>Node.&lt;float&gt;</code> | Saturation (0 ≤ saturation < +Infinity; typically 0 ≤ saturation < 4) |
| luminanceCoefficients | <code>Node.&lt;vec3&gt;</code> | Luminance coefficients for saturation term, typically Rec. 709 |

## Functions

<dl>
<dt><a href="#sRGBTransferEOTF">sRGBTransferEOTF(color)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Converts the given color value from sRGB to linear-sRGB color space.</p>
</dd>
<dt><a href="#sRGBTransferOETF">sRGBTransferOETF(color)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Converts the given color value from linear-sRGB to sRGB color space.</p>
</dd>
</dl>

<a name="sRGBTransferEOTF"></a>

## sRGBTransferEOTF(color) ⇒ <code>Node.&lt;vec3&gt;</code>
Converts the given color value from sRGB to linear-sRGB color space.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The linear-sRGB color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The sRGB color. |

<a name="sRGBTransferOETF"></a>

## sRGBTransferOETF(color) ⇒ <code>Node.&lt;vec3&gt;</code>
Converts the given color value from linear-sRGB to sRGB color space.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The sRGB color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The linear-sRGB color. |

## Classes

<dl>
<dt><a href="#ColorSpaceNode">ColorSpaceNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents a color space conversion. Meaning it converts
a color value from a source to a target color space.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#toOutputColorSpace">toOutputColorSpace(node)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node to the current output color space.</p>
</dd>
<dt><a href="#toWorkingColorSpace">toWorkingColorSpace(node)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node to the current working color space.</p>
</dd>
<dt><a href="#workingToColorSpace">workingToColorSpace(node, colorSpace)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node from the current working color space to the given color space.</p>
</dd>
<dt><a href="#colorSpaceToWorking">colorSpaceToWorking(node, colorSpace)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node from the given color space to the current working color space.</p>
</dd>
<dt><a href="#convertColorSpace">convertColorSpace(node, sourceColorSpace, targetColorSpace)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node from one color space to another one.</p>
</dd>
</dl>

<a name="ColorSpaceNode"></a>

## ColorSpaceNode ⇐ <code>TempNode</code>
This node represents a color space conversion. Meaning it converts
a color value from a source to a target color space.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [ColorSpaceNode](#ColorSpaceNode) ⇐ <code>TempNode</code>
    * [new ColorSpaceNode(colorNode, source, target)](#new_ColorSpaceNode_new)
    * [.colorNode](#ColorSpaceNode+colorNode) : <code>Node</code>
    * [.source](#ColorSpaceNode+source) : <code>string</code>
    * [.target](#ColorSpaceNode+target) : <code>string</code>
    * [.resolveColorSpace(builder, colorSpace)](#ColorSpaceNode+resolveColorSpace) ⇒ <code>string</code>

<a name="new_ColorSpaceNode_new"></a>

### new ColorSpaceNode(colorNode, source, target)
Constructs a new color space node.


| Param | Type | Description |
| --- | --- | --- |
| colorNode | <code>Node</code> | Represents the color to convert. |
| source | <code>string</code> | The source color space. |
| target | <code>string</code> | The target color space. |

<a name="ColorSpaceNode+colorNode"></a>

### colorSpaceNode.colorNode : <code>Node</code>
Represents the color to convert.

**Kind**: instance property of [<code>ColorSpaceNode</code>](#ColorSpaceNode)  
<a name="ColorSpaceNode+source"></a>

### colorSpaceNode.source : <code>string</code>
The source color space.

**Kind**: instance property of [<code>ColorSpaceNode</code>](#ColorSpaceNode)  
<a name="ColorSpaceNode+target"></a>

### colorSpaceNode.target : <code>string</code>
The target color space.

**Kind**: instance property of [<code>ColorSpaceNode</code>](#ColorSpaceNode)  
<a name="ColorSpaceNode+resolveColorSpace"></a>

### colorSpaceNode.resolveColorSpace(builder, colorSpace) ⇒ <code>string</code>
This method resolves the constants `WORKING_COLOR_SPACE` and
`OUTPUT_COLOR_SPACE` based on the current configuration of the
color management and renderer.

**Kind**: instance method of [<code>ColorSpaceNode</code>](#ColorSpaceNode)  
**Returns**: <code>string</code> - The resolved color space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| colorSpace | <code>string</code> | The color space to resolve. |

<a name="toOutputColorSpace"></a>

## toOutputColorSpace(node) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node to the current output color space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |

<a name="toWorkingColorSpace"></a>

## toWorkingColorSpace(node) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node to the current working color space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |

<a name="workingToColorSpace"></a>

## workingToColorSpace(node, colorSpace) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node from the current working color space to the given color space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |
| colorSpace | <code>string</code> | The target color space. |

<a name="colorSpaceToWorking"></a>

## colorSpaceToWorking(node, colorSpace) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node from the given color space to the current working color space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |
| colorSpace | <code>string</code> | The source color space. |

<a name="convertColorSpace"></a>

## convertColorSpace(node, sourceColorSpace, targetColorSpace) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node from one color space to another one.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |
| sourceColorSpace | <code>string</code> | The source color space. |
| targetColorSpace | <code>string</code> | The target color space. |

## Classes

<dl>
<dt><a href="#FrontFacingNode">FrontFacingNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used to evaluate whether a primitive is front or back facing.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#frontFacing">frontFacing</a> : <code>FrontFacingNode.&lt;bool&gt;</code></dt>
<dd><p>TSL object that represents whether a primitive is front or back facing</p>
</dd>
<dt><a href="#faceDirection">faceDirection</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the front facing status as a number instead of a bool.
<code>1</code> means front facing, <code>-1</code> means back facing.</p>
</dd>
</dl>

<a name="FrontFacingNode"></a>

## FrontFacingNode ⇐ <code>Node</code>
This node can be used to evaluate whether a primitive is front or back facing.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [FrontFacingNode](#FrontFacingNode) ⇐ <code>Node</code>
    * [new FrontFacingNode()](#new_FrontFacingNode_new)
    * [.isFrontFacingNode](#FrontFacingNode+isFrontFacingNode) : <code>boolean</code>

<a name="new_FrontFacingNode_new"></a>

### new FrontFacingNode()
Constructs a new front facing node.

<a name="FrontFacingNode+isFrontFacingNode"></a>

### frontFacingNode.isFrontFacingNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>FrontFacingNode</code>](#FrontFacingNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="frontFacing"></a>

## frontFacing : <code>FrontFacingNode.&lt;bool&gt;</code>
TSL object that represents whether a primitive is front or back facing

**Kind**: global constant  
**Tsl**:   
<a name="faceDirection"></a>

## faceDirection : <code>Node.&lt;float&gt;</code>
TSL object that represents the front facing status as a number instead of a bool.
`1` means front facing, `-1` means back facing.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#NormalMapNode">NormalMapNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This class can be used for applying normals maps to materials.</p>
<pre><code class="language-js">material.normalNode = normalMap( texture( normalTex ) );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#normalMap">normalMap(node, [scaleNode])</a> ⇒ <code><a href="#NormalMapNode">NormalMapNode</a></code></dt>
<dd><p>TSL function for creating a normal map node.</p>
</dd>
</dl>

<a name="NormalMapNode"></a>

## NormalMapNode ⇐ <code>TempNode</code>
This class can be used for applying normals maps to materials.

```js
material.normalNode = normalMap( texture( normalTex ) );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [NormalMapNode](#NormalMapNode) ⇐ <code>TempNode</code>
    * [new NormalMapNode(node, [scaleNode])](#new_NormalMapNode_new)
    * [.node](#NormalMapNode+node) : <code>Node.&lt;vec3&gt;</code>
    * [.scaleNode](#NormalMapNode+scaleNode) : <code>Node.&lt;vec2&gt;</code>
    * [.normalMapType](#NormalMapNode+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>

<a name="new_NormalMapNode_new"></a>

### new NormalMapNode(node, [scaleNode])
Constructs a new normal map node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> |  | Represents the normal map data. |
| [scaleNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | Controls the intensity of the effect. |

<a name="NormalMapNode+node"></a>

### normalMapNode.node : <code>Node.&lt;vec3&gt;</code>
Represents the normal map data.

**Kind**: instance property of [<code>NormalMapNode</code>](#NormalMapNode)  
<a name="NormalMapNode+scaleNode"></a>

### normalMapNode.scaleNode : <code>Node.&lt;vec2&gt;</code>
Controls the intensity of the effect.

**Kind**: instance property of [<code>NormalMapNode</code>](#NormalMapNode)  
**Default**: <code>null</code>  
<a name="NormalMapNode+normalMapType"></a>

### normalMapNode.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The normal map type.

**Kind**: instance property of [<code>NormalMapNode</code>](#NormalMapNode)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="normalMap"></a>

## normalMap(node, [scaleNode]) ⇒ [<code>NormalMapNode</code>](#NormalMapNode)
TSL function for creating a normal map node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> |  | Represents the normal map data. |
| [scaleNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | Controls the intensity of the effect. |

## Classes

<dl>
<dt><a href="#PassTextureNode">PassTextureNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>Represents the texture of a pass node.</p>
</dd>
<dt><a href="#PassMultipleTextureNode">PassMultipleTextureNode</a> ⇐ <code><a href="#PassTextureNode">PassTextureNode</a></code></dt>
<dd><p>An extension of <code>PassTextureNode</code> which allows to manage more than one
internal texture. Relevant for the <code>getPreviousTexture()</code> related API.</p>
</dd>
<dt><a href="#PassNode">PassNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Represents a render pass (sometimes called beauty pass) in context of post processing.
This pass produces a render for the given scene and camera and can provide multiple outputs
via MRT for further processing.</p>
<pre><code class="language-js">const postProcessing = new PostProcessing( renderer );

const scenePass = pass( scene, camera );

postProcessing.outputNode = scenePass;
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#pass">pass(scene, camera, options)</a> ⇒ <code><a href="#PassNode">PassNode</a></code></dt>
<dd><p>TSL function for creating a pass node.</p>
</dd>
<dt><a href="#passTexture">passTexture(pass, texture)</a> ⇒ <code><a href="#PassTextureNode">PassTextureNode</a></code></dt>
<dd><p>TSL function for creating a pass texture node.</p>
</dd>
<dt><a href="#depthPass">depthPass(scene, camera, options)</a> ⇒ <code><a href="#PassNode">PassNode</a></code></dt>
<dd><p>TSL function for creating a depth pass node.</p>
</dd>
</dl>

<a name="PassTextureNode"></a>

## PassTextureNode ⇐ <code>TextureNode</code>
Represents the texture of a pass node.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [PassTextureNode](#PassTextureNode) ⇐ <code>TextureNode</code>
    * [new PassTextureNode(passNode, texture)](#new_PassTextureNode_new)
    * [.passNode](#PassTextureNode+passNode) : [<code>PassNode</code>](#PassNode)

<a name="new_PassTextureNode_new"></a>

### new PassTextureNode(passNode, texture)
Constructs a new pass texture node.


| Param | Type | Description |
| --- | --- | --- |
| passNode | [<code>PassNode</code>](#PassNode) | The pass node. |
| texture | <code>Texture</code> | The output texture. |

<a name="PassTextureNode+passNode"></a>

### passTextureNode.passNode : [<code>PassNode</code>](#PassNode)
A reference to the pass node.

**Kind**: instance property of [<code>PassTextureNode</code>](#PassTextureNode)  
<a name="PassMultipleTextureNode"></a>

## PassMultipleTextureNode ⇐ [<code>PassTextureNode</code>](#PassTextureNode)
An extension of `PassTextureNode` which allows to manage more than one
internal texture. Relevant for the `getPreviousTexture()` related API.

**Kind**: global class  
**Extends**: [<code>PassTextureNode</code>](#PassTextureNode)  

* [PassMultipleTextureNode](#PassMultipleTextureNode) ⇐ [<code>PassTextureNode</code>](#PassTextureNode)
    * [new PassMultipleTextureNode(passNode, textureName, [previousTexture])](#new_PassMultipleTextureNode_new)
    * [.textureName](#PassMultipleTextureNode+textureName) : <code>string</code>
    * [.previousTexture](#PassMultipleTextureNode+previousTexture) : <code>boolean</code>
    * [.passNode](#PassTextureNode+passNode) : [<code>PassNode</code>](#PassNode)
    * [.updateTexture()](#PassMultipleTextureNode+updateTexture)

<a name="new_PassMultipleTextureNode_new"></a>

### new PassMultipleTextureNode(passNode, textureName, [previousTexture])
Constructs a new pass texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| passNode | [<code>PassNode</code>](#PassNode) |  | The pass node. |
| textureName | <code>string</code> |  | The output texture name. |
| [previousTexture] | <code>boolean</code> | <code>false</code> | Whether previous frame data should be used or not. |

<a name="PassMultipleTextureNode+textureName"></a>

### passMultipleTextureNode.textureName : <code>string</code>
The output texture name.

**Kind**: instance property of [<code>PassMultipleTextureNode</code>](#PassMultipleTextureNode)  
<a name="PassMultipleTextureNode+previousTexture"></a>

### passMultipleTextureNode.previousTexture : <code>boolean</code>
Whether previous frame data should be used or not.

**Kind**: instance property of [<code>PassMultipleTextureNode</code>](#PassMultipleTextureNode)  
<a name="PassTextureNode+passNode"></a>

### passMultipleTextureNode.passNode : [<code>PassNode</code>](#PassNode)
A reference to the pass node.

**Kind**: instance property of [<code>PassMultipleTextureNode</code>](#PassMultipleTextureNode)  
**Overrides**: [<code>passNode</code>](#PassTextureNode+passNode)  
<a name="PassMultipleTextureNode+updateTexture"></a>

### passMultipleTextureNode.updateTexture()
Updates the texture reference of this node.

**Kind**: instance method of [<code>PassMultipleTextureNode</code>](#PassMultipleTextureNode)  
<a name="PassNode"></a>

## PassNode ⇐ <code>TempNode</code>
Represents a render pass (sometimes called beauty pass) in context of post processing.
This pass produces a render for the given scene and camera and can provide multiple outputs
via MRT for further processing.

```js
const postProcessing = new PostProcessing( renderer );

const scenePass = pass( scene, camera );

postProcessing.outputNode = scenePass;
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [PassNode](#PassNode) ⇐ <code>TempNode</code>
    * [new PassNode(scope, scene, camera, options)](#new_PassNode_new)
    * _instance_
        * [.scope](#PassNode+scope) : <code>&#x27;color&#x27;</code> \| <code>&#x27;depth&#x27;</code>
        * [.scene](#PassNode+scene) : <code>Scene</code>
        * [.camera](#PassNode+camera) : <code>Camera</code>
        * [.options](#PassNode+options) : <code>Object</code>
        * [.renderTarget](#PassNode+renderTarget) : <code>RenderTarget</code>
        * [.isPassNode](#PassNode+isPassNode) : <code>boolean</code>
        * [.updateBeforeType](#PassNode+updateBeforeType) : <code>string</code>
        * [.setResolution(resolution)](#PassNode+setResolution) ⇒ [<code>PassNode</code>](#PassNode)
        * [.getResolution()](#PassNode+getResolution) ⇒ <code>number</code>
        * [.setMRT(mrt)](#PassNode+setMRT) ⇒ [<code>PassNode</code>](#PassNode)
        * [.getMRT()](#PassNode+getMRT) ⇒ <code>MRTNode</code>
        * [.isGlobal()](#PassNode+isGlobal) ⇒ <code>boolean</code>
        * [.getTexture(name)](#PassNode+getTexture) ⇒ <code>Texture</code>
        * [.getPreviousTexture(name)](#PassNode+getPreviousTexture) ⇒ <code>Texture</code>
        * [.toggleTexture(name)](#PassNode+toggleTexture)
        * [.getTextureNode([name])](#PassNode+getTextureNode) ⇒ <code>TextureNode</code>
        * [.getPreviousTextureNode([name])](#PassNode+getPreviousTextureNode) ⇒ <code>TextureNode</code>
        * [.getViewZNode([name])](#PassNode+getViewZNode) ⇒ <code>Node</code>
        * [.getLinearDepthNode([name])](#PassNode+getLinearDepthNode) ⇒ <code>Node</code>
        * [.setSize(width, height)](#PassNode+setSize)
        * [.setPixelRatio(pixelRatio)](#PassNode+setPixelRatio)
        * [.dispose()](#PassNode+dispose)
    * _static_
        * [.COLOR](#PassNode.COLOR) : <code>&#x27;color&#x27;</code>
        * [.DEPTH](#PassNode.DEPTH) : <code>&#x27;depth&#x27;</code>

<a name="new_PassNode_new"></a>

### new PassNode(scope, scene, camera, options)
Constructs a new pass node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>&#x27;color&#x27;</code> \| <code>&#x27;depth&#x27;</code> | The scope of the pass. The scope determines whether the node outputs color or depth. |
| scene | <code>Scene</code> | A reference to the scene. |
| camera | <code>Camera</code> | A reference to the camera. |
| options | <code>Object</code> | Options for the internal render target. |

<a name="PassNode+scope"></a>

### passNode.scope : <code>&#x27;color&#x27;</code> \| <code>&#x27;depth&#x27;</code>
The scope of the pass. The scope determines whether the node outputs color or depth.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+scene"></a>

### passNode.scene : <code>Scene</code>
A reference to the scene.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+camera"></a>

### passNode.camera : <code>Camera</code>
A reference to the camera.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+options"></a>

### passNode.options : <code>Object</code>
Options for the internal render target.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+renderTarget"></a>

### passNode.renderTarget : <code>RenderTarget</code>
The pass's render target.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+isPassNode"></a>

### passNode.isPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PassNode+updateBeforeType"></a>

### passNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
scene once per frame in its [PassNode#updateBefore](PassNode#updateBefore) method.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="PassNode+setResolution"></a>

### passNode.setResolution(resolution) ⇒ [<code>PassNode</code>](#PassNode)
Sets the resolution for the pass.
The resolution is a factor that is multiplied with the renderer's width and height.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: [<code>PassNode</code>](#PassNode) - A reference to this pass.  

| Param | Type | Description |
| --- | --- | --- |
| resolution | <code>number</code> | The resolution to set. A value of `1` means full resolution. |

<a name="PassNode+getResolution"></a>

### passNode.getResolution() ⇒ <code>number</code>
Gets the current resolution of the pass.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Default**: <code>1</code>  
**Returns**: <code>number</code> - The current resolution. A value of `1` means full resolution.  
<a name="PassNode+setMRT"></a>

### passNode.setMRT(mrt) ⇒ [<code>PassNode</code>](#PassNode)
Sets the given MRT node to setup MRT for this pass.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: [<code>PassNode</code>](#PassNode) - A reference to this pass.  

| Param | Type | Description |
| --- | --- | --- |
| mrt | <code>MRTNode</code> | The MRT object. |

<a name="PassNode+getMRT"></a>

### passNode.getMRT() ⇒ <code>MRTNode</code>
Returns the current MRT node.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>MRTNode</code> - The current MRT node.  
<a name="PassNode+isGlobal"></a>

### passNode.isGlobal() ⇒ <code>boolean</code>
The method is overwritten so it always returns `true`.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  
<a name="PassNode+getTexture"></a>

### passNode.getTexture(name) ⇒ <code>Texture</code>
Returns the texture for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>Texture</code> - The texture.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The output name to get the texture for. |

<a name="PassNode+getPreviousTexture"></a>

### passNode.getPreviousTexture(name) ⇒ <code>Texture</code>
Returns the texture holding the data of the previous frame for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>Texture</code> - The texture holding the data of the previous frame.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The output name to get the texture for. |

<a name="PassNode+toggleTexture"></a>

### passNode.toggleTexture(name)
Switches current and previous textures for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The output name. |

<a name="PassNode+getTextureNode"></a>

### passNode.getTextureNode([name]) ⇒ <code>TextureNode</code>
Returns the texture node for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>TextureNode</code> - The texture node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;output&#x27;&quot;</code> | The output name to get the texture node for. |

<a name="PassNode+getPreviousTextureNode"></a>

### passNode.getPreviousTextureNode([name]) ⇒ <code>TextureNode</code>
Returns the previous texture node for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>TextureNode</code> - The previous texture node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;output&#x27;&quot;</code> | The output name to get the previous texture node for. |

<a name="PassNode+getViewZNode"></a>

### passNode.getViewZNode([name]) ⇒ <code>Node</code>
Returns a viewZ node of this pass.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>Node</code> - The viewZ node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;depth&#x27;&quot;</code> | The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs. |

<a name="PassNode+getLinearDepthNode"></a>

### passNode.getLinearDepthNode([name]) ⇒ <code>Node</code>
Returns a linear depth node of this pass.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>Node</code> - The linear depth node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;depth&#x27;&quot;</code> | The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs. |

<a name="PassNode+setSize"></a>

### passNode.setSize(width, height)
Sets the size of the pass's render target. Honors the pixel ratio.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The height to set. |

<a name="PassNode+setPixelRatio"></a>

### passNode.setPixelRatio(pixelRatio)
Sets the pixel ratio the pass's render target and updates the size.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  

| Param | Type | Description |
| --- | --- | --- |
| pixelRatio | <code>number</code> | The pixel ratio to set. |

<a name="PassNode+dispose"></a>

### passNode.dispose()
Frees internal resources. Should be called when the node is no longer in use.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
<a name="PassNode.COLOR"></a>

### PassNode.COLOR : <code>&#x27;color&#x27;</code>
**Kind**: static property of [<code>PassNode</code>](#PassNode)  
**Default**: <code>&#x27;color&#x27;</code>  
<a name="PassNode.DEPTH"></a>

### PassNode.DEPTH : <code>&#x27;depth&#x27;</code>
**Kind**: static property of [<code>PassNode</code>](#PassNode)  
**Default**: <code>&#x27;depth&#x27;</code>  
<a name="pass"></a>

## pass(scene, camera, options) ⇒ [<code>PassNode</code>](#PassNode)
TSL function for creating a pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | A reference to the scene. |
| camera | <code>Camera</code> | A reference to the camera. |
| options | <code>Object</code> | Options for the internal render target. |

<a name="passTexture"></a>

## passTexture(pass, texture) ⇒ [<code>PassTextureNode</code>](#PassTextureNode)
TSL function for creating a pass texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pass | [<code>PassNode</code>](#PassNode) | The pass node. |
| texture | <code>Texture</code> | The output texture. |

<a name="depthPass"></a>

## depthPass(scene, camera, options) ⇒ [<code>PassNode</code>](#PassNode)
TSL function for creating a depth pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | A reference to the scene. |
| camera | <code>Camera</code> | A reference to the camera. |
| options | <code>Object</code> | Options for the internal render target. |

## Classes

<dl>
<dt><a href="#PosterizeNode">PosterizeNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Represents a posterize effect which reduces the number of colors
in an image, resulting in a more blocky and stylized appearance.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#posterize">posterize(sourceNode, stepsNode)</a> ⇒ <code><a href="#PosterizeNode">PosterizeNode</a></code></dt>
<dd><p>TSL function for creating a posterize node.</p>
</dd>
</dl>

<a name="PosterizeNode"></a>

## PosterizeNode ⇐ <code>TempNode</code>
Represents a posterize effect which reduces the number of colors
in an image, resulting in a more blocky and stylized appearance.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [PosterizeNode](#PosterizeNode) ⇐ <code>TempNode</code>
    * [new PosterizeNode(sourceNode, stepsNode)](#new_PosterizeNode_new)
    * [.sourceNode](#PosterizeNode+sourceNode) : <code>Node</code>
    * [.stepsNode](#PosterizeNode+stepsNode) : <code>Node</code>

<a name="new_PosterizeNode_new"></a>

### new PosterizeNode(sourceNode, stepsNode)
Constructs a new posterize node.


| Param | Type | Description |
| --- | --- | --- |
| sourceNode | <code>Node</code> | The input color. |
| stepsNode | <code>Node</code> | Controls the intensity of the posterization effect. A lower number results in a more blocky appearance. |

<a name="PosterizeNode+sourceNode"></a>

### posterizeNode.sourceNode : <code>Node</code>
The input color.

**Kind**: instance property of [<code>PosterizeNode</code>](#PosterizeNode)  
<a name="PosterizeNode+stepsNode"></a>

### posterizeNode.stepsNode : <code>Node</code>
Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.

**Kind**: instance property of [<code>PosterizeNode</code>](#PosterizeNode)  
<a name="posterize"></a>

## posterize(sourceNode, stepsNode) ⇒ [<code>PosterizeNode</code>](#PosterizeNode)
TSL function for creating a posterize node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| sourceNode | <code>Node</code> | The input color. |
| stepsNode | <code>Node</code> | Controls the intensity of the posterization effect. A lower number results in a more blocky appearance. |

## Classes

<dl>
<dt><a href="#RenderOutputNode">RenderOutputNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Normally, tone mapping and color conversion happens automatically
before outputting pixel too the default (screen) framebuffer. In certain
post processing setups this happens to late because certain effects
require e.g. sRGB input. For such scenarios, <code>RenderOutputNode</code> can be used
to apply tone mapping and color space conversion at an arbitrary point
in the effect chain.</p>
<p>When applying tone mapping and color space conversion manually with this node,
you have to set <a href="PostProcessing#outputColorTransform">PostProcessing#outputColorTransform</a> to <code>false</code>.</p>
<pre><code class="language-js">const postProcessing = new PostProcessing( renderer );
postProcessing.outputColorTransform = false;

const scenePass = pass( scene, camera );
const outputPass = renderOutput( scenePass );

postProcessing.outputNode = outputPass;
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#renderOutput">renderOutput(color, [toneMapping], [outputColorSpace])</a> ⇒ <code><a href="#RenderOutputNode">RenderOutputNode</a></code></dt>
<dd><p>TSL function for creating a posterize node.</p>
</dd>
</dl>

<a name="RenderOutputNode"></a>

## RenderOutputNode ⇐ <code>TempNode</code>
Normally, tone mapping and color conversion happens automatically
before outputting pixel too the default (screen) framebuffer. In certain
post processing setups this happens to late because certain effects
require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used
to apply tone mapping and color space conversion at an arbitrary point
in the effect chain.

When applying tone mapping and color space conversion manually with this node,
you have to set [PostProcessing#outputColorTransform](PostProcessing#outputColorTransform) to `false`.

```js
const postProcessing = new PostProcessing( renderer );
postProcessing.outputColorTransform = false;

const scenePass = pass( scene, camera );
const outputPass = renderOutput( scenePass );

postProcessing.outputNode = outputPass;
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [RenderOutputNode](#RenderOutputNode) ⇐ <code>TempNode</code>
    * [new RenderOutputNode(colorNode, toneMapping, outputColorSpace)](#new_RenderOutputNode_new)
    * [.colorNode](#RenderOutputNode+colorNode) : <code>Node</code>
    * [.toneMapping](#RenderOutputNode+toneMapping) : <code>number</code>
    * [.outputColorSpace](#RenderOutputNode+outputColorSpace) : <code>string</code>
    * [.isRenderOutputNode](#RenderOutputNode+isRenderOutputNode) : <code>boolean</code>

<a name="new_RenderOutputNode_new"></a>

### new RenderOutputNode(colorNode, toneMapping, outputColorSpace)
Constructs a new render output node.


| Param | Type | Description |
| --- | --- | --- |
| colorNode | <code>Node</code> | The color node to process. |
| toneMapping | <code>number</code> | The tone mapping type. |
| outputColorSpace | <code>string</code> | The output color space. |

<a name="RenderOutputNode+colorNode"></a>

### renderOutputNode.colorNode : <code>Node</code>
The color node to process.

**Kind**: instance property of [<code>RenderOutputNode</code>](#RenderOutputNode)  
<a name="RenderOutputNode+toneMapping"></a>

### renderOutputNode.toneMapping : <code>number</code>
The tone mapping type.

**Kind**: instance property of [<code>RenderOutputNode</code>](#RenderOutputNode)  
<a name="RenderOutputNode+outputColorSpace"></a>

### renderOutputNode.outputColorSpace : <code>string</code>
The output color space.

**Kind**: instance property of [<code>RenderOutputNode</code>](#RenderOutputNode)  
<a name="RenderOutputNode+isRenderOutputNode"></a>

### renderOutputNode.isRenderOutputNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>RenderOutputNode</code>](#RenderOutputNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="renderOutput"></a>

## renderOutput(color, [toneMapping], [outputColorSpace]) ⇒ [<code>RenderOutputNode</code>](#RenderOutputNode)
TSL function for creating a posterize node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node</code> |  | The color node to process. |
| [toneMapping] | <code>number</code> | <code></code> | The tone mapping type. |
| [outputColorSpace] | <code>string</code> | <code>null</code> | The output color space. |

## Classes

<dl>
<dt><a href="#ScreenNode">ScreenNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node provides a collection of screen related metrics.
Depending on <a href="#ScreenNode+scope">scope</a>, the nodes can represent
resolution or viewport data as well as fragment or uv coordinates.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#screenUV">screenUV</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents normalized screen coordinates, unitless in <code>[0, 1]</code>.</p>
</dd>
<dt><a href="#screenSize">screenSize</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the screen resolution in physical pixel units.</p>
</dd>
<dt><a href="#screenCoordinate">screenCoordinate</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the current <code>x</code>/<code>y</code> pixel position on the screen in physical pixel units.</p>
</dd>
<dt><a href="#viewport">viewport</a> : <code>ScreenNode.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the viewport rectangle as <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code> in physical pixel units.</p>
</dd>
<dt><a href="#viewportSize">viewportSize</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the viewport resolution in physical pixel units.</p>
</dd>
<dt><a href="#viewportCoordinate">viewportCoordinate</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the current <code>x</code>/<code>y</code> pixel position on the viewport in physical pixel units.</p>
</dd>
<dt><a href="#viewportUV">viewportUV</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents normalized viewport coordinates, unitless in <code>[0, 1]</code>.</p>
</dd>
<dt><del><a href="#viewportResolution">viewportResolution</a></del></dt>
<dd></dd>
<dt><del><a href="#viewportTopLeft">viewportTopLeft</a> : <code>Node.&lt;vec2&gt;</code></del></dt>
<dd></dd>
<dt><del><a href="#viewportBottomLeft">viewportBottomLeft</a> : <code>Node.&lt;vec2&gt;</code></del></dt>
<dd></dd>
</dl>

<a name="ScreenNode"></a>

## ScreenNode ⇐ <code>Node</code>
This node provides a collection of screen related metrics.
Depending on [scope](#ScreenNode+scope), the nodes can represent
resolution or viewport data as well as fragment or uv coordinates.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ScreenNode](#ScreenNode) ⇐ <code>Node</code>
    * [new ScreenNode(scope)](#new_ScreenNode_new)
    * [.scope](#ScreenNode+scope) : <code>&#x27;coordinate&#x27;</code> \| <code>&#x27;viewport&#x27;</code> \| <code>&#x27;size&#x27;</code> \| <code>&#x27;uv&#x27;</code>
    * [.isViewportNode](#ScreenNode+isViewportNode) : <code>boolean</code>
    * [.getNodeType()](#ScreenNode+getNodeType) ⇒ <code>&#x27;vec2&#x27;</code> \| <code>&#x27;vec4&#x27;</code>
    * [.getUpdateType()](#ScreenNode+getUpdateType) ⇒ <code>NodeUpdateType</code>
    * [.update(frame)](#ScreenNode+update)

<a name="new_ScreenNode_new"></a>

### new ScreenNode(scope)
Constructs a new screen node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>&#x27;coordinate&#x27;</code> \| <code>&#x27;viewport&#x27;</code> \| <code>&#x27;size&#x27;</code> \| <code>&#x27;uv&#x27;</code> | The node's scope. |

<a name="ScreenNode+scope"></a>

### screenNode.scope : <code>&#x27;coordinate&#x27;</code> \| <code>&#x27;viewport&#x27;</code> \| <code>&#x27;size&#x27;</code> \| <code>&#x27;uv&#x27;</code>
The node represents different metric depending on which scope is selected.

- `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.
- `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.
- `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.
- `ScreenNode.UV`: Normalized coordinates.

**Kind**: instance property of [<code>ScreenNode</code>](#ScreenNode)  
<a name="ScreenNode+isViewportNode"></a>

### screenNode.isViewportNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ScreenNode</code>](#ScreenNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ScreenNode+getNodeType"></a>

### screenNode.getNodeType() ⇒ <code>&#x27;vec2&#x27;</code> \| <code>&#x27;vec4&#x27;</code>
This method is overwritten since the node type depends on the selected scope.

**Kind**: instance method of [<code>ScreenNode</code>](#ScreenNode)  
**Returns**: <code>&#x27;vec2&#x27;</code> \| <code>&#x27;vec4&#x27;</code> - The node type.  
<a name="ScreenNode+getUpdateType"></a>

### screenNode.getUpdateType() ⇒ <code>NodeUpdateType</code>
This method is overwritten since the node's update type depends on the selected scope.

**Kind**: instance method of [<code>ScreenNode</code>](#ScreenNode)  
**Returns**: <code>NodeUpdateType</code> - The update type.  
<a name="ScreenNode+update"></a>

### screenNode.update(frame)
`ScreenNode` implements [Node#update](Node#update) to retrieve viewport and size information
from the current renderer.

**Kind**: instance method of [<code>ScreenNode</code>](#ScreenNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="screenUV"></a>

## screenUV : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.

**Kind**: global constant  
**Tsl**:   
<a name="screenSize"></a>

## screenSize : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents the screen resolution in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="screenCoordinate"></a>

## screenCoordinate : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="viewport"></a>

## viewport : <code>ScreenNode.&lt;vec4&gt;</code>
TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="viewportSize"></a>

## viewportSize : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents the viewport resolution in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="viewportCoordinate"></a>

## viewportCoordinate : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="viewportUV"></a>

## viewportUV : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.

**Kind**: global constant  
**Tsl**:   
<a name="viewportResolution"></a>

## ~~viewportResolution~~
***since r169. Use [screenSize](#screenSize) instead.***

**Kind**: global constant  
<a name="viewportTopLeft"></a>

## ~~viewportTopLeft : <code>Node.&lt;vec2&gt;</code>~~
***since r168. Use [screenUV](#screenUV) instead.***

**Kind**: global constant  
**Tsl**:   
<a name="viewportBottomLeft"></a>

## ~~viewportBottomLeft : <code>Node.&lt;vec2&gt;</code>~~
***since r168. Use `screenUV.flipY()` instead.***

**Kind**: global constant  
**Tsl**:   
## Functions

<dl>
<dt><a href="#linearToneMapping">linearToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Linear tone mapping, exposure only.</p>
</dd>
<dt><a href="#reinhardToneMapping">reinhardToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Reinhard tone mapping.</p>
<p>Reference: <a href="https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf">https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf</a></p>
</dd>
<dt><a href="#cineonToneMapping">cineonToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Cineon tone mapping.</p>
<p>Reference: <a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">http://filmicworlds.com/blog/filmic-tonemapping-operators/</a></p>
</dd>
<dt><a href="#acesFilmicToneMapping">acesFilmicToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>ACESFilmic tone mapping.</p>
<p>Reference: <a href="https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs">https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs</a></p>
</dd>
<dt><a href="#agxToneMapping">agxToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>AgX tone mapping.</p>
</dd>
<dt><a href="#neutralToneMapping">neutralToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Neutral tone mapping.</p>
<p>Reference: <a href="https://modelviewer.dev/examples/tone-mapping">https://modelviewer.dev/examples/tone-mapping</a></p>
</dd>
</dl>

<a name="linearToneMapping"></a>

## linearToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
Linear tone mapping, exposure only.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="reinhardToneMapping"></a>

## reinhardToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
Reinhard tone mapping.

Reference: [https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf](https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf)

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="cineonToneMapping"></a>

## cineonToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
Cineon tone mapping.

Reference: [http://filmicworlds.com/blog/filmic-tonemapping-operators/](http://filmicworlds.com/blog/filmic-tonemapping-operators/)

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="acesFilmicToneMapping"></a>

## acesFilmicToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
ACESFilmic tone mapping.

Reference: [https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs](https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs)

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="agxToneMapping"></a>

## agxToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
AgX tone mapping.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="neutralToneMapping"></a>

## neutralToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
Neutral tone mapping.

Reference: [https://modelviewer.dev/examples/tone-mapping](https://modelviewer.dev/examples/tone-mapping)

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

## Classes

<dl>
<dt><a href="#ToneMappingNode">ToneMappingNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents a tone mapping operation.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#toneMappingExposure">toneMappingExposure</a> : <code>RendererReferenceNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the global tone mapping exposure of the renderer.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#toneMapping">toneMapping(mapping, exposure, color)</a> ⇒ <code>ToneMappingNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating a tone mapping node.</p>
</dd>
</dl>

<a name="ToneMappingNode"></a>

## ToneMappingNode ⇐ <code>TempNode</code>
This node represents a tone mapping operation.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [ToneMappingNode](#ToneMappingNode) ⇐ <code>TempNode</code>
    * [new ToneMappingNode(toneMapping, exposureNode, [colorNode])](#new_ToneMappingNode_new)
    * [.toneMapping](#ToneMappingNode+toneMapping) : <code>number</code>
    * [.exposureNode](#ToneMappingNode+exposureNode) : <code>Node</code>
    * [.colorNode](#ToneMappingNode+colorNode) : <code>Node</code>
    * [.customCacheKey()](#ToneMappingNode+customCacheKey) ⇒ <code>number</code>

<a name="new_ToneMappingNode_new"></a>

### new ToneMappingNode(toneMapping, exposureNode, [colorNode])
Constructs a new tone mapping node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| toneMapping | <code>number</code> |  | The tone mapping type. |
| exposureNode | <code>Node</code> |  | The tone mapping exposure. |
| [colorNode] | <code>Node</code> | <code></code> | The color node to process. |

<a name="ToneMappingNode+toneMapping"></a>

### toneMappingNode.toneMapping : <code>number</code>
The tone mapping type.

**Kind**: instance property of [<code>ToneMappingNode</code>](#ToneMappingNode)  
<a name="ToneMappingNode+exposureNode"></a>

### toneMappingNode.exposureNode : <code>Node</code>
The tone mapping exposure.

**Kind**: instance property of [<code>ToneMappingNode</code>](#ToneMappingNode)  
**Default**: <code>null</code>  
<a name="ToneMappingNode+colorNode"></a>

### toneMappingNode.colorNode : <code>Node</code>
Represents the color to process.

**Kind**: instance property of [<code>ToneMappingNode</code>](#ToneMappingNode)  
**Default**: <code>null</code>  
<a name="ToneMappingNode+customCacheKey"></a>

### toneMappingNode.customCacheKey() ⇒ <code>number</code>
Overwrites the default `customCacheKey()` implementation by including the tone
mapping type into the cache key.

**Kind**: instance method of [<code>ToneMappingNode</code>](#ToneMappingNode)  
**Returns**: <code>number</code> - The hash.  
<a name="toneMappingExposure"></a>

## toneMappingExposure : <code>RendererReferenceNode.&lt;vec3&gt;</code>
TSL object that represents the global tone mapping exposure of the renderer.

**Kind**: global constant  
**Tsl**:   
<a name="toneMapping"></a>

## toneMapping(mapping, exposure, color) ⇒ <code>ToneMappingNode.&lt;vec3&gt;</code>
TSL function for creating a tone mapping node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| mapping | <code>number</code> | The tone mapping type. |
| exposure | <code>Node.&lt;float&gt;</code> \| <code>number</code> | The tone mapping exposure. |
| color | <code>Node.&lt;vec3&gt;</code> \| <code>Color</code> | The color node to process. |

## Classes

<dl>
<dt><a href="#ToonOutlinePassNode">ToonOutlinePassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>Represents a render pass for producing a toon outline effect on compatible objects.
Only 3D objects with materials of type <code>MeshToonMaterial</code> and <code>MeshToonNodeMaterial</code>
will receive the outline.</p>
<pre><code class="language-js">const postProcessing = new PostProcessing( renderer );

const scenePass = toonOutlinePass( scene, camera );

postProcessing.outputNode = scenePass;
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#toonOutlinePass">toonOutlinePass(scene, camera, color, [thickness], [alpha])</a> ⇒ <code><a href="#ToonOutlinePassNode">ToonOutlinePassNode</a></code></dt>
<dd><p>TSL function for creating a toon outline pass node.</p>
</dd>
</dl>

<a name="ToonOutlinePassNode"></a>

## ToonOutlinePassNode ⇐ <code>PassNode</code>
Represents a render pass for producing a toon outline effect on compatible objects.
Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`
will receive the outline.

```js
const postProcessing = new PostProcessing( renderer );

const scenePass = toonOutlinePass( scene, camera );

postProcessing.outputNode = scenePass;
```

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [ToonOutlinePassNode](#ToonOutlinePassNode) ⇐ <code>PassNode</code>
    * [new ToonOutlinePassNode(scene, camera, colorNode, thicknessNode, alphaNode)](#new_ToonOutlinePassNode_new)
    * [.colorNode](#ToonOutlinePassNode+colorNode) : <code>Node</code>
    * [.thicknessNode](#ToonOutlinePassNode+thicknessNode) : <code>Node</code>
    * [.alphaNode](#ToonOutlinePassNode+alphaNode) : <code>Node</code>

<a name="new_ToonOutlinePassNode_new"></a>

### new ToonOutlinePassNode(scene, camera, colorNode, thicknessNode, alphaNode)
Constructs a new outline pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | A reference to the scene. |
| camera | <code>Camera</code> | A reference to the camera. |
| colorNode | <code>Node</code> | Defines the outline's color. |
| thicknessNode | <code>Node</code> | Defines the outline's thickness. |
| alphaNode | <code>Node</code> | Defines the outline's alpha. |

<a name="ToonOutlinePassNode+colorNode"></a>

### toonOutlinePassNode.colorNode : <code>Node</code>
Defines the outline's color.

**Kind**: instance property of [<code>ToonOutlinePassNode</code>](#ToonOutlinePassNode)  
<a name="ToonOutlinePassNode+thicknessNode"></a>

### toonOutlinePassNode.thicknessNode : <code>Node</code>
Defines the outline's thickness.

**Kind**: instance property of [<code>ToonOutlinePassNode</code>](#ToonOutlinePassNode)  
<a name="ToonOutlinePassNode+alphaNode"></a>

### toonOutlinePassNode.alphaNode : <code>Node</code>
Defines the outline's alpha.

**Kind**: instance property of [<code>ToonOutlinePassNode</code>](#ToonOutlinePassNode)  
<a name="toonOutlinePass"></a>

## toonOutlinePass(scene, camera, color, [thickness], [alpha]) ⇒ [<code>ToonOutlinePassNode</code>](#ToonOutlinePassNode)
TSL function for creating a toon outline pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | A reference to the scene. |
| camera | <code>Camera</code> |  | A reference to the camera. |
| color | <code>Color</code> |  | Defines the outline's color. |
| [thickness] | <code>number</code> | <code>0.003</code> | Defines the outline's thickness. |
| [alpha] | <code>number</code> | <code>1</code> | Defines the outline's alpha. |

## Classes

<dl>
<dt><a href="#ViewportDepthNode">ViewportDepthNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node offers a collection of features in context of the depth logic in the fragment shader.
Depending on <a href="#ViewportDepthNode+scope">scope</a>, it can be used to define a depth value for the current
fragment or for depth evaluation purposes.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#depth">depth</a> : <code><a href="#ViewportDepthNode">ViewportDepthNode</a></code></dt>
<dd><p>TSL object that represents the depth value for the current fragment.</p>
</dd>
<dt><a href="#viewportLinearDepth">viewportLinearDepth</a> : <code><a href="#ViewportDepthNode">ViewportDepthNode</a></code></dt>
<dd><p>TSL object that represents the linear (orthographic) depth value of the current fragment</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#viewZToOrthographicDepth">viewZToOrthographicDepth(viewZ, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a viewZ value to an orthographic depth value.</p>
</dd>
<dt><a href="#orthographicDepthToViewZ">orthographicDepthToViewZ(depth, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting an orthographic depth value to a viewZ value.</p>
</dd>
<dt><a href="#viewZToPerspectiveDepth">viewZToPerspectiveDepth(viewZ, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a viewZ value to a perspective depth value.</p>
<p>Note: {link <a href="https://twitter.com/gonnavis/status/1377183786949959682%7D">https://twitter.com/gonnavis/status/1377183786949959682}</a>.</p>
</dd>
<dt><a href="#perspectiveDepthToViewZ">perspectiveDepthToViewZ(depth, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a perspective depth value to a viewZ value.</p>
</dd>
<dt><a href="#viewZToLogarithmicDepth">viewZToLogarithmicDepth(viewZ, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a viewZ value to a logarithmic depth value.</p>
</dd>
<dt><a href="#logarithmicDepthToViewZ">logarithmicDepthToViewZ(depth, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a logarithmic depth value to a viewZ value.</p>
</dd>
<dt><a href="#depthBase">depthBase(value)</a> ⇒ <code>ViewportDepthNode.&lt;float&gt;</code></dt>
<dd><p>TSL function for defining a value for the current fragment&#39;s depth.</p>
</dd>
<dt><a href="#linearDepth">linearDepth([value])</a> ⇒ <code>ViewportDepthNode.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a perspective depth value to linear depth.</p>
</dd>
</dl>

<a name="ViewportDepthNode"></a>

## ViewportDepthNode ⇐ <code>Node</code>
This node offers a collection of features in context of the depth logic in the fragment shader.
Depending on [scope](#ViewportDepthNode+scope), it can be used to define a depth value for the current
fragment or for depth evaluation purposes.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ViewportDepthNode](#ViewportDepthNode) ⇐ <code>Node</code>
    * [new ViewportDepthNode(scope, [valueNode])](#new_ViewportDepthNode_new)
    * [.scope](#ViewportDepthNode+scope) : <code>&#x27;depth&#x27;</code> \| <code>&#x27;depthBase&#x27;</code> \| <code>&#x27;linearDepth&#x27;</code>
    * [.valueNode](#ViewportDepthNode+valueNode) : <code>Node</code>
    * [.isViewportDepthNode](#ViewportDepthNode+isViewportDepthNode) : <code>boolean</code>

<a name="new_ViewportDepthNode_new"></a>

### new ViewportDepthNode(scope, [valueNode])
Constructs a new viewport depth node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scope | <code>&#x27;depth&#x27;</code> \| <code>&#x27;depthBase&#x27;</code> \| <code>&#x27;linearDepth&#x27;</code> |  | The node's scope. |
| [valueNode] | <code>Node</code> | <code></code> | The value node. |

<a name="ViewportDepthNode+scope"></a>

### viewportDepthNode.scope : <code>&#x27;depth&#x27;</code> \| <code>&#x27;depthBase&#x27;</code> \| <code>&#x27;linearDepth&#x27;</code>
The node behaves differently depending on which scope is selected.

- `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.
- `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).
- `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.
If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.

**Kind**: instance property of [<code>ViewportDepthNode</code>](#ViewportDepthNode)  
<a name="ViewportDepthNode+valueNode"></a>

### viewportDepthNode.valueNode : <code>Node</code>
Can be used to define a custom depth value.
The property is ignored in the `ViewportDepthNode.DEPTH` scope.

**Kind**: instance property of [<code>ViewportDepthNode</code>](#ViewportDepthNode)  
**Default**: <code>null</code>  
<a name="ViewportDepthNode+isViewportDepthNode"></a>

### viewportDepthNode.isViewportDepthNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ViewportDepthNode</code>](#ViewportDepthNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="depth"></a>

## depth : [<code>ViewportDepthNode</code>](#ViewportDepthNode)
TSL object that represents the depth value for the current fragment.

**Kind**: global constant  
**Tsl**:   
<a name="viewportLinearDepth"></a>

## viewportLinearDepth : [<code>ViewportDepthNode</code>](#ViewportDepthNode)
TSL object that represents the linear (orthographic) depth value of the current fragment

**Kind**: global constant  
**Tsl**:   
<a name="viewZToOrthographicDepth"></a>

## viewZToOrthographicDepth(viewZ, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a viewZ value to an orthographic depth value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| viewZ | <code>Node.&lt;float&gt;</code> | The viewZ node. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="orthographicDepthToViewZ"></a>

## orthographicDepthToViewZ(depth, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting an orthographic depth value to a viewZ value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| depth | <code>Node.&lt;float&gt;</code> | The orthographic depth. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="viewZToPerspectiveDepth"></a>

## viewZToPerspectiveDepth(viewZ, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a viewZ value to a perspective depth value.

Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| viewZ | <code>Node.&lt;float&gt;</code> | The viewZ node. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="perspectiveDepthToViewZ"></a>

## perspectiveDepthToViewZ(depth, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a perspective depth value to a viewZ value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| depth | <code>Node.&lt;float&gt;</code> | The perspective depth. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="viewZToLogarithmicDepth"></a>

## viewZToLogarithmicDepth(viewZ, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a viewZ value to a logarithmic depth value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| viewZ | <code>Node.&lt;float&gt;</code> | The viewZ node. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="logarithmicDepthToViewZ"></a>

## logarithmicDepthToViewZ(depth, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a logarithmic depth value to a viewZ value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| depth | <code>Node.&lt;float&gt;</code> | The logarithmic depth. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="depthBase"></a>

## depthBase(value) ⇒ <code>ViewportDepthNode.&lt;float&gt;</code>
TSL function for defining a value for the current fragment's depth.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Node.&lt;float&gt;</code> | The depth value to set. |

<a name="linearDepth"></a>

## linearDepth([value]) ⇒ <code>ViewportDepthNode.&lt;float&gt;</code>
TSL function for converting a perspective depth value to linear depth.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [value] | <code>Node.&lt;float&gt;</code> | <code></code> | The perspective depth. If `null` is provided, the current fragment's depth is used. |

## Classes

<dl>
<dt><a href="#ViewportDepthTextureNode">ViewportDepthTextureNode</a> ⇐ <code>ViewportTextureNode</code></dt>
<dd><p>Represents the depth of the current viewport as a texture. This module
can be used in combination with viewport texture to achieve effects
that require depth evaluation.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#viewportDepthTexture">viewportDepthTexture([uvNode], [levelNode])</a> ⇒ <code><a href="#ViewportDepthTextureNode">ViewportDepthTextureNode</a></code></dt>
<dd><p>TSL function for a viewport depth texture node.</p>
</dd>
</dl>

<a name="ViewportDepthTextureNode"></a>

## ViewportDepthTextureNode ⇐ <code>ViewportTextureNode</code>
Represents the depth of the current viewport as a texture. This module
can be used in combination with viewport texture to achieve effects
that require depth evaluation.

**Kind**: global class  
**Extends**: <code>ViewportTextureNode</code>  
<a name="new_ViewportDepthTextureNode_new"></a>

### new ViewportDepthTextureNode([uvNode], [levelNode])
Constructs a new viewport depth texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |

<a name="viewportDepthTexture"></a>

## viewportDepthTexture([uvNode], [levelNode]) ⇒ [<code>ViewportDepthTextureNode</code>](#ViewportDepthTextureNode)
TSL function for a viewport depth texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |

## Classes

<dl>
<dt><a href="#ViewportSharedTextureNode">ViewportSharedTextureNode</a> ⇐ <code>ViewportTextureNode</code></dt>
<dd><p><code>ViewportTextureNode</code> creates an internal texture for each node instance. This module
shares a texture across all instances of <code>ViewportSharedTextureNode</code>. It should
be the first choice when using data of the default/screen framebuffer for performance reasons.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#viewportSharedTexture">viewportSharedTexture([uvNode], [levelNode])</a> ⇒ <code><a href="#ViewportSharedTextureNode">ViewportSharedTextureNode</a></code></dt>
<dd><p>TSL function for creating a shared viewport texture node.</p>
</dd>
</dl>

<a name="ViewportSharedTextureNode"></a>

## ViewportSharedTextureNode ⇐ <code>ViewportTextureNode</code>
`ViewportTextureNode` creates an internal texture for each node instance. This module
shares a texture across all instances of `ViewportSharedTextureNode`. It should
be the first choice when using data of the default/screen framebuffer for performance reasons.

**Kind**: global class  
**Extends**: <code>ViewportTextureNode</code>  
<a name="new_ViewportSharedTextureNode_new"></a>

### new ViewportSharedTextureNode([uvNode], [levelNode])
Constructs a new viewport shared texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |

<a name="viewportSharedTexture"></a>

## viewportSharedTexture([uvNode], [levelNode]) ⇒ [<code>ViewportSharedTextureNode</code>](#ViewportSharedTextureNode)
TSL function for creating a shared viewport texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |

## Classes

<dl>
<dt><a href="#ViewportTextureNode">ViewportTextureNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>A special type of texture node which represents the data of the current viewport
as a texture. The module extracts data from the current bound framebuffer with
a copy operation so no extra render pass is required to produce the texture data
(which is good for performance). <code>ViewportTextureNode</code> can be used as an input for a
variety of effects like refractive or transmissive materials.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#viewportTexture">viewportTexture([uvNode], [levelNode], [framebufferTexture])</a> ⇒ <code><a href="#ViewportTextureNode">ViewportTextureNode</a></code></dt>
<dd><p>TSL function for creating a viewport texture node.</p>
</dd>
<dt><a href="#viewportMipTexture">viewportMipTexture([uvNode], [levelNode], [framebufferTexture])</a> ⇒ <code><a href="#ViewportTextureNode">ViewportTextureNode</a></code></dt>
<dd><p>TSL function for creating a viewport texture node with enabled mipmap generation.</p>
</dd>
</dl>

<a name="ViewportTextureNode"></a>

## ViewportTextureNode ⇐ <code>TextureNode</code>
A special type of texture node which represents the data of the current viewport
as a texture. The module extracts data from the current bound framebuffer with
a copy operation so no extra render pass is required to produce the texture data
(which is good for performance). `ViewportTextureNode` can be used as an input for a
variety of effects like refractive or transmissive materials.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [ViewportTextureNode](#ViewportTextureNode) ⇐ <code>TextureNode</code>
    * [new ViewportTextureNode([uvNode], [levelNode], [framebufferTexture])](#new_ViewportTextureNode_new)
    * [.generateMipmaps](#ViewportTextureNode+generateMipmaps) : <code>boolean</code>
    * [.isOutputTextureNode](#ViewportTextureNode+isOutputTextureNode) : <code>boolean</code>
    * [.updateBeforeType](#ViewportTextureNode+updateBeforeType) : <code>string</code>

<a name="new_ViewportTextureNode_new"></a>

### new ViewportTextureNode([uvNode], [levelNode], [framebufferTexture])
Constructs a new viewport texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |
| [framebufferTexture] | <code>Texture</code> | <code></code> | A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically. |

<a name="ViewportTextureNode+generateMipmaps"></a>

### viewportTextureNode.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps or not.

**Kind**: instance property of [<code>ViewportTextureNode</code>](#ViewportTextureNode)  
**Default**: <code>false</code>  
<a name="ViewportTextureNode+isOutputTextureNode"></a>

### viewportTextureNode.isOutputTextureNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ViewportTextureNode</code>](#ViewportTextureNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ViewportTextureNode+updateBeforeType"></a>

### viewportTextureNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
scene once per frame in its [ViewportTextureNode#updateBefore](ViewportTextureNode#updateBefore) method.

**Kind**: instance property of [<code>ViewportTextureNode</code>](#ViewportTextureNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="viewportTexture"></a>

## viewportTexture([uvNode], [levelNode], [framebufferTexture]) ⇒ [<code>ViewportTextureNode</code>](#ViewportTextureNode)
TSL function for creating a viewport texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |
| [framebufferTexture] | <code>Texture</code> | <code></code> | A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically. |

<a name="viewportMipTexture"></a>

## viewportMipTexture([uvNode], [levelNode], [framebufferTexture]) ⇒ [<code>ViewportTextureNode</code>](#ViewportTextureNode)
TSL function for creating a viewport texture node with enabled mipmap generation.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |
| [framebufferTexture] | <code>Texture</code> | <code></code> | A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically. |

## Functions

<dl>
<dt><a href="#getViewZNode">getViewZNode(builder)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns a node that represents the <code>z</code> coordinate in view space
for the current fragment. It&#39;s a different representation of the
default depth value.</p>
<p>This value can be part of a computation that defines how the fog
density increases when moving away from the camera.</p>
</dd>
<dt><a href="#rangeFogFactor">rangeFogFactor(near, far)</a></dt>
<dd><p>Constructs a new range factor node.</p>
</dd>
<dt><a href="#densityFogFactor">densityFogFactor(density)</a></dt>
<dd><p>Represents an exponential squared fog. This type of fog gives
a clear view near the camera and a faster than exponentially
densening fog farther from the camera.</p>
</dd>
<dt><a href="#fog">fog(color, factor)</a></dt>
<dd><p>This class can be used to configure a fog for the scene.
Nodes of this type are assigned to <code>Scene.fogNode</code>.</p>
</dd>
<dt><del><a href="#rangeFog">rangeFog(color, near, far)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
<dt><del><a href="#densityFog">densityFog(color, density)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
</dl>

<a name="getViewZNode"></a>

## getViewZNode(builder) ⇒ <code>Node</code>
Returns a node that represents the `z` coordinate in view space
for the current fragment. It's a different representation of the
default depth value.

This value can be part of a computation that defines how the fog
density increases when moving away from the camera.

**Kind**: global function  
**Returns**: <code>Node</code> - The viewZ node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="rangeFogFactor"></a>

## rangeFogFactor(near, far)
Constructs a new range factor node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| near | <code>Node</code> | Defines the near value. |
| far | <code>Node</code> | Defines the far value. |

<a name="densityFogFactor"></a>

## densityFogFactor(density)
Represents an exponential squared fog. This type of fog gives
a clear view near the camera and a faster than exponentially
densening fog farther from the camera.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| density | <code>Node</code> | Defines the fog density. |

<a name="fog"></a>

## fog(color, factor)
This class can be used to configure a fog for the scene.
Nodes of this type are assigned to `Scene.fogNode`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node</code> | Defines the color of the fog. |
| factor | <code>Node</code> | Defines how the fog is factored in the scene. |

<a name="rangeFog"></a>

## ~~rangeFog(color, near, far) ⇒ <code>function</code>~~
***since r171. Use `fog( color, rangeFogFactor( near, far ) )` instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| color | <code>Node</code> | 
| near | <code>Node</code> | 
| far | <code>Node</code> | 

<a name="densityFog"></a>

## ~~densityFog(color, density) ⇒ <code>function</code>~~
***since r171. Use `fog( color, densityFogFactor( density ) )` instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| color | <code>Node</code> | 
| density | <code>Node</code> | 

<a name="BasicLightingModel"></a>

## BasicLightingModel ⇐ <code>LightingModel</code>
Represents the lighting model for unlit materials. The only light contribution
is baked indirect lighting modulated with ambient occlusion and the material's
diffuse color. Environment mapping is supported. Used in [MeshBasicNodeMaterial](MeshBasicNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingModel</code>  

* [BasicLightingModel](#BasicLightingModel) ⇐ <code>LightingModel</code>
    * [new BasicLightingModel()](#new_BasicLightingModel_new)
    * [.indirect(builder)](#BasicLightingModel+indirect)
    * [.finish(builder)](#BasicLightingModel+finish)

<a name="new_BasicLightingModel_new"></a>

### new BasicLightingModel()
Constructs a new basic lighting model.

<a name="BasicLightingModel+indirect"></a>

### basicLightingModel.indirect(builder)
Implements the baked indirect lighting with its modulation.

**Kind**: instance method of [<code>BasicLightingModel</code>](#BasicLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BasicLightingModel+finish"></a>

### basicLightingModel.finish(builder)
Implements the environment mapping.

**Kind**: instance method of [<code>BasicLightingModel</code>](#BasicLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhongLightingModel"></a>

## PhongLightingModel ⇐ <code>BasicLightingModel</code>
Represents the lighting model for a phong material. Used in [MeshPhongNodeMaterial](MeshPhongNodeMaterial).

**Kind**: global class  
**Extends**: <code>BasicLightingModel</code>  

* [PhongLightingModel](#PhongLightingModel) ⇐ <code>BasicLightingModel</code>
    * [new PhongLightingModel([specular])](#new_PhongLightingModel_new)
    * [.specular](#PhongLightingModel+specular) : <code>boolean</code>
    * [.direct(lightData)](#PhongLightingModel+direct)
    * [.indirect(builder)](#PhongLightingModel+indirect)

<a name="new_PhongLightingModel_new"></a>

### new PhongLightingModel([specular])
Constructs a new phong lighting model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [specular] | <code>boolean</code> | <code>true</code> | Whether specular is supported or not. |

<a name="PhongLightingModel+specular"></a>

### phongLightingModel.specular : <code>boolean</code>
Whether specular is supported or not. Set this to `false` if you are
looking for a Lambert-like material meaning a material for non-shiny
surfaces, without specular highlights.

**Kind**: instance property of [<code>PhongLightingModel</code>](#PhongLightingModel)  
**Default**: <code>true</code>  
<a name="PhongLightingModel+direct"></a>

### phongLightingModel.direct(lightData)
Implements the direct lighting. The specular portion is optional an can be controlled
with the [specular](#PhongLightingModel+specular) flag.

**Kind**: instance method of [<code>PhongLightingModel</code>](#PhongLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |

<a name="PhongLightingModel+indirect"></a>

### phongLightingModel.indirect(builder)
Implements the indirect lighting.

**Kind**: instance method of [<code>PhongLightingModel</code>](#PhongLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel"></a>

## PhysicalLightingModel ⇐ <code>LightingModel</code>
Represents the lighting model for a PBR material.

**Kind**: global class  
**Extends**: <code>LightingModel</code>  

* [PhysicalLightingModel](#PhysicalLightingModel) ⇐ <code>LightingModel</code>
    * [new PhysicalLightingModel([clearcoat], [sheen], [iridescence], [anisotropy], [transmission], [dispersion])](#new_PhysicalLightingModel_new)
    * [.clearcoat](#PhysicalLightingModel+clearcoat) : <code>boolean</code>
    * [.sheen](#PhysicalLightingModel+sheen) : <code>boolean</code>
    * [.iridescence](#PhysicalLightingModel+iridescence) : <code>boolean</code>
    * [.anisotropy](#PhysicalLightingModel+anisotropy) : <code>boolean</code>
    * [.transmission](#PhysicalLightingModel+transmission) : <code>boolean</code>
    * [.dispersion](#PhysicalLightingModel+dispersion) : <code>boolean</code>
    * [.clearcoatRadiance](#PhysicalLightingModel+clearcoatRadiance) : <code>Node</code>
    * [.clearcoatSpecularDirect](#PhysicalLightingModel+clearcoatSpecularDirect) : <code>Node</code>
    * [.clearcoatSpecularIndirect](#PhysicalLightingModel+clearcoatSpecularIndirect) : <code>Node</code>
    * [.sheenSpecularDirect](#PhysicalLightingModel+sheenSpecularDirect) : <code>Node</code>
    * [.sheenSpecularIndirect](#PhysicalLightingModel+sheenSpecularIndirect) : <code>Node</code>
    * [.iridescenceFresnel](#PhysicalLightingModel+iridescenceFresnel) : <code>Node</code>
    * [.iridescenceF0](#PhysicalLightingModel+iridescenceF0) : <code>Node</code>
    * [.start(builder)](#PhysicalLightingModel+start)
    * [.direct(lightData, builder)](#PhysicalLightingModel+direct)
    * [.directRectArea(input, builder)](#PhysicalLightingModel+directRectArea)
    * [.indirect(builder)](#PhysicalLightingModel+indirect)
    * [.indirectDiffuse(builder)](#PhysicalLightingModel+indirectDiffuse)
    * [.indirectSpecular(builder)](#PhysicalLightingModel+indirectSpecular)
    * [.ambientOcclusion(builder)](#PhysicalLightingModel+ambientOcclusion)
    * [.finish(builder)](#PhysicalLightingModel+finish)

<a name="new_PhysicalLightingModel_new"></a>

### new PhysicalLightingModel([clearcoat], [sheen], [iridescence], [anisotropy], [transmission], [dispersion])
Constructs a new physical lighting model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [clearcoat] | <code>boolean</code> | <code>false</code> | Whether clearcoat is supported or not. |
| [sheen] | <code>boolean</code> | <code>false</code> | Whether sheen is supported or not. |
| [iridescence] | <code>boolean</code> | <code>false</code> | Whether iridescence is supported or not. |
| [anisotropy] | <code>boolean</code> | <code>false</code> | Whether anisotropy is supported or not. |
| [transmission] | <code>boolean</code> | <code>false</code> | Whether transmission is supported or not. |
| [dispersion] | <code>boolean</code> | <code>false</code> | Whether dispersion is supported or not. |

<a name="PhysicalLightingModel+clearcoat"></a>

### physicalLightingModel.clearcoat : <code>boolean</code>
Whether clearcoat is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+sheen"></a>

### physicalLightingModel.sheen : <code>boolean</code>
Whether sheen is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+iridescence"></a>

### physicalLightingModel.iridescence : <code>boolean</code>
Whether iridescence is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+anisotropy"></a>

### physicalLightingModel.anisotropy : <code>boolean</code>
Whether anisotropy is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+transmission"></a>

### physicalLightingModel.transmission : <code>boolean</code>
Whether transmission is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+dispersion"></a>

### physicalLightingModel.dispersion : <code>boolean</code>
Whether dispersion is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+clearcoatRadiance"></a>

### physicalLightingModel.clearcoatRadiance : <code>Node</code>
The clear coat radiance.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+clearcoatSpecularDirect"></a>

### physicalLightingModel.clearcoatSpecularDirect : <code>Node</code>
The clear coat specular direct.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+clearcoatSpecularIndirect"></a>

### physicalLightingModel.clearcoatSpecularIndirect : <code>Node</code>
The clear coat specular indirect.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+sheenSpecularDirect"></a>

### physicalLightingModel.sheenSpecularDirect : <code>Node</code>
The sheen specular direct.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+sheenSpecularIndirect"></a>

### physicalLightingModel.sheenSpecularIndirect : <code>Node</code>
The sheen specular indirect.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+iridescenceFresnel"></a>

### physicalLightingModel.iridescenceFresnel : <code>Node</code>
The iridescence Fresnel.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+iridescenceF0"></a>

### physicalLightingModel.iridescenceF0 : <code>Node</code>
The iridescence F0.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+start"></a>

### physicalLightingModel.start(builder)
Depending on what features are requested, the method prepares certain node variables
which are later used for lighting computations.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+direct"></a>

### physicalLightingModel.direct(lightData, builder)
Implements the direct light.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+directRectArea"></a>

### physicalLightingModel.directRectArea(input, builder)
This method is intended for implementing the direct light term for
rect area light nodes.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Object</code> | The input data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+indirect"></a>

### physicalLightingModel.indirect(builder)
Implements the indirect lighting.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+indirectDiffuse"></a>

### physicalLightingModel.indirectDiffuse(builder)
Implements the indirect diffuse term.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+indirectSpecular"></a>

### physicalLightingModel.indirectSpecular(builder)
Implements the indirect specular term.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+ambientOcclusion"></a>

### physicalLightingModel.ambientOcclusion(builder)
Implements the ambient occlusion term.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+finish"></a>

### physicalLightingModel.finish(builder)
Used for final lighting accumulations depending on the requested features.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ShadowMaskModel"></a>

## ShadowMaskModel ⇐ <code>LightingModel</code>
Represents lighting model for a shadow material. Used in [ShadowNodeMaterial](ShadowNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingModel</code>  

* [ShadowMaskModel](#ShadowMaskModel) ⇐ <code>LightingModel</code>
    * [new ShadowMaskModel()](#new_ShadowMaskModel_new)
    * [.shadowNode](#ShadowMaskModel+shadowNode) : <code>Node</code>
    * [.direct(input)](#ShadowMaskModel+direct)
    * [.finish(builder)](#ShadowMaskModel+finish)

<a name="new_ShadowMaskModel_new"></a>

### new ShadowMaskModel()
Constructs a new shadow mask model.

<a name="ShadowMaskModel+shadowNode"></a>

### shadowMaskModel.shadowNode : <code>Node</code>
The shadow mask node.

**Kind**: instance property of [<code>ShadowMaskModel</code>](#ShadowMaskModel)  
<a name="ShadowMaskModel+direct"></a>

### shadowMaskModel.direct(input)
Only used to save the shadow mask.

**Kind**: instance method of [<code>ShadowMaskModel</code>](#ShadowMaskModel)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Object</code> | The input data. |

<a name="ShadowMaskModel+finish"></a>

### shadowMaskModel.finish(builder)
Uses the shadow mask to produce the final color.

**Kind**: instance method of [<code>ShadowMaskModel</code>](#ShadowMaskModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ToonLightingModel"></a>

## ToonLightingModel ⇐ <code>LightingModel</code>
Represents the lighting model for a toon material. Used in [MeshToonNodeMaterial](MeshToonNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingModel</code>  

* [ToonLightingModel](#ToonLightingModel) ⇐ <code>LightingModel</code>
    * [.direct(lightData, builder)](#ToonLightingModel+direct)
    * [.indirect(builder)](#ToonLightingModel+indirect)

<a name="ToonLightingModel+direct"></a>

### toonLightingModel.direct(lightData, builder)
Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
reduced to a small number of discrete shades to create a comic-like, flat look.

**Kind**: instance method of [<code>ToonLightingModel</code>](#ToonLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ToonLightingModel+indirect"></a>

### toonLightingModel.indirect(builder)
Implements the indirect lighting.

**Kind**: instance method of [<code>ToonLightingModel</code>](#ToonLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="VolumetricLightingModel"></a>

## VolumetricLightingModel ⇐ <code>LightingModel</code>
VolumetricLightingModel class extends the LightingModel to implement volumetric lighting effects.
This model calculates the scattering and transmittance of light through a volumetric medium.
It dynamically adjusts the direction of the ray based on the camera and object positions.
The model supports custom scattering and depth nodes to enhance the lighting effects.

**Kind**: global class  
**Extends**: <code>LightingModel</code>  
<a name="getParallaxCorrectNormal"></a>

## getParallaxCorrectNormal(normal, cubeSize, cubePos) ⇒ <code>Node.&lt;vec3&gt;</code>
This computes a parallax corrected normal which is used for box-projected cube mapping (BPCEM).

Reference: [https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html](https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html)

```js
const uvNode = getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) );
material.envNode = pmremTexture( renderTarget.texture, uvNode );
```

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The parallax corrected normal.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Node.&lt;vec3&gt;</code> | The normal to correct. |
| cubeSize | <code>Node.&lt;vec3&gt;</code> | The cube size should reflect the size of the environment (BPCEM is usually applied in closed environments like rooms). |
| cubePos | <code>Node.&lt;vec3&gt;</code> | The cube position. |

## Classes

<dl>
<dt><a href="#RangeNode">RangeNode</a> ⇐ <code>Node</code></dt>
<dd><p><code>RangeNode</code> generates random instanced attribute data in a defined range.
An exemplary use case for this utility node is to generate random per-instance
colors:</p>
<pre><code class="language-js">const material = new MeshBasicNodeMaterial();
material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );
const mesh = new InstancedMesh( geometry, material, count );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#range">range([minNode], [maxNode])</a> ⇒ <code><a href="#RangeNode">RangeNode</a></code></dt>
<dd><p>TSL function for creating a range node.</p>
</dd>
</dl>

<a name="RangeNode"></a>

## RangeNode ⇐ <code>Node</code>
`RangeNode` generates random instanced attribute data in a defined range.
An exemplary use case for this utility node is to generate random per-instance
colors:
```js
const material = new MeshBasicNodeMaterial();
material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );
const mesh = new InstancedMesh( geometry, material, count );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [RangeNode](#RangeNode) ⇐ <code>Node</code>
    * [new RangeNode([minNode], [maxNode])](#new_RangeNode_new)
    * [.minNode](#RangeNode+minNode) : <code>Node.&lt;any&gt;</code>
    * [.maxNode](#RangeNode+maxNode) : <code>Node.&lt;any&gt;</code>
    * [.getVectorLength(builder)](#RangeNode+getVectorLength) ⇒ <code>number</code>
    * [.getNodeType(builder)](#RangeNode+getNodeType) ⇒ <code>string</code>

<a name="new_RangeNode_new"></a>

### new RangeNode([minNode], [maxNode])
Constructs a new range node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [minNode] | <code>Node.&lt;any&gt;</code> | <code>float()</code> | A node defining the lower bound of the range. |
| [maxNode] | <code>Node.&lt;any&gt;</code> | <code>float()</code> | A node defining the upper bound of the range. |

<a name="RangeNode+minNode"></a>

### rangeNode.minNode : <code>Node.&lt;any&gt;</code>
A node defining the lower bound of the range.

**Kind**: instance property of [<code>RangeNode</code>](#RangeNode)  
**Default**: <code>float()</code>  
<a name="RangeNode+maxNode"></a>

### rangeNode.maxNode : <code>Node.&lt;any&gt;</code>
A node defining the upper bound of the range.

**Kind**: instance property of [<code>RangeNode</code>](#RangeNode)  
**Default**: <code>float()</code>  
<a name="RangeNode+getVectorLength"></a>

### rangeNode.getVectorLength(builder) ⇒ <code>number</code>
Returns the vector length which is computed based on the range definition.

**Kind**: instance method of [<code>RangeNode</code>](#RangeNode)  
**Returns**: <code>number</code> - The vector length.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="RangeNode+getNodeType"></a>

### rangeNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from range definition.

**Kind**: instance method of [<code>RangeNode</code>](#RangeNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="range"></a>

## range([minNode], [maxNode]) ⇒ [<code>RangeNode</code>](#RangeNode)
TSL function for creating a range node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [minNode] | <code>Node.&lt;any&gt;</code> | <code>float()</code> | A node defining the lower bound of the range. |
| [maxNode] | <code>Node.&lt;any&gt;</code> | <code>float()</code> | A node defining the upper bound of the range. |

## Classes

<dl>
<dt><a href="#AtomicFunctionNode">AtomicFunctionNode</a> ⇐ <code>TempNode</code></dt>
<dd><p><code>AtomicFunctionNode</code> represents any function that can operate on atomic variable types
within a shader. In an atomic function, any modification to an atomic variable will
occur as an indivisible step with a defined order relative to other modifications.
Accordingly, even if multiple atomic functions are modifying an atomic variable at once
atomic operations will not interfere with each other.</p>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#atomicNode">atomicNode(method, pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>TSL function for creating an atomic function node.</p>
</dd>
<dt><a href="#atomicFunc">atomicFunc(method, pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>TSL function for appending an atomic function call into the programmatic flow of a compute shader.</p>
</dd>
<dt><a href="#atomicLoad">atomicLoad(pointerNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Loads the value stored in the atomic variable.</p>
</dd>
<dt><a href="#atomicStore">atomicStore(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores a value in the atomic variable.</p>
</dd>
<dt><a href="#atomicAdd">atomicAdd(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Increments the value stored in the atomic variable.</p>
</dd>
<dt><a href="#atomicSub">atomicSub(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Decrements the value stored in the atomic variable.</p>
</dd>
<dt><a href="#atomicMax">atomicMax(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the maximum between its current value and a parameter.</p>
</dd>
<dt><a href="#atomicMin">atomicMin(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the minimum between its current value and a parameter.</p>
</dd>
<dt><a href="#atomicAnd">atomicAnd(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the bitwise AND of its value with a parameter.</p>
</dd>
<dt><a href="#atomicOr">atomicOr(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the bitwise OR of its value with a parameter.</p>
</dd>
<dt><a href="#atomicXor">atomicXor(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the bitwise XOR of its value with a parameter.</p>
</dd>
</dl>

<a name="AtomicFunctionNode"></a>

## AtomicFunctionNode ⇐ <code>TempNode</code>
`AtomicFunctionNode` represents any function that can operate on atomic variable types
within a shader. In an atomic function, any modification to an atomic variable will
occur as an indivisible step with a defined order relative to other modifications.
Accordingly, even if multiple atomic functions are modifying an atomic variable at once
atomic operations will not interfere with each other.

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [AtomicFunctionNode](#AtomicFunctionNode) ⇐ <code>TempNode</code>
    * [new AtomicFunctionNode(method, pointerNode, valueNode)](#new_AtomicFunctionNode_new)
    * [.method](#AtomicFunctionNode+method) : <code>string</code>
    * [.pointerNode](#AtomicFunctionNode+pointerNode) : <code>Node</code>
    * [.valueNode](#AtomicFunctionNode+valueNode) : <code>Node</code>
    * [.getInputType(builder)](#AtomicFunctionNode+getInputType) ⇒ <code>string</code>
    * [.getNodeType(builder)](#AtomicFunctionNode+getNodeType) ⇒ <code>string</code>

<a name="new_AtomicFunctionNode_new"></a>

### new AtomicFunctionNode(method, pointerNode, valueNode)
Constructs a new atomic function node.


| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The signature of the atomic function to construct. |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="AtomicFunctionNode+method"></a>

### atomicFunctionNode.method : <code>string</code>
The signature of the atomic function to construct.

**Kind**: instance property of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
<a name="AtomicFunctionNode+pointerNode"></a>

### atomicFunctionNode.pointerNode : <code>Node</code>
An atomic variable or element of an atomic buffer.

**Kind**: instance property of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
<a name="AtomicFunctionNode+valueNode"></a>

### atomicFunctionNode.valueNode : <code>Node</code>
A value that modifies the atomic variable.

**Kind**: instance property of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
<a name="AtomicFunctionNode+getInputType"></a>

### atomicFunctionNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return the type of
the pointer node.

**Kind**: instance method of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AtomicFunctionNode+getNodeType"></a>

### atomicFunctionNode.getNodeType(builder) ⇒ <code>string</code>
Overwritten since the node type is inferred from the input type.

**Kind**: instance method of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="atomicNode"></a>

## atomicNode(method, pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
TSL function for creating an atomic function node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The signature of the atomic function to construct. |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicFunc"></a>

## atomicFunc(method, pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
TSL function for appending an atomic function call into the programmatic flow of a compute shader.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The signature of the atomic function to construct. |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicLoad"></a>

## atomicLoad(pointerNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Loads the value stored in the atomic variable.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |

<a name="atomicStore"></a>

## atomicStore(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores a value in the atomic variable.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicAdd"></a>

## atomicAdd(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Increments the value stored in the atomic variable.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicSub"></a>

## atomicSub(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Decrements the value stored in the atomic variable.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicMax"></a>

## atomicMax(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the maximum between its current value and a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicMin"></a>

## atomicMin(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the minimum between its current value and a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicAnd"></a>

## atomicAnd(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the bitwise AND of its value with a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicOr"></a>

## atomicOr(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the bitwise OR of its value with a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicXor"></a>

## atomicXor(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the bitwise XOR of its value with a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

## Classes

<dl>
<dt><a href="#BarrierNode">BarrierNode</a> ⇐ <code>Node</code></dt>
<dd><p>Represents a GPU control barrier that synchronizes compute operations within a given scope.</p>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#barrier">barrier(scope)</a> ⇒ <code><a href="#BarrierNode">BarrierNode</a></code></dt>
<dd><p>TSL function for creating a barrier node.</p>
</dd>
<dt><a href="#workgroupBarrier">workgroupBarrier()</a> ⇒ <code><a href="#BarrierNode">BarrierNode</a></code></dt>
<dd><p>TSL function for creating a workgroup barrier. All compute shader
invocations must wait for each invocation within a workgroup to
complete before the barrier can be surpassed.</p>
</dd>
<dt><a href="#storageBarrier">storageBarrier()</a> ⇒ <code><a href="#BarrierNode">BarrierNode</a></code></dt>
<dd><p>TSL function for creating a storage barrier. All invocations must
wait for each access to variables within the &#39;storage&#39; address space
to complete before the barrier can be passed.</p>
</dd>
<dt><a href="#textureBarrier">textureBarrier()</a> ⇒ <code><a href="#BarrierNode">BarrierNode</a></code></dt>
<dd><p>TSL function for creating a texture barrier. All invocations must
wait for each access to variables within the &#39;texture&#39; address space
to complete before the barrier can be passed.</p>
</dd>
</dl>

<a name="BarrierNode"></a>

## BarrierNode ⇐ <code>Node</code>
Represents a GPU control barrier that synchronizes compute operations within a given scope.

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>Node</code>  
<a name="new_BarrierNode_new"></a>

### new BarrierNode(scope)
Constructs a new barrier node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>string</code> | The scope defines the behavior of the node. |

<a name="barrier"></a>

## barrier(scope) ⇒ [<code>BarrierNode</code>](#BarrierNode)
TSL function for creating a barrier node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scope | <code>string</code> | The scope defines the behavior of the node.. |

<a name="workgroupBarrier"></a>

## workgroupBarrier() ⇒ [<code>BarrierNode</code>](#BarrierNode)
TSL function for creating a workgroup barrier. All compute shader
invocations must wait for each invocation within a workgroup to
complete before the barrier can be surpassed.

**Kind**: global function  
**Tsl**:   
<a name="storageBarrier"></a>

## storageBarrier() ⇒ [<code>BarrierNode</code>](#BarrierNode)
TSL function for creating a storage barrier. All invocations must
wait for each access to variables within the 'storage' address space
to complete before the barrier can be passed.

**Kind**: global function  
**Tsl**:   
<a name="textureBarrier"></a>

## textureBarrier() ⇒ [<code>BarrierNode</code>](#BarrierNode)
TSL function for creating a texture barrier. All invocations must
wait for each access to variables within the 'texture' address space
to complete before the barrier can be passed.

**Kind**: global function  
**Tsl**:   
## Classes

<dl>
<dt><a href="#ComputeBuiltinNode">ComputeBuiltinNode</a> ⇐ <code>Node</code></dt>
<dd><p><code>ComputeBuiltinNode</code> represents a compute-scope builtin value that expose information
about the currently running dispatch and/or the device it is running on.</p>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#numWorkgroups">numWorkgroups</a> : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code></dt>
<dd><p>Represents the number of workgroups dispatched by the compute shader.</p>
<pre><code class="language-js">// Run 512 invocations/threads with a workgroup size of 128.
const computeFn = Fn(() =&gt; {

    // numWorkgroups.x = 4
    storageBuffer.element(0).assign(numWorkgroups.x)

})().compute(512, [128]);

// Run 512 invocations/threads with the default workgroup size of 64.
const computeFn = Fn(() =&gt; {

    // numWorkgroups.x = 8
    storageBuffer.element(0).assign(numWorkgroups.x)

})().compute(512);
</code></pre>
</dd>
<dt><a href="#workgroupId">workgroupId</a> : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code></dt>
<dd><p>Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.</p>
<pre><code class="language-js">// Execute 12 compute threads with a workgroup size of 3.
const computeFn = Fn( () =&gt; {

    If( workgroupId.x.mod( 2 ).equal( 0 ), () =&gt; {

        storageBuffer.element( instanceIndex ).assign( instanceIndex );

    } ).Else( () =&gt; {

        storageBuffer.element( instanceIndex ).assign( 0 );

    } );

} )().compute( 12, [ 3 ] );

// workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];
// Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];
</code></pre>
</dd>
<dt><a href="#globalId">globalId</a> : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code></dt>
<dd><p>A non-linearized 3-dimensional representation of the current invocation&#39;s position within a 3D global grid.</p>
</dd>
<dt><a href="#localId">localId</a> : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code></dt>
<dd><p>A non-linearized 3-dimensional representation of the current invocation&#39;s position within a 3D workgroup grid.</p>
</dd>
<dt><a href="#subgroupSize">subgroupSize</a> : <code>ComputeBuiltinNode.&lt;uint&gt;</code></dt>
<dd><p>A device dependent variable that exposes the size of the current invocation&#39;s subgroup.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#computeBuiltin">computeBuiltin(name, nodeType)</a> ⇒ <code><a href="#ComputeBuiltinNode">ComputeBuiltinNode</a></code></dt>
<dd><p>TSL function for creating a compute builtin node.</p>
</dd>
</dl>

<a name="ComputeBuiltinNode"></a>

## ComputeBuiltinNode ⇐ <code>Node</code>
`ComputeBuiltinNode` represents a compute-scope builtin value that expose information
about the currently running dispatch and/or the device it is running on.

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ComputeBuiltinNode](#ComputeBuiltinNode) ⇐ <code>Node</code>
    * [new ComputeBuiltinNode(builtinName, nodeType)](#new_ComputeBuiltinNode_new)
    * [.getHash(builder)](#ComputeBuiltinNode+getHash) ⇒ <code>string</code>
    * [.getNodeType(builder)](#ComputeBuiltinNode+getNodeType) ⇒ <code>string</code>
    * [.setBuiltinName(builtinName)](#ComputeBuiltinNode+setBuiltinName) ⇒ [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)
    * [.getBuiltinName(builder)](#ComputeBuiltinNode+getBuiltinName) ⇒ <code>string</code>
    * [.hasBuiltin(builder)](#ComputeBuiltinNode+hasBuiltin) ⇒ <code>boolean</code>

<a name="new_ComputeBuiltinNode_new"></a>

### new ComputeBuiltinNode(builtinName, nodeType)
Constructs a new compute builtin node.


| Param | Type | Description |
| --- | --- | --- |
| builtinName | <code>string</code> | The built-in name. |
| nodeType | <code>string</code> | The node type. |

<a name="ComputeBuiltinNode+getHash"></a>

### computeBuiltinNode.getHash(builder) ⇒ <code>string</code>
This method is overwritten since hash is derived from the built-in name.

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: <code>string</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ComputeBuiltinNode+getNodeType"></a>

### computeBuiltinNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is simply derived from `nodeType`..

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ComputeBuiltinNode+setBuiltinName"></a>

### computeBuiltinNode.setBuiltinName(builtinName) ⇒ [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)
Sets the builtin name.

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| builtinName | <code>string</code> | The built-in name. |

<a name="ComputeBuiltinNode+getBuiltinName"></a>

### computeBuiltinNode.getBuiltinName(builder) ⇒ <code>string</code>
Returns the builtin name.

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: <code>string</code> - The builtin name.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ComputeBuiltinNode+hasBuiltin"></a>

### computeBuiltinNode.hasBuiltin(builder) ⇒ <code>boolean</code>
Whether the current node builder has the builtin or not.

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: <code>boolean</code> - Whether the builder has the builtin or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="numWorkgroups"></a>

## numWorkgroups : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code>
Represents the number of workgroups dispatched by the compute shader.
```js
// Run 512 invocations/threads with a workgroup size of 128.
const computeFn = Fn(() => {

    // numWorkgroups.x = 4
    storageBuffer.element(0).assign(numWorkgroups.x)

})().compute(512, [128]);

// Run 512 invocations/threads with the default workgroup size of 64.
const computeFn = Fn(() => {

    // numWorkgroups.x = 8
    storageBuffer.element(0).assign(numWorkgroups.x)

})().compute(512);
```

**Kind**: global constant  
**Tsl**:   
<a name="workgroupId"></a>

## workgroupId : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code>
Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.
```js
// Execute 12 compute threads with a workgroup size of 3.
const computeFn = Fn( () => {

	If( workgroupId.x.mod( 2 ).equal( 0 ), () => {

		storageBuffer.element( instanceIndex ).assign( instanceIndex );

	} ).Else( () => {

		storageBuffer.element( instanceIndex ).assign( 0 );

	} );

} )().compute( 12, [ 3 ] );

// workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];
// Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];
```

**Kind**: global constant  
**Tsl**:   
<a name="globalId"></a>

## globalId : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code>
A non-linearized 3-dimensional representation of the current invocation's position within a 3D global grid.

**Kind**: global constant  
**Tsl**:   
<a name="localId"></a>

## localId : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code>
A non-linearized 3-dimensional representation of the current invocation's position within a 3D workgroup grid.

**Kind**: global constant  
**Tsl**:   
<a name="subgroupSize"></a>

## subgroupSize : <code>ComputeBuiltinNode.&lt;uint&gt;</code>
A device dependent variable that exposes the size of the current invocation's subgroup.

**Kind**: global constant  
**Tsl**:   
<a name="computeBuiltin"></a>

## computeBuiltin(name, nodeType) ⇒ [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)
TSL function for creating a compute builtin node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The built-in name. |
| nodeType | <code>string</code> | The node type. |

## Classes

<dl>
<dt><a href="#ComputeNode">ComputeNode</a> ⇐ <code>Node</code></dt>
<dd><p>TODO</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#compute">compute(node, count, [workgroupSize])</a> ⇒ <code>AtomicFunctionNode</code></dt>
<dd><p>TSL function for creating a compute node.</p>
</dd>
</dl>

<a name="ComputeNode"></a>

## ComputeNode ⇐ <code>Node</code>
TODO

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ComputeNode](#ComputeNode) ⇐ <code>Node</code>
    * [new ComputeNode(computeNode, count, [workgroupSize])](#new_ComputeNode_new)
    * [.isComputeNode](#ComputeNode+isComputeNode) : <code>boolean</code>
    * [.computeNode](#ComputeNode+computeNode) : <code>Node</code>
    * [.count](#ComputeNode+count) : <code>number</code>
    * [.workgroupSize](#ComputeNode+workgroupSize) : <code>Array.&lt;number&gt;</code>
    * [.dispatchCount](#ComputeNode+dispatchCount) : <code>number</code>
    * [.version](#ComputeNode+version) : <code>number</code>
    * [.name](#ComputeNode+name) : <code>string</code>
    * [.updateBeforeType](#ComputeNode+updateBeforeType) : <code>string</code>
    * [.onInitFunction](#ComputeNode+onInitFunction) : <code>function</code>
    * [.dispose()](#ComputeNode+dispose)
    * [.label(name)](#ComputeNode+label) ⇒ [<code>ComputeNode</code>](#ComputeNode)
    * [.updateDispatchCount()](#ComputeNode+updateDispatchCount)
    * [.onInit(callback)](#ComputeNode+onInit) ⇒ [<code>ComputeNode</code>](#ComputeNode)
    * [.updateBefore(frame)](#ComputeNode+updateBefore)

<a name="new_ComputeNode_new"></a>

### new ComputeNode(computeNode, count, [workgroupSize])
Constructs a new compute node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| computeNode | <code>Node</code> |  | TODO |
| count | <code>number</code> |  | TODO. |
| [workgroupSize] | <code>Array.&lt;number&gt;</code> | <code>[64]</code> | TODO. |

<a name="ComputeNode+isComputeNode"></a>

### computeNode.isComputeNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ComputeNode+computeNode"></a>

### computeNode.computeNode : <code>Node</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+count"></a>

### computeNode.count : <code>number</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+workgroupSize"></a>

### computeNode.workgroupSize : <code>Array.&lt;number&gt;</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
**Default**: <code>[64]</code>  
<a name="ComputeNode+dispatchCount"></a>

### computeNode.dispatchCount : <code>number</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+version"></a>

### computeNode.version : <code>number</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+name"></a>

### computeNode.name : <code>string</code>
The name or label of the uniform.

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="ComputeNode+updateBeforeType"></a>

### computeNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since [updateBefore](#ComputeNode+updateBefore)
is executed once per object by default.

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="ComputeNode+onInitFunction"></a>

### computeNode.onInitFunction : <code>function</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+dispose"></a>

### computeNode.dispose()
Executes the `dispose` event for this node.

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+label"></a>

### computeNode.label(name) ⇒ [<code>ComputeNode</code>](#ComputeNode)
Sets the [name](#ComputeNode+name) property.

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  
**Returns**: [<code>ComputeNode</code>](#ComputeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the uniform. |

<a name="ComputeNode+updateDispatchCount"></a>

### computeNode.updateDispatchCount()
TODO

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+onInit"></a>

### computeNode.onInit(callback) ⇒ [<code>ComputeNode</code>](#ComputeNode)
TODO

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  
**Returns**: [<code>ComputeNode</code>](#ComputeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | TODO. |

<a name="ComputeNode+updateBefore"></a>

### computeNode.updateBefore(frame)
The method execute the compute for this node.

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="compute"></a>

## compute(node, count, [workgroupSize]) ⇒ <code>AtomicFunctionNode</code>
TSL function for creating a compute node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | TODO |
| count | <code>number</code> |  | TODO. |
| [workgroupSize] | <code>Array.&lt;number&gt;</code> | <code>[64]</code> | TODO. |

## Classes

<dl>
<dt><a href="#WorkgroupInfoElementNode">WorkgroupInfoElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>Represents an element of a &#39;workgroup&#39; scoped buffer.</p>
</dd>
<dt><a href="#WorkgroupInfoNode">WorkgroupInfoNode</a> ⇐ <code>Node</code></dt>
<dd><p>A node allowing the user to create a &#39;workgroup&#39; scoped buffer within the
context of a compute shader. Typically, workgroup scoped buffers are
created to hold data that is transferred from a global storage scope into
a local workgroup scope. For invocations within a workgroup, data
access speeds on &#39;workgroup&#39; scoped buffers can be significantly faster
than similar access operations on globally accessible storage buffers.</p>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#workgroupArray">workgroupArray(type, [count])</a> ⇒ <code><a href="#WorkgroupInfoNode">WorkgroupInfoNode</a></code></dt>
<dd><p>TSL function for creating a workgroup info node.
Creates a new &#39;workgroup&#39; scoped array buffer.</p>
</dd>
</dl>

<a name="WorkgroupInfoElementNode"></a>

## WorkgroupInfoElementNode ⇐ <code>ArrayElementNode</code>
Represents an element of a 'workgroup' scoped buffer.

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [WorkgroupInfoElementNode](#WorkgroupInfoElementNode) ⇐ <code>ArrayElementNode</code>
    * [new WorkgroupInfoElementNode(workgroupInfoNode, indexNode)](#new_WorkgroupInfoElementNode_new)
    * [.isWorkgroupInfoElementNode](#WorkgroupInfoElementNode+isWorkgroupInfoElementNode) : <code>boolean</code>

<a name="new_WorkgroupInfoElementNode_new"></a>

### new WorkgroupInfoElementNode(workgroupInfoNode, indexNode)
Constructs a new workgroup info element node.


| Param | Type | Description |
| --- | --- | --- |
| workgroupInfoNode | <code>Node</code> | The workgroup info node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="WorkgroupInfoElementNode+isWorkgroupInfoElementNode"></a>

### workgroupInfoElementNode.isWorkgroupInfoElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WorkgroupInfoElementNode</code>](#WorkgroupInfoElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WorkgroupInfoNode"></a>

## WorkgroupInfoNode ⇐ <code>Node</code>
A node allowing the user to create a 'workgroup' scoped buffer within the
context of a compute shader. Typically, workgroup scoped buffers are
created to hold data that is transferred from a global storage scope into
a local workgroup scope. For invocations within a workgroup, data
access speeds on 'workgroup' scoped buffers can be significantly faster
than similar access operations on globally accessible storage buffers.

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [WorkgroupInfoNode](#WorkgroupInfoNode) ⇐ <code>Node</code>
    * [new WorkgroupInfoNode(scope, bufferType, [bufferCount])](#new_WorkgroupInfoNode_new)
    * [.bufferType](#WorkgroupInfoNode+bufferType) : <code>string</code>
    * [.bufferCount](#WorkgroupInfoNode+bufferCount) : <code>number</code>
    * [.isWorkgroupInfoNode](#WorkgroupInfoNode+isWorkgroupInfoNode) : <code>boolean</code>
    * [.elementType](#WorkgroupInfoNode+elementType) : <code>string</code>
    * [.scope](#WorkgroupInfoNode+scope) : <code>string</code>
    * [.label(name)](#WorkgroupInfoNode+label) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
    * [.setScope(scope)](#WorkgroupInfoNode+setScope) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
    * [.getElementType()](#WorkgroupInfoNode+getElementType) ⇒ <code>string</code>
    * [.getInputType(builder)](#WorkgroupInfoNode+getInputType) ⇒ <code>string</code>
    * [.element(indexNode)](#WorkgroupInfoNode+element) ⇒ [<code>WorkgroupInfoElementNode</code>](#WorkgroupInfoElementNode)

<a name="new_WorkgroupInfoNode_new"></a>

### new WorkgroupInfoNode(scope, bufferType, [bufferCount])
Constructs a new buffer scoped to type scope.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scope | <code>string</code> |  | TODO. |
| bufferType | <code>string</code> |  | The data type of a 'workgroup' scoped buffer element. |
| [bufferCount] | <code>number</code> | <code>0</code> | The number of elements in the buffer. |

<a name="WorkgroupInfoNode+bufferType"></a>

### workgroupInfoNode.bufferType : <code>string</code>
The buffer type.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
<a name="WorkgroupInfoNode+bufferCount"></a>

### workgroupInfoNode.bufferCount : <code>number</code>
The buffer count.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Default**: <code>0</code>  
<a name="WorkgroupInfoNode+isWorkgroupInfoNode"></a>

### workgroupInfoNode.isWorkgroupInfoNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WorkgroupInfoNode+elementType"></a>

### workgroupInfoNode.elementType : <code>string</code>
The data type of the array buffer.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
<a name="WorkgroupInfoNode+scope"></a>

### workgroupInfoNode.scope : <code>string</code>
TODO.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
<a name="WorkgroupInfoNode+label"></a>

### workgroupInfoNode.label(name) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
Sets the name/label of this node.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name to set. |

<a name="WorkgroupInfoNode+setScope"></a>

### workgroupInfoNode.setScope(scope) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
Sets the scope of this node.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| scope | <code>string</code> | The scope to set. |

<a name="WorkgroupInfoNode+getElementType"></a>

### workgroupInfoNode.getElementType() ⇒ <code>string</code>
The data type of the array buffer.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: <code>string</code> - The element type.  
<a name="WorkgroupInfoNode+getInputType"></a>

### workgroupInfoNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation since the input type
is inferred from the scope.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="WorkgroupInfoNode+element"></a>

### workgroupInfoNode.element(indexNode) ⇒ [<code>WorkgroupInfoElementNode</code>](#WorkgroupInfoElementNode)
This method can be used to access elements via an index node.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: [<code>WorkgroupInfoElementNode</code>](#WorkgroupInfoElementNode) - A reference to an element.  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | indexNode. |

<a name="workgroupArray"></a>

## workgroupArray(type, [count]) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
TSL function for creating a workgroup info node.
Creates a new 'workgroup' scoped array buffer.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The data type of a 'workgroup' scoped buffer element. |
| [count] | <code>number</code> | <code>0</code> | The number of elements in the buffer. |

<a name="AONode"></a>

## AONode ⇐ <code>LightingNode</code>
A generic class that can be used by nodes which contribute
ambient occlusion to the scene. E.g. an ambient occlusion map
node can be used as input for this module. Used in [NodeMaterial](NodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [AONode](#AONode) ⇐ <code>LightingNode</code>
    * [new AONode([aoNode])](#new_AONode_new)
    * [.aoNode](#AONode+aoNode) : <code>Node.&lt;float&gt;</code>

<a name="new_AONode_new"></a>

### new AONode([aoNode])
Constructs a new AO node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [aoNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The ambient occlusion node. |

<a name="AONode+aoNode"></a>

### aoNode.aoNode : <code>Node.&lt;float&gt;</code>
The ambient occlusion node.

**Kind**: instance property of [<code>AONode</code>](#AONode)  
**Default**: <code>null</code>  
<a name="AmbientLightNode"></a>

## AmbientLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing ambient lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  
<a name="new_AmbientLightNode_new"></a>

### new AmbientLightNode([light])
Constructs a new ambient light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>AmbientLight</code> | <code></code> | The ambient light source. |

<a name="AnalyticLightNode"></a>

## AnalyticLightNode ⇐ <code>LightingNode</code>
Base class for analytic light nodes.

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [AnalyticLightNode](#AnalyticLightNode) ⇐ <code>LightingNode</code>
    * [new AnalyticLightNode([light])](#new_AnalyticLightNode_new)
    * [.light](#AnalyticLightNode+light) : <code>Light</code>
    * [.color](#AnalyticLightNode+color) : <code>Color</code>
    * [.colorNode](#AnalyticLightNode+colorNode) : <code>Node</code>
    * [.baseColorNode](#AnalyticLightNode+baseColorNode) : <code>Node</code>
    * [.shadowNode](#AnalyticLightNode+shadowNode) : <code>ShadowNode</code>
    * [.shadowColorNode](#AnalyticLightNode+shadowColorNode) : <code>Node</code>
    * [.isAnalyticLightNode](#AnalyticLightNode+isAnalyticLightNode) : <code>boolean</code>
    * [.updateType](#AnalyticLightNode+updateType) : <code>string</code>
    * [.customCacheKey()](#AnalyticLightNode+customCacheKey) ⇒ <code>number</code>
    * *[.setupDirect(builder)](#AnalyticLightNode+setupDirect) ⇒ <code>Object</code> \| <code>undefined</code>*
    * *[.setupDirectRectArea(builder)](#AnalyticLightNode+setupDirectRectArea) ⇒ <code>Object</code> \| <code>undefined</code>*
    * [.setupShadowNode()](#AnalyticLightNode+setupShadowNode) ⇒ <code>ShadowNode</code>
    * [.setupShadow(builder)](#AnalyticLightNode+setupShadow)
    * [.setup(builder)](#AnalyticLightNode+setup)
    * [.update(frame)](#AnalyticLightNode+update)

<a name="new_AnalyticLightNode_new"></a>

### new AnalyticLightNode([light])
Constructs a new analytic light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>Light</code> | <code></code> | The light source. |

<a name="AnalyticLightNode+light"></a>

### analyticLightNode.light : <code>Light</code>
The light source.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>null</code>  
<a name="AnalyticLightNode+color"></a>

### analyticLightNode.color : <code>Color</code>
The light's color value.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
<a name="AnalyticLightNode+colorNode"></a>

### analyticLightNode.colorNode : <code>Node</code>
The light's color node. Points to `colorNode` of the light source, if set. Otherwise
it creates a uniform node based on [color](#AnalyticLightNode+color).

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
<a name="AnalyticLightNode+baseColorNode"></a>

### analyticLightNode.baseColorNode : <code>Node</code>
This property is used to retain a reference to the original value of [colorNode](#AnalyticLightNode+colorNode).
The final color node is represented by a different node when using shadows.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>null</code>  
<a name="AnalyticLightNode+shadowNode"></a>

### analyticLightNode.shadowNode : <code>ShadowNode</code>
Represents the light's shadow.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>null</code>  
<a name="AnalyticLightNode+shadowColorNode"></a>

### analyticLightNode.shadowColorNode : <code>Node</code>
Represents the light's shadow color.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>null</code>  
<a name="AnalyticLightNode+isAnalyticLightNode"></a>

### analyticLightNode.isAnalyticLightNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="AnalyticLightNode+updateType"></a>

### analyticLightNode.updateType : <code>string</code>
Overwritten since analytic light nodes are updated
once per frame.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="AnalyticLightNode+customCacheKey"></a>

### analyticLightNode.customCacheKey() ⇒ <code>number</code>
Overwrites the default [Node#customCacheKey](Node#customCacheKey) implementation by including the
`light.id` and `light.castShadow` into the cache key.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Returns**: <code>number</code> - The custom cache key.  
<a name="AnalyticLightNode+setupDirect"></a>

### *analyticLightNode.setupDirect(builder) ⇒ <code>Object</code> \| <code>undefined</code>*
Sets up the direct lighting for the analytic light node.

**Kind**: instance abstract method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Returns**: <code>Object</code> \| <code>undefined</code> - The direct light data (color and direction).  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The builder object used for setting up the light. |

<a name="AnalyticLightNode+setupDirectRectArea"></a>

### *analyticLightNode.setupDirectRectArea(builder) ⇒ <code>Object</code> \| <code>undefined</code>*
Sets up the direct rect area lighting for the analytic light node.

**Kind**: instance abstract method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Returns**: <code>Object</code> \| <code>undefined</code> - The direct rect area light data.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The builder object used for setting up the light. |

<a name="AnalyticLightNode+setupShadowNode"></a>

### analyticLightNode.setupShadowNode() ⇒ <code>ShadowNode</code>
Setups the shadow node for this light. The method exists so concrete light classes
can setup different types of shadow nodes.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Returns**: <code>ShadowNode</code> - The created shadow node.  
<a name="AnalyticLightNode+setupShadow"></a>

### analyticLightNode.setupShadow(builder)
Setups the shadow for this light. This method is only executed if the light
cast shadows and the current build object receives shadows. It incorporates
shadows into the lighting computation.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AnalyticLightNode+setup"></a>

### analyticLightNode.setup(builder)
Unlike most other nodes, lighting nodes do not return a output node in [Node#setup](Node#setup).
The main purpose of lighting nodes is to configure the current [LightingModel](LightingModel) and/or
invocate the respective interface methods.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AnalyticLightNode+update"></a>

### analyticLightNode.update(frame)
The update method is used to update light uniforms per frame.
Potentially overwritten in concrete light nodes to update light
specific uniforms.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="BasicEnvironmentNode"></a>

## BasicEnvironmentNode ⇐ <code>LightingNode</code>
Represents a basic model for Image-based lighting (IBL). The environment
is defined via environment maps in the equirectangular or cube map format.
`BasicEnvironmentNode` is intended for non-PBR materials like [MeshBasicNodeMaterial](MeshBasicNodeMaterial)
or [MeshPhongNodeMaterial](MeshPhongNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [BasicEnvironmentNode](#BasicEnvironmentNode) ⇐ <code>LightingNode</code>
    * [new BasicEnvironmentNode([envNode])](#new_BasicEnvironmentNode_new)
    * [.envNode](#BasicEnvironmentNode+envNode) : <code>Node</code>

<a name="new_BasicEnvironmentNode_new"></a>

### new BasicEnvironmentNode([envNode])
Constructs a new basic environment node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [envNode] | <code>Node</code> | <code></code> | A node representing the environment. |

<a name="BasicEnvironmentNode+envNode"></a>

### basicEnvironmentNode.envNode : <code>Node</code>
A node representing the environment.

**Kind**: instance property of [<code>BasicEnvironmentNode</code>](#BasicEnvironmentNode)  
**Default**: <code>null</code>  
<a name="BasicLightMapNode"></a>

## BasicLightMapNode ⇐ <code>LightingNode</code>
A specific version of [IrradianceNode](IrradianceNode) that is only relevant
for [MeshBasicNodeMaterial](MeshBasicNodeMaterial). Since the material is unlit, it
requires a special scaling factor for the light map.

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [BasicLightMapNode](#BasicLightMapNode) ⇐ <code>LightingNode</code>
    * [new BasicLightMapNode([lightMapNode])](#new_BasicLightMapNode_new)
    * [.lightMapNode](#BasicLightMapNode+lightMapNode) : <code>Node.&lt;vec3&gt;</code>

<a name="new_BasicLightMapNode_new"></a>

### new BasicLightMapNode([lightMapNode])
Constructs a new basic light map node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [lightMapNode] | <code>Node.&lt;vec3&gt;</code> | <code></code> | The light map node. |

<a name="BasicLightMapNode+lightMapNode"></a>

### basicLightMapNode.lightMapNode : <code>Node.&lt;vec3&gt;</code>
The light map node.

**Kind**: instance property of [<code>BasicLightMapNode</code>](#BasicLightMapNode)  
<a name="DirectionalLightNode"></a>

## DirectionalLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing directional lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  
<a name="new_DirectionalLightNode_new"></a>

### new DirectionalLightNode([light])
Constructs a new directional light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>DirectionalLight</code> | <code></code> | The directional light source. |

<a name="EnvironmentNode"></a>

## EnvironmentNode ⇐ <code>LightingNode</code>
Represents a physical model for Image-based lighting (IBL). The environment
is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.
`EnvironmentNode` is intended for PBR materials like [MeshStandardNodeMaterial](MeshStandardNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [EnvironmentNode](#EnvironmentNode) ⇐ <code>LightingNode</code>
    * [new EnvironmentNode([envNode])](#new_EnvironmentNode_new)
    * [.envNode](#EnvironmentNode+envNode) : <code>Node</code>

<a name="new_EnvironmentNode_new"></a>

### new EnvironmentNode([envNode])
Constructs a new environment node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [envNode] | <code>Node</code> | <code></code> | A node representing the environment. |

<a name="EnvironmentNode+envNode"></a>

### environmentNode.envNode : <code>Node</code>
A node representing the environment.

**Kind**: instance property of [<code>EnvironmentNode</code>](#EnvironmentNode)  
**Default**: <code>null</code>  
<a name="HemisphereLightNode"></a>

## HemisphereLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing hemisphere lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [HemisphereLightNode](#HemisphereLightNode) ⇐ <code>AnalyticLightNode</code>
    * [new HemisphereLightNode([light])](#new_HemisphereLightNode_new)
    * [.lightPositionNode](#HemisphereLightNode+lightPositionNode) : <code>UniformNode.&lt;vec3&gt;</code>
    * [.lightDirectionNode](#HemisphereLightNode+lightDirectionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.groundColorNode](#HemisphereLightNode+groundColorNode) : <code>UniformNode.&lt;vec3&gt;</code>
    * [.update(frame)](#HemisphereLightNode+update)

<a name="new_HemisphereLightNode_new"></a>

### new HemisphereLightNode([light])
Constructs a new hemisphere light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>HemisphereLight</code> | <code></code> | The hemisphere light source. |

<a name="HemisphereLightNode+lightPositionNode"></a>

### hemisphereLightNode.lightPositionNode : <code>UniformNode.&lt;vec3&gt;</code>
Uniform node representing the light's position.

**Kind**: instance property of [<code>HemisphereLightNode</code>](#HemisphereLightNode)  
<a name="HemisphereLightNode+lightDirectionNode"></a>

### hemisphereLightNode.lightDirectionNode : <code>Node.&lt;vec3&gt;</code>
A node representing the light's direction.

**Kind**: instance property of [<code>HemisphereLightNode</code>](#HemisphereLightNode)  
<a name="HemisphereLightNode+groundColorNode"></a>

### hemisphereLightNode.groundColorNode : <code>UniformNode.&lt;vec3&gt;</code>
Uniform node representing the light's ground color.

**Kind**: instance property of [<code>HemisphereLightNode</code>](#HemisphereLightNode)  
<a name="HemisphereLightNode+update"></a>

### hemisphereLightNode.update(frame)
Overwritten to updated hemisphere light specific uniforms.

**Kind**: instance method of [<code>HemisphereLightNode</code>](#HemisphereLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="IESSpotLightNode"></a>

## IESSpotLightNode ⇐ <code>SpotLightNode</code>
An IES version of the default spot light node.

**Kind**: global class  
**Extends**: <code>SpotLightNode</code>  
<a name="IESSpotLightNode+getSpotAttenuation"></a>

### iesSpotLightNode.getSpotAttenuation(angleCosine) ⇒ <code>Node.&lt;float&gt;</code>
Overwrites the default implementation to compute an IES conform spot attenuation.

**Kind**: instance method of [<code>IESSpotLightNode</code>](#IESSpotLightNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The spot attenuation.  

| Param | Type | Description |
| --- | --- | --- |
| angleCosine | <code>Node.&lt;float&gt;</code> | The angle to compute the spot attenuation for. |

<a name="IrradianceNode"></a>

## IrradianceNode ⇐ <code>LightingNode</code>
A generic class that can be used by nodes which contribute
irradiance to the scene. E.g. a light map node can be used
as input for this module. Used in [NodeMaterial](NodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [IrradianceNode](#IrradianceNode) ⇐ <code>LightingNode</code>
    * [new IrradianceNode(node)](#new_IrradianceNode_new)
    * [.node](#IrradianceNode+node) : <code>Node.&lt;vec3&gt;</code>

<a name="new_IrradianceNode_new"></a>

### new IrradianceNode(node)
Constructs a new irradiance node.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> | A node contributing irradiance. |

<a name="IrradianceNode+node"></a>

### irradianceNode.node : <code>Node.&lt;vec3&gt;</code>
A node contributing irradiance.

**Kind**: instance property of [<code>IrradianceNode</code>](#IrradianceNode)  
<a name="LightProbeNode"></a>

## LightProbeNode ⇐ <code>AnalyticLightNode</code>
Module for representing light probes as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [LightProbeNode](#LightProbeNode) ⇐ <code>AnalyticLightNode</code>
    * [new LightProbeNode([light])](#new_LightProbeNode_new)
    * [.lightProbe](#LightProbeNode+lightProbe) : <code>UniformArrayNode</code>
    * [.update(frame)](#LightProbeNode+update)

<a name="new_LightProbeNode_new"></a>

### new LightProbeNode([light])
Constructs a new light probe node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>LightProbe</code> | <code></code> | The light probe. |

<a name="LightProbeNode+lightProbe"></a>

### lightProbeNode.lightProbe : <code>UniformArrayNode</code>
Light probe represented as a uniform of spherical harmonics.

**Kind**: instance property of [<code>LightProbeNode</code>](#LightProbeNode)  
<a name="LightProbeNode+update"></a>

### lightProbeNode.update(frame)
Overwritten to updated light probe specific uniforms.

**Kind**: instance method of [<code>LightProbeNode</code>](#LightProbeNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="getDistanceAttenuation"></a>

## getDistanceAttenuation(inputs) ⇒ <code>Node.&lt;float&gt;</code>
Represents a `discard` shader operation in TSL.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The distance falloff.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.lightDistance | <code>Node.&lt;float&gt;</code> | The distance of the light's position to the current fragment position. |
| inputs.cutoffDistance | <code>Node.&lt;float&gt;</code> | The light's cutoff distance. |
| inputs.decayExponent | <code>Node.&lt;float&gt;</code> | The light's decay exponent. |

<a name="LightingContextNode"></a>

## LightingContextNode ⇐ <code>ContextNode</code>
`LightingContextNode` represents an extension of the [ContextNode](ContextNode) module
by adding lighting specific context data. It represents the runtime context of
[LightsNode](LightsNode).

**Kind**: global class  
**Extends**: <code>ContextNode</code>  

* [LightingContextNode](#LightingContextNode) ⇐ <code>ContextNode</code>
    * [new LightingContextNode(lightsNode, [lightingModel], [backdropNode], [backdropAlphaNode])](#new_LightingContextNode_new)
    * [.lightingModel](#LightingContextNode+lightingModel) : <code>LightingModel</code>
    * [.backdropNode](#LightingContextNode+backdropNode) : <code>Node.&lt;vec3&gt;</code>
    * [.backdropAlphaNode](#LightingContextNode+backdropAlphaNode) : <code>Node.&lt;float&gt;</code>
    * [.getContext()](#LightingContextNode+getContext) ⇒ <code>Object</code>

<a name="new_LightingContextNode_new"></a>

### new LightingContextNode(lightsNode, [lightingModel], [backdropNode], [backdropAlphaNode])
Constructs a new lighting context node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| lightsNode | <code>LightsNode</code> |  | The lights node. |
| [lightingModel] | <code>LightingModel</code> | <code></code> | The current lighting model. |
| [backdropNode] | <code>Node.&lt;vec3&gt;</code> | <code></code> | A backdrop node. |
| [backdropAlphaNode] | <code>Node.&lt;float&gt;</code> | <code></code> | A backdrop alpha node. |

<a name="LightingContextNode+lightingModel"></a>

### lightingContextNode.lightingModel : <code>LightingModel</code>
The current lighting model.

**Kind**: instance property of [<code>LightingContextNode</code>](#LightingContextNode)  
**Default**: <code>null</code>  
<a name="LightingContextNode+backdropNode"></a>

### lightingContextNode.backdropNode : <code>Node.&lt;vec3&gt;</code>
A backdrop node.

**Kind**: instance property of [<code>LightingContextNode</code>](#LightingContextNode)  
**Default**: <code>null</code>  
<a name="LightingContextNode+backdropAlphaNode"></a>

### lightingContextNode.backdropAlphaNode : <code>Node.&lt;float&gt;</code>
A backdrop alpha node.

**Kind**: instance property of [<code>LightingContextNode</code>](#LightingContextNode)  
**Default**: <code>null</code>  
<a name="LightingContextNode+getContext"></a>

### lightingContextNode.getContext() ⇒ <code>Object</code>
Returns a lighting context object.

**Kind**: instance method of [<code>LightingContextNode</code>](#LightingContextNode)  
**Returns**: <code>Object</code> - The lighting context object.  
<a name="LightingNode"></a>

## LightingNode ⇐ <code>Node</code>
Base class for lighting nodes.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [LightingNode](#LightingNode) ⇐ <code>Node</code>
    * [new LightingNode()](#new_LightingNode_new)
    * [.isLightingNode](#LightingNode+isLightingNode) : <code>boolean</code>

<a name="new_LightingNode_new"></a>

### new LightingNode()
Constructs a new lighting node.

<a name="LightingNode+isLightingNode"></a>

### lightingNode.isLightingNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LightingNode</code>](#LightingNode)  
**Default**: <code>true</code>  
**Read only**: true  
## Classes

<dl>
<dt><a href="#LightsNode">LightsNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node represents the scene&#39;s lighting and manages the lighting model&#39;s life cycle
for the current build 3D object. It is responsible for computing the total outgoing
light in a given lighting context.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#lights">lights(lights)</a> ⇒ <code><a href="#LightsNode">LightsNode</a></code></dt>
<dd><p>TSL function for creating an instance of <code>LightsNode</code> and configuring
it with the given array of lights.</p>
</dd>
</dl>

<a name="LightsNode"></a>

## LightsNode ⇐ <code>Node</code>
This node represents the scene's lighting and manages the lighting model's life cycle
for the current build 3D object. It is responsible for computing the total outgoing
light in a given lighting context.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [LightsNode](#LightsNode) ⇐ <code>Node</code>
    * [new LightsNode()](#new_LightsNode_new)
    * [.totalDiffuseNode](#LightsNode+totalDiffuseNode) : <code>Node.&lt;vec3&gt;</code>
    * [.totalSpecularNode](#LightsNode+totalSpecularNode) : <code>Node.&lt;vec3&gt;</code>
    * [.outgoingLightNode](#LightsNode+outgoingLightNode) : <code>Node.&lt;vec3&gt;</code>
    * [.global](#LightsNode+global) : <code>boolean</code>
    * [.hasLights](#LightsNode+hasLights) : <code>boolean</code>
    * [.customCacheKey()](#LightsNode+customCacheKey) ⇒ <code>number</code>
    * [.getHash(builder)](#LightsNode+getHash) ⇒ <code>string</code>
    * [.setupLightsNode(builder)](#LightsNode+setupLightsNode)
    * [.setupDirectLight(builder, lightNode, lightData)](#LightsNode+setupDirectLight)
    * [.setupLights(builder, lightNodes)](#LightsNode+setupLights)
    * [.setup(builder)](#LightsNode+setup) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setLights(lights)](#LightsNode+setLights) ⇒ [<code>LightsNode</code>](#LightsNode)
    * [.getLights()](#LightsNode+getLights) ⇒ <code>Array.&lt;Light&gt;</code>

<a name="new_LightsNode_new"></a>

### new LightsNode()
Constructs a new lights node.

<a name="LightsNode+totalDiffuseNode"></a>

### lightsNode.totalDiffuseNode : <code>Node.&lt;vec3&gt;</code>
A node representing the total diffuse light.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
<a name="LightsNode+totalSpecularNode"></a>

### lightsNode.totalSpecularNode : <code>Node.&lt;vec3&gt;</code>
A node representing the total specular light.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
<a name="LightsNode+outgoingLightNode"></a>

### lightsNode.outgoingLightNode : <code>Node.&lt;vec3&gt;</code>
A node representing the outgoing light.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
<a name="LightsNode+global"></a>

### lightsNode.global : <code>boolean</code>
`LightsNode` sets this property to `true` by default.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
**Default**: <code>true</code>  
<a name="LightsNode+hasLights"></a>

### lightsNode.hasLights : <code>boolean</code>
Whether the scene has lights or not.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
<a name="LightsNode+customCacheKey"></a>

### lightsNode.customCacheKey() ⇒ <code>number</code>
Overwrites the default [Node#customCacheKey](Node#customCacheKey) implementation by including the
light IDs into the cache key.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: <code>number</code> - The custom cache key.  
<a name="LightsNode+getHash"></a>

### lightsNode.getHash(builder) ⇒ <code>string</code>
Computes a hash value for identifying the current light nodes setup.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: <code>string</code> - The computed hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="LightsNode+setupLightsNode"></a>

### lightsNode.setupLightsNode(builder)
Creates lighting nodes for each scene light. This makes it possible to further
process lights in the node system.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="LightsNode+setupDirectLight"></a>

### lightsNode.setupDirectLight(builder, lightNode, lightData)
Sets up a direct light in the lighting model.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>Object</code> | The builder object containing the context and stack. |
| lightNode | <code>Object</code> | The light node. |
| lightData | <code>Object</code> | The light object containing color and direction properties. |

<a name="LightsNode+setupLights"></a>

### lightsNode.setupLights(builder, lightNodes)
Setups the internal lights by building all respective
light nodes.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| lightNodes | <code>Array.&lt;LightingNode&gt;</code> | An array of lighting nodes. |

<a name="LightsNode+setup"></a>

### lightsNode.setup(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
The implementation makes sure that for each light in the scene
there is a corresponding light node. By building the light nodes
and evaluating the lighting model the outgoing light is computed.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - A node representing the outgoing light.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="LightsNode+setLights"></a>

### lightsNode.setLights(lights) ⇒ [<code>LightsNode</code>](#LightsNode)
Configures this node with an array of lights.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: [<code>LightsNode</code>](#LightsNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| lights | <code>Array.&lt;Light&gt;</code> | An array of lights. |

<a name="LightsNode+getLights"></a>

### lightsNode.getLights() ⇒ <code>Array.&lt;Light&gt;</code>
Returns an array of the scene's lights.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: <code>Array.&lt;Light&gt;</code> - The scene's lights.  
<a name="lights"></a>

## lights(lights) ⇒ [<code>LightsNode</code>](#LightsNode)
TSL function for creating an instance of `LightsNode` and configuring
it with the given array of lights.

**Kind**: global function  
**Returns**: [<code>LightsNode</code>](#LightsNode) - The created lights node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| lights | <code>Array.&lt;Light&gt;</code> | An array of lights. |

<a name="PointLightNode"></a>

## PointLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing point lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [PointLightNode](#PointLightNode) ⇐ <code>AnalyticLightNode</code>
    * [new PointLightNode([light])](#new_PointLightNode_new)
    * [.cutoffDistanceNode](#PointLightNode+cutoffDistanceNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.decayExponentNode](#PointLightNode+decayExponentNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.update(frame)](#PointLightNode+update)
    * [.setupShadowNode()](#PointLightNode+setupShadowNode) ⇒ <code>PointShadowNode</code>

<a name="new_PointLightNode_new"></a>

### new PointLightNode([light])
Constructs a new point light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>PointLight</code> | <code></code> | The point light source. |

<a name="PointLightNode+cutoffDistanceNode"></a>

### pointLightNode.cutoffDistanceNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the cutoff distance.

**Kind**: instance property of [<code>PointLightNode</code>](#PointLightNode)  
<a name="PointLightNode+decayExponentNode"></a>

### pointLightNode.decayExponentNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the decay exponent.

**Kind**: instance property of [<code>PointLightNode</code>](#PointLightNode)  
<a name="PointLightNode+update"></a>

### pointLightNode.update(frame)
Overwritten to updated point light specific uniforms.

**Kind**: instance method of [<code>PointLightNode</code>](#PointLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="PointLightNode+setupShadowNode"></a>

### pointLightNode.setupShadowNode() ⇒ <code>PointShadowNode</code>
Overwritten to setup point light specific shadow.

**Kind**: instance method of [<code>PointLightNode</code>](#PointLightNode)  
## Classes

<dl>
<dt><a href="#PointShadowNode">PointShadowNode</a> ⇐ <code>ShadowNode</code></dt>
<dd><p>Represents the shadow implementation for point light nodes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#pointShadow">pointShadow(light, [shadow])</a> ⇒ <code><a href="#PointShadowNode">PointShadowNode</a></code></dt>
<dd><p>TSL function for creating an instance of <code>PointShadowNode</code>.</p>
</dd>
</dl>

<a name="PointShadowNode"></a>

## PointShadowNode ⇐ <code>ShadowNode</code>
Represents the shadow implementation for point light nodes.

**Kind**: global class  
**Extends**: <code>ShadowNode</code>  

* [PointShadowNode](#PointShadowNode) ⇐ <code>ShadowNode</code>
    * [new PointShadowNode(light, [shadow])](#new_PointShadowNode_new)
    * [.getShadowFilterFn(type)](#PointShadowNode+getShadowFilterFn) ⇒ <code>function</code>
    * [.setupShadowCoord(builder, shadowPosition)](#PointShadowNode+setupShadowCoord) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupShadowFilter(builder, inputs)](#PointShadowNode+setupShadowFilter) ⇒ <code>Node.&lt;float&gt;</code>
    * [.renderShadow(frame)](#PointShadowNode+renderShadow)

<a name="new_PointShadowNode_new"></a>

### new PointShadowNode(light, [shadow])
Constructs a new point shadow node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>PointLight</code> |  | The shadow casting point light. |
| [shadow] | <code>PointLightShadow</code> | <code></code> | An optional point light shadow. |

<a name="PointShadowNode+getShadowFilterFn"></a>

### pointShadowNode.getShadowFilterFn(type) ⇒ <code>function</code>
Overwrites the default implementation to return point light shadow specific
filtering functions.

**Kind**: instance method of [<code>PointShadowNode</code>](#PointShadowNode)  
**Returns**: <code>function</code> - The filtering function.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>number</code> | The shadow type. |

<a name="PointShadowNode+setupShadowCoord"></a>

### pointShadowNode.setupShadowCoord(builder, shadowPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
Overwrites the default implementation so the unaltered shadow position is used.

**Kind**: instance method of [<code>PointShadowNode</code>](#PointShadowNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The shadow coordinates.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| shadowPosition | <code>Node.&lt;vec3&gt;</code> | A node representing the shadow position. |

<a name="PointShadowNode+setupShadowFilter"></a>

### pointShadowNode.setupShadowFilter(builder, inputs) ⇒ <code>Node.&lt;float&gt;</code>
Overwrites the default implementation to only use point light specific
shadow filter functions.

**Kind**: instance method of [<code>PointShadowNode</code>](#PointShadowNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The result node of the shadow filtering.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| inputs | <code>Object</code> | A configuration object that defines the shadow filtering. |
| inputs.filterFn | <code>function</code> | This function defines the filtering type of the shadow map e.g. PCF. |
| inputs.shadowTexture | <code>Texture</code> | A reference to the shadow map's texture. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | Shadow coordinates which are used to sample from the shadow map. |
| inputs.shadow | <code>LightShadow</code> | The light shadow. |

<a name="PointShadowNode+renderShadow"></a>

### pointShadowNode.renderShadow(frame)
Overwrites the default implementation with point light specific
rendering code.

**Kind**: instance method of [<code>PointShadowNode</code>](#PointShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="pointShadow"></a>

## pointShadow(light, [shadow]) ⇒ [<code>PointShadowNode</code>](#PointShadowNode)
TSL function for creating an instance of `PointShadowNode`.

**Kind**: global function  
**Returns**: [<code>PointShadowNode</code>](#PointShadowNode) - The created point shadow node.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>PointLight</code> |  | The shadow casting point light. |
| [shadow] | <code>PointLightShadow</code> | <code></code> | An optional point light shadow. |

<a name="RectAreaLightNode"></a>

## RectAreaLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing rect area lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [RectAreaLightNode](#RectAreaLightNode) ⇐ <code>AnalyticLightNode</code>
    * [new RectAreaLightNode([light])](#new_RectAreaLightNode_new)
    * _instance_
        * [.halfHeight](#RectAreaLightNode+halfHeight) : <code>UniformNode.&lt;vec3&gt;</code>
        * [.halfWidth](#RectAreaLightNode+halfWidth) : <code>UniformNode.&lt;vec3&gt;</code>
        * [.updateType](#RectAreaLightNode+updateType) : <code>string</code>
        * [.update(frame)](#RectAreaLightNode+update)
    * _static_
        * [.setLTC(ltc)](#RectAreaLightNode.setLTC)

<a name="new_RectAreaLightNode_new"></a>

### new RectAreaLightNode([light])
Constructs a new rect area light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>RectAreaLight</code> | <code></code> | The rect area light source. |

<a name="RectAreaLightNode+halfHeight"></a>

### rectAreaLightNode.halfHeight : <code>UniformNode.&lt;vec3&gt;</code>
Uniform node representing the half height of the are light.

**Kind**: instance property of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  
<a name="RectAreaLightNode+halfWidth"></a>

### rectAreaLightNode.halfWidth : <code>UniformNode.&lt;vec3&gt;</code>
Uniform node representing the half width of the are light.

**Kind**: instance property of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  
<a name="RectAreaLightNode+updateType"></a>

### rectAreaLightNode.updateType : <code>string</code>
The `updateType` is set to `NodeUpdateType.RENDER` since the light
relies on `viewMatrix` which might vary per render call.

**Kind**: instance property of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="RectAreaLightNode+update"></a>

### rectAreaLightNode.update(frame)
Overwritten to updated rect area light specific uniforms.

**Kind**: instance method of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="RectAreaLightNode.setLTC"></a>

### RectAreaLightNode.setLTC(ltc)
Used to configure the internal BRDF approximation texture data.

**Kind**: static method of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| ltc | <code>RectAreaLightTexturesLib</code> | The BRDF approximation texture data. |

## Classes

<dl>
<dt><a href="#ShadowBaseNode">ShadowBaseNode</a> ⇐ <code>Node</code></dt>
<dd><p>Base class for all shadow nodes.</p>
<p>Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.
Lighting nodes might share the same shadow node type or use specific ones depending on
their requirements.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#shadowPositionWorld">shadowPositionWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex position in world space during the shadow pass.</p>
</dd>
</dl>

<a name="ShadowBaseNode"></a>

## ShadowBaseNode ⇐ <code>Node</code>
Base class for all shadow nodes.

Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.
Lighting nodes might share the same shadow node type or use specific ones depending on
their requirements.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ShadowBaseNode](#ShadowBaseNode) ⇐ <code>Node</code>
    * [new ShadowBaseNode(light)](#new_ShadowBaseNode_new)
    * [.light](#ShadowBaseNode+light) : <code>Light</code>
    * [.updateBeforeType](#ShadowBaseNode+updateBeforeType) : <code>string</code>
    * [.isShadowBaseNode](#ShadowBaseNode+isShadowBaseNode) : <code>boolean</code>
    * [.setupShadowPosition(object)](#ShadowBaseNode+setupShadowPosition)
    * [.dispose()](#ShadowBaseNode+dispose)

<a name="new_ShadowBaseNode_new"></a>

### new ShadowBaseNode(light)
Constructs a new shadow base node.


| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The shadow casting light. |

<a name="ShadowBaseNode+light"></a>

### shadowBaseNode.light : <code>Light</code>
The shadow casting light.

**Kind**: instance property of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  
<a name="ShadowBaseNode+updateBeforeType"></a>

### shadowBaseNode.updateBeforeType : <code>string</code>
Overwritten since shadows are updated by default per render.

**Kind**: instance property of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="ShadowBaseNode+isShadowBaseNode"></a>

### shadowBaseNode.isShadowBaseNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowBaseNode+setupShadowPosition"></a>

### shadowBaseNode.setupShadowPosition(object)
Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.

**Kind**: instance method of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>NodeBuilder</code> | A configuration object that must at least hold a material reference. |

<a name="ShadowBaseNode+dispose"></a>

### shadowBaseNode.dispose()
Can be called when the shadow isn't required anymore. That can happen when
a lighting node stops casting shadows by setting [Object3D#castShadow](Object3D#castShadow)
to `false`.

**Kind**: instance method of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  
<a name="shadowPositionWorld"></a>

## shadowPositionWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex position in world space during the shadow pass.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#ShadowNode">ShadowNode</a> ⇐ <code>ShadowBaseNode</code></dt>
<dd><p>Represents the default shadow implementation for lighting nodes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#BasicShadowFilter">BasicShadowFilter(inputs)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map
with a binary <code>[0,1]</code> result.</p>
</dd>
<dt><a href="#PCFShadowFilter">PCFShadowFilter(inputs)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A shadow filtering function performing PCF filtering.</p>
</dd>
<dt><a href="#PCFSoftShadowFilter">PCFSoftShadowFilter(inputs)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A shadow filtering function performing PCF soft filtering.</p>
</dd>
<dt><a href="#VSMShadowFilter">VSMShadowFilter(inputs)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A shadow filtering function performing VSM filtering.</p>
</dd>
<dt><a href="#VSMPassVertical">VSMPassVertical(inputs)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Represents the shader code for the first VSM render pass.</p>
</dd>
<dt><a href="#VSMPassHorizontal">VSMPassHorizontal(inputs)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Represents the shader code for the second VSM render pass.</p>
</dd>
<dt><a href="#shadow">shadow(light, [shadow])</a> ⇒ <code><a href="#ShadowNode">ShadowNode</a></code></dt>
<dd><p>TSL function for creating an instance of <code>ShadowNode</code>.</p>
</dd>
</dl>

<a name="ShadowNode"></a>

## ShadowNode ⇐ <code>ShadowBaseNode</code>
Represents the default shadow implementation for lighting nodes.

**Kind**: global class  
**Extends**: <code>ShadowBaseNode</code>  

* [ShadowNode](#ShadowNode) ⇐ <code>ShadowBaseNode</code>
    * [new ShadowNode(light, [shadow])](#new_ShadowNode_new)
    * [.shadow](#ShadowNode+shadow) : <code>LightShadow</code>
    * [.shadowMap](#ShadowNode+shadowMap) : <code>RenderTarget</code>
    * [.vsmShadowMapVertical](#ShadowNode+vsmShadowMapVertical) : <code>RenderTarget</code>
    * [.vsmShadowMapHorizontal](#ShadowNode+vsmShadowMapHorizontal) : <code>RenderTarget</code>
    * [.vsmMaterialVertical](#ShadowNode+vsmMaterialVertical) : <code>NodeMaterial</code>
    * [.vsmMaterialHorizontal](#ShadowNode+vsmMaterialHorizontal) : <code>NodeMaterial</code>
    * [.isShadowNode](#ShadowNode+isShadowNode) : <code>boolean</code>
    * [.setupShadowFilter(builder, inputs)](#ShadowNode+setupShadowFilter) ⇒ <code>Node.&lt;float&gt;</code>
    * [.setupShadowCoord(builder, shadowPosition)](#ShadowNode+setupShadowCoord) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.getShadowFilterFn(type)](#ShadowNode+getShadowFilterFn) ⇒ <code>function</code>
    * [.setupShadow(builder)](#ShadowNode+setupShadow) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setup(builder)](#ShadowNode+setup) ⇒ <code>ShaderCallNodeInternal</code>
    * [.renderShadow(frame)](#ShadowNode+renderShadow)
    * [.updateShadow(frame)](#ShadowNode+updateShadow)
    * [.vsmPass(renderer)](#ShadowNode+vsmPass)
    * [.dispose()](#ShadowNode+dispose)
    * [.updateBefore(frame)](#ShadowNode+updateBefore)

<a name="new_ShadowNode_new"></a>

### new ShadowNode(light, [shadow])
Constructs a new shadow node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>Light</code> |  | The shadow casting light. |
| [shadow] | <code>LightShadow</code> | <code></code> | An optional light shadow. |

<a name="ShadowNode+shadow"></a>

### shadowNode.shadow : <code>LightShadow</code>
The light shadow which defines the properties light's
shadow.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+shadowMap"></a>

### shadowNode.shadowMap : <code>RenderTarget</code>
A reference to the shadow map which is a render target.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+vsmShadowMapVertical"></a>

### shadowNode.vsmShadowMapVertical : <code>RenderTarget</code>
Only relevant for VSM shadows. Render target for the
first VSM render pass.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+vsmShadowMapHorizontal"></a>

### shadowNode.vsmShadowMapHorizontal : <code>RenderTarget</code>
Only relevant for VSM shadows. Render target for the
second VSM render pass.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+vsmMaterialVertical"></a>

### shadowNode.vsmMaterialVertical : <code>NodeMaterial</code>
Only relevant for VSM shadows. Node material which
is used to render the first VSM pass.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+vsmMaterialHorizontal"></a>

### shadowNode.vsmMaterialHorizontal : <code>NodeMaterial</code>
Only relevant for VSM shadows. Node material which
is used to render the second VSM pass.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+isShadowNode"></a>

### shadowNode.isShadowNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowNode+setupShadowFilter"></a>

### shadowNode.setupShadowFilter(builder, inputs) ⇒ <code>Node.&lt;float&gt;</code>
Setups the shadow filtering.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The result node of the shadow filtering.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| inputs | <code>Object</code> | A configuration object that defines the shadow filtering. |
| inputs.filterFn | <code>function</code> | This function defines the filtering type of the shadow map e.g. PCF. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | Shadow coordinates which are used to sample from the shadow map. |
| inputs.shadow | <code>LightShadow</code> | The light shadow. |

<a name="ShadowNode+setupShadowCoord"></a>

### shadowNode.setupShadowCoord(builder, shadowPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the shadow coordinates.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The shadow coordinates.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| shadowPosition | <code>Node.&lt;vec3&gt;</code> | A node representing the shadow position. |

<a name="ShadowNode+getShadowFilterFn"></a>

### shadowNode.getShadowFilterFn(type) ⇒ <code>function</code>
Returns the shadow filtering function for the given shadow type.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>function</code> - The filtering function.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>number</code> | The shadow type. |

<a name="ShadowNode+setupShadow"></a>

### shadowNode.setupShadow(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the shadow output node.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The shadow output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="ShadowNode+setup"></a>

### shadowNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
The implementation performs the setup of the output node. An output is only
produces if shadow mapping is globally enabled in the renderer.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>ShaderCallNodeInternal</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="ShadowNode+renderShadow"></a>

### shadowNode.renderShadow(frame)
Renders the shadow. The logic of this function could be included
into [updateShadow](#ShadowNode+updateShadow) however more specialized shadow
nodes might require a custom shadow map rendering. By having a
dedicated method, it's easier to overwrite the default behavior.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="ShadowNode+updateShadow"></a>

### shadowNode.updateShadow(frame)
Updates the shadow.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="ShadowNode+vsmPass"></a>

### shadowNode.vsmPass(renderer)
For VSM additional render passes are required.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | A reference to the current renderer. |

<a name="ShadowNode+dispose"></a>

### shadowNode.dispose()
Frees the internal resources of this shadow node.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
<a name="ShadowNode+updateBefore"></a>

### shadowNode.updateBefore(frame)
The implementation performs the update of the shadow map if necessary.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="BasicShadowFilter"></a>

## BasicShadowFilter(inputs) ⇒ <code>Node.&lt;float&gt;</code>
A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map
with a binary `[0,1]` result.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The filtering result.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | The shadow coordinates. |

<a name="PCFShadowFilter"></a>

## PCFShadowFilter(inputs) ⇒ <code>Node.&lt;float&gt;</code>
A shadow filtering function performing PCF filtering.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The filtering result.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | The shadow coordinates. |
| inputs.shadow | <code>LightShadow</code> | The light shadow. |

<a name="PCFSoftShadowFilter"></a>

## PCFSoftShadowFilter(inputs) ⇒ <code>Node.&lt;float&gt;</code>
A shadow filtering function performing PCF soft filtering.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The filtering result.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | The shadow coordinates. |
| inputs.shadow | <code>LightShadow</code> | The light shadow. |

<a name="VSMShadowFilter"></a>

## VSMShadowFilter(inputs) ⇒ <code>Node.&lt;float&gt;</code>
A shadow filtering function performing VSM filtering.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The filtering result.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | The shadow coordinates. |

<a name="VSMPassVertical"></a>

## VSMPassVertical(inputs) ⇒ <code>Node.&lt;vec2&gt;</code>
Represents the shader code for the first VSM render pass.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The VSM output.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.samples | <code>Node.&lt;float&gt;</code> | The number of samples |
| inputs.radius | <code>Node.&lt;float&gt;</code> | The radius. |
| inputs.size | <code>Node.&lt;float&gt;</code> | The size. |
| inputs.shadowPass | <code>TextureNode</code> | A reference to the render target's depth data. |

<a name="VSMPassHorizontal"></a>

## VSMPassHorizontal(inputs) ⇒ <code>Node.&lt;vec2&gt;</code>
Represents the shader code for the second VSM render pass.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The VSM output.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.samples | <code>Node.&lt;float&gt;</code> | The number of samples |
| inputs.radius | <code>Node.&lt;float&gt;</code> | The radius. |
| inputs.size | <code>Node.&lt;float&gt;</code> | The size. |
| inputs.shadowPass | <code>TextureNode</code> | The result of the first VSM render pass. |

<a name="shadow"></a>

## shadow(light, [shadow]) ⇒ [<code>ShadowNode</code>](#ShadowNode)
TSL function for creating an instance of `ShadowNode`.

**Kind**: global function  
**Returns**: [<code>ShadowNode</code>](#ShadowNode) - The created shadow node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The shadow casting light. |
| [shadow] | <code>LightShadow</code> | The light shadow. |

<a name="SpotLightNode"></a>

## SpotLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing spot lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [SpotLightNode](#SpotLightNode) ⇐ <code>AnalyticLightNode</code>
    * [new SpotLightNode([light])](#new_SpotLightNode_new)
    * [.coneCosNode](#SpotLightNode+coneCosNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.penumbraCosNode](#SpotLightNode+penumbraCosNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.cutoffDistanceNode](#SpotLightNode+cutoffDistanceNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.decayExponentNode](#SpotLightNode+decayExponentNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.update(frame)](#SpotLightNode+update)
    * [.getSpotAttenuation(angleCosine)](#SpotLightNode+getSpotAttenuation) ⇒ <code>Node.&lt;float&gt;</code>

<a name="new_SpotLightNode_new"></a>

### new SpotLightNode([light])
Constructs a new spot light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>SpotLight</code> | <code></code> | The spot light source. |

<a name="SpotLightNode+coneCosNode"></a>

### spotLightNode.coneCosNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the cone cosine.

**Kind**: instance property of [<code>SpotLightNode</code>](#SpotLightNode)  
<a name="SpotLightNode+penumbraCosNode"></a>

### spotLightNode.penumbraCosNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the penumbra cosine.

**Kind**: instance property of [<code>SpotLightNode</code>](#SpotLightNode)  
<a name="SpotLightNode+cutoffDistanceNode"></a>

### spotLightNode.cutoffDistanceNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the cutoff distance.

**Kind**: instance property of [<code>SpotLightNode</code>](#SpotLightNode)  
<a name="SpotLightNode+decayExponentNode"></a>

### spotLightNode.decayExponentNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the decay exponent.

**Kind**: instance property of [<code>SpotLightNode</code>](#SpotLightNode)  
<a name="SpotLightNode+update"></a>

### spotLightNode.update(frame)
Overwritten to updated spot light specific uniforms.

**Kind**: instance method of [<code>SpotLightNode</code>](#SpotLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="SpotLightNode+getSpotAttenuation"></a>

### spotLightNode.getSpotAttenuation(angleCosine) ⇒ <code>Node.&lt;float&gt;</code>
Computes the spot attenuation for the given angle.

**Kind**: instance method of [<code>SpotLightNode</code>](#SpotLightNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The spot attenuation.  

| Param | Type | Description |
| --- | --- | --- |
| angleCosine | <code>Node.&lt;float&gt;</code> | The angle to compute the spot attenuation for. |

## Classes

<dl>
<dt><a href="#ConditionalNode">ConditionalNode</a> ⇐ <code>Node</code></dt>
<dd><p>Represents a logical <code>if/else</code> statement. Can be used as an alternative
to the <code>If()</code>/<code>Else()</code> syntax.</p>
<p>The corresponding TSL <code>select()</code> looks like so:</p>
<pre><code class="language-js">velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );
</code></pre>
<p>The <code>select()</code> method is called in a chaining fashion on a condition. The parameter nodes of <code>select()</code>
determine the outcome of the entire statement.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#select">select(condNode, ifNode, [elseNode])</a> ⇒ <code><a href="#ConditionalNode">ConditionalNode</a></code></dt>
<dd><p>TSL function for creating a conditional node.</p>
</dd>
<dt><del><a href="#cond">cond(...params)</a> ⇒ <code><a href="#ConditionalNode">ConditionalNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="ConditionalNode"></a>

## ConditionalNode ⇐ <code>Node</code>
Represents a logical `if/else` statement. Can be used as an alternative
to the `If()`/`Else()` syntax.

The corresponding TSL `select()` looks like so:
```js
velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );
```
The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`
determine the outcome of the entire statement.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ConditionalNode](#ConditionalNode) ⇐ <code>Node</code>
    * [new ConditionalNode(condNode, ifNode, [elseNode])](#new_ConditionalNode_new)
    * [.condNode](#ConditionalNode+condNode) : <code>Node</code>
    * [.ifNode](#ConditionalNode+ifNode) : <code>Node</code>
    * [.elseNode](#ConditionalNode+elseNode) : <code>Node</code>
    * [.getNodeType(builder)](#ConditionalNode+getNodeType) ⇒ <code>string</code>

<a name="new_ConditionalNode_new"></a>

### new ConditionalNode(condNode, ifNode, [elseNode])
Constructs a new conditional node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| condNode | <code>Node</code> |  | The node that defines the condition. |
| ifNode | <code>Node</code> |  | The node that is evaluate when the condition ends up `true`. |
| [elseNode] | <code>Node</code> | <code></code> | The node that is evaluate when the condition ends up `false`. |

<a name="ConditionalNode+condNode"></a>

### conditionalNode.condNode : <code>Node</code>
The node that defines the condition.

**Kind**: instance property of [<code>ConditionalNode</code>](#ConditionalNode)  
<a name="ConditionalNode+ifNode"></a>

### conditionalNode.ifNode : <code>Node</code>
The node that is evaluate when the condition ends up `true`.

**Kind**: instance property of [<code>ConditionalNode</code>](#ConditionalNode)  
<a name="ConditionalNode+elseNode"></a>

### conditionalNode.elseNode : <code>Node</code>
The node that is evaluate when the condition ends up `false`.

**Kind**: instance property of [<code>ConditionalNode</code>](#ConditionalNode)  
**Default**: <code>null</code>  
<a name="ConditionalNode+getNodeType"></a>

### conditionalNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the if/else
nodes.

**Kind**: instance method of [<code>ConditionalNode</code>](#ConditionalNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="select"></a>

## select(condNode, ifNode, [elseNode]) ⇒ [<code>ConditionalNode</code>](#ConditionalNode)
TSL function for creating a conditional node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| condNode | <code>Node</code> |  | The node that defines the condition. |
| ifNode | <code>Node</code> |  | The node that is evaluate when the condition ends up `true`. |
| [elseNode] | <code>Node</code> | <code></code> | The node that is evaluate when the condition ends up `false`. |

<a name="cond"></a>

## ~~cond(...params) ⇒ [<code>ConditionalNode</code>](#ConditionalNode)~~
***since r168. Use [select](#select) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="hash"></a>

## hash(seed) ⇒ <code>Node.&lt;float&gt;</code>
Generates a hash value in the range `[0, 1]` from the given seed.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The hash value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| seed | <code>Node.&lt;float&gt;</code> | The seed. |

## Classes

<dl>
<dt><a href="#MathNode">MathNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents a variety of mathematical methods available in shaders.
They are divided into three categories:</p>
<ul>
<li>Methods with one input like <code>sin</code>, <code>cos</code> or <code>normalize</code>.</li>
<li>Methods with two inputs like <code>dot</code>, <code>cross</code> or <code>pow</code>.</li>
<li>Methods with three inputs like <code>mix</code>, <code>clamp</code> or <code>smoothstep</code>.</li>
</ul>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#EPSILON">EPSILON</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>A small value used to handle floating-point precision errors.</p>
</dd>
<dt><a href="#INFINITY">INFINITY</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>Represents infinity.</p>
</dd>
<dt><a href="#PI">PI</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>Represents PI.</p>
</dd>
<dt><a href="#PI2">PI2</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>Represents PI * 2.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#all">all(x)</a> ⇒ <code>Node.&lt;bool&gt;</code></dt>
<dd><p>Returns <code>true</code> if all components of <code>x</code> are <code>true</code>.</p>
</dd>
<dt><a href="#any">any(x)</a> ⇒ <code>Node.&lt;bool&gt;</code></dt>
<dd><p>Returns <code>true</code> if any components of <code>x</code> are <code>true</code>.</p>
</dd>
<dt><a href="#radians">radians(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Converts a quantity in degrees to radians.</p>
</dd>
<dt><a href="#degrees">degrees(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Convert a quantity in radians to degrees.</p>
</dd>
<dt><a href="#exp">exp(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the natural exponentiation of the parameter.</p>
</dd>
<dt><a href="#exp2">exp2(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns 2 raised to the power of the parameter.</p>
</dd>
<dt><a href="#log">log(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the natural logarithm of the parameter.</p>
</dd>
<dt><a href="#log2">log2(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the base 2 logarithm of the parameter.</p>
</dd>
<dt><a href="#sqrt">sqrt(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the square root of the parameter.</p>
</dd>
<dt><a href="#inverseSqrt">inverseSqrt(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the inverse of the square root of the parameter.</p>
</dd>
<dt><a href="#floor">floor(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Finds the nearest integer less than or equal to the parameter.</p>
</dd>
<dt><a href="#ceil">ceil(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Finds the nearest integer that is greater than or equal to the parameter.</p>
</dd>
<dt><a href="#normalize">normalize(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Calculates the unit vector in the same direction as the original vector.</p>
</dd>
<dt><a href="#fract">fract(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Computes the fractional part of the parameter.</p>
</dd>
<dt><a href="#sin">sin(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the sine of the parameter.</p>
</dd>
<dt><a href="#cos">cos(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the cosine of the parameter.</p>
</dd>
<dt><a href="#tan">tan(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the tangent of the parameter.</p>
</dd>
<dt><a href="#asin">asin(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the arcsine of the parameter.</p>
</dd>
<dt><a href="#acos">acos(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the arccosine of the parameter.</p>
</dd>
<dt><a href="#atan">atan(y, x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the arc-tangent of the parameter.
If two parameters are provided, the result is <code>atan2(y/x)</code>.</p>
</dd>
<dt><a href="#abs">abs(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the absolute value of the parameter.</p>
</dd>
<dt><a href="#sign">sign(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Extracts the sign of the parameter.</p>
</dd>
<dt><a href="#length">length(x)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Calculates the length of a vector.</p>
</dd>
<dt><a href="#negate">negate(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Negates the value of the parameter (-x).</p>
</dd>
<dt><a href="#oneMinus">oneMinus(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Return <code>1</code> minus the parameter.</p>
</dd>
<dt><a href="#dFdx">dFdx(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the partial derivative of the parameter with respect to x.</p>
</dd>
<dt><a href="#dFdy">dFdy(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the partial derivative of the parameter with respect to y.</p>
</dd>
<dt><a href="#round">round(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Rounds the parameter to the nearest integer.</p>
</dd>
<dt><a href="#reciprocal">reciprocal(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the reciprocal of the parameter <code>(1/x)</code>.</p>
</dd>
<dt><a href="#trunc">trunc(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Truncates the parameter, removing the fractional part.</p>
</dd>
<dt><a href="#fwidth">fwidth(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the sum of the absolute derivatives in x and y.</p>
</dd>
<dt><a href="#transpose">transpose(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the transpose of a matrix.</p>
</dd>
<dt><a href="#bitcast">bitcast(x, y)</a> ⇒ <code>Node</code></dt>
<dd><p>Reinterpret the bit representation of a value in one type as a value in another type.</p>
</dd>
<dt><del><a href="#equals">equals(x, y)</a> ⇒ <code>Node.&lt;bool&gt;</code></del></dt>
<dd><p>Returns <code>true</code> if <code>x</code> equals <code>y</code>.</p>
</dd>
<dt><a href="#min">min(...values)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the least of the given values.</p>
</dd>
<dt><a href="#max">max(...values)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the greatest of the given values.</p>
</dd>
<dt><a href="#step">step(x, y)</a> ⇒ <code>Node</code></dt>
<dd><p>Generate a step function by comparing two values.</p>
</dd>
<dt><a href="#reflect">reflect(I, N)</a> ⇒ <code>Node.&lt;(vec2|vec3|vec4)&gt;</code></dt>
<dd><p>Calculates the reflection direction for an incident vector.</p>
</dd>
<dt><a href="#distance">distance(x, y)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Calculates the distance between two points.</p>
</dd>
<dt><a href="#difference">difference(x, y)</a> ⇒ <code>Node</code></dt>
<dd><p>Calculates the absolute difference between two values.</p>
</dd>
<dt><a href="#dot">dot(x, y)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Calculates the dot product of two vectors.</p>
</dd>
<dt><a href="#cross">cross(x, y)</a> ⇒ <code>Node.&lt;(vec2|vec3|vec4)&gt;</code></dt>
<dd><p>Calculates the cross product of two vectors.</p>
</dd>
<dt><a href="#pow">pow(x, y)</a> ⇒ <code>Node</code></dt>
<dd><p>Return the value of the first parameter raised to the power of the second one.</p>
</dd>
<dt><a href="#pow2">pow2(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the square of the parameter.</p>
</dd>
<dt><a href="#pow3">pow3(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the cube of the parameter.</p>
</dd>
<dt><a href="#pow4">pow4(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the fourth power of the parameter.</p>
</dd>
<dt><a href="#transformDirection">transformDirection(direction, matrix)</a> ⇒ <code>Node</code></dt>
<dd><p>Transforms the direction of a vector by a matrix and then normalizes the result.</p>
</dd>
<dt><a href="#cbrt">cbrt(a)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the cube root of a number.</p>
</dd>
<dt><a href="#lengthSq">lengthSq(a)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Calculate the squared length of a vector.</p>
</dd>
<dt><a href="#mix">mix(a, b, t)</a> ⇒ <code>Node</code></dt>
<dd><p>Linearly interpolates between two values.</p>
</dd>
<dt><a href="#clamp">clamp(value, [low], [high])</a> ⇒ <code>Node</code></dt>
<dd><p>Constrains a value to lie between two further values.</p>
</dd>
<dt><a href="#saturate">saturate(value)</a> ⇒ <code>Node</code></dt>
<dd><p>Constrains a value between <code>0</code> and <code>1</code>.</p>
</dd>
<dt><a href="#refract">refract(I, N, eta)</a> ⇒ <code>Node.&lt;(vec2|vec3|vec4)&gt;</code></dt>
<dd><p>Calculates the refraction direction for an incident vector.</p>
</dd>
<dt><a href="#smoothstep">smoothstep(low, high, x)</a> ⇒ <code>Node</code></dt>
<dd><p>Performs a Hermite interpolation between two values.</p>
</dd>
<dt><a href="#faceForward">faceForward(N, I, Nref)</a> ⇒ <code>Node.&lt;(vec2|vec3|vec4)&gt;</code></dt>
<dd><p>Returns a vector pointing in the same direction as another.</p>
</dd>
<dt><a href="#rand">rand(uv)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Returns a random value for the given uv.</p>
</dd>
<dt><a href="#mixElement">mixElement(t, e1, e2)</a> ⇒ <code>Node</code></dt>
<dd><p>Alias for <code>mix()</code> with a different parameter order.</p>
</dd>
<dt><a href="#smoothstepElement">smoothstepElement(x, low, high)</a> ⇒ <code>Node</code></dt>
<dd><p>Alias for <code>smoothstep()</code> with a different parameter order.</p>
</dd>
<dt><del><a href="#atan2">atan2(y, x)</a> ⇒ <code>Node</code></del></dt>
<dd><p>Returns the arc-tangent of the quotient of its parameters.</p>
</dd>
</dl>

<a name="MathNode"></a>

## MathNode ⇐ <code>TempNode</code>
This node represents a variety of mathematical methods available in shaders.
They are divided into three categories:

- Methods with one input like `sin`, `cos` or `normalize`.
- Methods with two inputs like `dot`, `cross` or `pow`.
- Methods with three inputs like `mix`, `clamp` or `smoothstep`.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [MathNode](#MathNode) ⇐ <code>TempNode</code>
    * [new MathNode(method, aNode, [bNode], [cNode])](#new_MathNode_new)
    * [.method](#MathNode+method) : <code>string</code>
    * [.aNode](#MathNode+aNode) : <code>Node</code>
    * [.bNode](#MathNode+bNode) : <code>Node</code>
    * [.cNode](#MathNode+cNode) : <code>Node</code>
    * [.isMathNode](#MathNode+isMathNode) : <code>boolean</code>
    * [.getInputType(builder)](#MathNode+getInputType) ⇒ <code>string</code>
    * [.getNodeType(builder)](#MathNode+getNodeType) ⇒ <code>string</code>

<a name="new_MathNode_new"></a>

### new MathNode(method, aNode, [bNode], [cNode])
Constructs a new math node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| method | <code>string</code> |  | The method name. |
| aNode | <code>Node</code> |  | The first input. |
| [bNode] | <code>Node</code> | <code></code> | The second input. |
| [cNode] | <code>Node</code> | <code></code> | The third input. |

<a name="MathNode+method"></a>

### mathNode.method : <code>string</code>
The method name.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
<a name="MathNode+aNode"></a>

### mathNode.aNode : <code>Node</code>
The first input.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
<a name="MathNode+bNode"></a>

### mathNode.bNode : <code>Node</code>
The second input.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
**Default**: <code>null</code>  
<a name="MathNode+cNode"></a>

### mathNode.cNode : <code>Node</code>
The third input.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
**Default**: <code>null</code>  
<a name="MathNode+isMathNode"></a>

### mathNode.isMathNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MathNode+getInputType"></a>

### mathNode.getInputType(builder) ⇒ <code>string</code>
The input type is inferred from the node types of the input nodes.

**Kind**: instance method of [<code>MathNode</code>](#MathNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MathNode+getNodeType"></a>

### mathNode.getNodeType(builder) ⇒ <code>string</code>
The selected method as well as the input type determine the node type of this node.

**Kind**: instance method of [<code>MathNode</code>](#MathNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="EPSILON"></a>

## EPSILON : <code>Node.&lt;float&gt;</code>
A small value used to handle floating-point precision errors.

**Kind**: global constant  
**Tsl**:   
<a name="INFINITY"></a>

## INFINITY : <code>Node.&lt;float&gt;</code>
Represents infinity.

**Kind**: global constant  
**Tsl**:   
<a name="PI"></a>

## PI : <code>Node.&lt;float&gt;</code>
Represents PI.

**Kind**: global constant  
**Tsl**:   
<a name="PI2"></a>

## PI2 : <code>Node.&lt;float&gt;</code>
Represents PI * 2.

**Kind**: global constant  
**Tsl**:   
<a name="all"></a>

## all(x) ⇒ <code>Node.&lt;bool&gt;</code>
Returns `true` if all components of `x` are `true`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="any"></a>

## any(x) ⇒ <code>Node.&lt;bool&gt;</code>
Returns `true` if any components of `x` are `true`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="radians"></a>

## radians(x) ⇒ <code>Node</code>
Converts a quantity in degrees to radians.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The input in degrees. |

<a name="degrees"></a>

## degrees(x) ⇒ <code>Node</code>
Convert a quantity in radians to degrees.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The input in radians. |

<a name="exp"></a>

## exp(x) ⇒ <code>Node</code>
Returns the natural exponentiation of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="exp2"></a>

## exp2(x) ⇒ <code>Node</code>
Returns 2 raised to the power of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="log"></a>

## log(x) ⇒ <code>Node</code>
Returns the natural logarithm of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="log2"></a>

## log2(x) ⇒ <code>Node</code>
Returns the base 2 logarithm of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="sqrt"></a>

## sqrt(x) ⇒ <code>Node</code>
Returns the square root of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="inverseSqrt"></a>

## inverseSqrt(x) ⇒ <code>Node</code>
Returns the inverse of the square root of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="floor"></a>

## floor(x) ⇒ <code>Node</code>
Finds the nearest integer less than or equal to the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="ceil"></a>

## ceil(x) ⇒ <code>Node</code>
Finds the nearest integer that is greater than or equal to the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="normalize"></a>

## normalize(x) ⇒ <code>Node</code>
Calculates the unit vector in the same direction as the original vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> | The input vector. |

<a name="fract"></a>

## fract(x) ⇒ <code>Node</code>
Computes the fractional part of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="sin"></a>

## sin(x) ⇒ <code>Node</code>
Returns the sine of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="cos"></a>

## cos(x) ⇒ <code>Node</code>
Returns the cosine of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="tan"></a>

## tan(x) ⇒ <code>Node</code>
Returns the tangent of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="asin"></a>

## asin(x) ⇒ <code>Node</code>
Returns the arcsine of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="acos"></a>

## acos(x) ⇒ <code>Node</code>
Returns the arccosine of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="atan"></a>

## atan(y, x) ⇒ <code>Node</code>
Returns the arc-tangent of the parameter.
If two parameters are provided, the result is `atan2(y/x)`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| y | <code>Node</code> \| <code>number</code> | The y parameter. |
| x | <code>Node</code> \| <code>number</code> | The x parameter. |

<a name="abs"></a>

## abs(x) ⇒ <code>Node</code>
Returns the absolute value of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="sign"></a>

## sign(x) ⇒ <code>Node</code>
Extracts the sign of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="length"></a>

## length(x) ⇒ <code>Node.&lt;float&gt;</code>
Calculates the length of a vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> | The parameter. |

<a name="negate"></a>

## negate(x) ⇒ <code>Node</code>
Negates the value of the parameter (-x).

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="oneMinus"></a>

## oneMinus(x) ⇒ <code>Node</code>
Return `1` minus the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="dFdx"></a>

## dFdx(x) ⇒ <code>Node</code>
Returns the partial derivative of the parameter with respect to x.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="dFdy"></a>

## dFdy(x) ⇒ <code>Node</code>
Returns the partial derivative of the parameter with respect to y.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="round"></a>

## round(x) ⇒ <code>Node</code>
Rounds the parameter to the nearest integer.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="reciprocal"></a>

## reciprocal(x) ⇒ <code>Node</code>
Returns the reciprocal of the parameter `(1/x)`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="trunc"></a>

## trunc(x) ⇒ <code>Node</code>
Truncates the parameter, removing the fractional part.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="fwidth"></a>

## fwidth(x) ⇒ <code>Node</code>
Returns the sum of the absolute derivatives in x and y.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="transpose"></a>

## transpose(x) ⇒ <code>Node</code>
Returns the transpose of a matrix.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;(mat2\|mat3\|mat4)&gt;</code> | The parameter. |

<a name="bitcast"></a>

## bitcast(x, y) ⇒ <code>Node</code>
Reinterpret the bit representation of a value in one type as a value in another type.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |
| y | <code>string</code> | The new type. |

<a name="equals"></a>

## ~~equals(x, y) ⇒ <code>Node.&lt;bool&gt;</code>~~
***since r175. Use [equal](equal) instead.***

Returns `true` if `x` equals `y`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |
| y | <code>Node</code> \| <code>number</code> | The second parameter. |

<a name="min"></a>

## min(...values) ⇒ <code>Node</code>
Returns the least of the given values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...values | <code>Node</code> \| <code>number</code> | The values to compare. |

<a name="max"></a>

## max(...values) ⇒ <code>Node</code>
Returns the greatest of the given values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...values | <code>Node</code> \| <code>number</code> | The values to compare. |

<a name="step"></a>

## step(x, y) ⇒ <code>Node</code>
Generate a step function by comparing two values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The y parameter. |
| y | <code>Node</code> \| <code>number</code> | The x parameter. |

<a name="reflect"></a>

## reflect(I, N) ⇒ <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code>
Calculates the reflection direction for an incident vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| I | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The incident vector. |
| N | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The normal vector. |

<a name="distance"></a>

## distance(x, y) ⇒ <code>Node.&lt;float&gt;</code>
Calculates the distance between two points.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The first point. |
| y | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The second point. |

<a name="difference"></a>

## difference(x, y) ⇒ <code>Node</code>
Calculates the absolute difference between two values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |
| y | <code>Node</code> \| <code>number</code> | The second parameter. |

<a name="dot"></a>

## dot(x, y) ⇒ <code>Node.&lt;float&gt;</code>
Calculates the dot product of two vectors.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The first vector. |
| y | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The second vector. |

<a name="cross"></a>

## cross(x, y) ⇒ <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code>
Calculates the cross product of two vectors.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The first vector. |
| y | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The second vector. |

<a name="pow"></a>

## pow(x, y) ⇒ <code>Node</code>
Return the value of the first parameter raised to the power of the second one.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |
| y | <code>Node</code> \| <code>number</code> | The second parameter. |

<a name="pow2"></a>

## pow2(x) ⇒ <code>Node</code>
Returns the square of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |

<a name="pow3"></a>

## pow3(x) ⇒ <code>Node</code>
Returns the cube of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |

<a name="pow4"></a>

## pow4(x) ⇒ <code>Node</code>
Returns the fourth power of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |

<a name="transformDirection"></a>

## transformDirection(direction, matrix) ⇒ <code>Node</code>
Transforms the direction of a vector by a matrix and then normalizes the result.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| direction | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The direction vector. |
| matrix | <code>Node.&lt;(mat2\|mat3\|mat4)&gt;</code> | The transformation matrix. |

<a name="cbrt"></a>

## cbrt(a) ⇒ <code>Node</code>
Returns the cube root of a number.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> \| <code>number</code> | The first parameter. |

<a name="lengthSq"></a>

## lengthSq(a) ⇒ <code>Node.&lt;float&gt;</code>
Calculate the squared length of a vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The vector. |

<a name="mix"></a>

## mix(a, b, t) ⇒ <code>Node</code>
Linearly interpolates between two values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> \| <code>number</code> | The first parameter. |
| b | <code>Node</code> \| <code>number</code> | The second parameter. |
| t | <code>Node</code> \| <code>number</code> | The interpolation value. |

<a name="clamp"></a>

## clamp(value, [low], [high]) ⇒ <code>Node</code>
Constrains a value to lie between two further values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Node</code> \| <code>number</code> |  | The value to constrain. |
| [low] | <code>Node</code> \| <code>number</code> | <code>0</code> | The lower bound. |
| [high] | <code>Node</code> \| <code>number</code> | <code>1</code> | The upper bound. |

<a name="saturate"></a>

## saturate(value) ⇒ <code>Node</code>
Constrains a value between `0` and `1`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Node</code> \| <code>number</code> | The value to constrain. |

<a name="refract"></a>

## refract(I, N, eta) ⇒ <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code>
Calculates the refraction direction for an incident vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| I | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The incident vector. |
| N | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The normal vector. |
| eta | <code>Node.&lt;float&gt;</code> | The ratio of indices of refraction. |

<a name="smoothstep"></a>

## smoothstep(low, high, x) ⇒ <code>Node</code>
Performs a Hermite interpolation between two values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| low | <code>Node</code> \| <code>number</code> | The value of the lower edge of the Hermite function. |
| high | <code>Node</code> \| <code>number</code> | The value of the upper edge of the Hermite function. |
| x | <code>Node</code> \| <code>number</code> | The source value for interpolation. |

<a name="faceForward"></a>

## faceForward(N, I, Nref) ⇒ <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code>
Returns a vector pointing in the same direction as another.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| N | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The vector to orient. |
| I | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The incident vector. |
| Nref | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The reference vector. |

<a name="rand"></a>

## rand(uv) ⇒ <code>Node.&lt;float&gt;</code>
Returns a random value for the given uv.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The uv node. |

<a name="mixElement"></a>

## mixElement(t, e1, e2) ⇒ <code>Node</code>
Alias for `mix()` with a different parameter order.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node</code> \| <code>number</code> | The interpolation value. |
| e1 | <code>Node</code> \| <code>number</code> | The first parameter. |
| e2 | <code>Node</code> \| <code>number</code> | The second parameter. |

<a name="smoothstepElement"></a>

## smoothstepElement(x, low, high) ⇒ <code>Node</code>
Alias for `smoothstep()` with a different parameter order.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The source value for interpolation. |
| low | <code>Node</code> \| <code>number</code> | The value of the lower edge of the Hermite function. |
| high | <code>Node</code> \| <code>number</code> | The value of the upper edge of the Hermite function. |

<a name="atan2"></a>

## ~~atan2(y, x) ⇒ <code>Node</code>~~
***since r172. Use [atan](#atan) instead.***

Returns the arc-tangent of the quotient of its parameters.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| y | <code>Node</code> \| <code>number</code> | The y parameter. |
| x | <code>Node</code> \| <code>number</code> | The x parameter. |

## Functions

<dl>
<dt><a href="#parabola">parabola(x, k)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A function that remaps the <code>[0,1]</code> interval into the <code>[0,1]</code> interval.
The corners are mapped to <code>0</code> and the center to <code>1</code>.
Reference: <a href="https://iquilezles.org/articles/functions/">https://iquilezles.org/articles/functions/</a>.</p>
</dd>
<dt><a href="#gain">gain(x, k)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A function that remaps the <code>[0,1]</code> interval into the <code>[0,1]</code> interval.
Expands the sides and compresses the center, and keeps <code>0.5</code> mapped to <code>0.5</code>.
Reference: <a href="https://iquilezles.org/articles/functions/">https://iquilezles.org/articles/functions/</a>.</p>
</dd>
<dt><a href="#pcurve">pcurve(x, a, b)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A function that remaps the <code>[0,1]</code> interval into the <code>[0,1]</code> interval.
A generalization of the <code>parabola()</code>. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.
Reference: <a href="https://iquilezles.org/articles/functions/">https://iquilezles.org/articles/functions/</a>.</p>
</dd>
<dt><a href="#sinc">sinc(x, k)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.
Reference: <a href="https://iquilezles.org/articles/functions/">https://iquilezles.org/articles/functions/</a>.</p>
</dd>
</dl>

<a name="parabola"></a>

## parabola(x, k) ⇒ <code>Node.&lt;float&gt;</code>
A function that remaps the `[0,1]` interval into the `[0,1]` interval.
The corners are mapped to `0` and the center to `1`.
Reference: [https://iquilezles.org/articles/functions/](https://iquilezles.org/articles/functions/).

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The remapped value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;float&gt;</code> | The value to remap. |
| k | <code>Node.&lt;float&gt;</code> | Allows to control the remapping functions shape by rising the parabola to a power `k`. |

<a name="gain"></a>

## gain(x, k) ⇒ <code>Node.&lt;float&gt;</code>
A function that remaps the `[0,1]` interval into the `[0,1]` interval.
Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.
Reference: [https://iquilezles.org/articles/functions/](https://iquilezles.org/articles/functions/).

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The remapped value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;float&gt;</code> | The value to remap. |
| k | <code>Node.&lt;float&gt;</code> | `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces "s" shaped curves. |

<a name="pcurve"></a>

## pcurve(x, a, b) ⇒ <code>Node.&lt;float&gt;</code>
A function that remaps the `[0,1]` interval into the `[0,1]` interval.
A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.
Reference: [https://iquilezles.org/articles/functions/](https://iquilezles.org/articles/functions/).

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The remapped value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;float&gt;</code> | The value to remap. |
| a | <code>Node.&lt;float&gt;</code> | First control parameter. |
| b | <code>Node.&lt;float&gt;</code> | Second control parameter. |

<a name="sinc"></a>

## sinc(x, k) ⇒ <code>Node.&lt;float&gt;</code>
A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.
Reference: [https://iquilezles.org/articles/functions/](https://iquilezles.org/articles/functions/).

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The result value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;float&gt;</code> | The value to compute the sin for. |
| k | <code>Node.&lt;float&gt;</code> | Controls the amount of bounces. |

## Classes

<dl>
<dt><a href="#OperatorNode">OperatorNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents basic mathematical and logical operations like addition,
subtraction or comparisons (e.g. <code>equal()</code>).</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#add">add(a, b, ...params)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Returns the addition of two or more value.</p>
</dd>
<dt><a href="#sub">sub(a, b, ...params)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Returns the subtraction of two or more value.</p>
</dd>
<dt><a href="#mul">mul(a, b, ...params)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Returns the multiplication of two or more value.</p>
</dd>
<dt><a href="#div">div(a, b, ...params)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Returns the division of two or more value.</p>
</dd>
<dt><a href="#mod">mod(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Computes the remainder of dividing the first node by the second one.</p>
</dd>
<dt><a href="#equal">equal(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if two nodes are equal.</p>
</dd>
<dt><a href="#notEqual">notEqual(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if two nodes are not equal.</p>
</dd>
<dt><a href="#lessThan">lessThan(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if the first node is less than the second.</p>
</dd>
<dt><a href="#greaterThan">greaterThan(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if the first node is greater than the second.</p>
</dd>
<dt><a href="#lessThanEqual">lessThanEqual(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if the first node is less than or equal to the second.</p>
</dd>
<dt><a href="#greaterThanEqual">greaterThanEqual(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if the first node is greater than or equal to the second.</p>
</dd>
<dt><a href="#and">and(...nodes)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs a logical AND operation on multiple nodes.</p>
</dd>
<dt><a href="#or">or(...nodes)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs a logical OR operation on multiple nodes.</p>
</dd>
<dt><a href="#not">not(value)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs logical NOT on a node.</p>
</dd>
<dt><a href="#xor">xor(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs logical XOR on two nodes.</p>
</dd>
<dt><a href="#bitAnd">bitAnd(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs bitwise AND on two nodes.</p>
</dd>
<dt><a href="#bitNot">bitNot(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs bitwise NOT on a node.</p>
</dd>
<dt><a href="#bitOr">bitOr(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs bitwise OR on two nodes.</p>
</dd>
<dt><a href="#bitXor">bitXor(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs bitwise XOR on two nodes.</p>
</dd>
<dt><a href="#shiftLeft">shiftLeft(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Shifts a node to the left.</p>
</dd>
<dt><a href="#shiftRight">shiftRight(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Shifts a node to the right.</p>
</dd>
<dt><del><a href="#remainder">remainder(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></del></dt>
<dd></dd>
<dt><del><a href="#modInt">modInt(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="OperatorNode"></a>

## OperatorNode ⇐ <code>TempNode</code>
This node represents basic mathematical and logical operations like addition,
subtraction or comparisons (e.g. `equal()`).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [OperatorNode](#OperatorNode) ⇐ <code>TempNode</code>
    * [new OperatorNode(op, aNode, bNode, ...params)](#new_OperatorNode_new)
    * [.op](#OperatorNode+op) : <code>string</code>
    * [.aNode](#OperatorNode+aNode) : <code>Node</code>
    * [.bNode](#OperatorNode+bNode) : <code>Node</code>
    * [.isOperatorNode](#OperatorNode+isOperatorNode) : <code>boolean</code>
    * [.getNodeType(builder, output)](#OperatorNode+getNodeType) ⇒ <code>string</code>

<a name="new_OperatorNode_new"></a>

### new OperatorNode(op, aNode, bNode, ...params)
Constructs a new operator node.


| Param | Type | Description |
| --- | --- | --- |
| op | <code>string</code> | The operator. |
| aNode | <code>Node</code> | The first input. |
| bNode | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="OperatorNode+op"></a>

### operatorNode.op : <code>string</code>
The operator.

**Kind**: instance property of [<code>OperatorNode</code>](#OperatorNode)  
<a name="OperatorNode+aNode"></a>

### operatorNode.aNode : <code>Node</code>
The first input.

**Kind**: instance property of [<code>OperatorNode</code>](#OperatorNode)  
<a name="OperatorNode+bNode"></a>

### operatorNode.bNode : <code>Node</code>
The second input.

**Kind**: instance property of [<code>OperatorNode</code>](#OperatorNode)  
<a name="OperatorNode+isOperatorNode"></a>

### operatorNode.isOperatorNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>OperatorNode</code>](#OperatorNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="OperatorNode+getNodeType"></a>

### operatorNode.getNodeType(builder, output) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the operator
and the input node types.

**Kind**: instance method of [<code>OperatorNode</code>](#OperatorNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | The current output string. |

<a name="add"></a>

## add(a, b, ...params) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Returns the addition of two or more value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="sub"></a>

## sub(a, b, ...params) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Returns the subtraction of two or more value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="mul"></a>

## mul(a, b, ...params) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Returns the multiplication of two or more value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="div"></a>

## div(a, b, ...params) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Returns the division of two or more value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="mod"></a>

## mod(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Computes the remainder of dividing the first node by the second one.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="equal"></a>

## equal(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if two nodes are equal.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="notEqual"></a>

## notEqual(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if two nodes are not equal.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="lessThan"></a>

## lessThan(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if the first node is less than the second.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="greaterThan"></a>

## greaterThan(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if the first node is greater than the second.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="lessThanEqual"></a>

## lessThanEqual(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if the first node is less than or equal to the second.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="greaterThanEqual"></a>

## greaterThanEqual(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if the first node is greater than or equal to the second.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="and"></a>

## and(...nodes) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs a logical AND operation on multiple nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...nodes | <code>Node</code> | The input nodes to be combined using AND. |

<a name="or"></a>

## or(...nodes) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs a logical OR operation on multiple nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...nodes | <code>Node</code> | The input nodes to be combined using OR. |

<a name="not"></a>

## not(value) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs logical NOT on a node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Node</code> | The value. |

<a name="xor"></a>

## xor(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs logical XOR on two nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="bitAnd"></a>

## bitAnd(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs bitwise AND on two nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="bitNot"></a>

## bitNot(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs bitwise NOT on a node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="bitOr"></a>

## bitOr(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs bitwise OR on two nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="bitXor"></a>

## bitXor(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs bitwise XOR on two nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="shiftLeft"></a>

## shiftLeft(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Shifts a node to the left.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The node to shift. |
| b | <code>Node</code> | The value to shift. |

<a name="shiftRight"></a>

## shiftRight(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Shifts a node to the right.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The node to shift. |
| b | <code>Node</code> | The value to shift. |

<a name="remainder"></a>

## ~~remainder(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)~~
***since r168. Use [mod](#mod) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="modInt"></a>

## ~~modInt(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)~~
***since r175. Use [mod](#mod) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="triNoise3D"></a>

## triNoise3D(position, speed, time) ⇒ <code>Node.&lt;float&gt;</code>
Generates a noise value from the given position, speed and time parameters.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The generated noise.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Node.&lt;vec3&gt;</code> | The position. |
| speed | <code>Node.&lt;float&gt;</code> | The speed. |
| time | <code>Node.&lt;float&gt;</code> | The time. |

<a name="GLSLNodeFunction"></a>

## GLSLNodeFunction ⇐ <code>NodeFunction</code>
This class represents a GLSL node function.

**Kind**: global class  
**Extends**: <code>NodeFunction</code>  

* [GLSLNodeFunction](#GLSLNodeFunction) ⇐ <code>NodeFunction</code>
    * [new GLSLNodeFunction(source)](#new_GLSLNodeFunction_new)
    * [.getCode([name])](#GLSLNodeFunction+getCode) ⇒ <code>string</code>

<a name="new_GLSLNodeFunction_new"></a>

### new GLSLNodeFunction(source)
Constructs a new GLSL node function.


| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The GLSL source. |

<a name="GLSLNodeFunction+getCode"></a>

### glslNodeFunction.getCode([name]) ⇒ <code>string</code>
This method returns the GLSL code of the node function.

**Kind**: instance method of [<code>GLSLNodeFunction</code>](#GLSLNodeFunction)  
**Returns**: <code>string</code> - The shader code.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;this.name&quot;</code> | The function's name. |

<a name="GLSLNodeParser"></a>

## GLSLNodeParser ⇐ <code>NodeParser</code>
A GLSL node parser.

**Kind**: global class  
**Extends**: <code>NodeParser</code>  
<a name="GLSLNodeParser+parseFunction"></a>

### glslNodeParser.parseFunction(source) ⇒ <code>GLSLNodeFunction</code>
The method parses the given GLSL code an returns a node function.

**Kind**: instance method of [<code>GLSLNodeParser</code>](#GLSLNodeParser)  
**Returns**: <code>GLSLNodeFunction</code> - A node function.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The GLSL code. |

## Classes

<dl>
<dt><a href="#PMREMNode">PMREMNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents a PMREM which is a special type of preprocessed
environment map intended for PBR materials.</p>
<pre><code class="language-js">const material = new MeshStandardNodeMaterial();
material.envNode = pmremTexture( envMap );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#pmremTexture">pmremTexture(value, [uvNode], [levelNode])</a> ⇒ <code><a href="#PMREMNode">PMREMNode</a></code></dt>
<dd><p>TSL function for creating a PMREM node.</p>
</dd>
</dl>

<a name="PMREMNode"></a>

## PMREMNode ⇐ <code>TempNode</code>
This node represents a PMREM which is a special type of preprocessed
environment map intended for PBR materials.

```js
const material = new MeshStandardNodeMaterial();
material.envNode = pmremTexture( envMap );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [PMREMNode](#PMREMNode) ⇐ <code>TempNode</code>
    * [new PMREMNode(value, [uvNode], [levelNode])](#new_PMREMNode_new)
    * [.uvNode](#PMREMNode+uvNode) : <code>Node.&lt;vec2&gt;</code>
    * [.levelNode](#PMREMNode+levelNode) : <code>Node.&lt;float&gt;</code>
    * [.updateBeforeType](#PMREMNode+updateBeforeType) : <code>string</code>
    * [.value](#PMREMNode+value) : <code>Texture</code>
    * [.updateFromTexture(texture)](#PMREMNode+updateFromTexture)

<a name="new_PMREMNode_new"></a>

### new PMREMNode(value, [uvNode], [levelNode])
Constructs a new function overloading node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The input texture. |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The level node. |

<a name="PMREMNode+uvNode"></a>

### pmremNode.uvNode : <code>Node.&lt;vec2&gt;</code>
The uv node.

**Kind**: instance property of [<code>PMREMNode</code>](#PMREMNode)  
<a name="PMREMNode+levelNode"></a>

### pmremNode.levelNode : <code>Node.&lt;float&gt;</code>
The level node.

**Kind**: instance property of [<code>PMREMNode</code>](#PMREMNode)  
<a name="PMREMNode+updateBeforeType"></a>

### pmremNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.RENDER`.

**Kind**: instance property of [<code>PMREMNode</code>](#PMREMNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="PMREMNode+value"></a>

### pmremNode.value : <code>Texture</code>
The node's texture value.

**Kind**: instance property of [<code>PMREMNode</code>](#PMREMNode)  
<a name="PMREMNode+updateFromTexture"></a>

### pmremNode.updateFromTexture(texture)
Uses the given PMREM texture to update internal values.

**Kind**: instance method of [<code>PMREMNode</code>](#PMREMNode)  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The PMREM texture. |

<a name="pmremTexture"></a>

## pmremTexture(value, [uvNode], [levelNode]) ⇒ [<code>PMREMNode</code>](#PMREMNode)
TSL function for creating a PMREM node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The input texture. |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The level node. |

<a name="checker"></a>

## checker(coord) ⇒ <code>Node.&lt;float&gt;</code>
Creates a 2x2 checkerboard pattern that can be used as procedural texture data.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The result data.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| coord | <code>Node.&lt;vec2&gt;</code> | The uv coordinates. |

<a name="shapeCircle"></a>

## shapeCircle(coord) ⇒ <code>Node.&lt;float&gt;</code>
Generates a circle based on the uv coordinates.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The circle shape.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| coord | <code>Node.&lt;vec2&gt;</code> | The uv to generate the circle. |

<a name="tslFn"></a>

## ~~tslFn(...params) ⇒ <code>function</code>~~
***since r168. Use [Fn](Fn) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="ArrayElementNode"></a>

## ArrayElementNode ⇐ <code>Node</code>
Base class for representing element access on an array-like
node data structures.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ArrayElementNode](#ArrayElementNode) ⇐ <code>Node</code>
    * [new ArrayElementNode(node, indexNode)](#new_ArrayElementNode_new)
    * [.node](#ArrayElementNode+node) : <code>Node</code>
    * [.indexNode](#ArrayElementNode+indexNode) : <code>Node</code>
    * [.isArrayElementNode](#ArrayElementNode+isArrayElementNode) : <code>boolean</code>
    * [.getNodeType(builder)](#ArrayElementNode+getNodeType) ⇒ <code>string</code>

<a name="new_ArrayElementNode_new"></a>

### new ArrayElementNode(node, indexNode)
Constructs an array element node.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The array-like node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="ArrayElementNode+node"></a>

### arrayElementNode.node : <code>Node</code>
The array-like node.

**Kind**: instance property of [<code>ArrayElementNode</code>](#ArrayElementNode)  
<a name="ArrayElementNode+indexNode"></a>

### arrayElementNode.indexNode : <code>Node</code>
The index node that defines the element access.

**Kind**: instance property of [<code>ArrayElementNode</code>](#ArrayElementNode)  
<a name="ArrayElementNode+isArrayElementNode"></a>

### arrayElementNode.isArrayElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ArrayElementNode</code>](#ArrayElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ArrayElementNode+getNodeType"></a>

### arrayElementNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the array-like node.

**Kind**: instance method of [<code>ArrayElementNode</code>](#ArrayElementNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ConvertNode"></a>

## ConvertNode ⇐ <code>Node</code>
This module is part of the TSL core and usually not used in app level code.
It represents a convert operation during the shader generation process
meaning it converts the data type of a node to a target data type.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ConvertNode](#ConvertNode) ⇐ <code>Node</code>
    * [new ConvertNode(node, convertTo)](#new_ConvertNode_new)
    * [.node](#ConvertNode+node) : <code>Node</code>
    * [.convertTo](#ConvertNode+convertTo) : <code>string</code>
    * [.getNodeType(builder)](#ConvertNode+getNodeType) ⇒ <code>string</code>

<a name="new_ConvertNode_new"></a>

### new ConvertNode(node, convertTo)
Constructs a new convert node.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node which type should be converted. |
| convertTo | <code>string</code> | The target node type. Multiple types can be defined by separating them with a `|` sign. |

<a name="ConvertNode+node"></a>

### convertNode.node : <code>Node</code>
The node which type should be converted.

**Kind**: instance property of [<code>ConvertNode</code>](#ConvertNode)  
<a name="ConvertNode+convertTo"></a>

### convertNode.convertTo : <code>string</code>
The target node type. Multiple types can be defined by separating them with a `|` sign.

**Kind**: instance property of [<code>ConvertNode</code>](#ConvertNode)  
<a name="ConvertNode+getNodeType"></a>

### convertNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the implementation tries to infer the best
matching type from the [convertTo](#ConvertNode+convertTo) property.

**Kind**: instance method of [<code>ConvertNode</code>](#ConvertNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#CubeMapNode">CubeMapNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node can be used to automatically convert environment maps in the
equirectangular format into the cube map format.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#cubeMapNode">cubeMapNode(envNode)</a> ⇒ <code><a href="#CubeMapNode">CubeMapNode</a></code></dt>
<dd><p>TSL function for creating a cube map node.</p>
</dd>
</dl>

<a name="CubeMapNode"></a>

## CubeMapNode ⇐ <code>TempNode</code>
This node can be used to automatically convert environment maps in the
equirectangular format into the cube map format.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [CubeMapNode](#CubeMapNode) ⇐ <code>TempNode</code>
    * [new CubeMapNode(envNode)](#new_CubeMapNode_new)
    * [.envNode](#CubeMapNode+envNode) : <code>Node</code>
    * [.updateBeforeType](#CubeMapNode+updateBeforeType) : <code>string</code>

<a name="new_CubeMapNode_new"></a>

### new CubeMapNode(envNode)
Constructs a new cube map node.


| Param | Type | Description |
| --- | --- | --- |
| envNode | <code>Node</code> | The node representing the environment map. |

<a name="CubeMapNode+envNode"></a>

### cubeMapNode.envNode : <code>Node</code>
The node representing the environment map.

**Kind**: instance property of [<code>CubeMapNode</code>](#CubeMapNode)  
<a name="CubeMapNode+updateBeforeType"></a>

### cubeMapNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
the texture once per render in its [CubeMapNode#updateBefore](CubeMapNode#updateBefore) method.

**Kind**: instance property of [<code>CubeMapNode</code>](#CubeMapNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="cubeMapNode"></a>

## cubeMapNode(envNode) ⇒ [<code>CubeMapNode</code>](#CubeMapNode)
TSL function for creating a cube map node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| envNode | <code>Node</code> | The node representing the environment map. |

## Functions

<dl>
<dt><a href="#Discard">Discard(conditional)</a> ⇒ <code>Node</code></dt>
<dd><p>Represents a <code>discard</code> shader operation in TSL.</p>
</dd>
<dt><a href="#Return">Return()</a> ⇒ <code>ExpressionNode</code></dt>
<dd><p>Represents a <code>return</code> shader operation in TSL.</p>
</dd>
</dl>

<a name="Discard"></a>

## Discard(conditional) ⇒ <code>Node</code>
Represents a `discard` shader operation in TSL.

**Kind**: global function  
**Returns**: <code>Node</code> - The `discard` expression.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| conditional | <code>ConditionalNode</code> | An optional conditional node. It allows to decide whether the discard should be executed or not. |

<a name="Return"></a>

## Return() ⇒ <code>ExpressionNode</code>
Represents a `return` shader operation in TSL.

**Kind**: global function  
**Returns**: <code>ExpressionNode</code> - The `return` expression.  
**Tsl**:   
## Classes

<dl>
<dt><a href="#EquirectUVNode">EquirectUVNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Can be used to compute texture coordinates for projecting an
equirectangular texture onto a mesh for using it as the scene&#39;s
background.</p>
<pre><code class="language-js">scene.backgroundNode = texture( equirectTexture, equirectUV() );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#equirectUV">equirectUV([dirNode])</a> ⇒ <code><a href="#EquirectUVNode">EquirectUVNode</a></code></dt>
<dd><p>TSL function for creating an equirect uv node.</p>
</dd>
</dl>

<a name="EquirectUVNode"></a>

## EquirectUVNode ⇐ <code>TempNode</code>
Can be used to compute texture coordinates for projecting an
equirectangular texture onto a mesh for using it as the scene's
background.

```js
scene.backgroundNode = texture( equirectTexture, equirectUV() );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [EquirectUVNode](#EquirectUVNode) ⇐ <code>TempNode</code>
    * [new EquirectUVNode([dirNode])](#new_EquirectUVNode_new)
    * [.dirNode](#EquirectUVNode+dirNode) : <code>Node.&lt;vec3&gt;</code>

<a name="new_EquirectUVNode_new"></a>

### new EquirectUVNode([dirNode])
Constructs a new equirect uv node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [dirNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionWorldDirection</code> | A direction vector for sampling which is by default `positionWorldDirection`. |

<a name="EquirectUVNode+dirNode"></a>

### equirectUVNode.dirNode : <code>Node.&lt;vec3&gt;</code>
A direction vector for sampling why is by default `positionWorldDirection`.

**Kind**: instance property of [<code>EquirectUVNode</code>](#EquirectUVNode)  
<a name="equirectUV"></a>

## equirectUV([dirNode]) ⇒ [<code>EquirectUVNode</code>](#EquirectUVNode)
TSL function for creating an equirect uv node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [dirNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionWorldDirection</code> | A direction vector for sampling which is by default `positionWorldDirection`. |

<a name="FlipNode"></a>

## FlipNode ⇐ <code>TempNode</code>
This module is part of the TSL core and usually not used in app level code.
It represents a flip operation during the shader generation process
meaning it flips normalized values with the following formula:
```
x = 1 - x;
```
`FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and
`flipSTPQ()` method invocations on node objects. For example:
```js
uvNode = uvNode.flipY();
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [FlipNode](#FlipNode) ⇐ <code>TempNode</code>
    * [new FlipNode(sourceNode, components)](#new_FlipNode_new)
    * [.sourceNode](#FlipNode+sourceNode) : <code>Node</code>
    * [.components](#FlipNode+components) : <code>string</code>
    * [.getNodeType(builder)](#FlipNode+getNodeType) ⇒ <code>string</code>

<a name="new_FlipNode_new"></a>

### new FlipNode(sourceNode, components)
Constructs a new flip node.


| Param | Type | Description |
| --- | --- | --- |
| sourceNode | <code>Node</code> | The node which component(s) should be flipped. |
| components | <code>string</code> | The components that should be flipped e.g. `'x'` or `'xy'`. |

<a name="FlipNode+sourceNode"></a>

### flipNode.sourceNode : <code>Node</code>
The node which component(s) should be flipped.

**Kind**: instance property of [<code>FlipNode</code>](#FlipNode)  
<a name="FlipNode+components"></a>

### flipNode.components : <code>string</code>
The components that should be flipped e.g. `'x'` or `'xy'`.

**Kind**: instance property of [<code>FlipNode</code>](#FlipNode)  
<a name="FlipNode+getNodeType"></a>

### flipNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the source node.

**Kind**: instance method of [<code>FlipNode</code>](#FlipNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#FunctionOverloadingNode">FunctionOverloadingNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class allows to define multiple overloaded versions
of the same function. Depending on the parameters of the function
call, the node picks the best-fit overloaded version.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#overloadingFn">overloadingFn(functionNodes)</a> ⇒ <code><a href="#FunctionOverloadingNode">FunctionOverloadingNode</a></code></dt>
<dd><p>TSL function for creating a function overloading node.</p>
</dd>
</dl>

<a name="FunctionOverloadingNode"></a>

## FunctionOverloadingNode ⇐ <code>Node</code>
This class allows to define multiple overloaded versions
of the same function. Depending on the parameters of the function
call, the node picks the best-fit overloaded version.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [FunctionOverloadingNode](#FunctionOverloadingNode) ⇐ <code>Node</code>
    * [new FunctionOverloadingNode(functionNodes, ...parametersNodes)](#new_FunctionOverloadingNode_new)
    * [.functionNodes](#FunctionOverloadingNode+functionNodes) : <code>Array.&lt;function()&gt;</code>
    * [.parametersNodes](#FunctionOverloadingNode+parametersNodes) : <code>Array.&lt;Node&gt;</code>
    * [.global](#FunctionOverloadingNode+global) : <code>boolean</code>
    * [.getNodeType(builder)](#FunctionOverloadingNode+getNodeType) ⇒ <code>string</code>

<a name="new_FunctionOverloadingNode_new"></a>

### new FunctionOverloadingNode(functionNodes, ...parametersNodes)
Constructs a new function overloading node.


| Param | Type | Description |
| --- | --- | --- |
| functionNodes | <code>Array.&lt;function()&gt;</code> | Array of `Fn` function definitions. |
| ...parametersNodes | <code>Node</code> | A list of parameter nodes. |

<a name="FunctionOverloadingNode+functionNodes"></a>

### functionOverloadingNode.functionNodes : <code>Array.&lt;function()&gt;</code>
Array of `Fn` function definitions.

**Kind**: instance property of [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)  
<a name="FunctionOverloadingNode+parametersNodes"></a>

### functionOverloadingNode.parametersNodes : <code>Array.&lt;Node&gt;</code>
A list of parameter nodes.

**Kind**: instance property of [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)  
<a name="FunctionOverloadingNode+global"></a>

### functionOverloadingNode.global : <code>boolean</code>
This node is marked as global.

**Kind**: instance property of [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)  
**Default**: <code>true</code>  
<a name="FunctionOverloadingNode+getNodeType"></a>

### functionOverloadingNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the function's return type.

**Kind**: instance method of [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="overloadingFn"></a>

## overloadingFn(functionNodes) ⇒ [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)
TSL function for creating a function overloading node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| functionNodes | <code>Array.&lt;function()&gt;</code> | Array of `Fn` function definitions. |

<a name="JoinNode"></a>

## JoinNode ⇐ <code>TempNode</code>
This module is part of the TSL core and usually not used in app level code.
It represents a join operation during the shader generation process.
For example in can compose/join two single floats into a `vec2` type.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [JoinNode](#JoinNode) ⇐ <code>TempNode</code>
    * [new JoinNode(nodes, [nodeType])](#new_JoinNode_new)
    * [.nodes](#JoinNode+nodes) : <code>Array.&lt;Node&gt;</code>
    * [.getNodeType(builder)](#JoinNode+getNodeType) ⇒ <code>string</code>

<a name="new_JoinNode_new"></a>

### new JoinNode(nodes, [nodeType])
Constructs a new join node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodes | <code>Array.&lt;Node&gt;</code> |  | An array of nodes that should be joined. |
| [nodeType] | <code>string</code> | <code>null</code> | The node type. |

<a name="JoinNode+nodes"></a>

### joinNode.nodes : <code>Array.&lt;Node&gt;</code>
An array of nodes that should be joined.

**Kind**: instance property of [<code>JoinNode</code>](#JoinNode)  
<a name="JoinNode+getNodeType"></a>

### joinNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type must be inferred from the
joined data length if not explicitly defined.

**Kind**: instance method of [<code>JoinNode</code>](#JoinNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#LoopNode">LoopNode</a> ⇐ <code>Node</code></dt>
<dd><p>This module offers a variety of ways to implement loops in TSL. In it&#39;s basic form it&#39;s:</p>
<pre><code class="language-js">Loop( count, ( { i } ) =&gt; {

} );
</code></pre>
<p>However, it is also possible to define a start and end ranges, data types and loop conditions:</p>
<pre><code class="language-js">Loop( { start: int( 0 ), end: int( 10 ), type: &#39;int&#39;, condition: &#39;&lt;&#39; }, ( { i } ) =&gt; {

} );
</code></pre>
<p>Nested loops can be defined in a compacted form:</p>
<pre><code class="language-js">Loop( 10, 5, ( { i, j } ) =&gt; {

} );
</code></pre>
<p>Loops that should run backwards can be defined like so:</p>
<pre><code class="language-js">Loop( { start: 10 }, () =&gt; {} );
</code></pre>
<p>The module also provides <code>Break()</code> and <code>Continue()</code> TSL expression for loop control.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#Loop">Loop(...params)</a> ⇒ <code><a href="#LoopNode">LoopNode</a></code></dt>
<dd><p>TSL function for creating a loop node.</p>
</dd>
<dt><a href="#Continue">Continue()</a> ⇒ <code>ExpressionNode</code></dt>
<dd><p>TSL function for creating a <code>Continue()</code> expression.</p>
</dd>
<dt><a href="#Break">Break()</a> ⇒ <code>ExpressionNode</code></dt>
<dd><p>TSL function for creating a <code>Break()</code> expression.</p>
</dd>
<dt><del><a href="#loop">loop(...params)</a> ⇒ <code><a href="#LoopNode">LoopNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="LoopNode"></a>

## LoopNode ⇐ <code>Node</code>
This module offers a variety of ways to implement loops in TSL. In it's basic form it's:
```js
Loop( count, ( { i } ) => {

} );
```
However, it is also possible to define a start and end ranges, data types and loop conditions:
```js
Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {

} );
```
Nested loops can be defined in a compacted form:
```js
Loop( 10, 5, ( { i, j } ) => {

} );
```
Loops that should run backwards can be defined like so:
```js
Loop( { start: 10 }, () => {} );
```
The module also provides `Break()` and `Continue()` TSL expression for loop control.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [LoopNode](#LoopNode) ⇐ <code>Node</code>
    * [new LoopNode(params)](#new_LoopNode_new)
    * [.getVarName(index)](#LoopNode+getVarName) ⇒ <code>string</code>
    * [.getProperties(builder)](#LoopNode+getProperties) ⇒ <code>Object</code>
    * [.getNodeType(builder)](#LoopNode+getNodeType) ⇒ <code>string</code>

<a name="new_LoopNode_new"></a>

### new LoopNode(params)
Constructs a new loop node.


| Param | Type | Description |
| --- | --- | --- |
| params | <code>Array.&lt;any&gt;</code> | Depending on the loop type, array holds different parameterization values for the loop. |

<a name="LoopNode+getVarName"></a>

### loopNode.getVarName(index) ⇒ <code>string</code>
Returns a loop variable name based on an index. The pattern is
`0` = `i`, `1`= `j`, `2`= `k` and so on.

**Kind**: instance method of [<code>LoopNode</code>](#LoopNode)  
**Returns**: <code>string</code> - The loop variable name.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index. |

<a name="LoopNode+getProperties"></a>

### loopNode.getProperties(builder) ⇒ <code>Object</code>
Returns properties about this node.

**Kind**: instance method of [<code>LoopNode</code>](#LoopNode)  
**Returns**: <code>Object</code> - The node properties.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LoopNode+getNodeType"></a>

### loopNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred based on the loop configuration.

**Kind**: instance method of [<code>LoopNode</code>](#LoopNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Loop"></a>

## Loop(...params) ⇒ [<code>LoopNode</code>](#LoopNode)
TSL function for creating a loop node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...params | <code>any</code> | A list of parameters. |

<a name="Continue"></a>

## Continue() ⇒ <code>ExpressionNode</code>
TSL function for creating a `Continue()` expression.

**Kind**: global function  
**Tsl**:   
<a name="Break"></a>

## Break() ⇒ <code>ExpressionNode</code>
TSL function for creating a `Break()` expression.

**Kind**: global function  
**Tsl**:   
<a name="loop"></a>

## ~~loop(...params) ⇒ [<code>LoopNode</code>](#LoopNode)~~
***since r168. Use [Loop](#Loop) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

## Classes

<dl>
<dt><a href="#MatcapUVNode">MatcapUVNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Can be used to compute texture coordinates for projecting a
matcap onto a mesh. Used by <a href="MeshMatcapNodeMaterial">MeshMatcapNodeMaterial</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#matcapUV">matcapUV()</a> ⇒ <code><a href="#MatcapUVNode">MatcapUVNode</a></code></dt>
<dd><p>TSL function for creating a matcap uv node.</p>
</dd>
</dl>

<a name="MatcapUVNode"></a>

## MatcapUVNode ⇐ <code>TempNode</code>
Can be used to compute texture coordinates for projecting a
matcap onto a mesh. Used by [MeshMatcapNodeMaterial](MeshMatcapNodeMaterial).

**Kind**: global class  
**Extends**: <code>TempNode</code>  
<a name="new_MatcapUVNode_new"></a>

### new MatcapUVNode()
Constructs a new matcap uv node.

<a name="matcapUV"></a>

## matcapUV() ⇒ [<code>MatcapUVNode</code>](#MatcapUVNode)
TSL function for creating a matcap uv node.

**Kind**: global function  
**Tsl**:   
## Classes

<dl>
<dt><a href="#MaxMipLevelNode">MaxMipLevelNode</a> ⇐ <code>UniformNode</code></dt>
<dd><p>A special type of uniform node that computes the
maximum mipmap level for a given texture node.</p>
<pre><code class="language-js">const level = maxMipLevel( textureNode );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#maxMipLevel">maxMipLevel(textureNode)</a> ⇒ <code><a href="#MaxMipLevelNode">MaxMipLevelNode</a></code></dt>
<dd><p>TSL function for creating a max mip level node.</p>
</dd>
</dl>

<a name="MaxMipLevelNode"></a>

## MaxMipLevelNode ⇐ <code>UniformNode</code>
A special type of uniform node that computes the
maximum mipmap level for a given texture node.

```js
const level = maxMipLevel( textureNode );
```

**Kind**: global class  
**Extends**: <code>UniformNode</code>  

* [MaxMipLevelNode](#MaxMipLevelNode) ⇐ <code>UniformNode</code>
    * [new MaxMipLevelNode(textureNode)](#new_MaxMipLevelNode_new)
    * [.updateType](#MaxMipLevelNode+updateType) : <code>string</code>
    * [.textureNode](#MaxMipLevelNode+textureNode) : <code>TextureNode</code>
    * [.texture](#MaxMipLevelNode+texture) : <code>Texture</code>

<a name="new_MaxMipLevelNode_new"></a>

### new MaxMipLevelNode(textureNode)
Constructs a new max mip level node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node to compute the max mip level for. |

<a name="MaxMipLevelNode+updateType"></a>

### maxMipLevelNode.updateType : <code>string</code>
The `updateType` is set to `NodeUpdateType.FRAME` since the node updates
the texture once per frame in its [MaxMipLevelNode#update](MaxMipLevelNode#update) method.

**Kind**: instance property of [<code>MaxMipLevelNode</code>](#MaxMipLevelNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="MaxMipLevelNode+textureNode"></a>

### maxMipLevelNode.textureNode : <code>TextureNode</code>
The texture node to compute the max mip level for.

**Kind**: instance property of [<code>MaxMipLevelNode</code>](#MaxMipLevelNode)  
**Read only**: true  
<a name="MaxMipLevelNode+texture"></a>

### maxMipLevelNode.texture : <code>Texture</code>
The texture.

**Kind**: instance property of [<code>MaxMipLevelNode</code>](#MaxMipLevelNode)  
**Read only**: true  
<a name="maxMipLevel"></a>

## maxMipLevel(textureNode) ⇒ [<code>MaxMipLevelNode</code>](#MaxMipLevelNode)
TSL function for creating a max mip level node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node to compute the max mip level for. |

<a name="MemberNode"></a>

## MemberNode ⇐ <code>Node</code>
Base class for representing member access on an object-like
node data structures.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [MemberNode](#MemberNode) ⇐ <code>Node</code>
    * [new MemberNode(node, property)](#new_MemberNode_new)
    * [.node](#MemberNode+node) : <code>Node</code>
    * [.property](#MemberNode+property) : <code>Node</code>
    * [.isMemberNode](#MemberNode+isMemberNode) : <code>boolean</code>

<a name="new_MemberNode_new"></a>

### new MemberNode(node, property)
Constructs an array element node.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The array-like node. |
| property | <code>string</code> | The property name. |

<a name="MemberNode+node"></a>

### memberNode.node : <code>Node</code>
The array-like node.

**Kind**: instance property of [<code>MemberNode</code>](#MemberNode)  
<a name="MemberNode+property"></a>

### memberNode.property : <code>Node</code>
The property name.

**Kind**: instance property of [<code>MemberNode</code>](#MemberNode)  
<a name="MemberNode+isMemberNode"></a>

### memberNode.isMemberNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MemberNode</code>](#MemberNode)  
**Default**: <code>true</code>  
**Read only**: true  
## Functions

<dl>
<dt><a href="#oscSine">oscSine(t)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Generates a sine wave oscillation based on a timer.</p>
</dd>
<dt><a href="#oscSquare">oscSquare(t)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Generates a square wave oscillation based on a timer.</p>
</dd>
<dt><a href="#oscTriangle">oscTriangle(t)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Generates a triangle wave oscillation based on a timer.</p>
</dd>
<dt><a href="#oscSawtooth">oscSawtooth(t)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Generates a sawtooth wave oscillation based on a timer.</p>
</dd>
</dl>

<a name="oscSine"></a>

## oscSine(t) ⇒ <code>Node.&lt;float&gt;</code>
Generates a sine wave oscillation based on a timer.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The oscillation node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node.&lt;float&gt;</code> | The timer to generate the oscillation with. |

<a name="oscSquare"></a>

## oscSquare(t) ⇒ <code>Node.&lt;float&gt;</code>
Generates a square wave oscillation based on a timer.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The oscillation node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node.&lt;float&gt;</code> | The timer to generate the oscillation with. |

<a name="oscTriangle"></a>

## oscTriangle(t) ⇒ <code>Node.&lt;float&gt;</code>
Generates a triangle wave oscillation based on a timer.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The oscillation node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node.&lt;float&gt;</code> | The timer to generate the oscillation with. |

<a name="oscSawtooth"></a>

## oscSawtooth(t) ⇒ <code>Node.&lt;float&gt;</code>
Generates a sawtooth wave oscillation based on a timer.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The oscillation node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node.&lt;float&gt;</code> | The timer to generate the oscillation with. |

## Functions

<dl>
<dt><a href="#directionToColor">directionToColor(node)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Packs a direction vector into a color value.</p>
</dd>
<dt><a href="#colorToDirection">colorToDirection(node)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Unpacks a color value into a direction vector.</p>
</dd>
</dl>

<a name="directionToColor"></a>

## directionToColor(node) ⇒ <code>Node.&lt;vec3&gt;</code>
Packs a direction vector into a color value.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> | The direction to pack. |

<a name="colorToDirection"></a>

## colorToDirection(node) ⇒ <code>Node.&lt;vec3&gt;</code>
Unpacks a color value into a direction vector.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The direction.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> | The color to unpack. |

## Functions

<dl>
<dt><a href="#getViewPosition">getViewPosition(screenPosition, depth, projectionMatrixInverse)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Computes a position in view space based on a fragment&#39;s screen position expressed as uv coordinates, the fragments
depth value and the camera&#39;s inverse projection matrix.</p>
</dd>
<dt><a href="#getScreenPosition">getScreenPosition(viewPosition, projectionMatrix)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Computes a screen position expressed as uv coordinates based on a fragment&#39;s position in view space
and the camera&#39;s projection matrix</p>
</dd>
<dt><a href="#getNormalFromDepth">getNormalFromDepth(uv, depthTexture, projectionMatrixInverse)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Computes a normal vector based on depth data. Can be used as a fallback when no normal render
target is available or if flat surface normals are required.</p>
</dd>
</dl>

<a name="getViewPosition"></a>

## getViewPosition(screenPosition, depth, projectionMatrixInverse) ⇒ <code>Node.&lt;vec3&gt;</code>
Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments
depth value and the camera's inverse projection matrix.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The fragments position in view space.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| screenPosition | <code>Node.&lt;vec2&gt;</code> | The fragment's screen position expressed as uv coordinates. |
| depth | <code>Node.&lt;float&gt;</code> | The fragment's depth value. |
| projectionMatrixInverse | <code>Node.&lt;mat4&gt;</code> | The camera's inverse projection matrix. |

<a name="getScreenPosition"></a>

## getScreenPosition(viewPosition, projectionMatrix) ⇒ <code>Node.&lt;vec2&gt;</code>
Computes a screen position expressed as uv coordinates based on a fragment's position in view space
and the camera's projection matrix

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The fragment's screen position expressed as uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| viewPosition | <code>Node.&lt;vec3&gt;</code> | The fragments position in view space. |
| projectionMatrix | <code>Node.&lt;mat4&gt;</code> | The camera's projection matrix. |

<a name="getNormalFromDepth"></a>

## getNormalFromDepth(uv, depthTexture, projectionMatrixInverse) ⇒ <code>Node.&lt;vec3&gt;</code>
Computes a normal vector based on depth data. Can be used as a fallback when no normal render
target is available or if flat surface normals are required.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The computed normal vector.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The texture coordinate. |
| depthTexture | <code>DepthTexture</code> | The depth texture. |
| projectionMatrixInverse | <code>Node.&lt;mat4&gt;</code> | The camera's inverse projection matrix. |

## Classes

<dl>
<dt><a href="#RTTNode">RTTNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p><code>RTTNode</code> takes another node and uses it with a <code>QuadMesh</code> to render into a texture (RTT).
This module is especially relevant in context of post processing where certain nodes require
texture input for their effects. With the helper function <code>convertToTexture()</code> which is based
on this module, the node system can automatically ensure texture input if required.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#rtt">rtt(node, [width], [height], [options])</a> ⇒ <code><a href="#RTTNode">RTTNode</a></code></dt>
<dd><p>TSL function for creating a RTT node.</p>
</dd>
<dt><a href="#convertToTexture">convertToTexture(node, [width], [height], [options])</a> ⇒ <code><a href="#RTTNode">RTTNode</a></code></dt>
<dd><p>TSL function for converting nodes to textures nodes.</p>
</dd>
</dl>

<a name="RTTNode"></a>

## RTTNode ⇐ <code>TextureNode</code>
`RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).
This module is especially relevant in context of post processing where certain nodes require
texture input for their effects. With the helper function `convertToTexture()` which is based
on this module, the node system can automatically ensure texture input if required.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [RTTNode](#RTTNode) ⇐ <code>TextureNode</code>
    * [new RTTNode(node, [width], [height], [options])](#new_RTTNode_new)
    * [.node](#RTTNode+node) : <code>Node</code>
    * [.width](#RTTNode+width) : <code>number</code>
    * [.height](#RTTNode+height) : <code>number</code>
    * [.pixelRatio](#RTTNode+pixelRatio) : <code>number</code>
    * [.renderTarget](#RTTNode+renderTarget) : <code>RenderTarget</code>
    * [.textureNeedsUpdate](#RTTNode+textureNeedsUpdate) : <code>boolean</code>
    * [.autoUpdate](#RTTNode+autoUpdate) : <code>boolean</code>
    * [.updateBeforeType](#RTTNode+updateBeforeType) : <code>string</code>
    * [.autoSize](#RTTNode+autoSize) : <code>boolean</code>
    * [.setSize(width, height)](#RTTNode+setSize)
    * [.setPixelRatio(pixelRatio)](#RTTNode+setPixelRatio)

<a name="new_RTTNode_new"></a>

### new RTTNode(node, [width], [height], [options])
Constructs a new RTT node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to render a texture with. |
| [width] | <code>number</code> | <code></code> | The width of the internal render target. If not width is applied, the render target is automatically resized. |
| [height] | <code>number</code> | <code></code> | The height of the internal render target. |
| [options] | <code>Object</code> | <code>{type:HalfFloatType}</code> | The options for the internal render target. |

<a name="RTTNode+node"></a>

### rttNode.node : <code>Node</code>
The node to render a texture with.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
<a name="RTTNode+width"></a>

### rttNode.width : <code>number</code>
The width of the internal render target.
If not width is applied, the render target is automatically resized.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>null</code>  
<a name="RTTNode+height"></a>

### rttNode.height : <code>number</code>
The height of the internal render target.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>null</code>  
<a name="RTTNode+pixelRatio"></a>

### rttNode.pixelRatio : <code>number</code>
The pixel ratio

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>1</code>  
<a name="RTTNode+renderTarget"></a>

### rttNode.renderTarget : <code>RenderTarget</code>
The render target

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
<a name="RTTNode+textureNeedsUpdate"></a>

### rttNode.textureNeedsUpdate : <code>boolean</code>
Whether the texture requires an update or not.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>true</code>  
<a name="RTTNode+autoUpdate"></a>

### rttNode.autoUpdate : <code>boolean</code>
Whether the texture should automatically be updated or not.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>true</code>  
<a name="RTTNode+updateBeforeType"></a>

### rttNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
the texture once per render in its [RTTNode#updateBefore](RTTNode#updateBefore) method.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="RTTNode+autoSize"></a>

### rttNode.autoSize : <code>boolean</code>
Whether the internal render target should automatically be resized or not.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="RTTNode+setSize"></a>

### rttNode.setSize(width, height)
Sets the size of the internal render target

**Kind**: instance method of [<code>RTTNode</code>](#RTTNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="RTTNode+setPixelRatio"></a>

### rttNode.setPixelRatio(pixelRatio)
Sets the pixel ratio. This will also resize the render target.

**Kind**: instance method of [<code>RTTNode</code>](#RTTNode)  

| Param | Type | Description |
| --- | --- | --- |
| pixelRatio | <code>number</code> | The pixel ratio to set. |

<a name="rtt"></a>

## rtt(node, [width], [height], [options]) ⇒ [<code>RTTNode</code>](#RTTNode)
TSL function for creating a RTT node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to render a texture with. |
| [width] | <code>number</code> | <code></code> | The width of the internal render target. If not width is applied, the render target is automatically resized. |
| [height] | <code>number</code> | <code></code> | The height of the internal render target. |
| [options] | <code>Object</code> | <code>{type:HalfFloatType}</code> | The options for the internal render target. |

<a name="convertToTexture"></a>

## convertToTexture(node, [width], [height], [options]) ⇒ [<code>RTTNode</code>](#RTTNode)
TSL function for converting nodes to textures nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to render a texture with. |
| [width] | <code>number</code> | <code></code> | The width of the internal render target. If not width is applied, the render target is automatically resized. |
| [height] | <code>number</code> | <code></code> | The height of the internal render target. |
| [options] | <code>Object</code> | <code>{type:HalfFloatType}</code> | The options for the internal render target. |

## Classes

<dl>
<dt><a href="#ReflectorNode">ReflectorNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>This node can be used to implement mirror-like flat reflective surfaces.</p>
<pre><code class="language-js">const groundReflector = reflector();
material.colorNode = groundReflector;

const plane = new Mesh( geometry, material );
plane.add( groundReflector.target );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#reflector">reflector([parameters])</a> ⇒ <code><a href="#ReflectorNode">ReflectorNode</a></code></dt>
<dd><p>TSL function for creating a reflector node.</p>
</dd>
</dl>

<a name="ReflectorNode"></a>

## ReflectorNode ⇐ <code>TextureNode</code>
This node can be used to implement mirror-like flat reflective surfaces.

```js
const groundReflector = reflector();
material.colorNode = groundReflector;

const plane = new Mesh( geometry, material );
plane.add( groundReflector.target );
```

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [ReflectorNode](#ReflectorNode) ⇐ <code>TextureNode</code>
    * [new ReflectorNode([parameters])](#new_ReflectorNode_new)
    * [.reflector](#ReflectorNode+reflector) : [<code>ReflectorBaseNode</code>](#new_ReflectorBaseNode_new)
    * [.target](#ReflectorNode+target) : <code>Object3D</code>
    * [.getDepthNode()](#ReflectorNode+getDepthNode) ⇒ <code>Node</code>

<a name="new_ReflectorNode_new"></a>

### new ReflectorNode([parameters])
Constructs a new reflector node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parameters] | <code>Object</code> | <code>{}</code> | An object holding configuration parameters. |
| [parameters.target] | <code>Object3D</code> | <code>new Object3D()</code> | The 3D object the reflector is linked to. |
| [parameters.resolution] | <code>number</code> | <code>1</code> | The resolution scale. |
| [parameters.generateMipmaps] | <code>boolean</code> | <code>false</code> | Whether mipmaps should be generated or not. |
| [parameters.bounces] | <code>boolean</code> | <code>true</code> | Whether reflectors can render other reflector nodes or not. |
| [parameters.depth] | <code>boolean</code> | <code>false</code> | Whether depth data should be generated or not. |
| [parameters.defaultTexture] | <code>TextureNode</code> |  | The default texture node. |
| [parameters.reflector] | [<code>ReflectorBaseNode</code>](#new_ReflectorBaseNode_new) |  | The reflector base node. |

<a name="ReflectorNode+reflector"></a>

### reflectorNode.reflector : [<code>ReflectorBaseNode</code>](#new_ReflectorBaseNode_new)
A reference to the internal reflector node.

**Kind**: instance property of [<code>ReflectorNode</code>](#ReflectorNode)  
<a name="ReflectorNode+target"></a>

### reflectorNode.target : <code>Object3D</code>
A reference to 3D object the reflector is linked to.

**Kind**: instance property of [<code>ReflectorNode</code>](#ReflectorNode)  
<a name="ReflectorNode+getDepthNode"></a>

### reflectorNode.getDepthNode() ⇒ <code>Node</code>
Returns a node representing the mirror's depth. That can be used
to implement more advanced reflection effects like distance attenuation.

**Kind**: instance method of [<code>ReflectorNode</code>](#ReflectorNode)  
**Returns**: <code>Node</code> - The depth node.  
<a name="reflector"></a>

## reflector([parameters]) ⇒ [<code>ReflectorNode</code>](#ReflectorNode)
TSL function for creating a reflector node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parameters] | <code>Object</code> | <code>{}</code> | An object holding configuration parameters. |
| [parameters.target] | <code>Object3D</code> | <code>new Object3D()</code> | The 3D object the reflector is linked to. |
| [parameters.resolution] | <code>number</code> | <code>1</code> | The resolution scale. |
| [parameters.generateMipmaps] | <code>boolean</code> | <code>false</code> | Whether mipmaps should be generated or not. |
| [parameters.bounces] | <code>boolean</code> | <code>true</code> | Whether reflectors can render other reflector nodes or not. |
| [parameters.depth] | <code>boolean</code> | <code>false</code> | Whether depth data should be generated or not. |
| [parameters.defaultTexture] | <code>TextureNode</code> |  | The default texture node. |
| [parameters.reflector] | [<code>ReflectorBaseNode</code>](#new_ReflectorBaseNode_new) |  | The reflector base node. |

## Classes

<dl>
<dt><a href="#RemapNode">RemapNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node allows to remap a node value from one range into another. E.g a value of
<code>0.4</code> in the range <code>[ 0.3, 0.5 ]</code> should be remapped into the normalized range <code>[ 0, 1 ]</code>.
<code>RemapNode</code> takes care of that and converts the original value of <code>0.4</code> to <code>0.5</code>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#remap">remap(node, inLowNode, inHighNode, [outLowNode], [outHighNode])</a> ⇒ <code><a href="#RemapNode">RemapNode</a></code></dt>
<dd><p>TSL function for creating a remap node.</p>
</dd>
<dt><a href="#remapClamp">remapClamp(node, inLowNode, inHighNode, [outLowNode], [outHighNode])</a> ⇒ <code><a href="#RemapNode">RemapNode</a></code></dt>
<dd><p>TSL function for creating a remap node, but with enabled clamping.</p>
</dd>
</dl>

<a name="RemapNode"></a>

## RemapNode ⇐ <code>Node</code>
This node allows to remap a node value from one range into another. E.g a value of
`0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.
`RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [RemapNode](#RemapNode) ⇐ <code>Node</code>
    * [new RemapNode(node, inLowNode, inHighNode, [outLowNode], [outHighNode])](#new_RemapNode_new)
    * [.node](#RemapNode+node) : <code>Node</code>
    * [.inLowNode](#RemapNode+inLowNode) : <code>Node</code>
    * [.inHighNode](#RemapNode+inHighNode) : <code>Node</code>
    * [.outLowNode](#RemapNode+outLowNode) : <code>Node</code>
    * [.outHighNode](#RemapNode+outHighNode) : <code>Node</code>
    * [.doClamp](#RemapNode+doClamp) : <code>boolean</code>

<a name="new_RemapNode_new"></a>

### new RemapNode(node, inLowNode, inHighNode, [outLowNode], [outHighNode])
Constructs a new remap node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be remapped. |
| inLowNode | <code>Node</code> |  | The source or current lower bound of the range. |
| inHighNode | <code>Node</code> |  | The source or current upper bound of the range. |
| [outLowNode] | <code>Node</code> | <code>float(0)</code> | The target lower bound of the range. |
| [outHighNode] | <code>Node</code> | <code>float(1)</code> | The target upper bound of the range. |

<a name="RemapNode+node"></a>

### remapNode.node : <code>Node</code>
The node that should be remapped.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
<a name="RemapNode+inLowNode"></a>

### remapNode.inLowNode : <code>Node</code>
The source or current lower bound of the range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
<a name="RemapNode+inHighNode"></a>

### remapNode.inHighNode : <code>Node</code>
The source or current upper bound of the range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
<a name="RemapNode+outLowNode"></a>

### remapNode.outLowNode : <code>Node</code>
The target lower bound of the range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
**Default**: <code>float(0)</code>  
<a name="RemapNode+outHighNode"></a>

### remapNode.outHighNode : <code>Node</code>
The target upper bound of the range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
**Default**: <code>float(1)</code>  
<a name="RemapNode+doClamp"></a>

### remapNode.doClamp : <code>boolean</code>
Whether the node value should be clamped before
remapping it to the target range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
**Default**: <code>true</code>  
<a name="remap"></a>

## remap(node, inLowNode, inHighNode, [outLowNode], [outHighNode]) ⇒ [<code>RemapNode</code>](#RemapNode)
TSL function for creating a remap node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be remapped. |
| inLowNode | <code>Node</code> |  | The source or current lower bound of the range. |
| inHighNode | <code>Node</code> |  | The source or current upper bound of the range. |
| [outLowNode] | <code>Node</code> | <code>float(0)</code> | The target lower bound of the range. |
| [outHighNode] | <code>Node</code> | <code>float(1)</code> | The target upper bound of the range. |

<a name="remapClamp"></a>

## remapClamp(node, inLowNode, inHighNode, [outLowNode], [outHighNode]) ⇒ [<code>RemapNode</code>](#RemapNode)
TSL function for creating a remap node, but with enabled clamping.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be remapped. |
| inLowNode | <code>Node</code> |  | The source or current lower bound of the range. |
| inHighNode | <code>Node</code> |  | The source or current upper bound of the range. |
| [outLowNode] | <code>Node</code> | <code>float(0)</code> | The target lower bound of the range. |
| [outHighNode] | <code>Node</code> | <code>float(1)</code> | The target upper bound of the range. |

## Classes

<dl>
<dt><a href="#RotateNode">RotateNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Applies a rotation to the given position node.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#rotate">rotate(positionNode, rotationNode)</a> ⇒ <code><a href="#RotateNode">RotateNode</a></code></dt>
<dd><p>TSL function for creating a rotate node.</p>
</dd>
</dl>

<a name="RotateNode"></a>

## RotateNode ⇐ <code>TempNode</code>
Applies a rotation to the given position node.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [RotateNode](#RotateNode) ⇐ <code>TempNode</code>
    * [new RotateNode(positionNode, rotationNode)](#new_RotateNode_new)
    * [.positionNode](#RotateNode+positionNode) : <code>Node</code>
    * [.rotationNode](#RotateNode+rotationNode) : <code>Node</code>
    * [.getNodeType(builder)](#RotateNode+getNodeType) ⇒ <code>string</code>

<a name="new_RotateNode_new"></a>

### new RotateNode(positionNode, rotationNode)
Constructs a new rotate node.


| Param | Type | Description |
| --- | --- | --- |
| positionNode | <code>Node</code> | The position node. |
| rotationNode | <code>Node</code> | Represents the rotation that is applied to the position node. Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value. |

<a name="RotateNode+positionNode"></a>

### rotateNode.positionNode : <code>Node</code>
The position node.

**Kind**: instance property of [<code>RotateNode</code>](#RotateNode)  
<a name="RotateNode+rotationNode"></a>

### rotateNode.rotationNode : <code>Node</code>
Represents the rotation that is applied to the position node.
 Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.

**Kind**: instance property of [<code>RotateNode</code>](#RotateNode)  
<a name="RotateNode+getNodeType"></a>

### rotateNode.getNodeType(builder) ⇒ <code>string</code>
The type of the [positionNode](#RotateNode+positionNode) defines the node's type.

**Kind**: instance method of [<code>RotateNode</code>](#RotateNode)  
**Returns**: <code>string</code> - The node's type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="rotate"></a>

## rotate(positionNode, rotationNode) ⇒ [<code>RotateNode</code>](#RotateNode)
TSL function for creating a rotate node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| positionNode | <code>Node</code> | The position node. |
| rotationNode | <code>Node</code> | Represents the rotation that is applied to the position node. Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value. |

<a name="SetNode"></a>

## SetNode ⇐ <code>TempNode</code>
This module is part of the TSL core and usually not used in app level code.
`SetNode` represents a set operation which means it is used to implement any
`setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.
For example:
```js
materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [SetNode](#SetNode) ⇐ <code>TempNode</code>
    * [new SetNode(sourceNode, components, targetNode)](#new_SetNode_new)
    * [.sourceNode](#SetNode+sourceNode) : <code>Node</code>
    * [.components](#SetNode+components) : <code>string</code>
    * [.targetNode](#SetNode+targetNode) : <code>Node</code>
    * [.getNodeType(builder)](#SetNode+getNodeType) ⇒ <code>string</code>

<a name="new_SetNode_new"></a>

### new SetNode(sourceNode, components, targetNode)
Constructs a new set node.


| Param | Type | Description |
| --- | --- | --- |
| sourceNode | <code>Node</code> | The node that should be updated. |
| components | <code>string</code> | The components that should be updated. |
| targetNode | <code>Node</code> | The value node. |

<a name="SetNode+sourceNode"></a>

### setNode.sourceNode : <code>Node</code>
The node that should be updated.

**Kind**: instance property of [<code>SetNode</code>](#SetNode)  
<a name="SetNode+components"></a>

### setNode.components : <code>string</code>
The components that should be updated.

**Kind**: instance property of [<code>SetNode</code>](#SetNode)  
<a name="SetNode+targetNode"></a>

### setNode.targetNode : <code>Node</code>
The value node.

**Kind**: instance property of [<code>SetNode</code>](#SetNode)  
<a name="SetNode+getNodeType"></a>

### setNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from [sourceNode](#SetNode+sourceNode).

**Kind**: instance method of [<code>SetNode</code>](#SetNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SplitNode"></a>

## SplitNode ⇐ <code>Node</code>
This module is part of the TSL core and usually not used in app level code.
`SplitNode` represents a property access operation which means it is
used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.
For example:
```js
const redValue = color.r;
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [SplitNode](#SplitNode) ⇐ <code>Node</code>
    * [new SplitNode(node, [components])](#new_SplitNode_new)
    * [.node](#SplitNode+node) : <code>Node</code>
    * [.components](#SplitNode+components) : <code>string</code>
    * [.isSplitNode](#SplitNode+isSplitNode) : <code>boolean</code>
    * [.getVectorLength()](#SplitNode+getVectorLength) ⇒ <code>number</code>
    * [.getComponentType(builder)](#SplitNode+getComponentType) ⇒ <code>string</code>
    * [.getNodeType(builder)](#SplitNode+getNodeType) ⇒ <code>string</code>

<a name="new_SplitNode_new"></a>

### new SplitNode(node, [components])
Constructs a new split node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be accessed. |
| [components] | <code>string</code> | <code>&quot;&#x27;x&#x27;&quot;</code> | The components that should be accessed. |

<a name="SplitNode+node"></a>

### splitNode.node : <code>Node</code>
The node that should be accessed.

**Kind**: instance property of [<code>SplitNode</code>](#SplitNode)  
<a name="SplitNode+components"></a>

### splitNode.components : <code>string</code>
The components that should be accessed.

**Kind**: instance property of [<code>SplitNode</code>](#SplitNode)  
<a name="SplitNode+isSplitNode"></a>

### splitNode.isSplitNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SplitNode</code>](#SplitNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SplitNode+getVectorLength"></a>

### splitNode.getVectorLength() ⇒ <code>number</code>
Returns the vector length which is computed based on the requested components.

**Kind**: instance method of [<code>SplitNode</code>](#SplitNode)  
**Returns**: <code>number</code> - The vector length.  
<a name="SplitNode+getComponentType"></a>

### splitNode.getComponentType(builder) ⇒ <code>string</code>
Returns the component type of the node's type.

**Kind**: instance method of [<code>SplitNode</code>](#SplitNode)  
**Returns**: <code>string</code> - The component type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SplitNode+getNodeType"></a>

### splitNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from requested components.

**Kind**: instance method of [<code>SplitNode</code>](#SplitNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#SpriteSheetUVNode">SpriteSheetUVNode</a> ⇐ <code>Node</code></dt>
<dd><p>Can be used to compute texture coordinates for animated sprite sheets.</p>
<pre><code class="language-js">const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );

material.colorNode = texture( spriteSheet, uvNode );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#spritesheetUV">spritesheetUV(countNode, [uvNode], [frameNode])</a> ⇒ <code><a href="#SpriteSheetUVNode">SpriteSheetUVNode</a></code></dt>
<dd><p>TSL function for creating a sprite sheet uv node.</p>
</dd>
</dl>

<a name="SpriteSheetUVNode"></a>

## SpriteSheetUVNode ⇐ <code>Node</code>
Can be used to compute texture coordinates for animated sprite sheets.

```js
const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );

material.colorNode = texture( spriteSheet, uvNode );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [SpriteSheetUVNode](#SpriteSheetUVNode) ⇐ <code>Node</code>
    * [new SpriteSheetUVNode(countNode, [uvNode], [frameNode])](#new_SpriteSheetUVNode_new)
    * [.countNode](#SpriteSheetUVNode+countNode) : <code>Node.&lt;vec2&gt;</code>
    * [.uvNode](#SpriteSheetUVNode+uvNode) : <code>Node.&lt;vec2&gt;</code>
    * [.frameNode](#SpriteSheetUVNode+frameNode) : <code>Node.&lt;float&gt;</code>

<a name="new_SpriteSheetUVNode_new"></a>

### new SpriteSheetUVNode(countNode, [uvNode], [frameNode])
Constructs a new sprite sheet uv node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| countNode | <code>Node.&lt;vec2&gt;</code> |  | The node that defines the number of sprites in the x and y direction (e.g 6x6). |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code>uv()</code> | The uv node. |
| [frameNode] | <code>Node.&lt;float&gt;</code> | <code>float()</code> | The node that defines the current frame/sprite. |

<a name="SpriteSheetUVNode+countNode"></a>

### spriteSheetUVNode.countNode : <code>Node.&lt;vec2&gt;</code>
The node that defines the number of sprites in the x and y direction (e.g 6x6).

**Kind**: instance property of [<code>SpriteSheetUVNode</code>](#SpriteSheetUVNode)  
<a name="SpriteSheetUVNode+uvNode"></a>

### spriteSheetUVNode.uvNode : <code>Node.&lt;vec2&gt;</code>
The uv node.

**Kind**: instance property of [<code>SpriteSheetUVNode</code>](#SpriteSheetUVNode)  
<a name="SpriteSheetUVNode+frameNode"></a>

### spriteSheetUVNode.frameNode : <code>Node.&lt;float&gt;</code>
The node that defines the current frame/sprite.

**Kind**: instance property of [<code>SpriteSheetUVNode</code>](#SpriteSheetUVNode)  
<a name="spritesheetUV"></a>

## spritesheetUV(countNode, [uvNode], [frameNode]) ⇒ [<code>SpriteSheetUVNode</code>](#SpriteSheetUVNode)
TSL function for creating a sprite sheet uv node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| countNode | <code>Node.&lt;vec2&gt;</code> |  | The node that defines the number of sprites in the x and y direction (e.g 6x6). |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code>uv()</code> | The uv node. |
| [frameNode] | <code>Node.&lt;float&gt;</code> | <code>float()</code> | The node that defines the current frame/sprite. |

<a name="billboarding"></a>

## billboarding(config) ⇒ <code>Node.&lt;vec3&gt;</code>
This can be used to achieve a billboarding behavior for flat meshes. That means they are
oriented always towards the camera.

```js
material.vertexNode = billboarding();
```

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The updated vertex position in clip space.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| config | <code>Object</code> |  | The configuration object. |
| [config.position] | <code>Node.&lt;vec3&gt;</code> | <code></code> | Can be used to define the vertex positions in world space. |
| [config.horizontal] | <code>boolean</code> | <code>true</code> | Whether to follow the camera rotation horizontally or not. |
| [config.vertical] | <code>boolean</code> | <code>false</code> | Whether to follow the camera rotation vertically or not. |

## Classes

<dl>
<dt><a href="#StorageArrayElementNode">StorageArrayElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>This class enables element access on instances of <a href="StorageBufferNode">StorageBufferNode</a>.
In most cases, it is indirectly used when accessing elements with the
<a href="StorageBufferNode#element">StorageBufferNode#element</a> method.</p>
<pre><code class="language-js">const position = positionStorage.element( instanceIndex );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#storageElement">storageElement(storageBufferNode, indexNode)</a> ⇒ <code><a href="#StorageArrayElementNode">StorageArrayElementNode</a></code></dt>
<dd><p>TSL function for creating a storage element node.</p>
</dd>
</dl>

<a name="StorageArrayElementNode"></a>

## StorageArrayElementNode ⇐ <code>ArrayElementNode</code>
This class enables element access on instances of [StorageBufferNode](StorageBufferNode).
In most cases, it is indirectly used when accessing elements with the
[StorageBufferNode#element](StorageBufferNode#element) method.

```js
const position = positionStorage.element( instanceIndex );
```

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [StorageArrayElementNode](#StorageArrayElementNode) ⇐ <code>ArrayElementNode</code>
    * [new StorageArrayElementNode(storageBufferNode, indexNode)](#new_StorageArrayElementNode_new)
    * [.isStorageArrayElementNode](#StorageArrayElementNode+isStorageArrayElementNode) : <code>boolean</code>
    * [.storageBufferNode](#StorageArrayElementNode+storageBufferNode) : <code>StorageBufferNode</code>

<a name="new_StorageArrayElementNode_new"></a>

### new StorageArrayElementNode(storageBufferNode, indexNode)
Constructs storage buffer element node.


| Param | Type | Description |
| --- | --- | --- |
| storageBufferNode | <code>StorageBufferNode</code> | The storage buffer node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="StorageArrayElementNode+isStorageArrayElementNode"></a>

### storageArrayElementNode.isStorageArrayElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageArrayElementNode</code>](#StorageArrayElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageArrayElementNode+storageBufferNode"></a>

### storageArrayElementNode.storageBufferNode : <code>StorageBufferNode</code>
The storage buffer node.

**Kind**: instance property of [<code>StorageArrayElementNode</code>](#StorageArrayElementNode)  

| Param | Type |
| --- | --- |
| value | <code>Node</code> | 

<a name="storageElement"></a>

## storageElement(storageBufferNode, indexNode) ⇒ [<code>StorageArrayElementNode</code>](#StorageArrayElementNode)
TSL function for creating a storage element node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| storageBufferNode | <code>StorageBufferNode</code> | The storage buffer node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

## Constants

<dl>
<dt><a href="#time">time</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>Represents the elapsed time in seconds.</p>
</dd>
<dt><a href="#deltaTime">deltaTime</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>Represents the delta time in seconds.</p>
</dd>
<dt><a href="#frameId">frameId</a> : <code>UniformNode.&lt;uint&gt;</code></dt>
<dd><p>Represents the current frame ID.</p>
</dd>
</dl>

## Functions

<dl>
<dt><del><a href="#timerLocal">timerLocal([timeScale])</a> ⇒ <code>UniformNode.&lt;float&gt;</code></del></dt>
<dd></dd>
<dt><del><a href="#timerGlobal">timerGlobal([timeScale])</a> ⇒ <code>UniformNode.&lt;float&gt;</code></del></dt>
<dd></dd>
<dt><del><a href="#timerDelta">timerDelta([timeScale])</a> ⇒ <code>UniformNode.&lt;float&gt;</code></del></dt>
<dd></dd>
</dl>

<a name="time"></a>

## time : <code>UniformNode.&lt;float&gt;</code>
Represents the elapsed time in seconds.

**Kind**: global constant  
**Tsl**:   
<a name="deltaTime"></a>

## deltaTime : <code>UniformNode.&lt;float&gt;</code>
Represents the delta time in seconds.

**Kind**: global constant  
**Tsl**:   
<a name="frameId"></a>

## frameId : <code>UniformNode.&lt;uint&gt;</code>
Represents the current frame ID.

**Kind**: global constant  
**Tsl**:   
<a name="timerLocal"></a>

## ~~timerLocal([timeScale]) ⇒ <code>UniformNode.&lt;float&gt;</code>~~
***since r170. Use [time](#time) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [timeScale] | <code>number</code> | <code>1</code> | The time scale. |

<a name="timerGlobal"></a>

## ~~timerGlobal([timeScale]) ⇒ <code>UniformNode.&lt;float&gt;</code>~~
***since r170. Use [time](#time) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [timeScale] | <code>number</code> | <code>1</code> | The time scale. |

<a name="timerDelta"></a>

## ~~timerDelta([timeScale]) ⇒ <code>UniformNode.&lt;float&gt;</code>~~
***since r170. Use [deltaTime](#deltaTime) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [timeScale] | <code>number</code> | <code>1</code> | The time scale. |

## Classes

<dl>
<dt><a href="#TriplanarTexturesNode">TriplanarTexturesNode</a> ⇐ <code>Node</code></dt>
<dd><p>Can be used for triplanar texture mapping.</p>
<pre><code class="language-js">material.colorNode = triplanarTexture( texture( diffuseMap ) );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#triplanarTextures">triplanarTextures(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode])</a> ⇒ <code><a href="#TriplanarTexturesNode">TriplanarTexturesNode</a></code></dt>
<dd><p>TSL function for creating a triplanar textures node.</p>
</dd>
<dt><a href="#triplanarTexture">triplanarTexture(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode])</a> ⇒ <code><a href="#TriplanarTexturesNode">TriplanarTexturesNode</a></code></dt>
<dd><p>TSL function for creating a triplanar textures node.</p>
</dd>
</dl>

<a name="TriplanarTexturesNode"></a>

## TriplanarTexturesNode ⇐ <code>Node</code>
Can be used for triplanar texture mapping.

```js
material.colorNode = triplanarTexture( texture( diffuseMap ) );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [TriplanarTexturesNode](#TriplanarTexturesNode) ⇐ <code>Node</code>
    * [new TriplanarTexturesNode(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode])](#new_TriplanarTexturesNode_new)
    * [.textureXNode](#TriplanarTexturesNode+textureXNode) : <code>Node</code>
    * [.textureYNode](#TriplanarTexturesNode+textureYNode) : <code>Node</code>
    * [.textureZNode](#TriplanarTexturesNode+textureZNode) : <code>Node</code>
    * [.scaleNode](#TriplanarTexturesNode+scaleNode) : <code>Node.&lt;float&gt;</code>
    * [.positionNode](#TriplanarTexturesNode+positionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.normalNode](#TriplanarTexturesNode+normalNode) : <code>Node.&lt;vec3&gt;</code>

<a name="new_TriplanarTexturesNode_new"></a>

### new TriplanarTexturesNode(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode])
Constructs a new triplanar textures node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureXNode | <code>Node</code> |  | First texture node. |
| [textureYNode] | <code>Node</code> | <code></code> | Second texture node. When not set, the shader will sample from `textureXNode` instead. |
| [textureZNode] | <code>Node</code> | <code></code> | Third texture node. When not set, the shader will sample from `textureXNode` instead. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The scale node. |
| [positionNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionLocal</code> | Vertex positions in local space. |
| [normalNode] | <code>Node.&lt;vec3&gt;</code> | <code>normalLocal</code> | Normals in local space. |

<a name="TriplanarTexturesNode+textureXNode"></a>

### triplanarTexturesNode.textureXNode : <code>Node</code>
First texture node.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
<a name="TriplanarTexturesNode+textureYNode"></a>

### triplanarTexturesNode.textureYNode : <code>Node</code>
Second texture node. When not set, the shader will sample from `textureXNode` instead.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>null</code>  
<a name="TriplanarTexturesNode+textureZNode"></a>

### triplanarTexturesNode.textureZNode : <code>Node</code>
Third texture node. When not set, the shader will sample from `textureXNode` instead.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>null</code>  
<a name="TriplanarTexturesNode+scaleNode"></a>

### triplanarTexturesNode.scaleNode : <code>Node.&lt;float&gt;</code>
The scale node.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>float(1)</code>  
<a name="TriplanarTexturesNode+positionNode"></a>

### triplanarTexturesNode.positionNode : <code>Node.&lt;vec3&gt;</code>
Vertex positions in local space.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>positionLocal</code>  
<a name="TriplanarTexturesNode+normalNode"></a>

### triplanarTexturesNode.normalNode : <code>Node.&lt;vec3&gt;</code>
Normals in local space.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>normalLocal</code>  
<a name="triplanarTextures"></a>

## triplanarTextures(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode]) ⇒ [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)
TSL function for creating a triplanar textures node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureXNode | <code>Node</code> |  | First texture node. |
| [textureYNode] | <code>Node</code> | <code></code> | Second texture node. When not set, the shader will sample from `textureXNode` instead. |
| [textureZNode] | <code>Node</code> | <code></code> | Third texture node. When not set, the shader will sample from `textureXNode` instead. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The scale node. |
| [positionNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionLocal</code> | Vertex positions in local space. |
| [normalNode] | <code>Node.&lt;vec3&gt;</code> | <code>normalLocal</code> | Normals in local space. |

<a name="triplanarTexture"></a>

## triplanarTexture(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode]) ⇒ [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)
TSL function for creating a triplanar textures node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureXNode | <code>Node</code> |  | First texture node. |
| [textureYNode] | <code>Node</code> | <code></code> | Second texture node. When not set, the shader will sample from `textureXNode` instead. |
| [textureZNode] | <code>Node</code> | <code></code> | Third texture node. When not set, the shader will sample from `textureXNode` instead. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The scale node. |
| [positionNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionLocal</code> | Vertex positions in local space. |
| [normalNode] | <code>Node.&lt;vec3&gt;</code> | <code>normalLocal</code> | Normals in local space. |

## Functions

<dl>
<dt><a href="#rotateUV">rotateUV(uv, rotation, center)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Rotates the given uv coordinates around a center point</p>
</dd>
<dt><a href="#spherizeUV">spherizeUV(uv, strength, center)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Applies a spherical warping effect to the given uv coordinates.</p>
</dd>
</dl>

<a name="rotateUV"></a>

## rotateUV(uv, rotation, center) ⇒ <code>Node.&lt;vec2&gt;</code>
Rotates the given uv coordinates around a center point

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The rotated uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The uv coordinates. |
| rotation | <code>Node.&lt;float&gt;</code> | The rotation defined in radians. |
| center | <code>Node.&lt;vec2&gt;</code> | The center of rotation |

<a name="spherizeUV"></a>

## spherizeUV(uv, strength, center) ⇒ <code>Node.&lt;vec2&gt;</code>
Applies a spherical warping effect to the given uv coordinates.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The updated uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The uv coordinates. |
| strength | <code>Node.&lt;float&gt;</code> | The strength of the effect. |
| center | <code>Node.&lt;vec2&gt;</code> | The center point |

<a name="viewportSafeUV"></a>

## viewportSafeUV(uv) ⇒ <code>Node.&lt;vec2&gt;</code>
A special version of a screen uv function that involves a depth comparison
when computing the final uvs. The function mitigates visual errors when
using viewport texture nodes for refraction purposes. Without this function
objects in front of a refractive surface might appear on the refractive surface
which is incorrect.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The update uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | Optional uv coordinates. By default `screenUV` is used. |

<a name="BatchedMesh"></a>

## BatchedMesh ⇐ <code>Mesh</code>
A special version of a mesh with multi draw batch rendering support. Use
this class if you have to render a large number of objects with the same
material but with different geometries or world transformations. The usage of
`BatchedMesh` will help you to reduce the number of draw calls and thus improve the overall
rendering performance in your application.

```js
const box = new THREE.BoxGeometry( 1, 1, 1 );
const sphere = new THREE.SphereGeometry( 1, 12, 12 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

// initialize and add geometries into the batched mesh
const batchedMesh = new BatchedMesh( 10, 5000, 10000, material );
const boxGeometryId = batchedMesh.addGeometry( box );
const sphereGeometryId = batchedMesh.addGeometry( sphere );

// create instances of those geometries
const boxInstancedId1 = batchedMesh.addInstance( boxGeometryId );
const boxInstancedId2 = batchedMesh.addInstance( boxGeometryId );

const sphereInstancedId1 = batchedMesh.addInstance( sphereGeometryId );
const sphereInstancedId2 = batchedMesh.addInstance( sphereGeometryId );

// position the geometries
batchedMesh.setMatrixAt( boxInstancedId1, boxMatrix1 );
batchedMesh.setMatrixAt( boxInstancedId2, boxMatrix2 );

batchedMesh.setMatrixAt( sphereInstancedId1, sphereMatrix1 );
batchedMesh.setMatrixAt( sphereInstancedId2, sphereMatrix2 );

scene.add( batchedMesh );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [BatchedMesh](#BatchedMesh) ⇐ <code>Mesh</code>
    * [new BatchedMesh(maxInstanceCount, maxVertexCount, [maxIndexCount], [material])](#new_BatchedMesh_new)
    * [.isBatchedMesh](#BatchedMesh+isBatchedMesh) : <code>boolean</code>
    * [.perObjectFrustumCulled](#BatchedMesh+perObjectFrustumCulled) : <code>boolean</code>
    * [.sortObjects](#BatchedMesh+sortObjects) : <code>boolean</code>
    * [.boundingBox](#BatchedMesh+boundingBox) : <code>Box3</code>
    * [.boundingSphere](#BatchedMesh+boundingSphere) : <code>Sphere</code>
    * [.customSort](#BatchedMesh+customSort) : <code>function</code>
    * [.maxInstanceCount](#BatchedMesh+maxInstanceCount) : <code>number</code>
    * [.instanceCount](#BatchedMesh+instanceCount) : <code>number</code>
    * [.unusedVertexCount](#BatchedMesh+unusedVertexCount) : <code>number</code>
    * [.unusedIndexCount](#BatchedMesh+unusedIndexCount) : <code>number</code>
    * [.validateInstanceId(instanceId)](#BatchedMesh+validateInstanceId)
    * [.validateGeometryId(geometryId)](#BatchedMesh+validateGeometryId)
    * [.setCustomSort(func)](#BatchedMesh+setCustomSort) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.computeBoundingBox()](#BatchedMesh+computeBoundingBox)
    * [.computeBoundingSphere()](#BatchedMesh+computeBoundingSphere)
    * [.addInstance(geometryId)](#BatchedMesh+addInstance) ⇒ <code>number</code>
    * [.addGeometry(geometry, [reservedVertexCount], [reservedIndexCount])](#BatchedMesh+addGeometry) ⇒ <code>number</code>
    * [.setGeometryAt(geometryId, geometry)](#BatchedMesh+setGeometryAt) ⇒ <code>number</code>
    * [.deleteGeometry(geometryId)](#BatchedMesh+deleteGeometry) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.deleteInstance(instanceId)](#BatchedMesh+deleteInstance) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.optimize(instanceId)](#BatchedMesh+optimize) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getBoundingBoxAt(geometryId, target)](#BatchedMesh+getBoundingBoxAt) ⇒ <code>Box3</code> \| <code>null</code>
    * [.getBoundingSphereAt(geometryId, target)](#BatchedMesh+getBoundingSphereAt) ⇒ <code>Sphere</code> \| <code>null</code>
    * [.setMatrixAt(instanceId, matrix)](#BatchedMesh+setMatrixAt) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getMatrixAt(instanceId, matrix)](#BatchedMesh+getMatrixAt) ⇒ <code>Matrix4</code>
    * [.setColorAt(instanceId, color)](#BatchedMesh+setColorAt) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getColorAt(instanceId, color)](#BatchedMesh+getColorAt) ⇒ <code>Color</code>
    * [.setVisibleAt(instanceId, visible)](#BatchedMesh+setVisibleAt) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getVisibleAt(instanceId)](#BatchedMesh+getVisibleAt) ⇒ <code>boolean</code>
    * [.setGeometryIdAt(instanceId, geometryId)](#BatchedMesh+setGeometryIdAt) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getGeometryIdAt(instanceId)](#BatchedMesh+getGeometryIdAt) ⇒ <code>number</code>
    * [.getGeometryRangeAt(geometryId, [target])](#BatchedMesh+getGeometryRangeAt) ⇒ <code>Object</code>
    * [.setInstanceCount(maxInstanceCount)](#BatchedMesh+setInstanceCount)
    * [.setGeometrySize(maxVertexCount, maxIndexCount)](#BatchedMesh+setGeometrySize)
    * [.dispose()](#BatchedMesh+dispose)

<a name="new_BatchedMesh_new"></a>

### new BatchedMesh(maxInstanceCount, maxVertexCount, [maxIndexCount], [material])
Constructs a new batched mesh.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| maxInstanceCount | <code>number</code> |  | The maximum number of individual instances planned to be added and rendered. |
| maxVertexCount | <code>number</code> |  | The maximum number of vertices to be used by all unique geometries. |
| [maxIndexCount] | <code>number</code> | <code>maxVertexCount*2</code> | The maximum number of indices to be used by all unique geometries |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> |  | The mesh material. |

<a name="BatchedMesh+isBatchedMesh"></a>

### batchedMesh.isBatchedMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BatchedMesh+perObjectFrustumCulled"></a>

### batchedMesh.perObjectFrustumCulled : <code>boolean</code>
When set ot `true`, the individual objects of a batch are frustum culled.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>true</code>  
<a name="BatchedMesh+sortObjects"></a>

### batchedMesh.sortObjects : <code>boolean</code>
When set to `true`, the individual objects of a batch are sorted to improve overdraw-related artifacts.
If the material is marked as "transparent" objects are rendered back to front and if not then they are
rendered front to back.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>true</code>  
<a name="BatchedMesh+boundingBox"></a>

### batchedMesh.boundingBox : <code>Box3</code>
The bounding box of the batched mesh. Can be computed via [computeBoundingBox](#BatchedMesh+computeBoundingBox).

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>null</code>  
<a name="BatchedMesh+boundingSphere"></a>

### batchedMesh.boundingSphere : <code>Sphere</code>
The bounding sphere of the batched mesh. Can be computed via [computeBoundingSphere](#BatchedMesh+computeBoundingSphere).

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>null</code>  
<a name="BatchedMesh+customSort"></a>

### batchedMesh.customSort : <code>function</code>
Takes a sort a function that is run before render. The function takes a list of instances to
sort and a camera. The objects in the list include a "z" field to perform a depth-ordered
sort with.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>null</code>  
<a name="BatchedMesh+maxInstanceCount"></a>

### batchedMesh.maxInstanceCount : <code>number</code>
The maximum number of individual instances that can be stored in the batch.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Read only**: true  
<a name="BatchedMesh+instanceCount"></a>

### batchedMesh.instanceCount : <code>number</code>
The instance count.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Read only**: true  
<a name="BatchedMesh+unusedVertexCount"></a>

### batchedMesh.unusedVertexCount : <code>number</code>
The number of unused vertices.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Read only**: true  
<a name="BatchedMesh+unusedIndexCount"></a>

### batchedMesh.unusedIndexCount : <code>number</code>
The number of unused indices.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Read only**: true  
<a name="BatchedMesh+validateInstanceId"></a>

### batchedMesh.validateInstanceId(instanceId)
Validates the instance defined by the given ID.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The instance to validate. |

<a name="BatchedMesh+validateGeometryId"></a>

### batchedMesh.validateGeometryId(geometryId)
Validates the geometry defined by the given ID.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The geometry to validate. |

<a name="BatchedMesh+setCustomSort"></a>

### batchedMesh.setCustomSort(func) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Takes a sort a function that is run before render. The function takes a list of instances to
sort and a camera. The objects in the list include a "z" field to perform a depth-ordered sort with.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| func | <code>function</code> | The custom sort function. |

<a name="BatchedMesh+computeBoundingBox"></a>

### batchedMesh.computeBoundingBox()
Computes the bounding box, updating [boundingBox](#BatchedMesh+boundingBox).
Bounding boxes aren't computed by default. They need to be explicitly computed,
otherwise they are `null`.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
<a name="BatchedMesh+computeBoundingSphere"></a>

### batchedMesh.computeBoundingSphere()
Computes the bounding sphere, updating [boundingSphere](#BatchedMesh+boundingSphere).
Bounding spheres aren't computed by default. They need to be explicitly computed,
otherwise they are `null`.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
<a name="BatchedMesh+addInstance"></a>

### batchedMesh.addInstance(geometryId) ⇒ <code>number</code>
Adds a new instance to the batch using the geometry of the given ID and returns
a new id referring to the new instance to be used by other functions.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>number</code> - The instance ID.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of a previously added geometry via [addGeometry](#BatchedMesh+addGeometry). |

<a name="BatchedMesh+addGeometry"></a>

### batchedMesh.addGeometry(geometry, [reservedVertexCount], [reservedIndexCount]) ⇒ <code>number</code>
Adds the given geometry to the batch and returns the associated
geometry id referring to it to be used in other functions.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>number</code> - The geometry ID.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to add. |
| [reservedVertexCount] | <code>number</code> | <code>-1</code> | Optional parameter specifying the amount of vertex buffer space to reserve for the added geometry. This is necessary if it is planned to set a new geometry at this index at a later time that is larger than the original geometry. Defaults to the length of the given geometry vertex buffer. |
| [reservedIndexCount] | <code>number</code> | <code>-1</code> | Optional parameter specifying the amount of index buffer space to reserve for the added geometry. This is necessary if it is planned to set a new geometry at this index at a later time that is larger than the original geometry. Defaults to the length of the given geometry index buffer. |

<a name="BatchedMesh+setGeometryAt"></a>

### batchedMesh.setGeometryAt(geometryId, geometry) ⇒ <code>number</code>
Replaces the geometry at the given ID with the provided geometry. Throws an error if there
is not enough space reserved for geometry. Calling this will change all instances that are
rendering that geometry.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>number</code> - The geometry ID.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of the geometry that should be replaced with the given geometry. |
| geometry | <code>BufferGeometry</code> | The new geometry. |

<a name="BatchedMesh+deleteGeometry"></a>

### batchedMesh.deleteGeometry(geometryId) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Deletes the geometry defined by the given ID from this batch. Any instances referencing
this geometry will also be removed as a side effect.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of the geometry to remove from the batch. |

<a name="BatchedMesh+deleteInstance"></a>

### batchedMesh.deleteInstance(instanceId) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Deletes an existing instance from the batch using the given ID.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of the instance to remove from the batch. |

<a name="BatchedMesh+optimize"></a>

### batchedMesh.optimize(instanceId) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Repacks the sub geometries in [name] to remove any unused space remaining from
previously deleted geometry, freeing up space to add new geometry.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of the instance to remove from the batch. |

<a name="BatchedMesh+getBoundingBoxAt"></a>

### batchedMesh.getBoundingBoxAt(geometryId, target) ⇒ <code>Box3</code> \| <code>null</code>
Returns the bounding box for the given geometry.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Box3</code> \| <code>null</code> - The geometry's bounding box. Returns `null` if no geometry has been found for the given ID.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of the geometry to return the bounding box for. |
| target | <code>Box3</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+getBoundingSphereAt"></a>

### batchedMesh.getBoundingSphereAt(geometryId, target) ⇒ <code>Sphere</code> \| <code>null</code>
Returns the bounding sphere for the given geometry.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Sphere</code> \| <code>null</code> - The geometry's bounding sphere. Returns `null` if no geometry has been found for the given ID.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of the geometry to return the bounding sphere for. |
| target | <code>Sphere</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+setMatrixAt"></a>

### batchedMesh.setMatrixAt(instanceId, matrix) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Sets the given local transformation matrix to the defined instance.
Negatively scaled matrices are not supported.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to set the matrix of. |
| matrix | <code>Matrix4</code> | A 4x4 matrix representing the local transformation of a single instance. |

<a name="BatchedMesh+getMatrixAt"></a>

### batchedMesh.getMatrixAt(instanceId, matrix) ⇒ <code>Matrix4</code>
Returns the local transformation matrix of the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Matrix4</code> - The instance's local transformation matrix.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to get the matrix of. |
| matrix | <code>Matrix4</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+setColorAt"></a>

### batchedMesh.setColorAt(instanceId, color) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Sets the given color to the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to set the color of. |
| color | <code>Color</code> | The color to set the instance to. |

<a name="BatchedMesh+getColorAt"></a>

### batchedMesh.getColorAt(instanceId, color) ⇒ <code>Color</code>
Returns the color of the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Color</code> - The instance's color.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to get the color of. |
| color | <code>Color</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+setVisibleAt"></a>

### batchedMesh.setVisibleAt(instanceId, visible) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Sets the visibility of the instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The id of the instance to set the visibility of. |
| visible | <code>boolean</code> | Whether the instance is visible or not. |

<a name="BatchedMesh+getVisibleAt"></a>

### batchedMesh.getVisibleAt(instanceId) ⇒ <code>boolean</code>
Returns the visibility state of the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>boolean</code> - Whether the instance is visible or not.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to get the visibility state of. |

<a name="BatchedMesh+setGeometryIdAt"></a>

### batchedMesh.setGeometryIdAt(instanceId, geometryId) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Sets the geometry ID of the instance at the given index.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of the instance to set the geometry ID of. |
| geometryId | <code>number</code> | The geometry ID to be use by the instance. |

<a name="BatchedMesh+getGeometryIdAt"></a>

### batchedMesh.getGeometryIdAt(instanceId) ⇒ <code>number</code>
Returns the geometry ID of the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>number</code> - The instance's geometry ID.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to get the geometry ID of. |

<a name="BatchedMesh+getGeometryRangeAt"></a>

### batchedMesh.getGeometryRangeAt(geometryId, [target]) ⇒ <code>Object</code>
Get the range representing the subset of triangles related to the attached geometry,
indicating the starting offset and count, or `null` if invalid.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Object</code> - The result object with range data.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The id of the geometry to get the range of. |
| [target] | <code>Object</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+setInstanceCount"></a>

### batchedMesh.setInstanceCount(maxInstanceCount)
Resizes the necessary buffers to support the provided number of instances.
If the provided arguments shrink the number of instances but there are not enough
unused Ids at the end of the list then an error is thrown.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| maxInstanceCount | <code>number</code> | The max number of individual instances that can be added and rendered by the batch. |

<a name="BatchedMesh+setGeometrySize"></a>

### batchedMesh.setGeometrySize(maxVertexCount, maxIndexCount)
Resizes the available space in the batch's vertex and index buffer attributes to the provided sizes.
If the provided arguments shrink the geometry buffers but there is not enough unused space at the
end of the geometry attributes then an error is thrown.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| maxVertexCount | <code>number</code> | The maximum number of vertices to be used by all unique geometries to resize to. |
| maxIndexCount | <code>number</code> | The maximum number of indices to be used by all unique geometries to resize to. |

<a name="BatchedMesh+dispose"></a>

### batchedMesh.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
<a name="Bone"></a>

## Bone ⇐ <code>Object3D</code>
A bone which is part of a [Skeleton](Skeleton). The skeleton in turn is used by
the [SkinnedMesh](SkinnedMesh).

```js
const root = new THREE.Bone();
const child = new THREE.Bone();

root.add( child );
child.position.y = 5;
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Bone](#Bone) ⇐ <code>Object3D</code>
    * [new Bone()](#new_Bone_new)
    * [.isBone](#Bone+isBone) : <code>boolean</code>

<a name="new_Bone_new"></a>

### new Bone()
Constructs a new bone.

<a name="Bone+isBone"></a>

### bone.isBone : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Bone</code>](#Bone)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ClippingGroup"></a>

## ClippingGroup ⇐ <code>Group</code>
In earlier three.js versions, clipping was defined globally
on the renderer or on material level. This special version of
`THREE.Group` allows to encode the clipping state into the scene
graph. Meaning if you create an instance of this group, all
descendant 3D objects will be affected by the respective clipping
planes.

Note: `ClippingGroup` can only be used with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>Group</code>  

* [ClippingGroup](#ClippingGroup) ⇐ <code>Group</code>
    * [new ClippingGroup()](#new_ClippingGroup_new)
    * [.isClippingGroup](#ClippingGroup+isClippingGroup) : <code>boolean</code>
    * [.clippingPlanes](#ClippingGroup+clippingPlanes) : <code>Array.&lt;Plane&gt;</code>
    * [.enabled](#ClippingGroup+enabled) : <code>boolean</code>
    * [.clipIntersection](#ClippingGroup+clipIntersection) : <code>boolean</code>
    * [.clipShadows](#ClippingGroup+clipShadows) : <code>boolean</code>

<a name="new_ClippingGroup_new"></a>

### new ClippingGroup()
Constructs a new clipping group.

<a name="ClippingGroup+isClippingGroup"></a>

### clippingGroup.isClippingGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ClippingGroup+clippingPlanes"></a>

### clippingGroup.clippingPlanes : <code>Array.&lt;Plane&gt;</code>
An array with clipping planes.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
<a name="ClippingGroup+enabled"></a>

### clippingGroup.enabled : <code>boolean</code>
Whether clipping should be enabled or not.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
**Default**: <code>true</code>  
<a name="ClippingGroup+clipIntersection"></a>

### clippingGroup.clipIntersection : <code>boolean</code>
Whether the intersection of the clipping planes is used to clip objects, rather than their union.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
**Default**: <code>false</code>  
<a name="ClippingGroup+clipShadows"></a>

### clippingGroup.clipShadows : <code>boolean</code>
Whether shadows should be clipped or not.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
**Default**: <code>false</code>  
<a name="Group"></a>

## Group ⇐ <code>Object3D</code>
This is almost identical to an [Object3D](Object3D). Its purpose is to
make working with groups of objects syntactically clearer.

```js
// Create a group and add the two cubes.
// These cubes can now be rotated / scaled etc as a group.
const group = new THREE.Group();

group.add( meshA );
group.add( meshB );

scene.add( group );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  
<a name="Group+isGroup"></a>

### group.isGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Group</code>](#Group)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InstancedMesh"></a>

## InstancedMesh ⇐ <code>Mesh</code>
A special version of a mesh with instanced rendering support. Use
this class if you have to render a large number of objects with the same
geometry and material(s) but with different world transformations. The usage
of 'InstancedMesh' will help you to reduce the number of draw calls and thus
improve the overall rendering performance in your application.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [InstancedMesh](#InstancedMesh) ⇐ <code>Mesh</code>
    * [new InstancedMesh([geometry], [material], count)](#new_InstancedMesh_new)
    * [.isInstancedMesh](#InstancedMesh+isInstancedMesh) : <code>boolean</code>
    * [.instanceMatrix](#InstancedMesh+instanceMatrix) : <code>InstancedBufferAttribute</code>
    * [.instanceColor](#InstancedMesh+instanceColor) : <code>InstancedBufferAttribute</code>
    * [.morphTexture](#InstancedMesh+morphTexture) : <code>DataTexture</code>
    * [.count](#InstancedMesh+count) : <code>number</code>
    * [.boundingBox](#InstancedMesh+boundingBox) : <code>Box3</code>
    * [.boundingSphere](#InstancedMesh+boundingSphere) : <code>Sphere</code>
    * [.computeBoundingBox()](#InstancedMesh+computeBoundingBox)
    * [.computeBoundingSphere()](#InstancedMesh+computeBoundingSphere)
    * [.getColorAt(index, color)](#InstancedMesh+getColorAt)
    * [.getMatrixAt(index, matrix)](#InstancedMesh+getMatrixAt)
    * [.getMorphAt(index, object)](#InstancedMesh+getMorphAt)
    * [.setColorAt(index, color)](#InstancedMesh+setColorAt)
    * [.setMatrixAt(index, matrix)](#InstancedMesh+setMatrixAt)
    * [.setMorphAt(index, object)](#InstancedMesh+setMorphAt)
    * [.dispose()](#InstancedMesh+dispose)

<a name="new_InstancedMesh_new"></a>

### new InstancedMesh([geometry], [material], count)
Constructs a new instanced mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |
| count | <code>number</code> | The number of instances. |

<a name="InstancedMesh+isInstancedMesh"></a>

### instancedMesh.isInstancedMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InstancedMesh+instanceMatrix"></a>

### instancedMesh.instanceMatrix : <code>InstancedBufferAttribute</code>
Represents the local transformation of all instances. You have to set its
[BufferAttribute#needsUpdate](BufferAttribute#needsUpdate) flag to true if you modify instanced data
via [setMatrixAt](#InstancedMesh+setMatrixAt).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="InstancedMesh+instanceColor"></a>

### instancedMesh.instanceColor : <code>InstancedBufferAttribute</code>
Represents the color of all instances. You have to set its
[BufferAttribute#needsUpdate](BufferAttribute#needsUpdate) flag to true if you modify instanced data
via [setColorAt](#InstancedMesh+setColorAt).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>null</code>  
<a name="InstancedMesh+morphTexture"></a>

### instancedMesh.morphTexture : <code>DataTexture</code>
Represents the morph target weights of all instances. You have to set its
[Texture#needsUpdate](Texture#needsUpdate) flag to true if you modify instanced data
via [setMorphAt](#InstancedMesh+setMorphAt).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>null</code>  
<a name="InstancedMesh+count"></a>

### instancedMesh.count : <code>number</code>
The number of instances.

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="InstancedMesh+boundingBox"></a>

### instancedMesh.boundingBox : <code>Box3</code>
The bounding box of the instanced mesh. Can be computed via [computeBoundingBox](#InstancedMesh+computeBoundingBox).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>null</code>  
<a name="InstancedMesh+boundingSphere"></a>

### instancedMesh.boundingSphere : <code>Sphere</code>
The bounding sphere of the instanced mesh. Can be computed via [computeBoundingSphere](#InstancedMesh+computeBoundingSphere).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>null</code>  
<a name="InstancedMesh+computeBoundingBox"></a>

### instancedMesh.computeBoundingBox()
Computes the bounding box of the instanced mesh, and updates [boundingBox](#InstancedMesh+boundingBox).
The bounding box is not automatically computed by the engine; this method must be called by your app.
You may need to recompute the bounding box if an instance is transformed via [setMatrixAt](#InstancedMesh+setMatrixAt).

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="InstancedMesh+computeBoundingSphere"></a>

### instancedMesh.computeBoundingSphere()
Computes the bounding sphere of the instanced mesh, and updates [boundingSphere](#InstancedMesh+boundingSphere)
The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
You may need to recompute the bounding sphere if an instance is transformed via [setMatrixAt](#InstancedMesh+setMatrixAt).

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="InstancedMesh+getColorAt"></a>

### instancedMesh.getColorAt(index, color)
Gets the color of the defined instance.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| color | <code>Color</code> | The target object that is used to store the method's result. |

<a name="InstancedMesh+getMatrixAt"></a>

### instancedMesh.getMatrixAt(index, matrix)
Gets the local transformation matrix of the defined instance.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| matrix | <code>Matrix4</code> | The target object that is used to store the method's result. |

<a name="InstancedMesh+getMorphAt"></a>

### instancedMesh.getMorphAt(index, object)
Gets the morph target weights of the defined instance.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| object | <code>Mesh</code> | The target object that is used to store the method's result. |

<a name="InstancedMesh+setColorAt"></a>

### instancedMesh.setColorAt(index, color)
Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of
[instanceColor](#InstancedMesh+instanceColor) to `true` after updating all the colors.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| color | <code>Color</code> | The instance color. |

<a name="InstancedMesh+setMatrixAt"></a>

### instancedMesh.setMatrixAt(index, matrix)
Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of
[instanceMatrix](#InstancedMesh+instanceMatrix) to `true` after updating all the colors.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| matrix | <code>Matrix4</code> | The local transformation. |

<a name="InstancedMesh+setMorphAt"></a>

### instancedMesh.setMorphAt(index, object)
Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of
[morphTexture](#InstancedMesh+morphTexture) to `true` after updating all the influences.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| object | <code>Mesh</code> | A mesh which `morphTargetInfluences` property containing the morph target weights of a single instance. |

<a name="InstancedMesh+dispose"></a>

### instancedMesh.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="LOD"></a>

## LOD ⇐ <code>Object3D</code>
A component for providing a basic Level of Detail (LOD) mechanism.

Every LOD level is associated with an object, and rendering can be switched
between them at the distances specified. Typically you would create, say,
three meshes, one for far away (low detail), one for mid range (medium
detail) and one for close up (high detail).

```js
const lod = new THREE.LOD();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );

//Create spheres with 3 levels of detail and create new LOD levels for them
for( let i = 0; i < 3; i++ ) {

	const geometry = new THREE.IcosahedronGeometry( 10, 3 - i );
	const mesh = new THREE.Mesh( geometry, material );
	lod.addLevel( mesh, i * 75 );

}

scene.add( lod );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [LOD](#LOD) ⇐ <code>Object3D</code>
    * [new LOD()](#new_LOD_new)
    * [.isLOD](#LOD+isLOD) : <code>boolean</code>
    * [.levels](#LOD+levels) : <code>Array.&lt;{object:Object3D, distance:number, hysteresis:number}&gt;</code>
    * [.autoUpdate](#LOD+autoUpdate) : <code>boolean</code>
    * [.addLevel(object, [distance], [hysteresis])](#LOD+addLevel) ⇒ [<code>LOD</code>](#LOD)
    * [.removeLevel(distance)](#LOD+removeLevel) ⇒ <code>boolean</code>
    * [.getCurrentLevel()](#LOD+getCurrentLevel) ⇒ <code>number</code>
    * [.getObjectForDistance(distance)](#LOD+getObjectForDistance) ⇒ <code>Object3D</code> \| <code>null</code>
    * [.raycast(raycaster, intersects)](#LOD+raycast)
    * [.update(camera)](#LOD+update)

<a name="new_LOD_new"></a>

### new LOD()
Constructs a new LOD.

<a name="LOD+isLOD"></a>

### loD.isLOD : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LOD</code>](#LOD)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LOD+levels"></a>

### loD.levels : <code>Array.&lt;{object:Object3D, distance:number, hysteresis:number}&gt;</code>
This array holds the LOD levels.

**Kind**: instance property of [<code>LOD</code>](#LOD)  
<a name="LOD+autoUpdate"></a>

### loD.autoUpdate : <code>boolean</code>
Whether the LOD object is updated automatically by the renderer per frame
or not. If set to `false`, you have to call [update](#LOD+update) in the
render loop by yourself.

**Kind**: instance property of [<code>LOD</code>](#LOD)  
**Default**: <code>true</code>  
<a name="LOD+addLevel"></a>

### loD.addLevel(object, [distance], [hysteresis]) ⇒ [<code>LOD</code>](#LOD)
Adds a mesh that will display at a certain distance and greater. Typically
the further away the distance, the lower the detail on the mesh.

**Kind**: instance method of [<code>LOD</code>](#LOD)  
**Returns**: [<code>LOD</code>](#LOD) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object to display at this level. |
| [distance] | <code>number</code> | <code>0</code> | The distance at which to display this level of detail. |
| [hysteresis] | <code>number</code> | <code>0</code> | Threshold used to avoid flickering at LOD boundaries, as a fraction of distance. |

<a name="LOD+removeLevel"></a>

### loD.removeLevel(distance) ⇒ <code>boolean</code>
Removes an existing level, based on the distance from the camera.
Returns `true` when the level has been removed. Otherwise `false`.

**Kind**: instance method of [<code>LOD</code>](#LOD)  
**Returns**: <code>boolean</code> - Whether the level has been removed or not.  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | Distance of the level to remove. |

<a name="LOD+getCurrentLevel"></a>

### loD.getCurrentLevel() ⇒ <code>number</code>
Returns the currently active LOD level index.

**Kind**: instance method of [<code>LOD</code>](#LOD)  
**Returns**: <code>number</code> - The current active LOD level index.  
<a name="LOD+getObjectForDistance"></a>

### loD.getObjectForDistance(distance) ⇒ <code>Object3D</code> \| <code>null</code>
Returns a reference to the first 3D object that is greater than
the given distance.

**Kind**: instance method of [<code>LOD</code>](#LOD)  
**Returns**: <code>Object3D</code> \| <code>null</code> - The found 3D object. `null` if no 3D object has been found.  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The LOD distance. |

<a name="LOD+raycast"></a>

### loD.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this LOD.

**Kind**: instance method of [<code>LOD</code>](#LOD)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="LOD+update"></a>

### loD.update(camera)
Updates the LOD by computing which LOD level should be visible according
to the current distance of the given camera.

**Kind**: instance method of [<code>LOD</code>](#LOD)  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="Line"></a>

## Line ⇐ <code>Object3D</code>
A continuous line. The line are rendered by connecting consecutive
vertices with straight lines.

```js
const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );

const points = [];
points.push( new THREE.Vector3( - 10, 0, 0 ) );
points.push( new THREE.Vector3( 0, 10, 0 ) );
points.push( new THREE.Vector3( 10, 0, 0 ) );

const geometry = new THREE.BufferGeometry().setFromPoints( points );

const line = new THREE.Line( geometry, material );
scene.add( line );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Line](#Line) ⇐ <code>Object3D</code>
    * [new Line([geometry], [material])](#new_Line_new)
    * [.isLine](#Line+isLine) : <code>boolean</code>
    * [.geometry](#Line+geometry) : <code>BufferGeometry</code>
    * [.material](#Line+material) : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
    * [.morphTargetDictionary](#Line+morphTargetDictionary) : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
    * [.morphTargetInfluences](#Line+morphTargetInfluences) : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
    * [.computeLineDistances()](#Line+computeLineDistances) ⇒ [<code>Line</code>](#Line)
    * [.raycast(raycaster, intersects)](#Line+raycast)
    * [.updateMorphTargets()](#Line+updateMorphTargets)

<a name="new_Line_new"></a>

### new Line([geometry], [material])
Constructs a new line.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The line geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The line material. |

<a name="Line+isLine"></a>

### line.isLine : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Line</code>](#Line)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Line+geometry"></a>

### line.geometry : <code>BufferGeometry</code>
The line geometry.

**Kind**: instance property of [<code>Line</code>](#Line)  
<a name="Line+material"></a>

### line.material : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
The line material.

**Kind**: instance property of [<code>Line</code>](#Line)  
**Default**: <code>LineBasicMaterial</code>  
<a name="Line+morphTargetDictionary"></a>

### line.morphTargetDictionary : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
A dictionary representing the morph targets in the geometry. The key is the
morph targets name, the value its attribute index. This member is `undefined`
by default and only set when morph targets are detected in the geometry.

**Kind**: instance property of [<code>Line</code>](#Line)  
**Default**: <code>undefined</code>  
<a name="Line+morphTargetInfluences"></a>

### line.morphTargetInfluences : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
An array of weights typically in the range `[0,1]` that specify how much of the morph
is applied. This member is `undefined` by default and only set when morph targets are
detected in the geometry.

**Kind**: instance property of [<code>Line</code>](#Line)  
**Default**: <code>undefined</code>  
<a name="Line+computeLineDistances"></a>

### line.computeLineDistances() ⇒ [<code>Line</code>](#Line)
Computes an array of distance values which are necessary for rendering dashed lines.
For each vertex in the geometry, the method calculates the cumulative length from the
current point to the very beginning of the line.

**Kind**: instance method of [<code>Line</code>](#Line)  
**Returns**: [<code>Line</code>](#Line) - A reference to this line.  
<a name="Line+raycast"></a>

### line.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this line.

**Kind**: instance method of [<code>Line</code>](#Line)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="Line+updateMorphTargets"></a>

### line.updateMorphTargets()
Sets the values of [morphTargetDictionary](#Line+morphTargetDictionary) and [morphTargetInfluences](#Line+morphTargetInfluences)
to make sure existing morph targets can influence this 3D object.

**Kind**: instance method of [<code>Line</code>](#Line)  
<a name="LineLoop"></a>

## LineLoop ⇐ <code>Line</code>
A continuous line. This is nearly the same as [Line](Line) the only difference
is that the last vertex is connected with the first vertex in order to close
the line to form a loop.

**Kind**: global class  
**Extends**: <code>Line</code>  

* [LineLoop](#LineLoop) ⇐ <code>Line</code>
    * [new LineLoop([geometry], [material])](#new_LineLoop_new)
    * [.isLineLoop](#LineLoop+isLineLoop) : <code>boolean</code>

<a name="new_LineLoop_new"></a>

### new LineLoop([geometry], [material])
Constructs a new line loop.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The line geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The line material. |

<a name="LineLoop+isLineLoop"></a>

### lineLoop.isLineLoop : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineLoop</code>](#LineLoop)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineSegments"></a>

## LineSegments ⇐ <code>Line</code>
A series of lines drawn between pairs of vertices.

**Kind**: global class  
**Extends**: <code>Line</code>  

* [LineSegments](#LineSegments) ⇐ <code>Line</code>
    * [new LineSegments([geometry], [material])](#new_LineSegments_new)
    * [.isLineSegments](#LineSegments+isLineSegments) : <code>boolean</code>

<a name="new_LineSegments_new"></a>

### new LineSegments([geometry], [material])
Constructs a new line segments.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The line geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The line material. |

<a name="LineSegments+isLineSegments"></a>

### lineSegments.isLineSegments : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineSegments</code>](#LineSegments)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Mesh"></a>

## Mesh ⇐ <code>Object3D</code>
Class representing triangular polygon mesh based objects.

```js
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Mesh](#Mesh) ⇐ <code>Object3D</code>
    * [new Mesh([geometry], [material])](#new_Mesh_new)
    * [.isMesh](#Mesh+isMesh) : <code>boolean</code>
    * [.geometry](#Mesh+geometry) : <code>BufferGeometry</code>
    * [.material](#Mesh+material) : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
    * [.morphTargetDictionary](#Mesh+morphTargetDictionary) : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
    * [.morphTargetInfluences](#Mesh+morphTargetInfluences) : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
    * [.updateMorphTargets()](#Mesh+updateMorphTargets)
    * [.getVertexPosition(index, target)](#Mesh+getVertexPosition) ⇒ <code>Vector3</code>
    * [.raycast(raycaster, intersects)](#Mesh+raycast)

<a name="new_Mesh_new"></a>

### new Mesh([geometry], [material])
Constructs a new mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |

<a name="Mesh+isMesh"></a>

### mesh.isMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Mesh+geometry"></a>

### mesh.geometry : <code>BufferGeometry</code>
The mesh geometry.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
<a name="Mesh+material"></a>

### mesh.material : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
The mesh material.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
**Default**: <code>MeshBasicMaterial</code>  
<a name="Mesh+morphTargetDictionary"></a>

### mesh.morphTargetDictionary : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
A dictionary representing the morph targets in the geometry. The key is the
morph targets name, the value its attribute index. This member is `undefined`
by default and only set when morph targets are detected in the geometry.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
**Default**: <code>undefined</code>  
<a name="Mesh+morphTargetInfluences"></a>

### mesh.morphTargetInfluences : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
An array of weights typically in the range `[0,1]` that specify how much of the morph
is applied. This member is `undefined` by default and only set when morph targets are
detected in the geometry.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
**Default**: <code>undefined</code>  
<a name="Mesh+updateMorphTargets"></a>

### mesh.updateMorphTargets()
Sets the values of [morphTargetDictionary](#Mesh+morphTargetDictionary) and [morphTargetInfluences](#Mesh+morphTargetInfluences)
to make sure existing morph targets can influence this 3D object.

**Kind**: instance method of [<code>Mesh</code>](#Mesh)  
<a name="Mesh+getVertexPosition"></a>

### mesh.getVertexPosition(index, target) ⇒ <code>Vector3</code>
Returns the local-space position of the vertex at the given index, taking into
account the current animation state of both morph targets and skinning.

**Kind**: instance method of [<code>Mesh</code>](#Mesh)  
**Returns**: <code>Vector3</code> - The vertex position in local space.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The vertex index. |
| target | <code>Vector3</code> | The target object that is used to store the method's result. |

<a name="Mesh+raycast"></a>

### mesh.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this line.

**Kind**: instance method of [<code>Mesh</code>](#Mesh)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="Points"></a>

## Points ⇐ <code>Object3D</code>
A class for displaying points or point clouds.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Points](#Points) ⇐ <code>Object3D</code>
    * [new Points([geometry], [material])](#new_Points_new)
    * [.isPoints](#Points+isPoints) : <code>boolean</code>
    * [.geometry](#Points+geometry) : <code>BufferGeometry</code>
    * [.material](#Points+material) : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
    * [.morphTargetDictionary](#Points+morphTargetDictionary) : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
    * [.morphTargetInfluences](#Points+morphTargetInfluences) : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
    * [.raycast(raycaster, intersects)](#Points+raycast)
    * [.updateMorphTargets()](#Points+updateMorphTargets)

<a name="new_Points_new"></a>

### new Points([geometry], [material])
Constructs a new point cloud.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The points geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The points material. |

<a name="Points+isPoints"></a>

### points.isPoints : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Points</code>](#Points)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Points+geometry"></a>

### points.geometry : <code>BufferGeometry</code>
The points geometry.

**Kind**: instance property of [<code>Points</code>](#Points)  
<a name="Points+material"></a>

### points.material : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
The line material.

**Kind**: instance property of [<code>Points</code>](#Points)  
**Default**: <code>PointsMaterial</code>  
<a name="Points+morphTargetDictionary"></a>

### points.morphTargetDictionary : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
A dictionary representing the morph targets in the geometry. The key is the
morph targets name, the value its attribute index. This member is `undefined`
by default and only set when morph targets are detected in the geometry.

**Kind**: instance property of [<code>Points</code>](#Points)  
**Default**: <code>undefined</code>  
<a name="Points+morphTargetInfluences"></a>

### points.morphTargetInfluences : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
An array of weights typically in the range `[0,1]` that specify how much of the morph
is applied. This member is `undefined` by default and only set when morph targets are
detected in the geometry.

**Kind**: instance property of [<code>Points</code>](#Points)  
**Default**: <code>undefined</code>  
<a name="Points+raycast"></a>

### points.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this point cloud.

**Kind**: instance method of [<code>Points</code>](#Points)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="Points+updateMorphTargets"></a>

### points.updateMorphTargets()
Sets the values of [morphTargetDictionary](#Points+morphTargetDictionary) and [morphTargetInfluences](#Points+morphTargetInfluences)
to make sure existing morph targets can influence this 3D object.

**Kind**: instance method of [<code>Points</code>](#Points)  
<a name="Skeleton"></a>

## Skeleton
Class for representing the armatures in `three.js`. The skeleton
is defined by a hierarchy of bones.

```js
const bones = [];

const shoulder = new THREE.Bone();
const elbow = new THREE.Bone();
const hand = new THREE.Bone();

shoulder.add( elbow );
elbow.add( hand );

bones.push( shoulder , elbow, hand);

shoulder.position.y = -5;
elbow.position.y = 0;
hand.position.y = 5;

const armSkeleton = new THREE.Skeleton( bones );
```

**Kind**: global class  

* [Skeleton](#Skeleton)
    * [new Skeleton([bones], [boneInverses])](#new_Skeleton_new)
    * [.bones](#Skeleton+bones) : <code>Array.&lt;Bone&gt;</code>
    * [.boneInverses](#Skeleton+boneInverses) : <code>Array.&lt;Matrix4&gt;</code>
    * [.boneMatrices](#Skeleton+boneMatrices) : <code>Float32Array</code>
    * [.boneTexture](#Skeleton+boneTexture) : <code>DataTexture</code>
    * [.init()](#Skeleton+init)
    * [.calculateInverses()](#Skeleton+calculateInverses)
    * [.pose()](#Skeleton+pose)
    * [.update()](#Skeleton+update)
    * [.clone()](#Skeleton+clone) ⇒ [<code>Skeleton</code>](#Skeleton)
    * [.computeBoneTexture()](#Skeleton+computeBoneTexture) ⇒ [<code>Skeleton</code>](#Skeleton)
    * [.getBoneByName(name)](#Skeleton+getBoneByName) ⇒ <code>Bone</code> \| <code>undefined</code>
    * [.dispose()](#Skeleton+dispose)
    * [.fromJSON(json, bones)](#Skeleton+fromJSON) ⇒ [<code>Skeleton</code>](#Skeleton)
    * [.toJSON()](#Skeleton+toJSON) ⇒ <code>Object</code>

<a name="new_Skeleton_new"></a>

### new Skeleton([bones], [boneInverses])
Constructs a new skeleton.


| Param | Type | Description |
| --- | --- | --- |
| [bones] | <code>Array.&lt;Bone&gt;</code> | An array of bones. |
| [boneInverses] | <code>Array.&lt;Matrix4&gt;</code> | An array of bone inverse matrices. If not provided, these matrices will be computed automatically via [calculateInverses](#Skeleton+calculateInverses). |

<a name="Skeleton+bones"></a>

### skeleton.bones : <code>Array.&lt;Bone&gt;</code>
An array of bones defining the skeleton.

**Kind**: instance property of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+boneInverses"></a>

### skeleton.boneInverses : <code>Array.&lt;Matrix4&gt;</code>
An array of bone inverse matrices.

**Kind**: instance property of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+boneMatrices"></a>

### skeleton.boneMatrices : <code>Float32Array</code>
An array buffer holding the bone data.
Input data for [boneTexture](#Skeleton+boneTexture).

**Kind**: instance property of [<code>Skeleton</code>](#Skeleton)  
**Default**: <code>null</code>  
<a name="Skeleton+boneTexture"></a>

### skeleton.boneTexture : <code>DataTexture</code>
A texture holding the bone data for use
in the vertex shader.

**Kind**: instance property of [<code>Skeleton</code>](#Skeleton)  
**Default**: <code>null</code>  
<a name="Skeleton+init"></a>

### skeleton.init()
Initializes the skeleton. This method gets automatically called by the constructor
but depending on how the skeleton is created it might be necessary to call this method
manually.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+calculateInverses"></a>

### skeleton.calculateInverses()
Computes the bone inverse matrices. This method resets [boneInverses](#Skeleton+boneInverses)
and fills it with new matrices.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+pose"></a>

### skeleton.pose()
Resets the skeleton to the base pose.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+update"></a>

### skeleton.update()
Resets the skeleton to the base pose.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+clone"></a>

### skeleton.clone() ⇒ [<code>Skeleton</code>](#Skeleton)
Returns a new skeleton with copied values from this instance.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: [<code>Skeleton</code>](#Skeleton) - A clone of this instance.  
<a name="Skeleton+computeBoneTexture"></a>

### skeleton.computeBoneTexture() ⇒ [<code>Skeleton</code>](#Skeleton)
Computes a data texture for passing bone data to the vertex shader.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: [<code>Skeleton</code>](#Skeleton) - A reference of this instance.  
<a name="Skeleton+getBoneByName"></a>

### skeleton.getBoneByName(name) ⇒ <code>Bone</code> \| <code>undefined</code>
Searches through the skeleton's bone array and returns the first with a
matching name.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: <code>Bone</code> \| <code>undefined</code> - The found bone. `undefined` if no bone has been found.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the bone. |

<a name="Skeleton+dispose"></a>

### skeleton.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+fromJSON"></a>

### skeleton.fromJSON(json, bones) ⇒ [<code>Skeleton</code>](#Skeleton)
Setups the skeleton by the given JSON and bones.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: [<code>Skeleton</code>](#Skeleton) - A reference of this instance.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The skeleton as serialized JSON. |
| bones | <code>Object.&lt;string, Bone&gt;</code> | An array of bones. |

<a name="Skeleton+toJSON"></a>

### skeleton.toJSON() ⇒ <code>Object</code>
Serializes the skeleton into JSON.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: <code>Object</code> - A JSON object representing the serialized skeleton.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  
<a name="SkinnedMesh"></a>

## SkinnedMesh ⇐ <code>Mesh</code>
A mesh that has a [Skeleton](Skeleton) that can then be used to animate the
vertices of the geometry with skinning/skeleton animation.

Next to a valid skeleton, the skinned mesh requires skin indices and weights
as buffer attributes in its geometry. These attribute define which bones affect a single
vertex to a certain extend.

Typically skinned meshes are not created manually but loaders like [GLTFLoader](GLTFLoader)
or [FBXLoader](FBXLoader) import respective models.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [SkinnedMesh](#SkinnedMesh) ⇐ <code>Mesh</code>
    * [new SkinnedMesh([geometry], [material])](#new_SkinnedMesh_new)
    * [.isSkinnedMesh](#SkinnedMesh+isSkinnedMesh) : <code>boolean</code>
    * [.bindMode](#SkinnedMesh+bindMode) : <code>AttachedBindMode</code> \| <code>DetachedBindMode</code>
    * [.bindMatrix](#SkinnedMesh+bindMatrix) : <code>Matrix4</code>
    * [.bindMatrixInverse](#SkinnedMesh+bindMatrixInverse) : <code>Matrix4</code>
    * [.boundingBox](#SkinnedMesh+boundingBox) : <code>Box3</code>
    * [.boundingSphere](#SkinnedMesh+boundingSphere) : <code>Sphere</code>
    * [.computeBoundingBox()](#SkinnedMesh+computeBoundingBox)
    * [.computeBoundingSphere()](#SkinnedMesh+computeBoundingSphere)
    * [.bind(skeleton, [bindMatrix])](#SkinnedMesh+bind)
    * [.pose()](#SkinnedMesh+pose)
    * [.normalizeSkinWeights()](#SkinnedMesh+normalizeSkinWeights)
    * [.applyBoneTransform(index, target)](#SkinnedMesh+applyBoneTransform) ⇒ <code>Vector3</code>

<a name="new_SkinnedMesh_new"></a>

### new SkinnedMesh([geometry], [material])
Constructs a new skinned mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |

<a name="SkinnedMesh+isSkinnedMesh"></a>

### skinnedMesh.isSkinnedMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SkinnedMesh+bindMode"></a>

### skinnedMesh.bindMode : <code>AttachedBindMode</code> \| <code>DetachedBindMode</code>
`AttachedBindMode` means the skinned mesh shares the same world space as the skeleton.
This is not true when using `DetachedBindMode` which is useful when sharing a skeleton
across multiple skinned meshes.

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Default**: <code>AttachedBindMode</code>  
<a name="SkinnedMesh+bindMatrix"></a>

### skinnedMesh.bindMatrix : <code>Matrix4</code>
The base matrix that is used for the bound bone transforms.

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+bindMatrixInverse"></a>

### skinnedMesh.bindMatrixInverse : <code>Matrix4</code>
The base matrix that is used for resetting the bound bone transforms.

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+boundingBox"></a>

### skinnedMesh.boundingBox : <code>Box3</code>
The bounding box of the skinned mesh. Can be computed via [computeBoundingBox](#SkinnedMesh+computeBoundingBox).

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Default**: <code>null</code>  
<a name="SkinnedMesh+boundingSphere"></a>

### skinnedMesh.boundingSphere : <code>Sphere</code>
The bounding sphere of the skinned mesh. Can be computed via [computeBoundingSphere](#SkinnedMesh+computeBoundingSphere).

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Default**: <code>null</code>  
<a name="SkinnedMesh+computeBoundingBox"></a>

### skinnedMesh.computeBoundingBox()
Computes the bounding box of the skinned mesh, and updates [boundingBox](#SkinnedMesh+boundingBox).
The bounding box is not automatically computed by the engine; this method must be called by your app.
If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect
the current animation state.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+computeBoundingSphere"></a>

### skinnedMesh.computeBoundingSphere()
Computes the bounding sphere of the skinned mesh, and updates [boundingSphere](#SkinnedMesh+boundingSphere).
The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting
and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed
per frame in order to reflect the current animation state.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+bind"></a>

### skinnedMesh.bind(skeleton, [bindMatrix])
Binds the given skeleton to the skinned mesh.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| skeleton | <code>Skeleton</code> | The skeleton to bind. |
| [bindMatrix] | <code>Matrix4</code> | The bind matrix. If no bind matrix is provided, the skinned mesh's world matrix will be used instead. |

<a name="SkinnedMesh+pose"></a>

### skinnedMesh.pose()
This method sets the skinned mesh in the rest pose).

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+normalizeSkinWeights"></a>

### skinnedMesh.normalizeSkinWeights()
Normalizes the skin weights which are defined as a buffer attribute
in the skinned mesh's geometry.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+applyBoneTransform"></a>

### skinnedMesh.applyBoneTransform(index, target) ⇒ <code>Vector3</code>
Applies the bone transform associated with the given index to the given
vertex position. Returns the updated vector.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Returns**: <code>Vector3</code> - The updated vertex position.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The vertex index. |
| target | <code>Vector3</code> | The target object that is used to store the method's result. the skinned mesh's world matrix will be used instead. |

<a name="Sprite"></a>

## Sprite ⇐ <code>Object3D</code>
A sprite is a plane that always faces towards the camera, generally with a
partially transparent texture applied.

Sprites do not cast shadows, setting [Object3D#castShadow](Object3D#castShadow) to `true` will
have no effect.

```js
const map = new THREE.TextureLoader().load( 'sprite.png' );
const material = new THREE.SpriteMaterial( { map: map } );

const sprite = new THREE.Sprite( material );
scene.add( sprite );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Sprite](#Sprite) ⇐ <code>Object3D</code>
    * [new Sprite([material])](#new_Sprite_new)
    * [.isSprite](#Sprite+isSprite) : <code>boolean</code>
    * [.geometry](#Sprite+geometry) : <code>BufferGeometry</code>
    * [.material](#Sprite+material) : <code>SpriteMaterial</code>
    * [.center](#Sprite+center) : <code>Vector2</code>
    * [.raycast(raycaster, intersects)](#Sprite+raycast)

<a name="new_Sprite_new"></a>

### new Sprite([material])
Constructs a new sprite.


| Param | Type | Description |
| --- | --- | --- |
| [material] | <code>SpriteMaterial</code> | The sprite material. |

<a name="Sprite+isSprite"></a>

### sprite.isSprite : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Sprite</code>](#Sprite)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Sprite+geometry"></a>

### sprite.geometry : <code>BufferGeometry</code>
The sprite geometry.

**Kind**: instance property of [<code>Sprite</code>](#Sprite)  
<a name="Sprite+material"></a>

### sprite.material : <code>SpriteMaterial</code>
The sprite material.

**Kind**: instance property of [<code>Sprite</code>](#Sprite)  
<a name="Sprite+center"></a>

### sprite.center : <code>Vector2</code>
The sprite's anchor point, and the point around which the sprite rotates.
A value of `(0.5, 0.5)` corresponds to the midpoint of the sprite. A value
of `(0, 0)` corresponds to the lower left corner of the sprite.

**Kind**: instance property of [<code>Sprite</code>](#Sprite)  
**Default**: <code>(0.5,0.5)</code>  
<a name="Sprite+raycast"></a>

### sprite.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this sprite.

**Kind**: instance method of [<code>Sprite</code>](#Sprite)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="WebGL3DRenderTarget"></a>

## WebGL3DRenderTarget ⇐ <code>WebGLRenderTarget</code>
A 3D render target used in context of [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>WebGLRenderTarget</code>  

* [WebGL3DRenderTarget](#WebGL3DRenderTarget) ⇐ <code>WebGLRenderTarget</code>
    * [new WebGL3DRenderTarget([width], [height], [depth], [options])](#new_WebGL3DRenderTarget_new)
    * [.isWebGL3DRenderTarget](#WebGL3DRenderTarget+isWebGL3DRenderTarget) : <code>boolean</code>
    * [.texture](#WebGL3DRenderTarget+texture) : <code>Data3DTexture</code>

<a name="new_WebGL3DRenderTarget_new"></a>

### new WebGL3DRenderTarget([width], [height], [depth], [options])
Constructs a new 3D render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [depth] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="WebGL3DRenderTarget+isWebGL3DRenderTarget"></a>

### webGL3DRenderTarget.isWebGL3DRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGL3DRenderTarget</code>](#WebGL3DRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGL3DRenderTarget+texture"></a>

### webGL3DRenderTarget.texture : <code>Data3DTexture</code>
Overwritten with a different texture type.

**Kind**: instance property of [<code>WebGL3DRenderTarget</code>](#WebGL3DRenderTarget)  
<a name="WebGLArrayRenderTarget"></a>

## WebGLArrayRenderTarget ⇐ <code>WebGLRenderTarget</code>
An array render target used in context of [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>WebGLRenderTarget</code>  

* [WebGLArrayRenderTarget](#WebGLArrayRenderTarget) ⇐ <code>WebGLRenderTarget</code>
    * [new WebGLArrayRenderTarget([width], [height], [depth], [options])](#new_WebGLArrayRenderTarget_new)
    * [.isWebGLArrayRenderTarget](#WebGLArrayRenderTarget+isWebGLArrayRenderTarget) : <code>boolean</code>
    * [.texture](#WebGLArrayRenderTarget+texture) : <code>DataArrayTexture</code>

<a name="new_WebGLArrayRenderTarget_new"></a>

### new WebGLArrayRenderTarget([width], [height], [depth], [options])
Constructs a new array render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [depth] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="WebGLArrayRenderTarget+isWebGLArrayRenderTarget"></a>

### webGLArrayRenderTarget.isWebGLArrayRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGLArrayRenderTarget</code>](#WebGLArrayRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGLArrayRenderTarget+texture"></a>

### webGLArrayRenderTarget.texture : <code>DataArrayTexture</code>
Overwritten with a different texture type.

**Kind**: instance property of [<code>WebGLArrayRenderTarget</code>](#WebGLArrayRenderTarget)  
<a name="WebGLCubeRenderTarget"></a>

## WebGLCubeRenderTarget ⇐ <code>WebGLRenderTarget</code>
A cube render target used in context of [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>WebGLRenderTarget</code>  

* [WebGLCubeRenderTarget](#WebGLCubeRenderTarget) ⇐ <code>WebGLRenderTarget</code>
    * [new WebGLCubeRenderTarget([size], [options])](#new_WebGLCubeRenderTarget_new)
    * [.isWebGLCubeRenderTarget](#WebGLCubeRenderTarget+isWebGLCubeRenderTarget) : <code>boolean</code>
    * [.texture](#WebGLCubeRenderTarget+texture) : <code>DataArrayTexture</code>
    * [.fromEquirectangularTexture(renderer, texture)](#WebGLCubeRenderTarget+fromEquirectangularTexture) ⇒ [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)
    * [.clear(renderer, [color], [depth], [stencil])](#WebGLCubeRenderTarget+clear)

<a name="new_WebGLCubeRenderTarget_new"></a>

### new WebGLCubeRenderTarget([size], [options])
Constructs a new cube render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>1</code> | The size of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="WebGLCubeRenderTarget+isWebGLCubeRenderTarget"></a>

### webGLCubeRenderTarget.isWebGLCubeRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGLCubeRenderTarget+texture"></a>

### webGLCubeRenderTarget.texture : <code>DataArrayTexture</code>
Overwritten with a different texture type.

**Kind**: instance property of [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)  
<a name="WebGLCubeRenderTarget+fromEquirectangularTexture"></a>

### webGLCubeRenderTarget.fromEquirectangularTexture(renderer, texture) ⇒ [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)
Converts the given equirectangular texture to a cube map.

**Kind**: instance method of [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)  
**Returns**: [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget) - A reference to this cube render target.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| texture | <code>Texture</code> | The equirectangular texture. |

<a name="WebGLCubeRenderTarget+clear"></a>

### webGLCubeRenderTarget.clear(renderer, [color], [depth], [stencil])
Clears this cube render target.

**Kind**: instance method of [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>WebGLRenderer</code> |  | The renderer. |
| [color] | <code>boolean</code> | <code>true</code> | Whether the color buffer should be cleared or not. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the depth buffer should be cleared or not. |
| [stencil] | <code>boolean</code> | <code>true</code> | Whether the stencil buffer should be cleared or not. |

<a name="WebGLRenderTarget"></a>

## WebGLRenderTarget ⇐ <code>RenderTarget</code>
A render target used in context of [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>RenderTarget</code>  

* [WebGLRenderTarget](#WebGLRenderTarget) ⇐ <code>RenderTarget</code>
    * [new WebGLRenderTarget([width], [height], [options])](#new_WebGLRenderTarget_new)
    * [.isWebGLRenderTarget](#WebGLRenderTarget+isWebGLRenderTarget) : <code>boolean</code>

<a name="new_WebGLRenderTarget_new"></a>

### new WebGLRenderTarget([width], [height], [options])
Constructs a new 3D render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="WebGLRenderTarget+isWebGLRenderTarget"></a>

### webGLRenderTarget.isWebGLRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGLRenderTarget</code>](#WebGLRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGLRenderer"></a>

## WebGLRenderer
This renderer uses WebGL 2 to display scenes.

WebGL 1 is not supported since `r163`.

**Kind**: global class  

* [WebGLRenderer](#WebGLRenderer)
    * [new WebGLRenderer([parameters])](#new_WebGLRenderer_new)
    * _instance_
        * [.isWebGLRenderer](#WebGLRenderer+isWebGLRenderer) : <code>boolean</code>
        * [.domElement](#WebGLRenderer+domElement) : <code>DOMElement</code>
        * [.debug](#WebGLRenderer+debug) : <code>Object</code>
            * [.checkShaderErrors](#WebGLRenderer+debug.checkShaderErrors) : <code>boolean</code>
            * [.onShaderError](#WebGLRenderer+debug.onShaderError) : <code>function</code>
        * [.autoClear](#WebGLRenderer+autoClear) : <code>boolean</code>
        * [.autoClearColor](#WebGLRenderer+autoClearColor) : <code>boolean</code>
        * [.autoClearDepth](#WebGLRenderer+autoClearDepth) : <code>boolean</code>
        * [.autoClearStencil](#WebGLRenderer+autoClearStencil) : <code>boolean</code>
        * [.sortObjects](#WebGLRenderer+sortObjects) : <code>boolean</code>
        * [.clippingPlanes](#WebGLRenderer+clippingPlanes) : <code>Array.&lt;Plane&gt;</code>
        * [.localClippingEnabled](#WebGLRenderer+localClippingEnabled) : <code>boolean</code>
        * [.toneMapping](#WebGLRenderer+toneMapping) : <code>NoToneMapping</code> \| <code>LinearToneMapping</code> \| <code>ReinhardToneMapping</code> \| <code>CineonToneMapping</code> \| <code>ACESFilmicToneMapping</code> \| <code>CustomToneMapping</code> \| <code>AgXToneMapping</code> \| <code>NeutralToneMapping</code>
        * [.toneMappingExposure](#WebGLRenderer+toneMappingExposure) : <code>number</code>
        * [.transmissionResolutionScale](#WebGLRenderer+transmissionResolutionScale) : <code>number</code>
        * [.capabilities](#WebGLRenderer+capabilities) : [<code>Capabilities</code>](#WebGLRenderer..Capabilities)
        * [.extensions](#WebGLRenderer+extensions) : <code>Object</code>
        * [.properties](#WebGLRenderer+properties) : <code>Object</code>
        * [.renderLists](#WebGLRenderer+renderLists) : <code>Object</code>
        * [.shadowMap](#WebGLRenderer+shadowMap) : [<code>ShadowMap</code>](#WebGLRenderer..ShadowMap)
        * [.state](#WebGLRenderer+state) : <code>Object</code>
        * [.info](#WebGLRenderer+info) : [<code>Info</code>](#WebGLRenderer..Info)
        * [.xr](#WebGLRenderer+xr) : <code>WebXRManager</code>
        * [.coordinateSystem](#WebGLRenderer+coordinateSystem) : <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code>
        * [.outputColorSpace](#WebGLRenderer+outputColorSpace) : <code>SRGBColorSpace</code> \| <code>LinearSRGBColorSpace</code>
        * [.getContext()](#WebGLRenderer+getContext) ⇒ <code>WebGL2RenderingContext</code>
        * [.getContextAttributes()](#WebGLRenderer+getContextAttributes) ⇒ <code>WebGLContextAttributes</code>
        * [.forceContextLoss()](#WebGLRenderer+forceContextLoss)
        * [.forceContextRestore()](#WebGLRenderer+forceContextRestore)
        * [.getPixelRatio()](#WebGLRenderer+getPixelRatio) ⇒ <code>number</code>
        * [.setPixelRatio(value)](#WebGLRenderer+setPixelRatio)
        * [.getSize(target)](#WebGLRenderer+getSize) ⇒ <code>Vector2</code>
        * [.setSize(width, height, [updateStyle])](#WebGLRenderer+setSize)
        * [.getDrawingBufferSize(target)](#WebGLRenderer+getDrawingBufferSize) ⇒ <code>Vector2</code>
        * [.setDrawingBufferSize(width, height, pixelRatio)](#WebGLRenderer+setDrawingBufferSize)
        * [.getCurrentViewport(target)](#WebGLRenderer+getCurrentViewport) ⇒ <code>Vector2</code>
        * [.getViewport(target)](#WebGLRenderer+getViewport) ⇒ <code>Vector4</code>
        * [.setViewport(x, y, width, height)](#WebGLRenderer+setViewport)
        * [.getScissor(target)](#WebGLRenderer+getScissor) ⇒ <code>Vector4</code>
        * [.setScissor(x, y, width, height)](#WebGLRenderer+setScissor)
        * [.getScissorTest()](#WebGLRenderer+getScissorTest) ⇒ <code>boolean</code>
        * [.setScissorTest(boolean)](#WebGLRenderer+setScissorTest)
        * [.setOpaqueSort(method)](#WebGLRenderer+setOpaqueSort)
        * [.setTransparentSort(method)](#WebGLRenderer+setTransparentSort)
        * [.getClearColor(target)](#WebGLRenderer+getClearColor) ⇒ <code>Color</code>
        * [.setClearColor(color, [alpha])](#WebGLRenderer+setClearColor)
        * [.getClearAlpha()](#WebGLRenderer+getClearAlpha) ⇒ <code>number</code>
        * [.setClearAlpha(alpha)](#WebGLRenderer+setClearAlpha)
        * [.clear([color], [depth], [stencil])](#WebGLRenderer+clear)
        * [.clearColor()](#WebGLRenderer+clearColor)
        * [.clearDepth()](#WebGLRenderer+clearDepth)
        * [.clearStencil()](#WebGLRenderer+clearStencil)
        * [.dispose()](#WebGLRenderer+dispose)
        * [.compile(scene, camera, [targetScene])](#WebGLRenderer+compile) ⇒ <code>Set</code>
        * [.compileAsync(scene, camera, [targetScene])](#WebGLRenderer+compileAsync) ⇒ <code>Promise</code>
        * [.render(scene, camera)](#WebGLRenderer+render)
        * [.getActiveCubeFace()](#WebGLRenderer+getActiveCubeFace) ⇒ <code>number</code>
        * [.getActiveMipmapLevel()](#WebGLRenderer+getActiveMipmapLevel) ⇒ <code>number</code>
        * [.getRenderTarget()](#WebGLRenderer+getRenderTarget) ⇒ <code>WebGLRenderTarget</code>
        * [.setRenderTarget(renderTarget, [activeCubeFace], [activeMipmapLevel])](#WebGLRenderer+setRenderTarget)
        * [.readRenderTargetPixels(renderTarget, x, y, width, height, buffer, [activeCubeFaceIndex])](#WebGLRenderer+readRenderTargetPixels)
        * [.readRenderTargetPixelsAsync(renderTarget, x, y, width, height, buffer, [activeCubeFaceIndex])](#WebGLRenderer+readRenderTargetPixelsAsync) ⇒ <code>Promise.&lt;TypedArray&gt;</code>
        * [.copyFramebufferToTexture(texture, position, [level])](#WebGLRenderer+copyFramebufferToTexture)
        * [.copyTextureToTexture(srcTexture, dstTexture, [srcRegion], [dstPosition], srcLevel, dstLevel)](#WebGLRenderer+copyTextureToTexture)
        * [.initRenderTarget(target)](#WebGLRenderer+initRenderTarget)
        * [.initTexture(texture)](#WebGLRenderer+initTexture)
        * [.resetState()](#WebGLRenderer+resetState)
    * _inner_
        * [~Options](#WebGLRenderer..Options) : <code>Object</code>
        * [~Capabilities](#WebGLRenderer..Capabilities) : <code>Object</code>
        * [~InfoMemory](#WebGLRenderer..InfoMemory) : <code>Object</code>
        * [~InfoRender](#WebGLRenderer..InfoRender) : <code>Object</code>
        * [~Info](#WebGLRenderer..Info) : <code>Object</code>
        * [~ShadowMap](#WebGLRenderer..ShadowMap) : <code>Object</code>

<a name="new_WebGLRenderer_new"></a>

### new WebGLRenderer([parameters])
Constructs a new WebGL renderer.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | [<code>Options</code>](#WebGLRenderer..Options) | The configuration parameter. |

<a name="WebGLRenderer+isWebGLRenderer"></a>

### webGLRenderer.isWebGLRenderer : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGLRenderer+domElement"></a>

### webGLRenderer.domElement : <code>DOMElement</code>
A canvas where the renderer draws its output.This is automatically created by the renderer
in the constructor (if not provided already); you just need to add it to your page like so:
```js
document.body.appendChild( renderer.domElement );
```

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+debug"></a>

### webGLRenderer.debug : <code>Object</code>
A object with debug configuration settings.

- `checkShaderErrors`: If it is `true`, defines whether material shader programs are
checked for errors during compilation and linkage process. It may be useful to disable
this check in production for performance gain. It is strongly recommended to keep these
checks enabled during development. If the shader does not compile and link - it will not
work and associated material will not render.
- `onShaderError(gl, program, glVertexShader,glFragmentShader)`: A callback function that
can be used for custom error reporting. The callback receives the WebGL context, an instance
of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
Assigning a custom function disables the default error reporting.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  

* [.debug](#WebGLRenderer+debug) : <code>Object</code>
    * [.checkShaderErrors](#WebGLRenderer+debug.checkShaderErrors) : <code>boolean</code>
    * [.onShaderError](#WebGLRenderer+debug.onShaderError) : <code>function</code>

<a name="WebGLRenderer+debug.checkShaderErrors"></a>

#### debug.checkShaderErrors : <code>boolean</code>
Enables error checking and reporting when shader programs are being compiled.

**Kind**: static property of [<code>debug</code>](#WebGLRenderer+debug)  
<a name="WebGLRenderer+debug.onShaderError"></a>

#### debug.onShaderError : <code>function</code>
Callback for custom error reporting.

**Kind**: static property of [<code>debug</code>](#WebGLRenderer+debug)  
<a name="WebGLRenderer+autoClear"></a>

### webGLRenderer.autoClear : <code>boolean</code>
Whether the renderer should automatically clear its output before rendering a frame or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+autoClearColor"></a>

### webGLRenderer.autoClearColor : <code>boolean</code>
If [autoClear](#WebGLRenderer+autoClear) set to `true`, whether the renderer should clear
the color buffer or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+autoClearDepth"></a>

### webGLRenderer.autoClearDepth : <code>boolean</code>
If [autoClear](#WebGLRenderer+autoClear) set to `true`, whether the renderer should clear
the depth buffer or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+autoClearStencil"></a>

### webGLRenderer.autoClearStencil : <code>boolean</code>
If [autoClear](#WebGLRenderer+autoClear) set to `true`, whether the renderer should clear
the stencil buffer or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+sortObjects"></a>

### webGLRenderer.sortObjects : <code>boolean</code>
Whether the renderer should sort objects or not.

Note: Sorting is used to attempt to properly render objects that have some
degree of transparency. By definition, sorting objects may not work in all
cases. Depending on the needs of application, it may be necessary to turn
off sorting and use other methods to deal with transparency rendering e.g.
manually determining each object's rendering order.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+clippingPlanes"></a>

### webGLRenderer.clippingPlanes : <code>Array.&lt;Plane&gt;</code>
User-defined clipping planes specified in world space. These planes apply globally.
Points in space whose dot product with the plane is negative are cut away.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+localClippingEnabled"></a>

### webGLRenderer.localClippingEnabled : <code>boolean</code>
Whether the renderer respects object-level clipping planes or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>false</code>  
<a name="WebGLRenderer+toneMapping"></a>

### webGLRenderer.toneMapping : <code>NoToneMapping</code> \| <code>LinearToneMapping</code> \| <code>ReinhardToneMapping</code> \| <code>CineonToneMapping</code> \| <code>ACESFilmicToneMapping</code> \| <code>CustomToneMapping</code> \| <code>AgXToneMapping</code> \| <code>NeutralToneMapping</code>
The tone mapping technique of the renderer.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>NoToneMapping</code>  
<a name="WebGLRenderer+toneMappingExposure"></a>

### webGLRenderer.toneMappingExposure : <code>number</code>
Exposure level of tone mapping.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>1</code>  
<a name="WebGLRenderer+transmissionResolutionScale"></a>

### webGLRenderer.transmissionResolutionScale : <code>number</code>
The normalized resolution scale for the transmission render target, measured in percentage
of viewport dimensions. Lowering this value can result in significant performance improvements
when using [MeshPhysicalMaterial#transmission](MeshPhysicalMaterial#transmission).

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>1</code>  
<a name="WebGLRenderer+capabilities"></a>

### webGLRenderer.capabilities : [<code>Capabilities</code>](#WebGLRenderer..Capabilities)
Holds details about the capabilities of the current rendering context.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+extensions"></a>

### webGLRenderer.extensions : <code>Object</code>
Provides methods for retrieving and testing WebGL extensions.

- `get(extensionName:string)`: Used to check whether a WebGL extension is supported
and return the extension object if available.
- `has(extensionName:string)`: returns `true` if the extension is supported.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+properties"></a>

### webGLRenderer.properties : <code>Object</code>
Used to track properties of other objects like native WebGL objects.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+renderLists"></a>

### webGLRenderer.renderLists : <code>Object</code>
Manages the render lists of the renderer.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+shadowMap"></a>

### webGLRenderer.shadowMap : [<code>ShadowMap</code>](#WebGLRenderer..ShadowMap)
Interface for managing shadows.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+state"></a>

### webGLRenderer.state : <code>Object</code>
Interface for managing the WebGL state.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+info"></a>

### webGLRenderer.info : [<code>Info</code>](#WebGLRenderer..Info)
Holds a series of statistical information about the GPU memory
and the rendering process. Useful for debugging and monitoring.

By default these data are reset at each render call but when having
multiple render passes per frame (e.g. when using post processing) it can
be preferred to reset with a custom pattern. First, set `autoReset` to
`false`.
```js
renderer.info.autoReset = false;
```
Call `reset()` whenever you have finished to render a single frame.
```js
renderer.info.reset();
```

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+xr"></a>

### webGLRenderer.xr : <code>WebXRManager</code>
A reference to the XR manager.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+coordinateSystem"></a>

### webGLRenderer.coordinateSystem : <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code>
Defines the coordinate system of the renderer.

In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>WebGLCoordinateSystem</code>  
**Read only**: true  
<a name="WebGLRenderer+outputColorSpace"></a>

### webGLRenderer.outputColorSpace : <code>SRGBColorSpace</code> \| <code>LinearSRGBColorSpace</code>
Defines the output color space of the renderer.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>SRGBColorSpace</code>  
<a name="WebGLRenderer+getContext"></a>

### webGLRenderer.getContext() ⇒ <code>WebGL2RenderingContext</code>
Returns the rendering context.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>WebGL2RenderingContext</code> - The rendering context.  
<a name="WebGLRenderer+getContextAttributes"></a>

### webGLRenderer.getContextAttributes() ⇒ <code>WebGLContextAttributes</code>
Returns the rendering context attributes.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>WebGLContextAttributes</code> - The rendering context attributes.  
<a name="WebGLRenderer+forceContextLoss"></a>

### webGLRenderer.forceContextLoss()
Simulates a loss of the WebGL context. This requires support for the `WEBGL_lose_context` extension.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+forceContextRestore"></a>

### webGLRenderer.forceContextRestore()
Simulates a restore of the WebGL context. This requires support for the `WEBGL_lose_context` extension.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+getPixelRatio"></a>

### webGLRenderer.getPixelRatio() ⇒ <code>number</code>
Returns the pixel ratio.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>number</code> - The pixel ratio.  
<a name="WebGLRenderer+setPixelRatio"></a>

### webGLRenderer.setPixelRatio(value)
Sets the given pixel ratio and resizes the canvas if necessary.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The pixel ratio. |

<a name="WebGLRenderer+getSize"></a>

### webGLRenderer.getSize(target) ⇒ <code>Vector2</code>
Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector2</code> - The renderer's size in logical pixels.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setSize"></a>

### webGLRenderer.setSize(width, height, [updateStyle])
Resizes the output canvas to (width, height) with device pixel ratio taken
into account, and also sets the viewport to fit that size, starting in (0,
0). Setting `updateStyle` to false prevents any style changes to the output canvas.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| width | <code>number</code> |  | The width in logical pixels. |
| height | <code>number</code> |  | The height in logical pixels. |
| [updateStyle] | <code>boolean</code> | <code>true</code> | Whether to update the `style` attribute of the canvas or not. |

<a name="WebGLRenderer+getDrawingBufferSize"></a>

### webGLRenderer.getDrawingBufferSize(target) ⇒ <code>Vector2</code>
Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector2</code> - The drawing buffer size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setDrawingBufferSize"></a>

### webGLRenderer.setDrawingBufferSize(width, height, pixelRatio)
This method allows to define the drawing buffer size by specifying
width, height and pixel ratio all at once. The size of the drawing
buffer is computed with this formula:
```js
size.x = width * pixelRatio;
size.y = height * pixelRatio;
```

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width in logical pixels. |
| height | <code>number</code> | The height in logical pixels. |
| pixelRatio | <code>number</code> | The pixel ratio. |

<a name="WebGLRenderer+getCurrentViewport"></a>

### webGLRenderer.getCurrentViewport(target) ⇒ <code>Vector2</code>
Returns the current viewport definition.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector2</code> - The current viewport definition.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+getViewport"></a>

### webGLRenderer.getViewport(target) ⇒ <code>Vector4</code>
Returns the viewport definition.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector4</code> - The viewport definition.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector4</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setViewport"></a>

### webGLRenderer.setViewport(x, y, width, height)
Sets the viewport to render from `(x, y)` to `(x + width, y + height)`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector4</code> | The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit. Or alternatively a four-component vector specifying all the parameters of the viewport. |
| y | <code>number</code> | The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit. |
| width | <code>number</code> | The width of the viewport in logical pixel unit. |
| height | <code>number</code> | The height of the viewport in logical pixel unit. |

<a name="WebGLRenderer+getScissor"></a>

### webGLRenderer.getScissor(target) ⇒ <code>Vector4</code>
Returns the scissor region.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector4</code> - The scissor region.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector4</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setScissor"></a>

### webGLRenderer.setScissor(x, y, width, height)
Sets the scissor region to render from `(x, y)` to `(x + width, y + height)`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector4</code> | The horizontal coordinate for the lower left corner of the scissor region origin in logical pixel unit. Or alternatively a four-component vector specifying all the parameters of the scissor region. |
| y | <code>number</code> | The vertical coordinate for the lower left corner of the scissor region origin  in logical pixel unit. |
| width | <code>number</code> | The width of the scissor region in logical pixel unit. |
| height | <code>number</code> | The height of the scissor region in logical pixel unit. |

<a name="WebGLRenderer+getScissorTest"></a>

### webGLRenderer.getScissorTest() ⇒ <code>boolean</code>
Returns `true` if the scissor test is enabled.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>boolean</code> - Whether the scissor test is enabled or not.  
<a name="WebGLRenderer+setScissorTest"></a>

### webGLRenderer.setScissorTest(boolean)
Enable or disable the scissor test. When this is enabled, only the pixels
within the defined scissor area will be affected by further renderer
actions.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| boolean | <code>boolean</code> | Whether the scissor test is enabled or not. |

<a name="WebGLRenderer+setOpaqueSort"></a>

### webGLRenderer.setOpaqueSort(method)
Sets a custom opaque sort function for the render lists. Pass `null`
to use the default `painterSortStable` function.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | The opaque sort function. |

<a name="WebGLRenderer+setTransparentSort"></a>

### webGLRenderer.setTransparentSort(method)
Sets a custom transparent sort function for the render lists. Pass `null`
to use the default `reversePainterSortStable` function.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | The opaque sort function. |

<a name="WebGLRenderer+getClearColor"></a>

### webGLRenderer.getClearColor(target) ⇒ <code>Color</code>
Returns the clear color.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Color</code> - The clear color.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Color</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setClearColor"></a>

### webGLRenderer.setClearColor(color, [alpha])
Sets the clear color and alpha.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Color</code> |  | The clear color. |
| [alpha] | <code>number</code> | <code>1</code> | The clear alpha. |

<a name="WebGLRenderer+getClearAlpha"></a>

### webGLRenderer.getClearAlpha() ⇒ <code>number</code>
Returns the clear alpha. Ranges within `[0,1]`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>number</code> - The clear alpha.  
<a name="WebGLRenderer+setClearAlpha"></a>

### webGLRenderer.setClearAlpha(alpha)
Sets the clear alpha.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| alpha | <code>number</code> | The clear alpha. |

<a name="WebGLRenderer+clear"></a>

### webGLRenderer.clear([color], [depth], [stencil])
Tells the renderer to clear its color, depth or stencil drawing buffer(s).
This method initializes the buffers to the current clear color values.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>boolean</code> | <code>true</code> | Whether the color buffer should be cleared or not. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the depth buffer should be cleared or not. |
| [stencil] | <code>boolean</code> | <code>true</code> | Whether the stencil buffer should be cleared or not. |

<a name="WebGLRenderer+clearColor"></a>

### webGLRenderer.clearColor()
Clears the color buffer. Equivalent to calling `renderer.clear( true, false, false )`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+clearDepth"></a>

### webGLRenderer.clearDepth()
Clears the depth buffer. Equivalent to calling `renderer.clear( false, true, false )`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+clearStencil"></a>

### webGLRenderer.clearStencil()
Clears the stencil buffer. Equivalent to calling `renderer.clear( false, false, true )`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+dispose"></a>

### webGLRenderer.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+compile"></a>

### webGLRenderer.compile(scene, camera, [targetScene]) ⇒ <code>Set</code>
Compiles all materials in the scene with the camera. This is useful to precompile shaders
before the first rendering. If you want to add a 3D object to an existing scene, use the third
optional parameter for applying the target scene.

Note that the (target) scene's lighting and environment must be configured before calling this method.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Set</code> - The precompiled materials.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Object3D</code> |  | The scene or another type of 3D object to precompile. |
| camera | <code>Camera</code> |  | The camera. |
| [targetScene] | <code>Scene</code> | <code></code> | The target scene. |

<a name="WebGLRenderer+compileAsync"></a>

### webGLRenderer.compileAsync(scene, camera, [targetScene]) ⇒ <code>Promise</code>
Asynchronous version of [compile](#WebGLRenderer+compile).

This method makes use of the `KHR_parallel_shader_compile` WebGL extension. Hence,
it is recommended to use this version of `compile()` whenever possible.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Object3D</code> |  | The scene or another type of 3D object to precompile. |
| camera | <code>Camera</code> |  | The camera. |
| [targetScene] | <code>Scene</code> | <code></code> | The target scene. |

<a name="WebGLRenderer+render"></a>

### webGLRenderer.render(scene, camera)
Renders the given scene (or other type of 3D object) using the given camera.

The render is done to a previously specified render target set by calling [setRenderTarget](#WebGLRenderer+setRenderTarget)
or to the canvas as usual.

By default render buffers are cleared before rendering but you can prevent
this by setting the property `autoClear` to `false`. If you want to prevent
only certain buffers being cleared you can `autoClearColor`, `autoClearDepth`
or `autoClearStencil` to `false`. To force a clear, use [clear](#WebGLRenderer+clear).

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="WebGLRenderer+getActiveCubeFace"></a>

### webGLRenderer.getActiveCubeFace() ⇒ <code>number</code>
Returns the active cube face.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>number</code> - The active cube face.  
<a name="WebGLRenderer+getActiveMipmapLevel"></a>

### webGLRenderer.getActiveMipmapLevel() ⇒ <code>number</code>
Returns the active mipmap level.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>number</code> - The active mipmap level.  
<a name="WebGLRenderer+getRenderTarget"></a>

### webGLRenderer.getRenderTarget() ⇒ <code>WebGLRenderTarget</code>
Returns the active render target.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>WebGLRenderTarget</code> - The active render target. Returns `null` if no render target
is currently set.  
<a name="WebGLRenderer+setRenderTarget"></a>

### webGLRenderer.setRenderTarget(renderTarget, [activeCubeFace], [activeMipmapLevel])
Sets the active rendertarget.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderTarget | <code>WebGLRenderTarget</code> |  | The render target to set. When `null` is given, the canvas is set as the active render target instead. |
| [activeCubeFace] | <code>number</code> | <code>0</code> | The active cube face when using a cube render target. Indicates the z layer to render in to when using 3D or array render targets. |
| [activeMipmapLevel] | <code>number</code> | <code>0</code> | The active mipmap level. |

<a name="WebGLRenderer+readRenderTargetPixels"></a>

### webGLRenderer.readRenderTargetPixels(renderTarget, x, y, width, height, buffer, [activeCubeFaceIndex])
Reads the pixel data from the given render target into the given buffer.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| renderTarget | <code>WebGLRenderTarget</code> | The render target to read from. |
| x | <code>number</code> | The `x` coordinate of the copy region's origin. |
| y | <code>number</code> | The `y` coordinate of the copy region's origin. |
| width | <code>number</code> | The width of the copy region. |
| height | <code>number</code> | The height of the copy region. |
| buffer | <code>TypedArray</code> | The result buffer. |
| [activeCubeFaceIndex] | <code>number</code> | The active cube face index. |

<a name="WebGLRenderer+readRenderTargetPixelsAsync"></a>

### webGLRenderer.readRenderTargetPixelsAsync(renderTarget, x, y, width, height, buffer, [activeCubeFaceIndex]) ⇒ <code>Promise.&lt;TypedArray&gt;</code>
Asynchronous, non-blocking version of [readRenderTargetPixels](#WebGLRenderer+readRenderTargetPixels).

It is recommended to use this version of `readRenderTargetPixels()` whenever possible.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Promise.&lt;TypedArray&gt;</code> - A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.  

| Param | Type | Description |
| --- | --- | --- |
| renderTarget | <code>WebGLRenderTarget</code> | The render target to read from. |
| x | <code>number</code> | The `x` coordinate of the copy region's origin. |
| y | <code>number</code> | The `y` coordinate of the copy region's origin. |
| width | <code>number</code> | The width of the copy region. |
| height | <code>number</code> | The height of the copy region. |
| buffer | <code>TypedArray</code> | The result buffer. |
| [activeCubeFaceIndex] | <code>number</code> | The active cube face index. |

<a name="WebGLRenderer+copyFramebufferToTexture"></a>

### webGLRenderer.copyFramebufferToTexture(texture, position, [level])
Copies pixels from the current bound framebuffer into the given texture.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>FramebufferTexture</code> |  | The texture. |
| position | <code>Vector2</code> |  | The start position of the copy operation. |
| [level] | <code>number</code> | <code>0</code> | The mip level. The default represents the base mip. |

<a name="WebGLRenderer+copyTextureToTexture"></a>

### webGLRenderer.copyTextureToTexture(srcTexture, dstTexture, [srcRegion], [dstPosition], srcLevel, dstLevel)
Copies data of the given source texture into a destination texture.

When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized
[initRenderTarget](#WebGLRenderer+initRenderTarget).

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| srcTexture | <code>Texture</code> |  | The source texture. |
| dstTexture | <code>Texture</code> |  | The destination texture. |
| [srcRegion] | <code>Box2</code> \| <code>Box3</code> | <code></code> | A bounding box which describes the source region. Can be two or three-dimensional. |
| [dstPosition] | <code>Vector2</code> \| <code>Vector3</code> | <code></code> | A vector that represents the origin of the destination region. Can be two or three-dimensional. |
| srcLevel | <code>number</code> |  | The source mipmap level to copy. |
| dstLevel | <code>number</code> |  | The destination mipmap level. |

<a name="WebGLRenderer+initRenderTarget"></a>

### webGLRenderer.initRenderTarget(target)
Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data
can be copied into it using [copyTextureToTexture](#WebGLRenderer+copyTextureToTexture) before it has been
rendered to.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>WebGLRenderTarget</code> | The render target. |

<a name="WebGLRenderer+initTexture"></a>

### webGLRenderer.initTexture(texture)
Initializes the given texture. Useful for preloading a texture rather than waiting until first
render (which can cause noticeable lags due to decode and GPU upload overhead).

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="WebGLRenderer+resetState"></a>

### webGLRenderer.resetState()
Can be used to reset the internal WebGL state. This method is mostly
relevant for applications which share a single WebGL context across
multiple WebGL libraries.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer..Options"></a>

### WebGLRenderer~Options : <code>Object</code>
WebGLRenderer options.

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [canvas] | <code>DOMElement</code> | <code></code> | A canvas element where the renderer draws its output. If not passed in here, a new canvas element will be created by the renderer. |
| [context] | <code>WebGL2RenderingContext</code> | <code></code> | Can be used to attach an existing rendering context to this renderer. |
| [precision] | <code>&#x27;highp&#x27;</code> \| <code>&#x27;mediump&#x27;</code> \| <code>&#x27;lowp&#x27;</code> | <code>&#x27;highp&#x27;</code> | The default shader precision. Uses `highp` if supported by the device. |
| [alpha] | <code>boolean</code> | <code>false</code> | Controls the default clear alpha value. When set to`true`, the value is `0`. Otherwise it's `1`. |
| [premultipliedAlpha] | <code>boolean</code> | <code>true</code> | Whether the renderer will assume colors have premultiplied alpha or not. |
| [antialias] | <code>boolean</code> | <code>false</code> | Whether to use the default MSAA or not. |
| [stencil] | <code>boolean</code> | <code>false</code> | Whether the drawing buffer has a stencil buffer of at least 8 bits or not. |
| [preserveDrawingBuffer] | <code>boolean</code> | <code>false</code> | Whether to preserve the buffer until manually cleared or overwritten. |
| [powerPreference] | <code>&#x27;default&#x27;</code> \| <code>&#x27;low-power&#x27;</code> \| <code>&#x27;high-performance&#x27;</code> | <code>&#x27;default&#x27;</code> | Provides a hint to the user agent indicating what configuration of GPU is suitable for this WebGL context. |
| [failIfMajorPerformanceCaveat] | <code>boolean</code> | <code>false</code> | Whether the renderer creation will fail upon low performance is detected. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the drawing buffer has a depth buffer of at least 16 bits. |
| [logarithmicDepthBuffer] | <code>boolean</code> | <code>false</code> | Whether to use a logarithmic depth buffer. It may be necessary to use this if dealing with huge differences in scale in a single scene. Note that this setting uses `gl_FragDepth` if available which disables the Early Fragment Test optimization and can cause a decrease in performance. |
| [reverseDepthBuffer] | <code>boolean</code> | <code>false</code> | Whether to use a reverse depth buffer. Requires the `EXT_clip_control` extension. This is a more faster and accurate version than logarithmic depth buffer. |

<a name="WebGLRenderer..Capabilities"></a>

### WebGLRenderer~Capabilities : <code>Object</code>
WebGLRenderer Capabilities.

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| getMaxAnisotropy | <code>function</code> | Returns the maximum available anisotropy. |
| getMaxPrecision | <code>function</code> | Returns the maximum available precision for vertex and fragment shaders. |
| logarithmicDepthBuffer | <code>boolean</code> | `true` if `logarithmicDepthBuffer` was set to `true` in the constructor. |
| maxAttributes | <code>number</code> | The number of shader attributes that can be used by the vertex shader. |
| maxCubemapSize | <code>number</code> | Maximum height * width of cube map textures that a shader can use. |
| maxFragmentUniforms | <code>number</code> | The number of uniforms that can be used by a fragment shader. |
| maxSamples | <code>number</code> | Maximum number of samples in context of Multisample anti-aliasing (MSAA). |
| maxTextures | <code>number</code> | The maximum number of textures that can be used by a shader. |
| maxTextureSize | <code>number</code> | Maximum height * width of a texture that a shader use. |
| maxVaryings | <code>number</code> | The number of varying vectors that can used by shaders. |
| maxVertexTextures | <code>number</code> | The number of textures that can be used in a vertex shader. |
| maxVertexUniforms | <code>number</code> | The maximum number of uniforms that can be used in a vertex shader. |
| precision | <code>string</code> | The shader precision currently being used by the renderer. |
| reverseDepthBuffer | <code>boolean</code> | `true` if `reverseDepthBuffer` was set to `true` in the constructor and the rendering context supports `EXT_clip_control`. |
| vertexTextures | <code>boolean</code> | `true` if vertex textures can be used. |

<a name="WebGLRenderer..InfoMemory"></a>

### WebGLRenderer~InfoMemory : <code>Object</code>
WebGLRenderer Info Memory

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| geometries | <code>number</code> | The number of active geometries. |
| textures | <code>number</code> | The number of active textures. |

<a name="WebGLRenderer..InfoRender"></a>

### WebGLRenderer~InfoRender : <code>Object</code>
WebGLRenderer Info Render

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| frame | <code>number</code> | The frame ID. |
| calls | <code>number</code> | The number of draw calls per frame. |
| triangles | <code>number</code> | The number of rendered triangles primitives per frame. |
| points | <code>number</code> | The number of rendered points primitives per frame. |
| lines | <code>number</code> | The number of rendered lines primitives per frame. |

<a name="WebGLRenderer..Info"></a>

### WebGLRenderer~Info : <code>Object</code>
WebGLRenderer Info

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [autoReset] | <code>boolean</code> | <code>true</code> | Whether to automatically reset the info by the renderer or not. |
| memory | [<code>InfoMemory</code>](#WebGLRenderer..InfoMemory) |  | Information about allocated objects. |
| render | [<code>InfoRender</code>](#WebGLRenderer..InfoRender) |  | Information about rendered objects. |
| programs | <code>Array.&lt;WebGLProgram&gt;</code> |  | An array `WebGLProgram`s used for rendering. |
| reset | <code>function</code> |  | Resets the info object for the next frame. |

<a name="WebGLRenderer..ShadowMap"></a>

### WebGLRenderer~ShadowMap : <code>Object</code>
WebGLRenderer Shadow Map.

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [enabled] | <code>boolean</code> | <code>false</code> | If set to `true`, use shadow maps in the scene. |
| [autoUpdate] | <code>boolean</code> | <code>true</code> | Enables automatic updates to the shadows in the scene. If you do not require dynamic lighting / shadows, you may set this to `false`. |
| [needsUpdate] | <code>boolean</code> | <code>false</code> | When set to `true`, shadow maps in the scene will be updated in the next `render` call. |
| [type] | <code>BasicShadowMap</code> \| <code>PCFShadowMap</code> \| <code>PCFSoftShadowMap</code> \| <code>VSMShadowMap</code> | <code>PCFShadowMap</code> | Defines the shadow map type. |

## Functions

<dl>
<dt><a href="#getFloatLength">getFloatLength(floatLength)</a> ⇒ <code>number</code></dt>
<dd><p>This function is usually called with the length in bytes of an array buffer.
It returns an padded value which ensure chunk size alignment according to STD140 layout.</p>
</dd>
<dt><a href="#getVectorLength">getVectorLength(count, [vectorLength])</a> ⇒ <code>number</code></dt>
<dd><p>Given the count of vectors and their vector length, this function computes
a total length in bytes with buffer alignment according to STD140 layout.</p>
</dd>
<dt><a href="#getStrideLength">getStrideLength(vectorLength)</a> ⇒ <code>number</code></dt>
<dd><p>This function is called with a vector length and ensure the computed length
matches a predefined stride (in this case <code>4</code>).</p>
</dd>
</dl>

<a name="getFloatLength"></a>

## getFloatLength(floatLength) ⇒ <code>number</code>
This function is usually called with the length in bytes of an array buffer.
It returns an padded value which ensure chunk size alignment according to STD140 layout.

**Kind**: global function  
**Returns**: <code>number</code> - The padded length.  

| Param | Type | Description |
| --- | --- | --- |
| floatLength | <code>number</code> | The buffer length. |

<a name="getVectorLength"></a>

## getVectorLength(count, [vectorLength]) ⇒ <code>number</code>
Given the count of vectors and their vector length, this function computes
a total length in bytes with buffer alignment according to STD140 layout.

**Kind**: global function  
**Returns**: <code>number</code> - The padded length.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> |  | The number of vectors. |
| [vectorLength] | <code>number</code> | <code>4</code> | The vector length. |

<a name="getStrideLength"></a>

## getStrideLength(vectorLength) ⇒ <code>number</code>
This function is called with a vector length and ensure the computed length
matches a predefined stride (in this case `4`).

**Kind**: global function  
**Returns**: <code>number</code> - The padded length.  

| Param | Type | Description |
| --- | --- | --- |
| vectorLength | <code>number</code> | The vector length. |

<a name="BundleGroup"></a>

## BundleGroup ⇐ <code>Group</code>
A specialized group which enables applications access to the
Render Bundle API of WebGPU. The group with all its descendant nodes
are considered as one render bundle and processed as such by
the renderer.

This module is only fully supported by `WebGPURenderer` with a WebGPU backend.
With a WebGL backend, the group can technically be rendered but without
any performance improvements.

**Kind**: global class  
**Extends**: <code>Group</code>  

* [BundleGroup](#BundleGroup) ⇐ <code>Group</code>
    * [new BundleGroup()](#new_BundleGroup_new)
    * [.isBundleGroup](#BundleGroup+isBundleGroup) : <code>boolean</code>
    * [.type](#BundleGroup+type) : <code>string</code>
    * [.static](#BundleGroup+static) : <code>boolean</code>
    * [.version](#BundleGroup+version) : <code>number</code>
    * [.needsUpdate](#BundleGroup+needsUpdate) : <code>boolean</code>

<a name="new_BundleGroup_new"></a>

### new BundleGroup()
Constructs a new bundle group.

<a name="BundleGroup+isBundleGroup"></a>

### bundleGroup.isBundleGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BundleGroup+type"></a>

### bundleGroup.type : <code>string</code>
This property is only relevant for detecting types
during serialization/deserialization. It should always
match the class name.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>&quot;&#x27;BundleGroup&#x27;&quot;</code>  
**Read only**: true  
<a name="BundleGroup+static"></a>

### bundleGroup.static : <code>boolean</code>
Whether the bundle is static or not. When set to `true`, the structure
is assumed to be static and does not change. E.g. no new objects are
added to the group

If a change is required, an update can still be forced by setting the
`needsUpdate` flag to `true`.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>true</code>  
<a name="BundleGroup+version"></a>

### bundleGroup.version : <code>number</code>
The bundle group's version.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="BundleGroup+needsUpdate"></a>

### bundleGroup.needsUpdate : <code>boolean</code>
Set this property to `true` when the bundle group has changed.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="CubeRenderTarget"></a>

## CubeRenderTarget ⇐ <code>WebGLCubeRenderTarget</code>
This class represents a cube render target. It is a special version
of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>WebGLCubeRenderTarget</code>  

* [CubeRenderTarget](#CubeRenderTarget) ⇐ <code>WebGLCubeRenderTarget</code>
    * [new CubeRenderTarget([size], [options])](#new_CubeRenderTarget_new)
    * [.isCubeRenderTarget](#CubeRenderTarget+isCubeRenderTarget) : <code>boolean</code>
    * [.fromEquirectangularTexture(renderer, texture)](#CubeRenderTarget+fromEquirectangularTexture) ⇒ [<code>CubeRenderTarget</code>](#CubeRenderTarget)

<a name="new_CubeRenderTarget_new"></a>

### new CubeRenderTarget([size], [options])
Constructs a new cube render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>1</code> | The size of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="CubeRenderTarget+isCubeRenderTarget"></a>

### cubeRenderTarget.isCubeRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubeRenderTarget</code>](#CubeRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubeRenderTarget+fromEquirectangularTexture"></a>

### cubeRenderTarget.fromEquirectangularTexture(renderer, texture) ⇒ [<code>CubeRenderTarget</code>](#CubeRenderTarget)
Converts the given equirectangular texture to a cube map.

**Kind**: instance method of [<code>CubeRenderTarget</code>](#CubeRenderTarget)  
**Returns**: [<code>CubeRenderTarget</code>](#CubeRenderTarget) - A reference to this cube render target.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |
| texture | <code>Texture</code> | The equirectangular texture. |

<a name="IndirectStorageBufferAttribute"></a>

## IndirectStorageBufferAttribute ⇐ <code>StorageBufferAttribute</code>
This special type of buffer attribute is intended for compute shaders.
It can be used to encode draw parameters for indirect draw calls.

Note: This type of buffer attribute can only be used with `WebGPURenderer`
and a WebGPU backend.

**Kind**: global class  
**Extends**: <code>StorageBufferAttribute</code>  

* [IndirectStorageBufferAttribute](#IndirectStorageBufferAttribute) ⇐ <code>StorageBufferAttribute</code>
    * [new IndirectStorageBufferAttribute(count, itemSize)](#new_IndirectStorageBufferAttribute_new)
    * [.isIndirectStorageBufferAttribute](#IndirectStorageBufferAttribute+isIndirectStorageBufferAttribute) : <code>boolean</code>

<a name="new_IndirectStorageBufferAttribute_new"></a>

### new IndirectStorageBufferAttribute(count, itemSize)
Constructs a new storage buffer attribute.


| Param | Type | Description |
| --- | --- | --- |
| count | <code>number</code> \| <code>Uint32Array</code> | The item count. It is also valid to pass a `Uint32Array` as an argument. The subsequent parameter is then obsolete. |
| itemSize | <code>number</code> | The item size. |

<a name="IndirectStorageBufferAttribute+isIndirectStorageBufferAttribute"></a>

### indirectStorageBufferAttribute.isIndirectStorageBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>IndirectStorageBufferAttribute</code>](#IndirectStorageBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Info"></a>

## Info
This renderer module provides a series of statistical information
about the GPU memory and the rendering process. Useful for debugging
and monitoring.

**Kind**: global class  

* [Info](#Info)
    * [new Info()](#new_Info_new)
    * [.autoReset](#Info+autoReset) : <code>boolean</code>
    * [.frame](#Info+frame) : <code>number</code>
    * [.calls](#Info+calls) : <code>number</code>
    * [.render](#Info+render) : <code>Object</code>
    * [.compute](#Info+compute) : <code>Object</code>
    * [.memory](#Info+memory) : <code>Object</code>
    * [.update(object, count, instanceCount)](#Info+update)
    * [.reset()](#Info+reset)
    * [.dispose()](#Info+dispose)

<a name="new_Info_new"></a>

### new Info()
Constructs a new info component.

<a name="Info+autoReset"></a>

### info.autoReset : <code>boolean</code>
Whether frame related metrics should automatically
be resetted or not. This property should be set to `false`
by apps which manage their own animation loop. They must
then call `renderer.info.reset()` once per frame manually.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Default**: <code>true</code>  
<a name="Info+frame"></a>

### info.frame : <code>number</code>
The current frame ID. This ID is managed
by `NodeFrame`.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Info+calls"></a>

### info.calls : <code>number</code>
The number of render calls since the
app has been started.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Info+render"></a>

### info.render : <code>Object</code>
Render related metrics.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Read only**: true  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| calls | <code>number</code> | The number of render calls since the app has been started. |
| frameCalls | <code>number</code> | The number of render calls of the current frame. |
| drawCalls | <code>number</code> | The number of draw calls of the current frame. |
| triangles | <code>number</code> | The number of rendered triangle primitives of the current frame. |
| points | <code>number</code> | The number of rendered point primitives of the current frame. |
| lines | <code>number</code> | The number of rendered line primitives of the current frame. |
| timestamp | <code>number</code> | The timestamp of the frame when using `renderer.renderAsync()`. |

<a name="Info+compute"></a>

### info.compute : <code>Object</code>
Compute related metrics.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Read only**: true  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| calls | <code>number</code> | The number of compute calls since the app has been started. |
| frameCalls | <code>number</code> | The number of compute calls of the current frame. |
| timestamp | <code>number</code> | The timestamp of the frame when using `renderer.computeAsync()`. |

<a name="Info+memory"></a>

### info.memory : <code>Object</code>
Memory related metrics.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Read only**: true  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| geometries | <code>number</code> | The number of active geometries. |
| frameCalls | <code>number</code> | The number of active textures. |

<a name="Info+update"></a>

### info.update(object, count, instanceCount)
This method should be executed per draw call and updates the corresponding metrics.

**Kind**: instance method of [<code>Info</code>](#Info)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object that is going to be rendered. |
| count | <code>number</code> | The vertex or index count. |
| instanceCount | <code>number</code> | The instance count. |

<a name="Info+reset"></a>

### info.reset()
Resets frame related metrics.

**Kind**: instance method of [<code>Info</code>](#Info)  
<a name="Info+dispose"></a>

### info.dispose()
Performs a complete reset of the object.

**Kind**: instance method of [<code>Info</code>](#Info)  
<a name="PostProcessing"></a>

## PostProcessing
This module is responsible to manage the post processing setups in apps.
You usually create a single instance of this class and use it to define
the output of your post processing effect chain.
```js
const postProcessing = new PostProcessing( renderer );

const scenePass = pass( scene, camera );

postProcessing.outputNode = scenePass;
```

Note: This module can only be used with `WebGPURenderer`.

**Kind**: global class  

* [PostProcessing](#PostProcessing)
    * [new PostProcessing(renderer, outputNode)](#new_PostProcessing_new)
    * [.renderer](#PostProcessing+renderer) : <code>Renderer</code>
    * [.outputNode](#PostProcessing+outputNode) : <code>Node.&lt;vec4&gt;</code>
    * [.outputColorTransform](#PostProcessing+outputColorTransform) : <code>boolean</code>
    * [.needsUpdate](#PostProcessing+needsUpdate) : <code>Node.&lt;vec4&gt;</code>
    * [.render()](#PostProcessing+render)
    * [.dispose()](#PostProcessing+dispose)
    * [.renderAsync()](#PostProcessing+renderAsync) ⇒ <code>Promise</code>

<a name="new_PostProcessing_new"></a>

### new PostProcessing(renderer, outputNode)
Constructs a new post processing management module.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | A reference to the renderer. |
| outputNode | <code>Node.&lt;vec4&gt;</code> | An optional output node. |

<a name="PostProcessing+renderer"></a>

### postProcessing.renderer : <code>Renderer</code>
A reference to the renderer.

**Kind**: instance property of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+outputNode"></a>

### postProcessing.outputNode : <code>Node.&lt;vec4&gt;</code>
A node which defines the final output of the post
processing. This is usually the last node in a chain
of effect nodes.

**Kind**: instance property of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+outputColorTransform"></a>

### postProcessing.outputColorTransform : <code>boolean</code>
Whether the default output tone mapping and color
space transformation should be enabled or not.

It is enabled by default by it must be disabled when
effects must be executed after tone mapping and color
space conversion. A typical example is FXAA which
requires sRGB input.

When set to `false`, the app must control the output
transformation with `RenderOutputNode`.

```js
const outputPass = renderOutput( scenePass );
```

**Kind**: instance property of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+needsUpdate"></a>

### postProcessing.needsUpdate : <code>Node.&lt;vec4&gt;</code>
Must be set to `true` when the output node changes.

**Kind**: instance property of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+render"></a>

### postProcessing.render()
When `PostProcessing` is used to apply post processing effects,
the application must use this version of `render()` inside
its animation loop (not the one from the renderer).

**Kind**: instance method of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+dispose"></a>

### postProcessing.dispose()
Frees internal resources.

**Kind**: instance method of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+renderAsync"></a>

### postProcessing.renderAsync() ⇒ <code>Promise</code>
When `PostProcessing` is used to apply post processing effects,
the application must use this version of `renderAsync()` inside
its animation loop (not the one from the renderer).

**Kind**: instance method of [<code>PostProcessing</code>](#PostProcessing)  
**Returns**: <code>Promise</code> - A Promise that resolves when the render has been finished.  
<a name="QuadMesh"></a>

## QuadMesh ⇐ <code>Mesh</code>
This module is a helper for passes which need to render a full
screen effect which is quite common in context of post processing.

The intended usage is to reuse a single quad mesh for rendering
subsequent passes by just reassigning the `material` reference.

Note: This module can only be used with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [QuadMesh](#QuadMesh) ⇐ <code>Mesh</code>
    * [new QuadMesh([material])](#new_QuadMesh_new)
    * [.camera](#QuadMesh+camera) : <code>OrthographicCamera</code>
    * [.isQuadMesh](#QuadMesh+isQuadMesh) : <code>boolean</code>
    * [.renderAsync(renderer)](#QuadMesh+renderAsync) ⇒ <code>Promise</code>
    * [.render(renderer)](#QuadMesh+render)

<a name="new_QuadMesh_new"></a>

### new QuadMesh([material])
Constructs a new quad mesh.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [material] | <code>Material</code> | <code></code> | The material to render the quad mesh with. |

<a name="QuadMesh+camera"></a>

### quadMesh.camera : <code>OrthographicCamera</code>
The camera to render the quad mesh with.

**Kind**: instance property of [<code>QuadMesh</code>](#QuadMesh)  
**Read only**: true  
<a name="QuadMesh+isQuadMesh"></a>

### quadMesh.isQuadMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>QuadMesh</code>](#QuadMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="QuadMesh+renderAsync"></a>

### quadMesh.renderAsync(renderer) ⇒ <code>Promise</code>
Async version of `render()`.

**Kind**: instance method of [<code>QuadMesh</code>](#QuadMesh)  
**Returns**: <code>Promise</code> - A Promise that resolves when the render has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |

<a name="QuadMesh+render"></a>

### quadMesh.render(renderer)
Renders the quad mesh

**Kind**: instance method of [<code>QuadMesh</code>](#QuadMesh)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |

<a name="getCacheKey"></a>

## getCacheKey(renderContext) ⇒ <code>number</code>
Computes a cache key for the given render context. This key
should identify the render target state so it is possible to
configure the correct attachments in the respective backend.

**Kind**: global function  
**Returns**: <code>number</code> - The cache key.  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | [<code>RenderContext</code>](#new_RenderContext_new) | The render context. |

## Classes

<dl>
<dt><a href="#Renderer">Renderer</a></dt>
<dd><p>Base class for renderers.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#ShadowMapConfig">ShadowMapConfig</a> : <code>Object</code></dt>
<dd><p>Shadow map configuration</p>
</dd>
<dt><a href="#XRConfig">XRConfig</a> : <code>Object</code></dt>
<dd><p>XR configuration.</p>
</dd>
<dt><a href="#DebugConfig">DebugConfig</a> : <code>Object</code></dt>
<dd><p>Debug configuration.</p>
</dd>
<dt><a href="#renderObjectFunction">renderObjectFunction</a> : <code>function</code></dt>
<dd><p>Callback for <a href="#Renderer+setRenderObjectFunction">setRenderObjectFunction</a>.</p>
</dd>
</dl>

<a name="Renderer"></a>

## Renderer
Base class for renderers.

**Kind**: global class  

* [Renderer](#Renderer)
    * [new Renderer(backend, [parameters])](#new_Renderer_new)
    * _instance_
        * [.isRenderer](#Renderer+isRenderer) : <code>boolean</code>
        * [.domElement](#Renderer+domElement) : <code>HTMLCanvasElement</code> \| <code>OffscreenCanvas</code>
        * [.backend](#Renderer+backend) : <code>Backend</code>
        * [.samples](#Renderer+samples) : <code>number</code>
        * [.autoClear](#Renderer+autoClear) : <code>boolean</code>
        * [.autoClearColor](#Renderer+autoClearColor) : <code>boolean</code>
        * [.autoClearDepth](#Renderer+autoClearDepth) : <code>boolean</code>
        * [.autoClearStencil](#Renderer+autoClearStencil) : <code>boolean</code>
        * [.alpha](#Renderer+alpha) : <code>boolean</code>
        * [.logarithmicDepthBuffer](#Renderer+logarithmicDepthBuffer) : <code>boolean</code>
        * [.outputColorSpace](#Renderer+outputColorSpace) : <code>string</code>
        * [.toneMapping](#Renderer+toneMapping) : <code>number</code>
        * [.toneMappingExposure](#Renderer+toneMappingExposure) : <code>number</code>
        * [.sortObjects](#Renderer+sortObjects) : <code>boolean</code>
        * [.depth](#Renderer+depth) : <code>boolean</code>
        * [.stencil](#Renderer+stencil) : <code>boolean</code>
        * [.info](#Renderer+info) : <code>Info</code>
        * [.library](#Renderer+library) : <code>NodeLibrary</code>
        * [.lighting](#Renderer+lighting) : <code>Lighting</code>
        * [.onDeviceLost](#Renderer+onDeviceLost) : <code>function</code>
        * [.transparent](#Renderer+transparent) : <code>boolean</code>
        * [.opaque](#Renderer+opaque) : <code>boolean</code>
        * [.shadowMap](#Renderer+shadowMap) : [<code>ShadowMapConfig</code>](#ShadowMapConfig)
        * [.xr](#Renderer+xr) : <code>XRManager</code>
        * [.debug](#Renderer+debug) : [<code>DebugConfig</code>](#DebugConfig)
        * [.coordinateSystem](#Renderer+coordinateSystem) : <code>number</code>
        * [.currentToneMapping](#Renderer+currentToneMapping) : <code>number</code>
        * [.currentColorSpace](#Renderer+currentColorSpace) : <code>string</code>
        * [.isOutputTarget](#Renderer+isOutputTarget) ⇒ <code>boolean</code>
        * [.init()](#Renderer+init) ⇒ <code>Promise.&lt;this&gt;</code>
        * [.compileAsync(scene, camera, targetScene)](#Renderer+compileAsync) ⇒ <code>Promise.&lt;(Array\|undefined)&gt;</code>
        * [.renderAsync(scene, camera)](#Renderer+renderAsync) ⇒ <code>Promise</code>
        * [.waitForGPU()](#Renderer+waitForGPU) ⇒ <code>Promise</code>
        * [.setMRT(mrt)](#Renderer+setMRT) ⇒ [<code>Renderer</code>](#Renderer)
        * [.getMRT()](#Renderer+getMRT) ⇒ <code>MRTNode</code>
        * [.getColorBufferType()](#Renderer+getColorBufferType) ⇒ <code>number</code>
        * [.render(scene, camera)](#Renderer+render) ⇒ <code>Promise</code>
        * [.getMaxAnisotropy()](#Renderer+getMaxAnisotropy) ⇒ <code>number</code>
        * [.getActiveCubeFace()](#Renderer+getActiveCubeFace) ⇒ <code>number</code>
        * [.getActiveMipmapLevel()](#Renderer+getActiveMipmapLevel) ⇒ <code>number</code>
        * [.setAnimationLoop(callback)](#Renderer+setAnimationLoop) ⇒ <code>Promise</code>
        * [.getArrayBufferAsync(attribute)](#Renderer+getArrayBufferAsync) ⇒ <code>Promise.&lt;ArrayBuffer&gt;</code>
        * [.getContext()](#Renderer+getContext) ⇒ <code>GPUCanvasContext</code> \| <code>WebGL2RenderingContext</code>
        * [.getPixelRatio()](#Renderer+getPixelRatio) ⇒ <code>number</code>
        * [.getDrawingBufferSize(target)](#Renderer+getDrawingBufferSize) ⇒ <code>Vector2</code>
        * [.getSize(target)](#Renderer+getSize) ⇒ <code>Vector2</code>
        * [.setPixelRatio([value])](#Renderer+setPixelRatio)
        * [.setDrawingBufferSize(width, height, pixelRatio)](#Renderer+setDrawingBufferSize)
        * [.setSize(width, height, [updateStyle])](#Renderer+setSize)
        * [.setOpaqueSort(method)](#Renderer+setOpaqueSort)
        * [.setTransparentSort(method)](#Renderer+setTransparentSort)
        * [.getScissor(target)](#Renderer+getScissor) ⇒ <code>Vector4</code>
        * [.setScissor(x, y, width, height)](#Renderer+setScissor)
        * [.getScissorTest()](#Renderer+getScissorTest) ⇒ <code>boolean</code>
        * [.setScissorTest(boolean)](#Renderer+setScissorTest)
        * [.getViewport(target)](#Renderer+getViewport) ⇒ <code>Vector4</code>
        * [.setViewport(x, y, width, height, minDepth, maxDepth)](#Renderer+setViewport)
        * [.getClearColor(target)](#Renderer+getClearColor) ⇒ <code>Color</code>
        * [.setClearColor(color, [alpha])](#Renderer+setClearColor)
        * [.getClearAlpha()](#Renderer+getClearAlpha) ⇒ <code>number</code>
        * [.setClearAlpha(alpha)](#Renderer+setClearAlpha)
        * [.getClearDepth()](#Renderer+getClearDepth) ⇒ <code>number</code>
        * [.setClearDepth(depth)](#Renderer+setClearDepth)
        * [.getClearStencil()](#Renderer+getClearStencil) ⇒ <code>number</code>
        * [.setClearStencil(stencil)](#Renderer+setClearStencil)
        * [.isOccluded(object)](#Renderer+isOccluded) ⇒ <code>boolean</code>
        * [.clear([color], [depth], [stencil])](#Renderer+clear) ⇒ <code>Promise</code>
        * [.clearColor()](#Renderer+clearColor) ⇒ <code>Promise</code>
        * [.clearDepth()](#Renderer+clearDepth) ⇒ <code>Promise</code>
        * [.clearStencil()](#Renderer+clearStencil) ⇒ <code>Promise</code>
        * [.clearAsync([color], [depth], [stencil])](#Renderer+clearAsync) ⇒ <code>Promise</code>
        * [.clearColorAsync()](#Renderer+clearColorAsync) ⇒ <code>Promise</code>
        * [.clearDepthAsync()](#Renderer+clearDepthAsync) ⇒ <code>Promise</code>
        * [.clearStencilAsync()](#Renderer+clearStencilAsync) ⇒ <code>Promise</code>
        * [.dispose()](#Renderer+dispose)
        * [.setRenderTarget(renderTarget, [activeCubeFace], [activeMipmapLevel])](#Renderer+setRenderTarget)
        * [.getRenderTarget()](#Renderer+getRenderTarget) ⇒ <code>RenderTarget</code>
        * [.setOutputRenderTarget(renderTarget)](#Renderer+setOutputRenderTarget)
        * [.getOutputRenderTarget()](#Renderer+getOutputRenderTarget) ⇒ <code>RenderTarget</code>
        * [.setRenderObjectFunction(renderObjectFunction)](#Renderer+setRenderObjectFunction)
        * [.getRenderObjectFunction()](#Renderer+getRenderObjectFunction) ⇒ <code>function</code>
        * [.compute(computeNodes)](#Renderer+compute) ⇒ <code>Promise</code> \| <code>undefined</code>
        * [.computeAsync(computeNodes)](#Renderer+computeAsync) ⇒ <code>Promise</code>
        * [.hasFeatureAsync(name)](#Renderer+hasFeatureAsync) ⇒ <code>Promise.&lt;boolean&gt;</code>
        * [.hasFeature(name)](#Renderer+hasFeature) ⇒ <code>boolean</code>
        * [.hasInitialized()](#Renderer+hasInitialized) ⇒ <code>boolean</code>
        * [.initTextureAsync(texture)](#Renderer+initTextureAsync) ⇒ <code>Promise</code>
        * [.initTexture(texture)](#Renderer+initTexture)
        * [.copyFramebufferToTexture(framebufferTexture, [rectangle])](#Renderer+copyFramebufferToTexture)
        * [.copyTextureToTexture(srcTexture, dstTexture, [srcRegion], [dstPosition], [srcLevel], [dstLevel])](#Renderer+copyTextureToTexture)
        * [.readRenderTargetPixelsAsync(renderTarget, x, y, width, height, [textureIndex], [faceIndex])](#Renderer+readRenderTargetPixelsAsync) ⇒ <code>Promise.&lt;TypedArray&gt;</code>
        * [._projectObject(object, camera, groupOrder, renderList, clippingContext)](#Renderer+_projectObject)
        * [.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext, [passId])](#Renderer+renderObject)
        * [.compile(scene, camera, targetScene)](#Renderer+compile) ⇒ <code>function</code>
    * _inner_
        * [~Options](#Renderer..Options) : <code>Object</code>

<a name="new_Renderer_new"></a>

### new Renderer(backend, [parameters])
Constructs a new renderer.


| Param | Type | Description |
| --- | --- | --- |
| backend | <code>Backend</code> | The backend the renderer is targeting (e.g. WebGPU or WebGL 2). |
| [parameters] | [<code>Options</code>](#Renderer..Options) | The configuration parameter. |

<a name="Renderer+isRenderer"></a>

### renderer.isRenderer : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Renderer+domElement"></a>

### renderer.domElement : <code>HTMLCanvasElement</code> \| <code>OffscreenCanvas</code>
A reference to the canvas element the renderer is drawing to.
This value of this property will automatically be created by
the renderer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+backend"></a>

### renderer.backend : <code>Backend</code>
A reference to the current backend.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+samples"></a>

### renderer.samples : <code>number</code>
The number of MSAA samples.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>0</code>  
<a name="Renderer+autoClear"></a>

### renderer.autoClear : <code>boolean</code>
Whether the renderer should automatically clear the current rendering target
before execute a `render()` call. The target can be the canvas (default framebuffer)
or the current bound render target (custom framebuffer).

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+autoClearColor"></a>

### renderer.autoClearColor : <code>boolean</code>
When `autoClear` is set to `true`, this property defines whether the renderer
should clear the color buffer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+autoClearDepth"></a>

### renderer.autoClearDepth : <code>boolean</code>
When `autoClear` is set to `true`, this property defines whether the renderer
should clear the depth buffer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+autoClearStencil"></a>

### renderer.autoClearStencil : <code>boolean</code>
When `autoClear` is set to `true`, this property defines whether the renderer
should clear the stencil buffer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+alpha"></a>

### renderer.alpha : <code>boolean</code>
Whether the default framebuffer should be transparent or opaque.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+logarithmicDepthBuffer"></a>

### renderer.logarithmicDepthBuffer : <code>boolean</code>
Whether logarithmic depth buffer is enabled or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>false</code>  
<a name="Renderer+outputColorSpace"></a>

### renderer.outputColorSpace : <code>string</code>
Defines the output color space of the renderer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>&quot;SRGBColorSpace&quot;</code>  
<a name="Renderer+toneMapping"></a>

### renderer.toneMapping : <code>number</code>
Defines the tone mapping of the renderer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>NoToneMapping</code>  
<a name="Renderer+toneMappingExposure"></a>

### renderer.toneMappingExposure : <code>number</code>
Defines the tone mapping exposure.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>1</code>  
<a name="Renderer+sortObjects"></a>

### renderer.sortObjects : <code>boolean</code>
Whether the renderer should sort its render lists or not.

Note: Sorting is used to attempt to properly render objects that have some degree of transparency.
By definition, sorting objects may not work in all cases. Depending on the needs of application,
it may be necessary to turn off sorting and use other methods to deal with transparency rendering
e.g. manually determining each object's rendering order.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+depth"></a>

### renderer.depth : <code>boolean</code>
Whether the default framebuffer should have a depth buffer or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+stencil"></a>

### renderer.stencil : <code>boolean</code>
Whether the default framebuffer should have a stencil buffer or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>false</code>  
<a name="Renderer+info"></a>

### renderer.info : <code>Info</code>
Holds a series of statistical information about the GPU memory
and the rendering process. Useful for debugging and monitoring.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+library"></a>

### renderer.library : <code>NodeLibrary</code>
The node library defines how certain library objects like materials, lights
or tone mapping functions are mapped to node types. This is required since
although instances of classes like `MeshBasicMaterial` or `PointLight` can
be part of the scene graph, they are internally represented as nodes for
further processing.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+lighting"></a>

### renderer.lighting : <code>Lighting</code>
A map-like data structure for managing lights.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+onDeviceLost"></a>

### renderer.onDeviceLost : <code>function</code>
A callback function that defines what should happen when a device/context lost occurs.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+transparent"></a>

### renderer.transparent : <code>boolean</code>
Whether the renderer should render transparent render objects or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+opaque"></a>

### renderer.opaque : <code>boolean</code>
Whether the renderer should render opaque render objects or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+shadowMap"></a>

### renderer.shadowMap : [<code>ShadowMapConfig</code>](#ShadowMapConfig)
The renderer's shadow configuration.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+xr"></a>

### renderer.xr : <code>XRManager</code>
The renderer's XR manager.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+debug"></a>

### renderer.debug : [<code>DebugConfig</code>](#DebugConfig)
The renderer's debug configuration.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+coordinateSystem"></a>

### renderer.coordinateSystem : <code>number</code>
The coordinate system of the renderer. The value of this property
depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
`THREE.WebGPUCoordinateSystem`.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Read only**: true  
<a name="Renderer+currentToneMapping"></a>

### renderer.currentToneMapping : <code>number</code>
The current output tone mapping of the renderer. When a render target is set,
the output tone mapping is always `NoToneMapping`.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+currentColorSpace"></a>

### renderer.currentColorSpace : <code>string</code>
The current output color space of the renderer. When a render target is set,
the output color space is always `LinearSRGBColorSpace`.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+isOutputTarget"></a>

### renderer.isOutputTarget ⇒ <code>boolean</code>
Returns `true` if the rendering settings are set to screen output.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - True if the current render target is the same of output render target or `null`, otherwise false.  
<a name="Renderer+init"></a>

### renderer.init() ⇒ <code>Promise.&lt;this&gt;</code>
Initializes the renderer so it is ready for usage.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;this&gt;</code> - A Promise that resolves when the renderer has been initialized.  
<a name="Renderer+compileAsync"></a>

### renderer.compileAsync(scene, camera, targetScene) ⇒ <code>Promise.&lt;(Array\|undefined)&gt;</code>
Compiles all materials in the given scene. This can be useful to avoid a
phenomenon which is called "shader compilation stutter", which occurs when
rendering an object with a new shader for the first time.

If you want to add a 3D object to an existing scene, use the third optional
parameter for applying the target scene. Note that the (target) scene's lighting
and environment must be configured before calling this method.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;(Array\|undefined)&gt;</code> - A Promise that resolves when the compile has been finished.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Object3D</code> |  | The scene or 3D object to precompile. |
| camera | <code>Camera</code> |  | The camera that is used to render the scene. |
| targetScene | <code>Scene</code> | <code></code> | If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added. |

<a name="Renderer+renderAsync"></a>

### renderer.renderAsync(scene, camera) ⇒ <code>Promise</code>
Renders the scene in an async fashion.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the render has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or 3D object to render. |
| camera | <code>Camera</code> | The camera. |

<a name="Renderer+waitForGPU"></a>

### renderer.waitForGPU() ⇒ <code>Promise</code>
Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
the CPU waits for the GPU to complete its operation (e.g. a compute task).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when synchronization has been finished.  
<a name="Renderer+setMRT"></a>

### renderer.setMRT(mrt) ⇒ [<code>Renderer</code>](#Renderer)
Sets the given MRT configuration.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: [<code>Renderer</code>](#Renderer) - A reference to this renderer.  

| Param | Type | Description |
| --- | --- | --- |
| mrt | <code>MRTNode</code> | The MRT node to set. |

<a name="Renderer+getMRT"></a>

### renderer.getMRT() ⇒ <code>MRTNode</code>
Returns the MRT configuration.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>MRTNode</code> - The MRT configuration.  
<a name="Renderer+getColorBufferType"></a>

### renderer.getColorBufferType() ⇒ <code>number</code>
Returns the color buffer type.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The color buffer type.  
<a name="Renderer+render"></a>

### renderer.render(scene, camera) ⇒ <code>Promise</code>
Renders the scene or 3D object with the given camera. This method can only be called
if the renderer has been initialized.

The target of the method is the default framebuffer (meaning the canvas)
or alternatively a render target when specified via `setRenderTarget()`.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolve when the scene has been rendered.
Only returned when the renderer has not been initialized.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or 3D object to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="Renderer+getMaxAnisotropy"></a>

### renderer.getMaxAnisotropy() ⇒ <code>number</code>
Returns the maximum available anisotropy for texture filtering.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The maximum available anisotropy.  
<a name="Renderer+getActiveCubeFace"></a>

### renderer.getActiveCubeFace() ⇒ <code>number</code>
Returns the active cube face.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The active cube face.  
<a name="Renderer+getActiveMipmapLevel"></a>

### renderer.getActiveMipmapLevel() ⇒ <code>number</code>
Returns the active mipmap level.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The active mipmap level.  
<a name="Renderer+setAnimationLoop"></a>

### renderer.setAnimationLoop(callback) ⇒ <code>Promise</code>
Applications are advised to always define the animation loop
with this method and not manually with `requestAnimationFrame()`
for best compatibility.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the set has been executed.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The application's animation loop. |

<a name="Renderer+getArrayBufferAsync"></a>

### renderer.getArrayBufferAsync(attribute) ⇒ <code>Promise.&lt;ArrayBuffer&gt;</code>
Can be used to transfer buffer data from a storage buffer attribute
from the GPU to the CPU in context of compute shaders.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;ArrayBuffer&gt;</code> - A promise that resolves with the buffer data when the data are ready.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>StorageBufferAttribute</code> | The storage buffer attribute. |

<a name="Renderer+getContext"></a>

### renderer.getContext() ⇒ <code>GPUCanvasContext</code> \| <code>WebGL2RenderingContext</code>
Returns the rendering context.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>GPUCanvasContext</code> \| <code>WebGL2RenderingContext</code> - The rendering context.  
<a name="Renderer+getPixelRatio"></a>

### renderer.getPixelRatio() ⇒ <code>number</code>
Returns the pixel ratio.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The pixel ratio.  
<a name="Renderer+getDrawingBufferSize"></a>

### renderer.getDrawingBufferSize(target) ⇒ <code>Vector2</code>
Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Vector2</code> - The drawing buffer size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="Renderer+getSize"></a>

### renderer.getSize(target) ⇒ <code>Vector2</code>
Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Vector2</code> - The renderer's size in logical pixels.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="Renderer+setPixelRatio"></a>

### renderer.setPixelRatio([value])
Sets the given pixel ratio and resizes the canvas if necessary.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [value] | <code>number</code> | <code>1</code> | The pixel ratio. |

<a name="Renderer+setDrawingBufferSize"></a>

### renderer.setDrawingBufferSize(width, height, pixelRatio)
This method allows to define the drawing buffer size by specifying
width, height and pixel ratio all at once. The size of the drawing
buffer is computed with this formula:
```js
size.x = width * pixelRatio;
size.y = height * pixelRatio;
```

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width in logical pixels. |
| height | <code>number</code> | The height in logical pixels. |
| pixelRatio | <code>number</code> | The pixel ratio. |

<a name="Renderer+setSize"></a>

### renderer.setSize(width, height, [updateStyle])
Sets the size of the renderer.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| width | <code>number</code> |  | The width in logical pixels. |
| height | <code>number</code> |  | The height in logical pixels. |
| [updateStyle] | <code>boolean</code> | <code>true</code> | Whether to update the `style` attribute of the canvas or not. |

<a name="Renderer+setOpaqueSort"></a>

### renderer.setOpaqueSort(method)
Defines a manual sort function for the opaque render list.
Pass `null` to use the default sort.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | The sort function. |

<a name="Renderer+setTransparentSort"></a>

### renderer.setTransparentSort(method)
Defines a manual sort function for the transparent render list.
Pass `null` to use the default sort.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | The sort function. |

<a name="Renderer+getScissor"></a>

### renderer.getScissor(target) ⇒ <code>Vector4</code>
Returns the scissor rectangle.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Vector4</code> - The scissor rectangle.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector4</code> | The method writes the result in this target object. |

<a name="Renderer+setScissor"></a>

### renderer.setScissor(x, y, width, height)
Defines the scissor rectangle.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector4</code> | The horizontal coordinate for the lower left corner of the box in logical pixel unit. Instead of passing four arguments, the method also works with a single four-dimensional vector. |
| y | <code>number</code> | The vertical coordinate for the lower left corner of the box in logical pixel unit. |
| width | <code>number</code> | The width of the scissor box in logical pixel unit. |
| height | <code>number</code> | The height of the scissor box in logical pixel unit. |

<a name="Renderer+getScissorTest"></a>

### renderer.getScissorTest() ⇒ <code>boolean</code>
Returns the scissor test value.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - Whether the scissor test should be enabled or not.  
<a name="Renderer+setScissorTest"></a>

### renderer.setScissorTest(boolean)
Defines the scissor test.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| boolean | <code>boolean</code> | Whether the scissor test should be enabled or not. |

<a name="Renderer+getViewport"></a>

### renderer.getViewport(target) ⇒ <code>Vector4</code>
Returns the viewport definition.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Vector4</code> - The viewport definition.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector4</code> | The method writes the result in this target object. |

<a name="Renderer+setViewport"></a>

### renderer.setViewport(x, y, width, height, minDepth, maxDepth)
Defines the viewport.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| x | <code>number</code> \| <code>Vector4</code> |  | The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit. |
| y | <code>number</code> |  | The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit. |
| width | <code>number</code> |  | The width of the viewport in logical pixel unit. |
| height | <code>number</code> |  | The height of the viewport in logical pixel unit. |
| minDepth | <code>number</code> | <code>0</code> | The minimum depth value of the viewport. WebGPU only. |
| maxDepth | <code>number</code> | <code>1</code> | The maximum depth value of the viewport. WebGPU only. |

<a name="Renderer+getClearColor"></a>

### renderer.getClearColor(target) ⇒ <code>Color</code>
Returns the clear color.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Color</code> - The clear color.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Color</code> | The method writes the result in this target object. |

<a name="Renderer+setClearColor"></a>

### renderer.setClearColor(color, [alpha])
Defines the clear color and optionally the clear alpha.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Color</code> |  | The clear color. |
| [alpha] | <code>number</code> | <code>1</code> | The clear alpha. |

<a name="Renderer+getClearAlpha"></a>

### renderer.getClearAlpha() ⇒ <code>number</code>
Returns the clear alpha.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The clear alpha.  
<a name="Renderer+setClearAlpha"></a>

### renderer.setClearAlpha(alpha)
Defines the clear alpha.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| alpha | <code>number</code> | The clear alpha. |

<a name="Renderer+getClearDepth"></a>

### renderer.getClearDepth() ⇒ <code>number</code>
Returns the clear depth.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The clear depth.  
<a name="Renderer+setClearDepth"></a>

### renderer.setClearDepth(depth)
Defines the clear depth.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| depth | <code>number</code> | The clear depth. |

<a name="Renderer+getClearStencil"></a>

### renderer.getClearStencil() ⇒ <code>number</code>
Returns the clear stencil.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The clear stencil.  
<a name="Renderer+setClearStencil"></a>

### renderer.setClearStencil(stencil)
Defines the clear stencil.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| stencil | <code>number</code> | The clear stencil. |

<a name="Renderer+isOccluded"></a>

### renderer.isOccluded(object) ⇒ <code>boolean</code>
This method performs an occlusion query for the given 3D object.
It returns `true` if the given 3D object is fully occluded by other
3D objects in the scene.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - Whether the 3D object is fully occluded or not.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to test. |

<a name="Renderer+clear"></a>

### renderer.clear([color], [depth], [stencil]) ⇒ <code>Promise</code>
Performs a manual clear operation. This method ignores `autoClear` properties.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.
Only returned when the renderer has not been initialized.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>boolean</code> | <code>true</code> | Whether the color buffer should be cleared or not. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the depth buffer should be cleared or not. |
| [stencil] | <code>boolean</code> | <code>true</code> | Whether the stencil buffer should be cleared or not. |

<a name="Renderer+clearColor"></a>

### renderer.clearColor() ⇒ <code>Promise</code>
Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.
Only returned when the renderer has not been initialized.  
<a name="Renderer+clearDepth"></a>

### renderer.clearDepth() ⇒ <code>Promise</code>
Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.
Only returned when the renderer has not been initialized.  
<a name="Renderer+clearStencil"></a>

### renderer.clearStencil() ⇒ <code>Promise</code>
Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.
Only returned when the renderer has not been initialized.  
<a name="Renderer+clearAsync"></a>

### renderer.clearAsync([color], [depth], [stencil]) ⇒ <code>Promise</code>
Async version of [clear](#Renderer+clear).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>boolean</code> | <code>true</code> | Whether the color buffer should be cleared or not. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the depth buffer should be cleared or not. |
| [stencil] | <code>boolean</code> | <code>true</code> | Whether the stencil buffer should be cleared or not. |

<a name="Renderer+clearColorAsync"></a>

### renderer.clearColorAsync() ⇒ <code>Promise</code>
Async version of [clearColor](#Renderer+clearColor).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.  
<a name="Renderer+clearDepthAsync"></a>

### renderer.clearDepthAsync() ⇒ <code>Promise</code>
Async version of [clearDepth](#Renderer+clearDepth).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.  
<a name="Renderer+clearStencilAsync"></a>

### renderer.clearStencilAsync() ⇒ <code>Promise</code>
Async version of [clearStencil](#Renderer+clearStencil).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.  
<a name="Renderer+dispose"></a>

### renderer.dispose()
Frees all internal resources of the renderer. Call this method if the renderer
is no longer in use by your app.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+setRenderTarget"></a>

### renderer.setRenderTarget(renderTarget, [activeCubeFace], [activeMipmapLevel])
Sets the given render target. Calling this method means the renderer does not
target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
Use `null` as the first argument to reset the state.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderTarget | <code>RenderTarget</code> |  | The render target to set. |
| [activeCubeFace] | <code>number</code> | <code>0</code> | The active cube face. |
| [activeMipmapLevel] | <code>number</code> | <code>0</code> | The active mipmap level. |

<a name="Renderer+getRenderTarget"></a>

### renderer.getRenderTarget() ⇒ <code>RenderTarget</code>
Returns the current render target.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>RenderTarget</code> - The render target. Returns `null` if no render target is set.  
<a name="Renderer+setOutputRenderTarget"></a>

### renderer.setOutputRenderTarget(renderTarget)
Sets the output render target for the renderer.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| renderTarget | <code>Object</code> | The render target to set as the output target. |

<a name="Renderer+getOutputRenderTarget"></a>

### renderer.getOutputRenderTarget() ⇒ <code>RenderTarget</code>
Returns the current output target.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>RenderTarget</code> - The current output render target. Returns `null` if no output target is set.  
<a name="Renderer+setRenderObjectFunction"></a>

### renderer.setRenderObjectFunction(renderObjectFunction)
Sets the given render object function. Calling this method overwrites the default implementation
which is [renderObject](#Renderer+renderObject). Defining a custom function can be useful
if you want to modify the way objects are rendered. For example you can define things like "every
object that has material of a certain type should perform a pre-pass with a special overwrite material".
The custom function must always call `renderObject()` in its implementation.

Use `null` as the first argument to reset the state.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| renderObjectFunction | [<code>renderObjectFunction</code>](#renderObjectFunction) | The render object function. |

<a name="Renderer+getRenderObjectFunction"></a>

### renderer.getRenderObjectFunction() ⇒ <code>function</code>
Returns the current render object function.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>function</code> - The current render object function. Returns `null` if no function is set.  
<a name="Renderer+compute"></a>

### renderer.compute(computeNodes) ⇒ <code>Promise</code> \| <code>undefined</code>
Execute a single or an array of compute nodes. This method can only be called
if the renderer has been initialized.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> \| <code>undefined</code> - A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.  

| Param | Type | Description |
| --- | --- | --- |
| computeNodes | <code>Node</code> \| <code>Array.&lt;Node&gt;</code> | The compute node(s). |

<a name="Renderer+computeAsync"></a>

### renderer.computeAsync(computeNodes) ⇒ <code>Promise</code>
Execute a single or an array of compute nodes.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolve when the compute has finished.  

| Param | Type | Description |
| --- | --- | --- |
| computeNodes | <code>Node</code> \| <code>Array.&lt;Node&gt;</code> | The compute node(s). |

<a name="Renderer+hasFeatureAsync"></a>

### renderer.hasFeatureAsync(name) ⇒ <code>Promise.&lt;boolean&gt;</code>
Checks if the given feature is supported by the selected backend.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - A Promise that resolves with a bool that indicates whether the feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The feature's name. |

<a name="Renderer+hasFeature"></a>

### renderer.hasFeature(name) ⇒ <code>boolean</code>
Checks if the given feature is supported by the selected backend. If the
renderer has not been initialized, this method always returns `false`.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - Whether the feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The feature's name. |

<a name="Renderer+hasInitialized"></a>

### renderer.hasInitialized() ⇒ <code>boolean</code>
Returns `true` when the renderer has been initialized.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - Whether the renderer has been initialized or not.  
<a name="Renderer+initTextureAsync"></a>

### renderer.initTextureAsync(texture) ⇒ <code>Promise</code>
Initializes the given textures. Useful for preloading a texture rather than waiting until first render
(which can cause noticeable lags due to decode and GPU upload overhead).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the texture has been initialized.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="Renderer+initTexture"></a>

### renderer.initTexture(texture)
Initializes the given texture. Useful for preloading a texture rather than waiting until first render
(which can cause noticeable lags due to decode and GPU upload overhead).

This method can only be used if the renderer has been initialized.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="Renderer+copyFramebufferToTexture"></a>

### renderer.copyFramebufferToTexture(framebufferTexture, [rectangle])
Copies the current bound framebuffer into the given texture.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| framebufferTexture | <code>FramebufferTexture</code> |  | The texture. |
| [rectangle] | <code>Vector2</code> \| <code>Vector4</code> | <code></code> | A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied. |

<a name="Renderer+copyTextureToTexture"></a>

### renderer.copyTextureToTexture(srcTexture, dstTexture, [srcRegion], [dstPosition], [srcLevel], [dstLevel])
Copies data of the given source texture into a destination texture.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| srcTexture | <code>Texture</code> |  | The source texture. |
| dstTexture | <code>Texture</code> |  | The destination texture. |
| [srcRegion] | <code>Box2</code> \| <code>Box3</code> | <code></code> | A bounding box which describes the source region. Can be two or three-dimensional. |
| [dstPosition] | <code>Vector2</code> \| <code>Vector3</code> | <code></code> | A vector that represents the origin of the destination region. Can be two or three-dimensional. |
| [srcLevel] | <code>number</code> | <code>0</code> | The source mip level to copy from. |
| [dstLevel] | <code>number</code> | <code>0</code> | The destination mip level to copy to. |

<a name="Renderer+readRenderTargetPixelsAsync"></a>

### renderer.readRenderTargetPixelsAsync(renderTarget, x, y, width, height, [textureIndex], [faceIndex]) ⇒ <code>Promise.&lt;TypedArray&gt;</code>
Reads pixel data from the given render target.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;TypedArray&gt;</code> - A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderTarget | <code>RenderTarget</code> |  | The render target to read from. |
| x | <code>number</code> |  | The `x` coordinate of the copy region's origin. |
| y | <code>number</code> |  | The `y` coordinate of the copy region's origin. |
| width | <code>number</code> |  | The width of the copy region. |
| height | <code>number</code> |  | The height of the copy region. |
| [textureIndex] | <code>number</code> | <code>0</code> | The texture index of a MRT render target. |
| [faceIndex] | <code>number</code> | <code>0</code> | The active cube face index. |

<a name="Renderer+_projectObject"></a>

### renderer.\_projectObject(object, camera, groupOrder, renderList, clippingContext)
Analyzes the given 3D object's hierarchy and builds render lists from the
processed hierarchy.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to process (usually a scene). |
| camera | <code>Camera</code> | The camera the object is rendered with. |
| groupOrder | <code>number</code> | The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups. |
| renderList | <code>RenderList</code> | The current render list. |
| clippingContext | <code>ClippingContext</code> | The current clipping context. |

<a name="Renderer+renderObject"></a>

### renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext, [passId])
This method represents the default render object function that manages the render lifecycle
of the object.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object. |
| scene | <code>Scene</code> |  | The scene the 3D object belongs to. |
| camera | <code>Camera</code> |  | The camera the object should be rendered with. |
| geometry | <code>BufferGeometry</code> |  | The object's geometry. |
| material | <code>Material</code> |  | The object's material. |
| group | <code>Object</code> |  | Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`. |
| lightsNode | <code>LightsNode</code> |  | The current lights node. |
| clippingContext | <code>ClippingContext</code> | <code></code> | The clipping context. |
| [passId] | <code>string</code> | <code>null</code> | An optional ID for identifying the pass. |

<a name="Renderer+compile"></a>

### renderer.compile(scene, camera, targetScene) ⇒ <code>function</code>
Alias for `compileAsync()`.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>function</code> - A Promise that resolves when the compile has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or 3D object to precompile. |
| camera | <code>Camera</code> | The camera that is used to render the scene. |
| targetScene | <code>Scene</code> | If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added. |

<a name="Renderer..Options"></a>

### Renderer~Options : <code>Object</code>
Renderer options.

**Kind**: inner typedef of [<code>Renderer</code>](#Renderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [logarithmicDepthBuffer] | <code>boolean</code> | <code>false</code> | Whether logarithmic depth buffer is enabled or not. |
| [alpha] | <code>boolean</code> | <code>true</code> | Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the default framebuffer should have a depth buffer or not. |
| [stencil] | <code>boolean</code> | <code>false</code> | Whether the default framebuffer should have a stencil buffer or not. |
| [antialias] | <code>boolean</code> | <code>false</code> | Whether MSAA as the default anti-aliasing should be enabled or not. |
| [samples] | <code>number</code> | <code>0</code> | When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0 to overwrite the default. |
| [getFallback] | <code>function</code> | <code></code> | This callback function can be used to provide a fallback backend, if the primary backend can't be targeted. |
| [colorBufferType] | <code>number</code> | <code>HalfFloatType</code> | Defines the type of color buffers. The default `HalfFloatType` is recommend for best quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though. |

<a name="ShadowMapConfig"></a>

## ShadowMapConfig : <code>Object</code>
Shadow map configuration

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| enabled | <code>boolean</code> | Whether to globally enable shadows or not. |
| type | <code>number</code> | The shadow map type. |

<a name="XRConfig"></a>

## XRConfig : <code>Object</code>
XR configuration.

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| enabled | <code>boolean</code> | Whether to globally enable XR or not. |

<a name="DebugConfig"></a>

## DebugConfig : <code>Object</code>
Debug configuration.

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| checkShaderErrors | <code>boolean</code> | Whether shader errors should be checked or not. |
| onShaderError | <code>function</code> | A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now. |
| getShaderAsync | <code>function</code> | Allows the get the raw shader code for the given scene, camera and 3D object. |

<a name="renderObjectFunction"></a>

## renderObjectFunction : <code>function</code>
Callback for [setRenderObjectFunction](#Renderer+setRenderObjectFunction).

**Kind**: global typedef  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object. |
| scene | <code>Scene</code> |  | The scene the 3D object belongs to. |
| camera | <code>Camera</code> |  | The camera the object should be rendered with. |
| geometry | <code>BufferGeometry</code> |  | The object's geometry. |
| material | <code>Material</code> |  | The object's material. |
| group | <code>Object</code> |  | Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`. |
| lightsNode | <code>LightsNode</code> |  | The current lights node. |
| clippingContext | <code>ClippingContext</code> |  | The clipping context. |
| [passId] | <code>string</code> | <code>null</code> | An optional ID for identifying the pass. |

## Functions

<dl>
<dt><a href="#saveRendererState">saveRendererState(renderer, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given renderer and stores it into the given state object.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#resetRendererState">resetRendererState(renderer, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given renderer and stores it into the given state object.
Besides, the function also resets the state of the renderer to its default values.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#restoreRendererState">restoreRendererState(renderer, state)</a></dt>
<dd><p>Restores the state of the given renderer from the given state object.</p>
</dd>
<dt><a href="#saveSceneState">saveSceneState(scene, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given scene and stores it into the given state object.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#resetSceneState">resetSceneState(scene, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given scene and stores it into the given state object.
Besides, the function also resets the state of the scene to its default values.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#restoreSceneState">restoreSceneState(scene, state)</a></dt>
<dd><p>Restores the state of the given scene from the given state object.</p>
</dd>
<dt><a href="#saveRendererAndSceneState">saveRendererAndSceneState(renderer, scene, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given renderer and scene and stores it into the given state object.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#resetRendererAndSceneState">resetRendererAndSceneState(renderer, scene, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given renderer and scene and stores it into the given state object.
Besides, the function also resets the state of the renderer and scene to its default values.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#restoreRendererAndSceneState">restoreRendererAndSceneState(renderer, scene, state)</a></dt>
<dd><p>Restores the state of the given renderer and scene from the given state object.</p>
</dd>
</dl>

<a name="saveRendererState"></a>

## saveRendererState(renderer, [state]) ⇒ <code>Object</code>
Saves the state of the given renderer and stores it into the given state object.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>Renderer</code> |  | The renderer. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="resetRendererState"></a>

## resetRendererState(renderer, [state]) ⇒ <code>Object</code>
Saves the state of the given renderer and stores it into the given state object.
Besides, the function also resets the state of the renderer to its default values.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>Renderer</code> |  | The renderer. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="restoreRendererState"></a>

## restoreRendererState(renderer, state)
Restores the state of the given renderer from the given state object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |
| state | <code>Object</code> | The state to restore. |

<a name="saveSceneState"></a>

## saveSceneState(scene, [state]) ⇒ <code>Object</code>
Saves the state of the given scene and stores it into the given state object.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="resetSceneState"></a>

## resetSceneState(scene, [state]) ⇒ <code>Object</code>
Saves the state of the given scene and stores it into the given state object.
Besides, the function also resets the state of the scene to its default values.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="restoreSceneState"></a>

## restoreSceneState(scene, state)
Restores the state of the given scene from the given state object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene. |
| state | <code>Object</code> | The state to restore. |

<a name="saveRendererAndSceneState"></a>

## saveRendererAndSceneState(renderer, scene, [state]) ⇒ <code>Object</code>
Saves the state of the given renderer and scene and stores it into the given state object.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>Renderer</code> |  | The renderer. |
| scene | <code>Scene</code> |  | The scene. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="resetRendererAndSceneState"></a>

## resetRendererAndSceneState(renderer, scene, [state]) ⇒ <code>Object</code>
Saves the state of the given renderer and scene and stores it into the given state object.
Besides, the function also resets the state of the renderer and scene to its default values.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>Renderer</code> |  | The renderer. |
| scene | <code>Scene</code> |  | The scene. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="restoreRendererAndSceneState"></a>

## restoreRendererAndSceneState(renderer, scene, state)
Restores the state of the given renderer and scene from the given state object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |
| scene | <code>Scene</code> | The scene. |
| state | <code>Object</code> | The state to restore. |

<a name="StorageBufferAttribute"></a>

## StorageBufferAttribute ⇐ <code>BufferAttribute</code>
This special type of buffer attribute is intended for compute shaders.
In earlier three.js versions it was only possible to update attribute data
on the CPU via JavaScript and then upload the data to the GPU. With the
new material system and renderer it is now possible to use compute shaders
to compute the data for an attribute more efficiently on the GPU.

The idea is to create an instance of this class and provide it as an input
to [StorageBufferNode](StorageBufferNode).

Note: This type of buffer attribute can only be used with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>BufferAttribute</code>  

* [StorageBufferAttribute](#StorageBufferAttribute) ⇐ <code>BufferAttribute</code>
    * [new StorageBufferAttribute(count, itemSize, [typeClass])](#new_StorageBufferAttribute_new)
    * [.isStorageBufferAttribute](#StorageBufferAttribute+isStorageBufferAttribute) : <code>boolean</code>

<a name="new_StorageBufferAttribute_new"></a>

### new StorageBufferAttribute(count, itemSize, [typeClass])
Constructs a new storage buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> \| <code>TypedArray</code> |  | The item count. It is also valid to pass a typed array as an argument. The subsequent parameters are then obsolete. |
| itemSize | <code>number</code> |  | The item size. |
| [typeClass] | <code>TypedArray.constructor</code> | <code>Float32Array</code> | A typed array constructor. |

<a name="StorageBufferAttribute+isStorageBufferAttribute"></a>

### storageBufferAttribute.isStorageBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageBufferAttribute</code>](#StorageBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageInstancedBufferAttribute"></a>

## StorageInstancedBufferAttribute ⇐ <code>InstancedBufferAttribute</code>
This special type of instanced buffer attribute is intended for compute shaders.
In earlier three.js versions it was only possible to update attribute data
on the CPU via JavaScript and then upload the data to the GPU. With the
new material system and renderer it is now possible to use compute shaders
to compute the data for an attribute more efficiently on the GPU.

The idea is to create an instance of this class and provide it as an input
to [StorageBufferNode](StorageBufferNode).

Note: This type of buffer attribute can only be used with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>InstancedBufferAttribute</code>  

* [StorageInstancedBufferAttribute](#StorageInstancedBufferAttribute) ⇐ <code>InstancedBufferAttribute</code>
    * [new StorageInstancedBufferAttribute(count, itemSize, [typeClass])](#new_StorageInstancedBufferAttribute_new)
    * [.isStorageInstancedBufferAttribute](#StorageInstancedBufferAttribute+isStorageInstancedBufferAttribute) : <code>boolean</code>

<a name="new_StorageInstancedBufferAttribute_new"></a>

### new StorageInstancedBufferAttribute(count, itemSize, [typeClass])
Constructs a new storage instanced buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> \| <code>TypedArray</code> |  | The item count. It is also valid to pass a typed array as an argument. The subsequent parameters are then obsolete. |
| itemSize | <code>number</code> |  | The item size. |
| [typeClass] | <code>TypedArray.constructor</code> | <code>Float32Array</code> | A typed array constructor. |

<a name="StorageInstancedBufferAttribute+isStorageInstancedBufferAttribute"></a>

### storageInstancedBufferAttribute.isStorageInstancedBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageInstancedBufferAttribute</code>](#StorageInstancedBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageTexture"></a>

## StorageTexture ⇐ <code>Texture</code>
This special type of texture is intended for compute shaders.
It can be used to compute the data of a texture with a compute shader.

Note: This type of texture can only be used with `WebGPURenderer`
and a WebGPU backend.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [StorageTexture](#StorageTexture) ⇐ <code>Texture</code>
    * [new StorageTexture([width], [height])](#new_StorageTexture_new)
    * [.image](#StorageTexture+image) : <code>Object</code>
    * [.magFilter](#StorageTexture+magFilter) : <code>number</code>
    * [.minFilter](#StorageTexture+minFilter) : <code>number</code>
    * [.isStorageTexture](#StorageTexture+isStorageTexture) : <code>boolean</code>

<a name="new_StorageTexture_new"></a>

### new StorageTexture([width], [height])
Constructs a new storage texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The storage texture's width. |
| [height] | <code>number</code> | <code>1</code> | The storage texture's height. |

<a name="StorageTexture+image"></a>

### storageTexture.image : <code>Object</code>
The image object which just represents the texture's dimension.

**Kind**: instance property of [<code>StorageTexture</code>](#StorageTexture)  
<a name="StorageTexture+magFilter"></a>

### storageTexture.magFilter : <code>number</code>
The default `magFilter` for storage textures is `THREE.LinearFilter`.

**Kind**: instance property of [<code>StorageTexture</code>](#StorageTexture)  
<a name="StorageTexture+minFilter"></a>

### storageTexture.minFilter : <code>number</code>
The default `minFilter` for storage textures is `THREE.LinearFilter`.

**Kind**: instance property of [<code>StorageTexture</code>](#StorageTexture)  
<a name="StorageTexture+isStorageTexture"></a>

### storageTexture.isStorageTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageTexture</code>](#StorageTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TimestampQueryPool"></a>

## *TimestampQueryPool*
Abstract base class of a timestamp query pool.

**Kind**: global abstract class  

* *[TimestampQueryPool](#TimestampQueryPool)*
    * *[new TimestampQueryPool([maxQueries])](#new_TimestampQueryPool_new)*
    * *[.trackTimestamp](#TimestampQueryPool+trackTimestamp) : <code>boolean</code>*
    * *[.maxQueries](#TimestampQueryPool+maxQueries) : <code>number</code>*
    * *[.currentQueryIndex](#TimestampQueryPool+currentQueryIndex) : <code>number</code>*
    * *[.queryOffsets](#TimestampQueryPool+queryOffsets) : <code>Map.&lt;string, number&gt;</code>*
    * *[.isDisposed](#TimestampQueryPool+isDisposed) : <code>boolean</code>*
    * *[.lastValue](#TimestampQueryPool+lastValue) : <code>number</code>*
    * *[.pendingResolve](#TimestampQueryPool+pendingResolve) : <code>boolean</code>*
    * **[.allocateQueriesForContext(renderContext)](#TimestampQueryPool+allocateQueriesForContext)**
    * **[.resolveQueriesAsync()](#TimestampQueryPool+resolveQueriesAsync) ⇒ <code>Promise.&lt;number&gt;</code> \| <code>number</code>**
    * **[.dispose()](#TimestampQueryPool+dispose)**

<a name="new_TimestampQueryPool_new"></a>

### *new TimestampQueryPool([maxQueries])*
Creates a new timestamp query pool.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [maxQueries] | <code>number</code> | <code>256</code> | Maximum number of queries this pool can hold. |

<a name="TimestampQueryPool+trackTimestamp"></a>

### *timestampQueryPool.trackTimestamp : <code>boolean</code>*
Whether to track timestamps or not.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>true</code>  
<a name="TimestampQueryPool+maxQueries"></a>

### *timestampQueryPool.maxQueries : <code>number</code>*
Maximum number of queries this pool can hold.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>256</code>  
<a name="TimestampQueryPool+currentQueryIndex"></a>

### *timestampQueryPool.currentQueryIndex : <code>number</code>*
How many queries allocated so far.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>0</code>  
<a name="TimestampQueryPool+queryOffsets"></a>

### *timestampQueryPool.queryOffsets : <code>Map.&lt;string, number&gt;</code>*
Tracks offsets for different contexts.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
<a name="TimestampQueryPool+isDisposed"></a>

### *timestampQueryPool.isDisposed : <code>boolean</code>*
Whether the pool has been disposed or not.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>false</code>  
<a name="TimestampQueryPool+lastValue"></a>

### *timestampQueryPool.lastValue : <code>number</code>*
TODO

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>0</code>  
<a name="TimestampQueryPool+pendingResolve"></a>

### *timestampQueryPool.pendingResolve : <code>boolean</code>*
TODO

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>false</code>  
<a name="TimestampQueryPool+allocateQueriesForContext"></a>

### **timestampQueryPool.allocateQueriesForContext(renderContext)**
Allocate queries for a specific renderContext.

**Kind**: instance abstract method of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to allocate queries for. |

<a name="TimestampQueryPool+resolveQueriesAsync"></a>

### **timestampQueryPool.resolveQueriesAsync() ⇒ <code>Promise.&lt;number&gt;</code> \| <code>number</code>**
Resolve all timestamps and return data (or process them).

**Kind**: instance abstract method of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Returns**: <code>Promise.&lt;number&gt;</code> \| <code>number</code> - The resolved timestamp value.  
<a name="TimestampQueryPool+dispose"></a>

### **timestampQueryPool.dispose()**
Dispose of the query pool.

**Kind**: instance abstract method of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
## Classes

<dl>
<dt><a href="#XRManager">XRManager</a> ⇐ <code>EventDispatcher</code></dt>
<dd><p>The XR manager is built on top of the WebXR Device API to
manage XR sessions with <code>WebGPURenderer</code>.</p>
<p>XR is currently only supported with a WebGL 2 backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#setProjectionFromUnion">setProjectionFromUnion(camera, cameraL, cameraR)</a></dt>
<dd><p>Assumes 2 cameras that are parallel and share an X-axis, and that
the cameras&#39; projection and world matrices have already been set.
And that near and far planes are identical for both cameras.
Visualization of this technique: <a href="https://computergraphics.stackexchange.com/a/4765">https://computergraphics.stackexchange.com/a/4765</a></p>
</dd>
<dt><a href="#updateCamera">updateCamera(camera, parent)</a></dt>
<dd><p>Updates the world matrices for the given camera based on the parent 3D object.</p>
</dd>
<dt><a href="#updateUserCamera">updateUserCamera(camera, cameraXR, parent)</a></dt>
<dd><p>Updates the given camera with the transformation of the XR camera and parent object.</p>
</dd>
</dl>

<a name="XRManager"></a>

## XRManager ⇐ <code>EventDispatcher</code>
The XR manager is built on top of the WebXR Device API to
manage XR sessions with `WebGPURenderer`.

XR is currently only supported with a WebGL 2 backend.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [XRManager](#XRManager) ⇐ <code>EventDispatcher</code>
    * [new XRManager(renderer)](#new_XRManager_new)
    * [.enabled](#XRManager+enabled) : <code>boolean</code>
    * [.isPresenting](#XRManager+isPresenting) : <code>boolean</code>
    * [.cameraAutoUpdate](#XRManager+cameraAutoUpdate) : <code>boolean</code>
    * [._supportsLayers](#XRManager+_supportsLayers) : <code>boolean</code>
    * [.getController(index)](#XRManager+getController) ⇒ <code>Group</code>
    * [.getControllerGrip(index)](#XRManager+getControllerGrip) ⇒ <code>Group</code>
    * [.getHand(index)](#XRManager+getHand) ⇒ <code>Group</code>
    * [.getFoveation()](#XRManager+getFoveation) ⇒ <code>number</code> \| <code>undefined</code>
    * [.setFoveation(foveation)](#XRManager+setFoveation)
    * [.getFramebufferScaleFactor()](#XRManager+getFramebufferScaleFactor) ⇒ <code>number</code>
    * [.setFramebufferScaleFactor(factor)](#XRManager+setFramebufferScaleFactor)
    * [.getReferenceSpaceType()](#XRManager+getReferenceSpaceType) ⇒ <code>XRReferenceSpaceType</code>
    * [.setReferenceSpaceType(type)](#XRManager+setReferenceSpaceType)
    * [.getReferenceSpace()](#XRManager+getReferenceSpace) ⇒ <code>XRReferenceSpace</code>
    * [.setReferenceSpace(space)](#XRManager+setReferenceSpace)
    * [.getCamera()](#XRManager+getCamera) ⇒ <code>ArrayCamera</code>
    * [.getEnvironmentBlendMode()](#XRManager+getEnvironmentBlendMode) ⇒ <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code>
    * [.getFrame()](#XRManager+getFrame) ⇒ <code>XRFrame</code>
    * [.getSession()](#XRManager+getSession) ⇒ <code>XRSession</code>
    * [.setSession(session)](#XRManager+setSession) ⇒ <code>Promise</code>
    * [.updateCamera(camera)](#XRManager+updateCamera)

<a name="new_XRManager_new"></a>

### new XRManager(renderer)
Constructs a new XR manager.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |

<a name="XRManager+enabled"></a>

### xrManager.enabled : <code>boolean</code>
This flag globally enables XR rendering.

**Kind**: instance property of [<code>XRManager</code>](#XRManager)  
**Default**: <code>false</code>  
<a name="XRManager+isPresenting"></a>

### xrManager.isPresenting : <code>boolean</code>
Whether the XR device is currently presenting or not.

**Kind**: instance property of [<code>XRManager</code>](#XRManager)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="XRManager+cameraAutoUpdate"></a>

### xrManager.cameraAutoUpdate : <code>boolean</code>
Whether the XR camera should automatically be updated or not.

**Kind**: instance property of [<code>XRManager</code>](#XRManager)  
**Default**: <code>true</code>  
<a name="XRManager+_supportsLayers"></a>

### xrManager.\_supportsLayers : <code>boolean</code>
Whether the device has support for all layer types.

**Kind**: instance property of [<code>XRManager</code>](#XRManager)  
**Default**: <code>false</code>  
<a name="XRManager+getController"></a>

### xrManager.getController(index) ⇒ <code>Group</code>
Returns an instance of `THREE.Group` that represents the transformation
of a XR controller in target ray space. The requested controller is defined
by the given index.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>Group</code> - A group that represents the controller's transformation.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the XR controller. |

<a name="XRManager+getControllerGrip"></a>

### xrManager.getControllerGrip(index) ⇒ <code>Group</code>
Returns an instance of `THREE.Group` that represents the transformation
of a XR controller in grip space. The requested controller is defined
by the given index.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>Group</code> - A group that represents the controller's transformation.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the XR controller. |

<a name="XRManager+getHand"></a>

### xrManager.getHand(index) ⇒ <code>Group</code>
Returns an instance of `THREE.Group` that represents the transformation
of a XR controller in hand space. The requested controller is defined
by the given index.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>Group</code> - A group that represents the controller's transformation.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the XR controller. |

<a name="XRManager+getFoveation"></a>

### xrManager.getFoveation() ⇒ <code>number</code> \| <code>undefined</code>
Returns the foveation value.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>number</code> \| <code>undefined</code> - The foveation value. Returns `undefined` if no base or projection layer is defined.  
<a name="XRManager+setFoveation"></a>

### xrManager.setFoveation(foveation)
Sets the foveation value.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| foveation | <code>number</code> | A number in the range `[0,1]` where `0` means no foveation (full resolution) and `1` means maximum foveation (the edges render at lower resolution). |

<a name="XRManager+getFramebufferScaleFactor"></a>

### xrManager.getFramebufferScaleFactor() ⇒ <code>number</code>
Returns the framebuffer scale factor.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>number</code> - The framebuffer scale factor.  
<a name="XRManager+setFramebufferScaleFactor"></a>

### xrManager.setFramebufferScaleFactor(factor)
Sets the framebuffer scale factor.

This method can not be used during a XR session.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| factor | <code>number</code> | The framebuffer scale factor. |

<a name="XRManager+getReferenceSpaceType"></a>

### xrManager.getReferenceSpaceType() ⇒ <code>XRReferenceSpaceType</code>
Returns the reference space type.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>XRReferenceSpaceType</code> - The reference space type.  
<a name="XRManager+setReferenceSpaceType"></a>

### xrManager.setReferenceSpaceType(type)
Sets the reference space type.

This method can not be used during a XR session.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>XRReferenceSpaceType</code> | The reference space type. |

<a name="XRManager+getReferenceSpace"></a>

### xrManager.getReferenceSpace() ⇒ <code>XRReferenceSpace</code>
Returns the XR reference space.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>XRReferenceSpace</code> - The XR reference space.  
<a name="XRManager+setReferenceSpace"></a>

### xrManager.setReferenceSpace(space)
Sets a custom XR reference space.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| space | <code>XRReferenceSpace</code> | The XR reference space. |

<a name="XRManager+getCamera"></a>

### xrManager.getCamera() ⇒ <code>ArrayCamera</code>
Returns the XR camera.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>ArrayCamera</code> - The XR camera.  
<a name="XRManager+getEnvironmentBlendMode"></a>

### xrManager.getEnvironmentBlendMode() ⇒ <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code>
Returns the environment blend mode from the current XR session.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code> - The environment blend mode. Returns `undefined` when used outside of a XR session.  
<a name="XRManager+getFrame"></a>

### xrManager.getFrame() ⇒ <code>XRFrame</code>
Returns the current XR frame.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>XRFrame</code> - The XR frame. Returns `null` when used outside a XR session.  
<a name="XRManager+getSession"></a>

### xrManager.getSession() ⇒ <code>XRSession</code>
Returns the current XR session.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>XRSession</code> - The XR session. Returns `null` when used outside a XR session.  
<a name="XRManager+setSession"></a>

### xrManager.setSession(session) ⇒ <code>Promise</code>
After a XR session has been requested usually with one of the `*Button` modules, it
is injected into the renderer with this method. This method triggers the start of
the actual XR rendering.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>Promise</code> - A Promise that resolves when the session has been set.  

| Param | Type | Description |
| --- | --- | --- |
| session | <code>XRSession</code> | The XR session to set. |

<a name="XRManager+updateCamera"></a>

### xrManager.updateCamera(camera)
This method is called by the renderer per frame and updates the XR camera
and it sub cameras based on the given camera. The given camera is the "user"
camera created on application level and used for non-XR rendering.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>PerspectiveCamera</code> | The camera. |

<a name="setProjectionFromUnion"></a>

## setProjectionFromUnion(camera, cameraL, cameraR)
Assumes 2 cameras that are parallel and share an X-axis, and that
the cameras' projection and world matrices have already been set.
And that near and far planes are identical for both cameras.
Visualization of this technique: https://computergraphics.stackexchange.com/a/4765

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>ArrayCamera</code> | The camera to update. |
| cameraL | <code>PerspectiveCamera</code> | The left camera. |
| cameraR | <code>PerspectiveCamera</code> | The right camera. |

<a name="updateCamera"></a>

## updateCamera(camera, parent)
Updates the world matrices for the given camera based on the parent 3D object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera to update. |
| parent | <code>Object3D</code> | The parent 3D object. |

<a name="updateUserCamera"></a>

## updateUserCamera(camera, cameraXR, parent)
Updates the given camera with the transformation of the XR camera and parent object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera to update. |
| cameraXR | <code>ArrayCamera</code> | The XR camera. |
| parent | <code>Object3D</code> | The parent 3D object. |

<a name="GLSLNodeBuilder"></a>

## GLSLNodeBuilder ⇐ <code>NodeBuilder</code>
A node builder targeting GLSL.

This module generates GLSL shader code from node materials and also
generates the respective bindings and vertex buffer definitions. These
data are later used by the renderer to create render and compute pipelines
for render objects.

**Kind**: global class  
**Extends**: <code>NodeBuilder</code>  

* [GLSLNodeBuilder](#GLSLNodeBuilder) ⇐ <code>NodeBuilder</code>
    * [new GLSLNodeBuilder(object, renderer)](#new_GLSLNodeBuilder_new)
    * [.uniformGroups](#GLSLNodeBuilder+uniformGroups) : <code>Object.&lt;string, Object.&lt;string, NodeUniformsGroup&gt;&gt;</code>
    * [.transforms](#GLSLNodeBuilder+transforms) : <code>Array.&lt;Object.&lt;string, (AttributeNode\|string)&gt;&gt;</code>
    * [.extensions](#GLSLNodeBuilder+extensions) : <code>Object.&lt;string, Map.&lt;string, Object&gt;&gt;</code>
    * [.builtins](#GLSLNodeBuilder+builtins) : <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code>
    * [.needsToWorkingColorSpace(texture)](#GLSLNodeBuilder+needsToWorkingColorSpace) ⇒ <code>boolean</code>
    * [.getMethod(method)](#GLSLNodeBuilder+getMethod) ⇒ <code>string</code>
    * [.getOutputStructName()](#GLSLNodeBuilder+getOutputStructName) ⇒ <code>string</code>
    * [.buildFunctionCode(shaderNode)](#GLSLNodeBuilder+buildFunctionCode) ⇒ <code>string</code>
    * [.setupPBO(storageBufferNode)](#GLSLNodeBuilder+setupPBO)
    * [.getPropertyName(node, [shaderStage])](#GLSLNodeBuilder+getPropertyName) ⇒ <code>string</code>
    * [.generatePBO(storageArrayElementNode)](#GLSLNodeBuilder+generatePBO) ⇒ <code>string</code>
    * [.generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, [levelSnippet])](#GLSLNodeBuilder+generateTextureLoad) ⇒ <code>string</code>
    * [.generateTexture(texture, textureProperty, uvSnippet, depthSnippet)](#GLSLNodeBuilder+generateTexture) ⇒ <code>string</code>
    * [.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet)](#GLSLNodeBuilder+generateTextureLevel) ⇒ <code>string</code>
    * [.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet)](#GLSLNodeBuilder+generateTextureBias) ⇒ <code>string</code>
    * [.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet)](#GLSLNodeBuilder+generateTextureGrad) ⇒ <code>string</code>
    * [.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, [shaderStage])](#GLSLNodeBuilder+generateTextureCompare) ⇒ <code>string</code>
    * [.getVars(shaderStage)](#GLSLNodeBuilder+getVars) ⇒ <code>string</code>
    * [.getUniforms(shaderStage)](#GLSLNodeBuilder+getUniforms) ⇒ <code>string</code>
    * [.getTypeFromAttribute(attribute)](#GLSLNodeBuilder+getTypeFromAttribute) ⇒ <code>string</code>
    * [.getAttributes(shaderStage)](#GLSLNodeBuilder+getAttributes) ⇒ <code>string</code>
    * [.getStructMembers(struct)](#GLSLNodeBuilder+getStructMembers) ⇒ <code>string</code>
    * [.getStructs(shaderStage)](#GLSLNodeBuilder+getStructs) ⇒ <code>string</code>
    * [.getVaryings(shaderStage)](#GLSLNodeBuilder+getVaryings) ⇒ <code>string</code>
    * [.getVertexIndex()](#GLSLNodeBuilder+getVertexIndex) ⇒ <code>string</code>
    * [.getInstanceIndex()](#GLSLNodeBuilder+getInstanceIndex) ⇒ <code>string</code>
    * [.getInvocationLocalIndex()](#GLSLNodeBuilder+getInvocationLocalIndex) ⇒ <code>string</code>
    * [.getDrawIndex()](#GLSLNodeBuilder+getDrawIndex) ⇒ <code>string</code>
    * [.getFrontFacing()](#GLSLNodeBuilder+getFrontFacing) ⇒ <code>string</code>
    * [.getFragCoord()](#GLSLNodeBuilder+getFragCoord) ⇒ <code>string</code>
    * [.getFragDepth()](#GLSLNodeBuilder+getFragDepth) ⇒ <code>string</code>
    * [.enableExtension(name, behavior, [shaderStage])](#GLSLNodeBuilder+enableExtension)
    * [.getExtensions(shaderStage)](#GLSLNodeBuilder+getExtensions) ⇒ <code>string</code>
    * [.getClipDistance()](#GLSLNodeBuilder+getClipDistance) ⇒ <code>string</code>
    * [.isAvailable(name)](#GLSLNodeBuilder+isAvailable) ⇒ <code>boolean</code>
    * [.isFlipY()](#GLSLNodeBuilder+isFlipY) ⇒ <code>boolean</code>
    * [.enableHardwareClipping(planeCount)](#GLSLNodeBuilder+enableHardwareClipping)
    * [.registerTransform(varyingName, attributeNode)](#GLSLNodeBuilder+registerTransform)
    * [.getTransforms(shaderStage)](#GLSLNodeBuilder+getTransforms) ⇒ <code>string</code>
    * [.buildCode()](#GLSLNodeBuilder+buildCode)
    * [.getUniformFromNode(node, type, shaderStage, [name])](#GLSLNodeBuilder+getUniformFromNode) ⇒ <code>NodeUniform</code>

<a name="new_GLSLNodeBuilder_new"></a>

### new GLSLNodeBuilder(object, renderer)
Constructs a new GLSL node builder renderer.


| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object. |
| renderer | <code>Renderer</code> | The renderer. |

<a name="GLSLNodeBuilder+uniformGroups"></a>

### glslNodeBuilder.uniformGroups : <code>Object.&lt;string, Object.&lt;string, NodeUniformsGroup&gt;&gt;</code>
A dictionary holds for each shader stage ('vertex', 'fragment', 'compute')
another dictionary which manages UBOs per group ('render','frame','object').

**Kind**: instance property of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+transforms"></a>

### glslNodeBuilder.transforms : <code>Array.&lt;Object.&lt;string, (AttributeNode\|string)&gt;&gt;</code>
An array that holds objects defining the varying and attribute data in
context of Transform Feedback.

**Kind**: instance property of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+extensions"></a>

### glslNodeBuilder.extensions : <code>Object.&lt;string, Map.&lt;string, Object&gt;&gt;</code>
A dictionary that holds for each shader stage a Map of used extensions.

**Kind**: instance property of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+builtins"></a>

### glslNodeBuilder.builtins : <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code>
A dictionary that holds for each shader stage an Array of used builtins.

**Kind**: instance property of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+needsToWorkingColorSpace"></a>

### glslNodeBuilder.needsToWorkingColorSpace(texture) ⇒ <code>boolean</code>
Checks if the given texture requires a manual conversion to the working color space.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture requires a conversion to working color space or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to check. |

<a name="GLSLNodeBuilder+getMethod"></a>

### glslNodeBuilder.getMethod(method) ⇒ <code>string</code>
Returns the native shader method name for a given generic name.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The resolved GLSL method name.  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The method name to resolve. |

<a name="GLSLNodeBuilder+getOutputStructName"></a>

### glslNodeBuilder.getOutputStructName() ⇒ <code>string</code>
Returns the output struct name. Not relevant for GLSL.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+buildFunctionCode"></a>

### glslNodeBuilder.buildFunctionCode(shaderNode) ⇒ <code>string</code>
Builds the given shader node.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL function code.  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | The shader node. |

<a name="GLSLNodeBuilder+setupPBO"></a>

### glslNodeBuilder.setupPBO(storageBufferNode)
Setups the Pixel Buffer Object (PBO) for the given storage
buffer node.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| storageBufferNode | <code>StorageBufferNode</code> | The storage buffer node. |

<a name="GLSLNodeBuilder+getPropertyName"></a>

### glslNodeBuilder.getPropertyName(node, [shaderStage]) ⇒ <code>string</code>
Returns a GLSL snippet that represents the property name of the given node.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="GLSLNodeBuilder+generatePBO"></a>

### glslNodeBuilder.generatePBO(storageArrayElementNode) ⇒ <code>string</code>
Setups the Pixel Buffer Object (PBO) for the given storage
buffer node.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Description |
| --- | --- | --- |
| storageArrayElementNode | <code>StorageArrayElementNode</code> | The storage array element node. |

<a name="GLSLNodeBuilder+generateTextureLoad"></a>

### glslNodeBuilder.generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, [levelSnippet]) ⇒ <code>string</code>
Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvIndexSnippet | <code>string</code> |  | A GLSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> |  | A GLSL snippet that represents the 0-based texture array index to sample. |
| [levelSnippet] | <code>string</code> | <code>&quot;&#x27;0u&#x27;&quot;</code> | A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="GLSLNodeBuilder+generateTexture"></a>

### glslNodeBuilder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet) ⇒ <code>string</code>
Generates the GLSL snippet for sampling/loading the given texture.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> | A GLSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> | A GLSL snippet that represents the 0-based texture array index to sample. |

<a name="GLSLNodeBuilder+generateTextureLevel"></a>

### glslNodeBuilder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) ⇒ <code>string</code>
Generates the GLSL snippet when sampling textures with explicit mip level.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> | A GLSL snippet that represents texture coordinates used for sampling. |
| levelSnippet | <code>string</code> | A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="GLSLNodeBuilder+generateTextureBias"></a>

### glslNodeBuilder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) ⇒ <code>string</code>
Generates the GLSL snippet when sampling textures with a bias to the mip level.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> | A GLSL snippet that represents texture coordinates used for sampling. |
| biasSnippet | <code>string</code> | A GLSL snippet that represents the bias to apply to the mip level before sampling. |

<a name="GLSLNodeBuilder+generateTextureGrad"></a>

### glslNodeBuilder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) ⇒ <code>string</code>
Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> | A GLSL snippet that represents texture coordinates used for sampling. |
| gradSnippet | <code>Array.&lt;string&gt;</code> | An array holding both gradient GLSL snippets. |

<a name="GLSLNodeBuilder+generateTextureCompare"></a>

### glslNodeBuilder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
against a reference value.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A GLSL snippet that represents texture coordinates used for sampling. |
| compareSnippet | <code>string</code> |  | A GLSL snippet that represents the reference value. |
| depthSnippet | <code>string</code> |  | A GLSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="GLSLNodeBuilder+getVars"></a>

### glslNodeBuilder.getVars(shaderStage) ⇒ <code>string</code>
Returns the variables of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the variables.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getUniforms"></a>

### glslNodeBuilder.getUniforms(shaderStage) ⇒ <code>string</code>
Returns the uniforms of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the uniforms.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getTypeFromAttribute"></a>

### glslNodeBuilder.getTypeFromAttribute(attribute) ⇒ <code>string</code>
Returns the type for a given buffer attribute.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The type.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute. |

<a name="GLSLNodeBuilder+getAttributes"></a>

### glslNodeBuilder.getAttributes(shaderStage) ⇒ <code>string</code>
Returns the shader attributes of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the shader attributes.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getStructMembers"></a>

### glslNodeBuilder.getStructMembers(struct) ⇒ <code>string</code>
Returns the members of the given struct type node as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the struct members.  

| Param | Type | Description |
| --- | --- | --- |
| struct | <code>StructTypeNode</code> | The struct type node. |

<a name="GLSLNodeBuilder+getStructs"></a>

### glslNodeBuilder.getStructs(shaderStage) ⇒ <code>string</code>
Returns the structs of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the structs.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getVaryings"></a>

### glslNodeBuilder.getVaryings(shaderStage) ⇒ <code>string</code>
Returns the varyings of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the varyings.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getVertexIndex"></a>

### glslNodeBuilder.getVertexIndex() ⇒ <code>string</code>
Returns the vertex index builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The vertex index.  
<a name="GLSLNodeBuilder+getInstanceIndex"></a>

### glslNodeBuilder.getInstanceIndex() ⇒ <code>string</code>
Returns the instance index builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The instance index.  
<a name="GLSLNodeBuilder+getInvocationLocalIndex"></a>

### glslNodeBuilder.getInvocationLocalIndex() ⇒ <code>string</code>
Returns the invocation local index builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The invocation local index.  
<a name="GLSLNodeBuilder+getDrawIndex"></a>

### glslNodeBuilder.getDrawIndex() ⇒ <code>string</code>
Returns the draw index builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.  
<a name="GLSLNodeBuilder+getFrontFacing"></a>

### glslNodeBuilder.getFrontFacing() ⇒ <code>string</code>
Returns the front facing builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The front facing builtin.  
<a name="GLSLNodeBuilder+getFragCoord"></a>

### glslNodeBuilder.getFragCoord() ⇒ <code>string</code>
Returns the frag coord builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The frag coord builtin.  
<a name="GLSLNodeBuilder+getFragDepth"></a>

### glslNodeBuilder.getFragDepth() ⇒ <code>string</code>
Returns the frag depth builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The frag depth builtin.  
<a name="GLSLNodeBuilder+enableExtension"></a>

### glslNodeBuilder.enableExtension(name, behavior, [shaderStage])
Enables the given extension.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The extension name. |
| behavior | <code>string</code> |  | The extension behavior. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage. |

<a name="GLSLNodeBuilder+getExtensions"></a>

### glslNodeBuilder.getExtensions(shaderStage) ⇒ <code>string</code>
Returns the enabled extensions of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the enabled extensions.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getClipDistance"></a>

### glslNodeBuilder.getClipDistance() ⇒ <code>string</code>
Returns the clip distances builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The clip distances builtin.  
<a name="GLSLNodeBuilder+isAvailable"></a>

### glslNodeBuilder.isAvailable(name) ⇒ <code>boolean</code>
Whether the requested feature is available or not.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the requested feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The requested feature. |

<a name="GLSLNodeBuilder+isFlipY"></a>

### glslNodeBuilder.isFlipY() ⇒ <code>boolean</code>
Whether to flip texture data along its vertical axis or not.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>boolean</code> - Returns always `true` in context of GLSL.  
<a name="GLSLNodeBuilder+enableHardwareClipping"></a>

### glslNodeBuilder.enableHardwareClipping(planeCount)
Enables hardware clipping.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| planeCount | <code>string</code> | The clipping plane count. |

<a name="GLSLNodeBuilder+registerTransform"></a>

### glslNodeBuilder.registerTransform(varyingName, attributeNode)
Registers a transform in context of Transform Feedback.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| varyingName | <code>string</code> | The varying name. |
| attributeNode | <code>AttributeNode</code> | The attribute node. |

<a name="GLSLNodeBuilder+getTransforms"></a>

### glslNodeBuilder.getTransforms(shaderStage) ⇒ <code>string</code>
Returns the transforms of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the transforms.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+buildCode"></a>

### glslNodeBuilder.buildCode()
Controls the code build of the shader stages.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+getUniformFromNode"></a>

### glslNodeBuilder.getUniformFromNode(node, type, shaderStage, [name]) ⇒ <code>NodeUniform</code>
This method is one of the more important ones since it's responsible
for generating a matching binding instance for the given uniform node.

These bindings are later used in the renderer to create bind groups
and layouts.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>NodeUniform</code> - The node uniform object.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>UniformNode</code> |  | The uniform node. |
| type | <code>string</code> |  | The node data type. |
| shaderStage | <code>string</code> |  | The shader stage. |
| [name] | <code>string</code> | <code>null</code> | An optional uniform name. |

<a name="WebGLTimestampQueryPool"></a>

## WebGLTimestampQueryPool ⇐ <code>TimestampQueryPool</code>
Manages a pool of WebGL timestamp queries for performance measurement.
Handles creation, execution, and resolution of timer queries using WebGL extensions.

**Kind**: global class  
**Extends**: <code>TimestampQueryPool</code>  

* [WebGLTimestampQueryPool](#WebGLTimestampQueryPool) ⇐ <code>TimestampQueryPool</code>
    * [new WebGLTimestampQueryPool(gl, type, [maxQueries])](#new_WebGLTimestampQueryPool_new)
    * [.allocateQueriesForContext(renderContext)](#WebGLTimestampQueryPool+allocateQueriesForContext) ⇒ <code>number</code>
    * [.beginQuery(renderContext)](#WebGLTimestampQueryPool+beginQuery)
    * [.endQuery(renderContext)](#WebGLTimestampQueryPool+endQuery)
    * [.resolveQueriesAsync()](#WebGLTimestampQueryPool+resolveQueriesAsync) ⇒ <code>Promise.&lt;number&gt;</code>
    * [.resolveQuery(query)](#WebGLTimestampQueryPool+resolveQuery) ⇒ <code>Promise.&lt;number&gt;</code>
    * [.dispose()](#WebGLTimestampQueryPool+dispose)

<a name="new_WebGLTimestampQueryPool_new"></a>

### new WebGLTimestampQueryPool(gl, type, [maxQueries])
Creates a new WebGL timestamp query pool.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| gl | <code>WebGLRenderingContext</code> \| <code>WebGL2RenderingContext</code> |  | The WebGL context. |
| type | <code>string</code> |  | The type identifier for this query pool. |
| [maxQueries] | <code>number</code> | <code>2048</code> | Maximum number of queries this pool can hold. |

<a name="WebGLTimestampQueryPool+allocateQueriesForContext"></a>

### webGLTimestampQueryPool.allocateQueriesForContext(renderContext) ⇒ <code>number</code>
Allocates a pair of queries for a given render context.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  
**Returns**: <code>number</code> - The base offset for the allocated queries, or null if allocation failed.  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to allocate queries for. |

<a name="WebGLTimestampQueryPool+beginQuery"></a>

### webGLTimestampQueryPool.beginQuery(renderContext)
Begins a timestamp query for the specified render context.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to begin timing for. |

<a name="WebGLTimestampQueryPool+endQuery"></a>

### webGLTimestampQueryPool.endQuery(renderContext)
Ends the active timestamp query for the specified render context.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to end timing for. |
| renderContext.id | <code>string</code> | Unique identifier for the render context. |

<a name="WebGLTimestampQueryPool+resolveQueriesAsync"></a>

### webGLTimestampQueryPool.resolveQueriesAsync() ⇒ <code>Promise.&lt;number&gt;</code>
Asynchronously resolves all completed queries and returns the total duration.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  
**Returns**: <code>Promise.&lt;number&gt;</code> - The total duration in milliseconds, or the last valid value if resolution fails.  
<a name="WebGLTimestampQueryPool+resolveQuery"></a>

### webGLTimestampQueryPool.resolveQuery(query) ⇒ <code>Promise.&lt;number&gt;</code>
Resolves a single query, checking for completion and disjoint operation.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  
**Returns**: <code>Promise.&lt;number&gt;</code> - The elapsed time in milliseconds.  

| Param | Type | Description |
| --- | --- | --- |
| query | <code>WebGLQuery</code> | The query object to resolve. |

<a name="WebGLTimestampQueryPool+dispose"></a>

### webGLTimestampQueryPool.dispose()
Releases all resources held by this query pool.
This includes deleting all query objects and clearing internal state.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  
<a name="WebGPURenderer"></a>

## WebGPURenderer ⇐ <code>Renderer</code>
This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability
to target different backends. By default, the renderer tries to use a WebGPU backend if the
browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.

**Kind**: global class  
**Extends**: <code>Renderer</code>  

* [WebGPURenderer](#WebGPURenderer) ⇐ <code>Renderer</code>
    * [new WebGPURenderer([parameters])](#new_WebGPURenderer_new)
    * _instance_
        * [.library](#WebGPURenderer+library) : <code>StandardNodeLibrary</code>
        * [.isWebGPURenderer](#WebGPURenderer+isWebGPURenderer) : <code>boolean</code>
    * _inner_
        * [~Options](#WebGPURenderer..Options) : <code>Object</code>

<a name="new_WebGPURenderer_new"></a>

### new WebGPURenderer([parameters])
Constructs a new WebGPU renderer.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | [<code>Options</code>](#WebGPURenderer..Options) | The configuration parameter. |

<a name="WebGPURenderer+library"></a>

### webGPURenderer.library : <code>StandardNodeLibrary</code>
The generic default value is overwritten with the
standard node library for type mapping.

**Kind**: instance property of [<code>WebGPURenderer</code>](#WebGPURenderer)  
<a name="WebGPURenderer+isWebGPURenderer"></a>

### webGPURenderer.isWebGPURenderer : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGPURenderer</code>](#WebGPURenderer)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGPURenderer..Options"></a>

### WebGPURenderer~Options : <code>Object</code>
WebGPURenderer options.

**Kind**: inner typedef of [<code>WebGPURenderer</code>](#WebGPURenderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [logarithmicDepthBuffer] | <code>boolean</code> | <code>false</code> | Whether logarithmic depth buffer is enabled or not. |
| [alpha] | <code>boolean</code> | <code>true</code> | Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the default framebuffer should have a depth buffer or not. |
| [stencil] | <code>boolean</code> | <code>false</code> | Whether the default framebuffer should have a stencil buffer or not. |
| [antialias] | <code>boolean</code> | <code>false</code> | Whether MSAA as the default anti-aliasing should be enabled or not. |
| [samples] | <code>number</code> | <code>0</code> | When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default. |
| [forceWebGL] | <code>boolean</code> | <code>false</code> | If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not. |
| [outputType] | <code>number</code> |  | Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead. |
| [colorBufferType] | <code>number</code> | <code>HalfFloatType</code> | Defines the type of color buffers. The default `HalfFloatType` is recommend for best quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though. |

<a name="WGSLNodeBuilder"></a>

## WGSLNodeBuilder ⇐ <code>NodeBuilder</code>
A node builder targeting WGSL.

This module generates WGSL shader code from node materials and also
generates the respective bindings and vertex buffer definitions. These
data are later used by the renderer to create render and compute pipelines
for render objects.

**Kind**: global class  
**Extends**: <code>NodeBuilder</code>  

* [WGSLNodeBuilder](#WGSLNodeBuilder) ⇐ <code>NodeBuilder</code>
    * [new WGSLNodeBuilder(object, renderer)](#new_WGSLNodeBuilder_new)
    * [.uniformGroups](#WGSLNodeBuilder+uniformGroups) : <code>Object.&lt;string, Object.&lt;string, NodeUniformsGroup&gt;&gt;</code>
    * [.builtins](#WGSLNodeBuilder+builtins) : <code>Object.&lt;string, Map.&lt;string, Object&gt;&gt;</code>
    * [.directives](#WGSLNodeBuilder+directives) : <code>Object.&lt;string, Set.&lt;string&gt;&gt;</code>
    * [.scopedArrays](#WGSLNodeBuilder+scopedArrays) : <code>Map.&lt;string, Object&gt;</code>
    * [.needsToWorkingColorSpace(texture)](#WGSLNodeBuilder+needsToWorkingColorSpace) ⇒ <code>boolean</code>
    * [.generateWrapFunction(texture)](#WGSLNodeBuilder+generateWrapFunction) ⇒ <code>string</code>
    * [.generateArrayDeclaration(type, [count])](#WGSLNodeBuilder+generateArrayDeclaration) ⇒ <code>string</code>
    * [.generateTextureDimension(texture, textureProperty, levelSnippet)](#WGSLNodeBuilder+generateTextureDimension) ⇒ <code>string</code>
    * [.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet)](#WGSLNodeBuilder+generateFilteredTexture) ⇒ <code>string</code>
    * [.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, [levelSnippet])](#WGSLNodeBuilder+generateTextureLod) ⇒ <code>string</code>
    * [.generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, [levelSnippet])](#WGSLNodeBuilder+generateTextureLoad) ⇒ <code>string</code>
    * [.generateTextureStore(texture, textureProperty, uvIndexSnippet, valueSnippet)](#WGSLNodeBuilder+generateTextureStore) ⇒ <code>string</code>
    * [.isSampleCompare(texture)](#WGSLNodeBuilder+isSampleCompare) ⇒ <code>boolean</code>
    * [.isUnfilterable(texture)](#WGSLNodeBuilder+isUnfilterable) ⇒ <code>boolean</code>
    * [.generateTexture(texture, textureProperty, uvSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTexture) ⇒ <code>string</code>
    * [.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTextureGrad) ⇒ <code>string</code>
    * [.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTextureCompare) ⇒ <code>string</code>
    * [.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTextureLevel) ⇒ <code>string</code>
    * [.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTextureBias) ⇒ <code>string</code>
    * [.getPropertyName(node, [shaderStage])](#WGSLNodeBuilder+getPropertyName) ⇒ <code>string</code>
    * [.getOutputStructName()](#WGSLNodeBuilder+getOutputStructName) ⇒ <code>string</code>
    * [.getFunctionOperator(op)](#WGSLNodeBuilder+getFunctionOperator) ⇒ <code>string</code>
    * [.getNodeAccess(node, shaderStage)](#WGSLNodeBuilder+getNodeAccess) ⇒ <code>string</code>
    * [.getStorageAccess(node, shaderStage)](#WGSLNodeBuilder+getStorageAccess) ⇒ <code>string</code>
    * [.getUniformFromNode(node, type, shaderStage, [name])](#WGSLNodeBuilder+getUniformFromNode) ⇒ <code>NodeUniform</code>
    * [.getBuiltin(name, property, type, [shaderStage])](#WGSLNodeBuilder+getBuiltin) ⇒ <code>string</code>
    * [.hasBuiltin(name, [shaderStage])](#WGSLNodeBuilder+hasBuiltin) ⇒ <code>boolean</code>
    * [.getVertexIndex()](#WGSLNodeBuilder+getVertexIndex) ⇒ <code>string</code>
    * [.buildFunctionCode(shaderNode)](#WGSLNodeBuilder+buildFunctionCode) ⇒ <code>string</code>
    * [.getInstanceIndex()](#WGSLNodeBuilder+getInstanceIndex) ⇒ <code>string</code>
    * [.getInvocationLocalIndex()](#WGSLNodeBuilder+getInvocationLocalIndex) ⇒ <code>string</code>
    * [.getSubgroupSize()](#WGSLNodeBuilder+getSubgroupSize) ⇒ <code>string</code>
    * [.getInvocationSubgroupIndex()](#WGSLNodeBuilder+getInvocationSubgroupIndex) ⇒ <code>string</code>
    * [.getSubgroupIndex()](#WGSLNodeBuilder+getSubgroupIndex) ⇒ <code>string</code>
    * [.getDrawIndex()](#WGSLNodeBuilder+getDrawIndex) ⇒ <code>null</code>
    * [.getFrontFacing()](#WGSLNodeBuilder+getFrontFacing) ⇒ <code>string</code>
    * [.getFragCoord()](#WGSLNodeBuilder+getFragCoord) ⇒ <code>string</code>
    * [.getFragDepth()](#WGSLNodeBuilder+getFragDepth) ⇒ <code>string</code>
    * [.getClipDistance()](#WGSLNodeBuilder+getClipDistance) ⇒ <code>string</code>
    * [.isFlipY()](#WGSLNodeBuilder+isFlipY) ⇒ <code>boolean</code>
    * [.enableDirective(name, [shaderStage])](#WGSLNodeBuilder+enableDirective)
    * [.getDirectives(shaderStage)](#WGSLNodeBuilder+getDirectives) ⇒ <code>string</code>
    * [.enableSubGroups()](#WGSLNodeBuilder+enableSubGroups)
    * [.enableSubgroupsF16()](#WGSLNodeBuilder+enableSubgroupsF16)
    * [.enableClipDistances()](#WGSLNodeBuilder+enableClipDistances)
    * [.enableShaderF16()](#WGSLNodeBuilder+enableShaderF16)
    * [.enableDualSourceBlending()](#WGSLNodeBuilder+enableDualSourceBlending)
    * [.enableHardwareClipping(planeCount)](#WGSLNodeBuilder+enableHardwareClipping)
    * [.getBuiltins(shaderStage)](#WGSLNodeBuilder+getBuiltins) ⇒ <code>string</code>
    * [.getScopedArray(name, scope, bufferType, bufferCount)](#WGSLNodeBuilder+getScopedArray) ⇒ <code>string</code>
    * [.getScopedArrays(shaderStage)](#WGSLNodeBuilder+getScopedArrays) ⇒ <code>string</code> \| <code>undefined</code>
    * [.getAttributes(shaderStage)](#WGSLNodeBuilder+getAttributes) ⇒ <code>string</code>
    * [.getStructMembers(struct)](#WGSLNodeBuilder+getStructMembers) ⇒ <code>string</code>
    * [.getStructs(shaderStage)](#WGSLNodeBuilder+getStructs) ⇒ <code>string</code>
    * [.getVar(type, name, [count])](#WGSLNodeBuilder+getVar) ⇒ <code>string</code>
    * [.getVars(shaderStage)](#WGSLNodeBuilder+getVars) ⇒ <code>string</code>
    * [.getVaryings(shaderStage)](#WGSLNodeBuilder+getVaryings) ⇒ <code>string</code>
    * [.getUniforms(shaderStage)](#WGSLNodeBuilder+getUniforms) ⇒ <code>string</code>
    * [.buildCode()](#WGSLNodeBuilder+buildCode)
    * [.getMethod(method, [output])](#WGSLNodeBuilder+getMethod) ⇒ <code>string</code>
    * [.getType(type)](#WGSLNodeBuilder+getType) ⇒ <code>string</code>
    * [.isAvailable(name)](#WGSLNodeBuilder+isAvailable) ⇒ <code>boolean</code>

<a name="new_WGSLNodeBuilder_new"></a>

### new WGSLNodeBuilder(object, renderer)
Constructs a new WGSL node builder renderer.


| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object. |
| renderer | <code>Renderer</code> | The renderer. |

<a name="WGSLNodeBuilder+uniformGroups"></a>

### wgslNodeBuilder.uniformGroups : <code>Object.&lt;string, Object.&lt;string, NodeUniformsGroup&gt;&gt;</code>
A dictionary that holds for each shader stage ('vertex', 'fragment', 'compute')
another dictionary which manages UBOs per group ('render','frame','object').

**Kind**: instance property of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+builtins"></a>

### wgslNodeBuilder.builtins : <code>Object.&lt;string, Map.&lt;string, Object&gt;&gt;</code>
A dictionary that holds for each shader stage a Map of builtins.

**Kind**: instance property of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+directives"></a>

### wgslNodeBuilder.directives : <code>Object.&lt;string, Set.&lt;string&gt;&gt;</code>
A dictionary that holds for each shader stage a Set of directives.

**Kind**: instance property of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+scopedArrays"></a>

### wgslNodeBuilder.scopedArrays : <code>Map.&lt;string, Object&gt;</code>
A map for managing scope arrays. Only relevant for when using
[WorkgroupInfoNode](WorkgroupInfoNode) in context of compute shaders.

**Kind**: instance property of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+needsToWorkingColorSpace"></a>

### wgslNodeBuilder.needsToWorkingColorSpace(texture) ⇒ <code>boolean</code>
Checks if the given texture requires a manual conversion to the working color space.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture requires a conversion to working color space or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to check. |

<a name="WGSLNodeBuilder+generateWrapFunction"></a>

### wgslNodeBuilder.generateWrapFunction(texture) ⇒ <code>string</code>
Generates a wrap function used in context of textures.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The name of the generated function.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to generate the function for. |

<a name="WGSLNodeBuilder+generateArrayDeclaration"></a>

### wgslNodeBuilder.generateArrayDeclaration(type, [count]) ⇒ <code>string</code>
Generates the array declaration string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |
| [count] | <code>number</code> | The count. |

<a name="WGSLNodeBuilder+generateTextureDimension"></a>

### wgslNodeBuilder.generateTextureDimension(texture, textureProperty, levelSnippet) ⇒ <code>string</code>
Generates a WGSL variable that holds the texture dimension of the given texture.
It also returns information about the number of layers (elements) of an arrayed
texture as well as the cube face count of cube textures.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The name of the dimension variable.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to generate the function for. |
| textureProperty | <code>string</code> | The name of the video texture uniform in the shader. |
| levelSnippet | <code>string</code> | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="WGSLNodeBuilder+generateFilteredTexture"></a>

### wgslNodeBuilder.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet) ⇒ <code>string</code>
Generates the WGSL snippet for a manual filtered texture.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| levelSnippet | <code>string</code> | <code>&quot;0u&quot;</code> | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="WGSLNodeBuilder+generateTextureLod"></a>

### wgslNodeBuilder.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, [levelSnippet]) ⇒ <code>string</code>
Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
Since it's a lookup, no sampling or filtering is applied.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [levelSnippet] | <code>string</code> | <code>&quot;&#x27;0u&#x27;&quot;</code> | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="WGSLNodeBuilder+generateTextureLoad"></a>

### wgslNodeBuilder.generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, [levelSnippet]) ⇒ <code>string</code>
Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvIndexSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [levelSnippet] | <code>string</code> | <code>&quot;&#x27;0u&#x27;&quot;</code> | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="WGSLNodeBuilder+generateTextureStore"></a>

### wgslNodeBuilder.generateTextureStore(texture, textureProperty, uvIndexSnippet, valueSnippet) ⇒ <code>string</code>
Generates the WGSL snippet that writes a single texel to a texture.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvIndexSnippet | <code>string</code> | A WGSL snippet that represents texture coordinates used for sampling. |
| valueSnippet | <code>string</code> | A WGSL snippet that represent the new texel value. |

<a name="WGSLNodeBuilder+isSampleCompare"></a>

### wgslNodeBuilder.isSampleCompare(texture) ⇒ <code>boolean</code>
Returns `true` if the sampled values of the given texture should be compared against a reference value.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the sampled values of the given texture should be compared against a reference value or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="WGSLNodeBuilder+isUnfilterable"></a>

### wgslNodeBuilder.isUnfilterable(texture) ⇒ <code>boolean</code>
Returns `true` if the given texture is unfilterable.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture is unfilterable or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="WGSLNodeBuilder+generateTexture"></a>

### wgslNodeBuilder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet for sampling/loading the given texture.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+generateTextureGrad"></a>

### wgslNodeBuilder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| gradSnippet | <code>Array.&lt;string&gt;</code> |  | An array holding both gradient WGSL snippets. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+generateTextureCompare"></a>

### wgslNodeBuilder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
against a reference value.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| compareSnippet | <code>string</code> |  | A WGSL snippet that represents the reference value. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+generateTextureLevel"></a>

### wgslNodeBuilder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet when sampling textures with explicit mip level.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| levelSnippet | <code>string</code> |  | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+generateTextureBias"></a>

### wgslNodeBuilder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet when sampling textures with a bias to the mip level.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| biasSnippet | <code>string</code> |  | A WGSL snippet that represents the bias to apply to the mip level before sampling. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+getPropertyName"></a>

### wgslNodeBuilder.getPropertyName(node, [shaderStage]) ⇒ <code>string</code>
Returns a WGSL snippet that represents the property name of the given node.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+getOutputStructName"></a>

### wgslNodeBuilder.getOutputStructName() ⇒ <code>string</code>
Returns the output struct name.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The name of the output struct.  
<a name="WGSLNodeBuilder+getFunctionOperator"></a>

### wgslNodeBuilder.getFunctionOperator(op) ⇒ <code>string</code>
Returns the native shader operator name for a given generic name.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The resolved operator name.  

| Param | Type | Description |
| --- | --- | --- |
| op | <code>string</code> | The operator name to resolve. |

<a name="WGSLNodeBuilder+getNodeAccess"></a>

### wgslNodeBuilder.getNodeAccess(node, shaderStage) ⇒ <code>string</code>
Returns the node access for the given node and shader stage.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The node access.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>StorageTextureNode</code> \| <code>StorageBufferNode</code> | The storage node. |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getStorageAccess"></a>

### wgslNodeBuilder.getStorageAccess(node, shaderStage) ⇒ <code>string</code>
Returns A WGSL snippet representing the storage access.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet representing the storage access.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>StorageTextureNode</code> \| <code>StorageBufferNode</code> | The storage node. |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getUniformFromNode"></a>

### wgslNodeBuilder.getUniformFromNode(node, type, shaderStage, [name]) ⇒ <code>NodeUniform</code>
This method is one of the more important ones since it's responsible
for generating a matching binding instance for the given uniform node.

These bindings are later used in the renderer to create bind groups
and layouts.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>NodeUniform</code> - The node uniform object.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>UniformNode</code> |  | The uniform node. |
| type | <code>string</code> |  | The node data type. |
| shaderStage | <code>string</code> |  | The shader stage. |
| [name] | <code>string</code> | <code>null</code> | An optional uniform name. |

<a name="WGSLNodeBuilder+getBuiltin"></a>

### wgslNodeBuilder.getBuiltin(name, property, type, [shaderStage]) ⇒ <code>string</code>
This method should be used whenever builtins are required in nodes.
The internal builtins data structure will make sure builtins are
defined in the WGSL source.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The builtin name. |
| property | <code>string</code> |  | The property name. |
| type | <code>string</code> |  | The node data type. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+hasBuiltin"></a>

### wgslNodeBuilder.hasBuiltin(name, [shaderStage]) ⇒ <code>boolean</code>
Returns `true` if the given builtin is defined in the given shader stage.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given builtin is defined in the given shader stage or not.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The builtin name. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+getVertexIndex"></a>

### wgslNodeBuilder.getVertexIndex() ⇒ <code>string</code>
Returns the vertex index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The vertex index.  
<a name="WGSLNodeBuilder+buildFunctionCode"></a>

### wgslNodeBuilder.buildFunctionCode(shaderNode) ⇒ <code>string</code>
Builds the given shader node.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL function code.  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | The shader node. |

<a name="WGSLNodeBuilder+getInstanceIndex"></a>

### wgslNodeBuilder.getInstanceIndex() ⇒ <code>string</code>
Returns the instance index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The instance index.  
<a name="WGSLNodeBuilder+getInvocationLocalIndex"></a>

### wgslNodeBuilder.getInvocationLocalIndex() ⇒ <code>string</code>
Returns the invocation local index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The invocation local index.  
<a name="WGSLNodeBuilder+getSubgroupSize"></a>

### wgslNodeBuilder.getSubgroupSize() ⇒ <code>string</code>
Returns the subgroup size builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The subgroup size.  
<a name="WGSLNodeBuilder+getInvocationSubgroupIndex"></a>

### wgslNodeBuilder.getInvocationSubgroupIndex() ⇒ <code>string</code>
Returns the invocation subgroup index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The invocation subgroup index.  
<a name="WGSLNodeBuilder+getSubgroupIndex"></a>

### wgslNodeBuilder.getSubgroupIndex() ⇒ <code>string</code>
Returns the subgroup index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The subgroup index.  
<a name="WGSLNodeBuilder+getDrawIndex"></a>

### wgslNodeBuilder.getDrawIndex() ⇒ <code>null</code>
Overwritten as a NOP since this method is intended for the WebGL 2 backend.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>null</code> - Null.  
<a name="WGSLNodeBuilder+getFrontFacing"></a>

### wgslNodeBuilder.getFrontFacing() ⇒ <code>string</code>
Returns the front facing builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The front facing builtin.  
<a name="WGSLNodeBuilder+getFragCoord"></a>

### wgslNodeBuilder.getFragCoord() ⇒ <code>string</code>
Returns the frag coord builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The frag coord builtin.  
<a name="WGSLNodeBuilder+getFragDepth"></a>

### wgslNodeBuilder.getFragDepth() ⇒ <code>string</code>
Returns the frag depth builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The frag depth builtin.  
<a name="WGSLNodeBuilder+getClipDistance"></a>

### wgslNodeBuilder.getClipDistance() ⇒ <code>string</code>
Returns the clip distances builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The clip distances builtin.  
<a name="WGSLNodeBuilder+isFlipY"></a>

### wgslNodeBuilder.isFlipY() ⇒ <code>boolean</code>
Whether to flip texture data along its vertical axis or not.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Returns always `false` in context of WGSL.  
<a name="WGSLNodeBuilder+enableDirective"></a>

### wgslNodeBuilder.enableDirective(name, [shaderStage])
Enables the given directive for the given shader stage.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The directive name. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage to enable the directive for. |

<a name="WGSLNodeBuilder+getDirectives"></a>

### wgslNodeBuilder.getDirectives(shaderStage) ⇒ <code>string</code>
Returns the directives of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - A WGSL snippet that enables the directives of the given stage.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+enableSubGroups"></a>

### wgslNodeBuilder.enableSubGroups()
Enables the 'subgroups' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableSubgroupsF16"></a>

### wgslNodeBuilder.enableSubgroupsF16()
Enables the 'subgroups-f16' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableClipDistances"></a>

### wgslNodeBuilder.enableClipDistances()
Enables the 'clip_distances' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableShaderF16"></a>

### wgslNodeBuilder.enableShaderF16()
Enables the 'f16' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableDualSourceBlending"></a>

### wgslNodeBuilder.enableDualSourceBlending()
Enables the 'dual_source_blending' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableHardwareClipping"></a>

### wgslNodeBuilder.enableHardwareClipping(planeCount)
Enables hardware clipping.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| planeCount | <code>string</code> | The clipping plane count. |

<a name="WGSLNodeBuilder+getBuiltins"></a>

### wgslNodeBuilder.getBuiltins(shaderStage) ⇒ <code>string</code>
Returns the builtins of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - A WGSL snippet that represents the builtins of the given stage.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getScopedArray"></a>

### wgslNodeBuilder.getScopedArray(name, scope, bufferType, bufferCount) ⇒ <code>string</code>
This method should be used when a new scoped buffer is used in context of
compute shaders. It adds the array to the internal data structure which is
later used to generate the respective WGSL.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The array name.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The array name. |
| scope | <code>string</code> | The scope. |
| bufferType | <code>string</code> | The buffer type. |
| bufferCount | <code>string</code> | The buffer count. |

<a name="WGSLNodeBuilder+getScopedArrays"></a>

### wgslNodeBuilder.getScopedArrays(shaderStage) ⇒ <code>string</code> \| <code>undefined</code>
Returns the scoped arrays of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> \| <code>undefined</code> - The WGSL snippet that defines the scoped arrays.
Returns `undefined` when used in the vertex or fragment stage.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getAttributes"></a>

### wgslNodeBuilder.getAttributes(shaderStage) ⇒ <code>string</code>
Returns the shader attributes of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the shader attributes.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getStructMembers"></a>

### wgslNodeBuilder.getStructMembers(struct) ⇒ <code>string</code>
Returns the members of the given struct type node as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the struct members.  

| Param | Type | Description |
| --- | --- | --- |
| struct | <code>StructTypeNode</code> | The struct type node. |

<a name="WGSLNodeBuilder+getStructs"></a>

### wgslNodeBuilder.getStructs(shaderStage) ⇒ <code>string</code>
Returns the structs of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the structs.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getVar"></a>

### wgslNodeBuilder.getVar(type, name, [count]) ⇒ <code>string</code>
Returns a WGSL string representing a variable.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines a variable.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The variable's type. |
| name | <code>string</code> |  | The variable's name. |
| [count] | <code>number</code> | <code></code> | The array length. |

<a name="WGSLNodeBuilder+getVars"></a>

### wgslNodeBuilder.getVars(shaderStage) ⇒ <code>string</code>
Returns the variables of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the variables.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getVaryings"></a>

### wgslNodeBuilder.getVaryings(shaderStage) ⇒ <code>string</code>
Returns the varyings of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the varyings.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getUniforms"></a>

### wgslNodeBuilder.getUniforms(shaderStage) ⇒ <code>string</code>
Returns the uniforms of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the uniforms.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+buildCode"></a>

### wgslNodeBuilder.buildCode()
Controls the code build of the shader stages.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+getMethod"></a>

### wgslNodeBuilder.getMethod(method, [output]) ⇒ <code>string</code>
Returns the native shader method name for a given generic name.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The resolved WGSL method name.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| method | <code>string</code> |  | The method name to resolve. |
| [output] | <code>string</code> | <code>null</code> | An optional output. |

<a name="WGSLNodeBuilder+getType"></a>

### wgslNodeBuilder.getType(type) ⇒ <code>string</code>
Returns the WGSL type of the given node data type.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The node data type. |

<a name="WGSLNodeBuilder+isAvailable"></a>

### wgslNodeBuilder.isAvailable(name) ⇒ <code>boolean</code>
Whether the requested feature is available or not.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the requested feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The requested feature. |

<a name="WGSLNodeFunction"></a>

## WGSLNodeFunction ⇐ <code>NodeFunction</code>
This class represents a WSL node function.

**Kind**: global class  
**Extends**: <code>NodeFunction</code>  

* [WGSLNodeFunction](#WGSLNodeFunction) ⇐ <code>NodeFunction</code>
    * [new WGSLNodeFunction(source)](#new_WGSLNodeFunction_new)
    * [.getCode([name])](#WGSLNodeFunction+getCode) ⇒ <code>string</code>

<a name="new_WGSLNodeFunction_new"></a>

### new WGSLNodeFunction(source)
Constructs a new WGSL node function.


| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The WGSL source. |

<a name="WGSLNodeFunction+getCode"></a>

### wgslNodeFunction.getCode([name]) ⇒ <code>string</code>
This method returns the WGSL code of the node function.

**Kind**: instance method of [<code>WGSLNodeFunction</code>](#WGSLNodeFunction)  
**Returns**: <code>string</code> - The shader code.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;this.name&quot;</code> | The function's name. |

<a name="WGSLNodeParser"></a>

## WGSLNodeParser ⇐ <code>NodeParser</code>
A WGSL node parser.

**Kind**: global class  
**Extends**: <code>NodeParser</code>  
<a name="WGSLNodeParser+parseFunction"></a>

### wgslNodeParser.parseFunction(source) ⇒ <code>WGSLNodeFunction</code>
The method parses the given WGSL code an returns a node function.

**Kind**: instance method of [<code>WGSLNodeParser</code>](#WGSLNodeParser)  
**Returns**: <code>WGSLNodeFunction</code> - A node function.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The WGSL code. |

<a name="getFormat"></a>

## getFormat(texture, [device]) ⇒ <code>string</code>
Returns the GPU format for the given texture.

**Kind**: global function  
**Returns**: <code>string</code> - The GPU format.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| [device] | <code>GPUDevice</code> | <code></code> | The GPU device which is used for feature detection. It is not necessary to apply the device for most formats. |

<a name="WebGPUTimestampQueryPool"></a>

## WebGPUTimestampQueryPool ⇐ <code>TimestampQueryPool</code>
Manages a pool of WebGPU timestamp queries for performance measurement.
Extends the base TimestampQueryPool to provide WebGPU-specific implementation.

**Kind**: global class  
**Extends**: <code>TimestampQueryPool</code>  

* [WebGPUTimestampQueryPool](#WebGPUTimestampQueryPool) ⇐ <code>TimestampQueryPool</code>
    * [new WebGPUTimestampQueryPool(device, type, [maxQueries])](#new_WebGPUTimestampQueryPool_new)
    * [.allocateQueriesForContext(renderContext)](#WebGPUTimestampQueryPool+allocateQueriesForContext) ⇒ <code>number</code>
    * [.resolveQueriesAsync()](#WebGPUTimestampQueryPool+resolveQueriesAsync) ⇒ <code>Promise.&lt;number&gt;</code>
    * [.dispose()](#WebGPUTimestampQueryPool+dispose) ⇒ <code>Promise</code>

<a name="new_WebGPUTimestampQueryPool_new"></a>

### new WebGPUTimestampQueryPool(device, type, [maxQueries])
Creates a new WebGPU timestamp query pool.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| device | <code>GPUDevice</code> |  | The WebGPU device to create queries on. |
| type | <code>string</code> |  | The type identifier for this query pool. |
| [maxQueries] | <code>number</code> | <code>2048</code> | Maximum number of queries this pool can hold. |

<a name="WebGPUTimestampQueryPool+allocateQueriesForContext"></a>

### webGPUTimestampQueryPool.allocateQueriesForContext(renderContext) ⇒ <code>number</code>
Allocates a pair of queries for a given render context.

**Kind**: instance method of [<code>WebGPUTimestampQueryPool</code>](#WebGPUTimestampQueryPool)  
**Returns**: <code>number</code> - The base offset for the allocated queries, or null if allocation failed.  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to allocate queries for. |

<a name="WebGPUTimestampQueryPool+resolveQueriesAsync"></a>

### webGPUTimestampQueryPool.resolveQueriesAsync() ⇒ <code>Promise.&lt;number&gt;</code>
Asynchronously resolves all pending queries and returns the total duration.
If there's already a pending resolve operation, returns that promise instead.

**Kind**: instance method of [<code>WebGPUTimestampQueryPool</code>](#WebGPUTimestampQueryPool)  
**Returns**: <code>Promise.&lt;number&gt;</code> - The total duration in milliseconds, or the last valid value if resolution fails.  
<a name="WebGPUTimestampQueryPool+dispose"></a>

### webGPUTimestampQueryPool.dispose() ⇒ <code>Promise</code>
Dispose of the query pool.

**Kind**: instance method of [<code>WebGPUTimestampQueryPool</code>](#WebGPUTimestampQueryPool)  
**Returns**: <code>Promise</code> - A Promise that resolves when the dispose has been executed.  
<a name="WebXRDepthSensing"></a>

## WebXRDepthSensing
A XR module that manages the access to the Depth Sensing API.

**Kind**: global class  

* [WebXRDepthSensing](#WebXRDepthSensing)
    * [new WebXRDepthSensing()](#new_WebXRDepthSensing_new)
    * [.texture](#WebXRDepthSensing+texture) : <code>Texture</code>
    * [.mesh](#WebXRDepthSensing+mesh) : <code>Mesh</code>
    * [.depthNear](#WebXRDepthSensing+depthNear) : <code>number</code>
    * [.depthFar](#WebXRDepthSensing+depthFar) : <code>number</code>
    * [.init(renderer, depthData, renderState)](#WebXRDepthSensing+init)
    * [.getMesh(cameraXR)](#WebXRDepthSensing+getMesh) ⇒ <code>Mesh</code>
    * [.reset()](#WebXRDepthSensing+reset)
    * [.getDepthTexture()](#WebXRDepthSensing+getDepthTexture) ⇒ <code>Texture</code>

<a name="new_WebXRDepthSensing_new"></a>

### new WebXRDepthSensing()
Constructs a new depth sensing module.

<a name="WebXRDepthSensing+texture"></a>

### webXRDepthSensing.texture : <code>Texture</code>
A texture representing the depth of the user's environment.

**Kind**: instance property of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+mesh"></a>

### webXRDepthSensing.mesh : <code>Mesh</code>
A plane mesh for visualizing the depth texture.

**Kind**: instance property of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+depthNear"></a>

### webXRDepthSensing.depthNear : <code>number</code>
The depth near value.

**Kind**: instance property of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+depthFar"></a>

### webXRDepthSensing.depthFar : <code>number</code>
The depth near far.

**Kind**: instance property of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+init"></a>

### webXRDepthSensing.init(renderer, depthData, renderState)
Inits the depth sensing module

**Kind**: instance method of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| depthData | <code>XRWebGLDepthInformation</code> | The XR depth data. |
| renderState | <code>XRRenderState</code> | The XR render state. |

<a name="WebXRDepthSensing+getMesh"></a>

### webXRDepthSensing.getMesh(cameraXR) ⇒ <code>Mesh</code>
Returns a plane mesh that visualizes the depth texture.

**Kind**: instance method of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
**Returns**: <code>Mesh</code> - The plane mesh.  

| Param | Type | Description |
| --- | --- | --- |
| cameraXR | <code>ArrayCamera</code> | The XR camera. |

<a name="WebXRDepthSensing+reset"></a>

### webXRDepthSensing.reset()
Resets the module

**Kind**: instance method of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+getDepthTexture"></a>

### webXRDepthSensing.getDepthTexture() ⇒ <code>Texture</code>
Returns a texture representing the depth of the user's environment.

**Kind**: instance method of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
**Returns**: <code>Texture</code> - The depth texture.  
<a name="WebXRManager"></a>

## WebXRManager ⇐ <code>EventDispatcher</code>
This class represents an abstraction of the WebXR Device API and is
internally used by [WebGLRenderer](WebGLRenderer). `WebXRManager` also provides a public
interface that allows users to enable/disable XR and perform XR related
tasks like for instance retrieving controllers.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [WebXRManager](#WebXRManager) ⇐ <code>EventDispatcher</code>
    * [.cameraAutoUpdate](#WebXRManager+cameraAutoUpdate) : <code>boolean</code>
    * [.enabled](#WebXRManager+enabled) : <code>boolean</code>
    * [.isPresenting](#WebXRManager+isPresenting) : <code>boolean</code>
    * [.getController(index)](#WebXRManager+getController) ⇒ <code>Group</code>
    * [.getControllerGrip(index)](#WebXRManager+getControllerGrip) ⇒ <code>Group</code>
    * [.getHand(index)](#WebXRManager+getHand) ⇒ <code>Group</code>
    * [.setFramebufferScaleFactor(value)](#WebXRManager+setFramebufferScaleFactor)
    * [.setReferenceSpaceType(value)](#WebXRManager+setReferenceSpaceType)
    * [.getReferenceSpace()](#WebXRManager+getReferenceSpace) ⇒ <code>XRReferenceSpace</code>
    * [.setReferenceSpace(space)](#WebXRManager+setReferenceSpace)
    * [.getBaseLayer()](#WebXRManager+getBaseLayer) ⇒ <code>XRWebGLLayer</code> \| <code>XRProjectionLayer</code>
    * [.getBinding()](#WebXRManager+getBinding) ⇒ <code>XRWebGLBinding</code>
    * [.getFrame()](#WebXRManager+getFrame) ⇒ <code>XRFrame</code>
    * [.getSession()](#WebXRManager+getSession) ⇒ <code>XRSession</code>
    * [.setSession(value)](#WebXRManager+setSession) ⇒ <code>Promise</code>
    * [.getEnvironmentBlendMode()](#WebXRManager+getEnvironmentBlendMode) ⇒ <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code>
    * [.getDepthTexture()](#WebXRManager+getDepthTexture) ⇒ <code>Texture</code>
    * [.updateCamera(camera)](#WebXRManager+updateCamera)
    * [.getCamera()](#WebXRManager+getCamera) ⇒ <code>ArrayCamera</code>
    * [.getFoveation()](#WebXRManager+getFoveation) ⇒ <code>number</code>
    * [.setFoveation(value)](#WebXRManager+setFoveation)
    * [.hasDepthSensing()](#WebXRManager+hasDepthSensing) ⇒ <code>boolean</code>
    * [.getDepthSensingMesh()](#WebXRManager+getDepthSensingMesh) ⇒ <code>Mesh</code>

<a name="WebXRManager+cameraAutoUpdate"></a>

### webXRManager.cameraAutoUpdate : <code>boolean</code>
Whether the manager's XR camera should be automatically updated or not.

**Kind**: instance property of [<code>WebXRManager</code>](#WebXRManager)  
**Default**: <code>true</code>  
<a name="WebXRManager+enabled"></a>

### webXRManager.enabled : <code>boolean</code>
This flag notifies the renderer to be ready for XR rendering. Set it to `true`
if you are going to use XR in your app.

**Kind**: instance property of [<code>WebXRManager</code>](#WebXRManager)  
**Default**: <code>false</code>  
<a name="WebXRManager+isPresenting"></a>

### webXRManager.isPresenting : <code>boolean</code>
Whether XR presentation is active or not.

**Kind**: instance property of [<code>WebXRManager</code>](#WebXRManager)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="WebXRManager+getController"></a>

### webXRManager.getController(index) ⇒ <code>Group</code>
Returns a group representing the `target ray` space of the XR controller.
Use this space for visualizing 3D objects that support the user in pointing
tasks like UI interaction.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Group</code> - A group representing the `target ray` space.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the controller. |

<a name="WebXRManager+getControllerGrip"></a>

### webXRManager.getControllerGrip(index) ⇒ <code>Group</code>
Returns a group representing the `grip` space of the XR controller.
Use this space for visualizing 3D objects that support the user in pointing
tasks like UI interaction.

Note: If you want to show something in the user's hand AND offer a
pointing ray at the same time, you'll want to attached the handheld object
to the group returned by `getControllerGrip()` and the ray to the
group returned by `getController()`. The idea is to have two
different groups in two different coordinate spaces for the same WebXR
controller.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Group</code> - A group representing the `grip` space.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the controller. |

<a name="WebXRManager+getHand"></a>

### webXRManager.getHand(index) ⇒ <code>Group</code>
Returns a group representing the `hand` space of the XR controller.
Use this space for visualizing 3D objects that support the user in pointing
tasks like UI interaction.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Group</code> - A group representing the `hand` space.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the controller. |

<a name="WebXRManager+setFramebufferScaleFactor"></a>

### webXRManager.setFramebufferScaleFactor(value)
Sets the framebuffer scale factor.

This method can not be used during a XR session.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The framebuffer scale factor. |

<a name="WebXRManager+setReferenceSpaceType"></a>

### webXRManager.setReferenceSpaceType(value)
Sets the reference space type. Can be used to configure a spatial relationship with the user's physical
environment. Depending on how the user moves in 3D space, setting an appropriate reference space can
improve tracking. Default is `local-floor`.

This method can not be used during a XR session.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>string</code> | The reference space type. |

<a name="WebXRManager+getReferenceSpace"></a>

### webXRManager.getReferenceSpace() ⇒ <code>XRReferenceSpace</code>
Returns the XR reference space.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRReferenceSpace</code> - The XR reference space.  
<a name="WebXRManager+setReferenceSpace"></a>

### webXRManager.setReferenceSpace(space)
Sets a custom XR reference space.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| space | <code>XRReferenceSpace</code> | The XR reference space. |

<a name="WebXRManager+getBaseLayer"></a>

### webXRManager.getBaseLayer() ⇒ <code>XRWebGLLayer</code> \| <code>XRProjectionLayer</code>
Returns the current base layer.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRWebGLLayer</code> \| <code>XRProjectionLayer</code> - The XR base layer.  
<a name="WebXRManager+getBinding"></a>

### webXRManager.getBinding() ⇒ <code>XRWebGLBinding</code>
Returns the current XR binding.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRWebGLBinding</code> - The XR binding.  
<a name="WebXRManager+getFrame"></a>

### webXRManager.getFrame() ⇒ <code>XRFrame</code>
Returns the current XR frame.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRFrame</code> - The XR frame. Returns `null` when used outside a XR session.  
<a name="WebXRManager+getSession"></a>

### webXRManager.getSession() ⇒ <code>XRSession</code>
Returns the current XR session.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRSession</code> - The XR session. Returns `null` when used outside a XR session.  
<a name="WebXRManager+setSession"></a>

### webXRManager.setSession(value) ⇒ <code>Promise</code>
After a XR session has been requested usually with one of the `*Button` modules, it
is injected into the renderer with this method. This method triggers the start of
the actual XR rendering.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Promise</code> - A Promise that resolves when the session has been set.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>XRSession</code> | The XR session to set. |

<a name="WebXRManager+getEnvironmentBlendMode"></a>

### webXRManager.getEnvironmentBlendMode() ⇒ <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code>
Returns the environment blend mode from the current XR session.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code> - The environment blend mode. Returns `undefined` when used outside of a XR session.  
<a name="WebXRManager+getDepthTexture"></a>

### webXRManager.getDepthTexture() ⇒ <code>Texture</code>
Returns the current depth texture computed via depth sensing.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Texture</code> - The depth texture.  
<a name="WebXRManager+updateCamera"></a>

### webXRManager.updateCamera(camera)
Updates the state of the XR camera. Use this method on app level if you
set cameraAutoUpdate` to `false`. The method requires the non-XR
camera of the scene as a parameter. The passed in camera's transformation
is automatically adjusted to the position of the XR camera when calling
this method.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera. |

<a name="WebXRManager+getCamera"></a>

### webXRManager.getCamera() ⇒ <code>ArrayCamera</code>
Returns an instance of [ArrayCamera](ArrayCamera) which represents the XR camera
of the active XR session. For each view it holds a separate camera object.

The camera's `fov` is currently not used and does not reflect the fov of
the XR camera. If you need the fov on app level, you have to compute in
manually from the XR camera's projection matrices.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>ArrayCamera</code> - The XR camera.  
<a name="WebXRManager+getFoveation"></a>

### webXRManager.getFoveation() ⇒ <code>number</code>
Returns the amount of foveation used by the XR compositor for the projection layer.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>number</code> - The amount of foveation.  
<a name="WebXRManager+setFoveation"></a>

### webXRManager.setFoveation(value)
Sets the foveation value.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | A number in the range `[0,1]` where `0` means no foveation (full resolution) and `1` means maximum foveation (the edges render at lower resolution). |

<a name="WebXRManager+hasDepthSensing"></a>

### webXRManager.hasDepthSensing() ⇒ <code>boolean</code>
Returns `true` if depth sensing is supported.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>boolean</code> - Whether depth sensing is supported or not.  
<a name="WebXRManager+getDepthSensingMesh"></a>

### webXRManager.getDepthSensingMesh() ⇒ <code>Mesh</code>
Returns the depth sensing mesh.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Mesh</code> - The depth sensing mesh.  
<a name="Fog"></a>

## Fog
This class can be used to define a linear fog that grows linearly denser
with the distance.

```js
const scene = new THREE.Scene();
scene.fog = new THREE.Fog( 0xcccccc, 10, 15 );
```

**Kind**: global class  

* [Fog](#Fog)
    * [new Fog(color, [near], [far])](#new_Fog_new)
    * [.isFog](#Fog+isFog) : <code>boolean</code>
    * [.name](#Fog+name) : <code>string</code>
    * [.color](#Fog+color) : <code>Color</code>
    * [.near](#Fog+near) : <code>number</code>
    * [.far](#Fog+far) : <code>number</code>
    * [.clone()](#Fog+clone) ⇒ [<code>Fog</code>](#Fog)
    * [.toJSON(meta)](#Fog+toJSON) ⇒ <code>Object</code>

<a name="new_Fog_new"></a>

### new Fog(color, [near], [far])
Constructs a new fog.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>number</code> \| <code>Color</code> |  | The fog's color. |
| [near] | <code>number</code> | <code>1</code> | The minimum distance to start applying fog. |
| [far] | <code>number</code> | <code>1000</code> | The maximum distance at which fog stops being calculated and applied. |

<a name="Fog+isFog"></a>

### fog.isFog : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Fog+name"></a>

### fog.name : <code>string</code>
The name of the fog.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
<a name="Fog+color"></a>

### fog.color : <code>Color</code>
The fog's color.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
<a name="Fog+near"></a>

### fog.near : <code>number</code>
The minimum distance to start applying fog. Objects that are less than
`near` units from the active camera won't be affected by fog.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
**Default**: <code>1</code>  
<a name="Fog+far"></a>

### fog.far : <code>number</code>
The maximum distance at which fog stops being calculated and applied.
Objects that are more than `far` units away from the active camera won't
be affected by fog.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
**Default**: <code>1000</code>  
<a name="Fog+clone"></a>

### fog.clone() ⇒ [<code>Fog</code>](#Fog)
Returns a new fog with copied values from this instance.

**Kind**: instance method of [<code>Fog</code>](#Fog)  
**Returns**: [<code>Fog</code>](#Fog) - A clone of this instance.  
<a name="Fog+toJSON"></a>

### fog.toJSON(meta) ⇒ <code>Object</code>
Serializes the fog into JSON.

**Kind**: instance method of [<code>Fog</code>](#Fog)  
**Returns**: <code>Object</code> - A JSON object representing the serialized fog  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="FogExp2"></a>

## FogExp2
This class can be used to define an exponential squared fog,
which gives a clear view near the camera and a faster than exponentially
densening fog farther from the camera.

```js
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
```

**Kind**: global class  

* [FogExp2](#FogExp2)
    * [new FogExp2(color, [density])](#new_FogExp2_new)
    * [.isFogExp2](#FogExp2+isFogExp2) : <code>boolean</code>
    * [.name](#FogExp2+name) : <code>string</code>
    * [.color](#FogExp2+color) : <code>Color</code>
    * [.density](#FogExp2+density) : <code>number</code>
    * [.clone()](#FogExp2+clone) ⇒ [<code>FogExp2</code>](#FogExp2)
    * [.toJSON(meta)](#FogExp2+toJSON) ⇒ <code>Object</code>

<a name="new_FogExp2_new"></a>

### new FogExp2(color, [density])
Constructs a new fog.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>number</code> \| <code>Color</code> |  | The fog's color. |
| [density] | <code>number</code> | <code>0.00025</code> | Defines how fast the fog will grow dense. |

<a name="FogExp2+isFogExp2"></a>

### fogExp2.isFogExp2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>FogExp2</code>](#FogExp2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="FogExp2+name"></a>

### fogExp2.name : <code>string</code>
The name of the fog.

**Kind**: instance property of [<code>FogExp2</code>](#FogExp2)  
<a name="FogExp2+color"></a>

### fogExp2.color : <code>Color</code>
The fog's color.

**Kind**: instance property of [<code>FogExp2</code>](#FogExp2)  
<a name="FogExp2+density"></a>

### fogExp2.density : <code>number</code>
Defines how fast the fog will grow dense.

**Kind**: instance property of [<code>FogExp2</code>](#FogExp2)  
**Default**: <code>0.00025</code>  
<a name="FogExp2+clone"></a>

### fogExp2.clone() ⇒ [<code>FogExp2</code>](#FogExp2)
Returns a new fog with copied values from this instance.

**Kind**: instance method of [<code>FogExp2</code>](#FogExp2)  
**Returns**: [<code>FogExp2</code>](#FogExp2) - A clone of this instance.  
<a name="FogExp2+toJSON"></a>

### fogExp2.toJSON(meta) ⇒ <code>Object</code>
Serializes the fog into JSON.

**Kind**: instance method of [<code>FogExp2</code>](#FogExp2)  
**Returns**: <code>Object</code> - A JSON object representing the serialized fog  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Scene"></a>

## Scene ⇐ <code>Object3D</code>
Scenes allow you to set up what is to be rendered and where by three.js.
This is where you place 3D objects like meshes, lines or lights.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Scene](#Scene) ⇐ <code>Object3D</code>
    * [new Scene()](#new_Scene_new)
    * [.isScene](#Scene+isScene) : <code>boolean</code>
    * [.background](#Scene+background) : <code>Color</code> \| <code>Texture</code>
    * [.environment](#Scene+environment) : <code>Texture</code>
    * [.fog](#Scene+fog) : <code>Fog</code> \| <code>FogExp2</code>
    * [.backgroundBlurriness](#Scene+backgroundBlurriness) : <code>number</code>
    * [.backgroundIntensity](#Scene+backgroundIntensity) : <code>number</code>
    * [.backgroundRotation](#Scene+backgroundRotation) : <code>Euler</code>
    * [.environmentIntensity](#Scene+environmentIntensity) : <code>number</code>
    * [.environmentRotation](#Scene+environmentRotation) : <code>Euler</code>
    * [.overrideMaterial](#Scene+overrideMaterial) : <code>Material</code>

<a name="new_Scene_new"></a>

### new Scene()
Constructs a new scene.

<a name="Scene+isScene"></a>

### scene.isScene : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Scene+background"></a>

### scene.background : <code>Color</code> \| <code>Texture</code>
Defines the background of the scene. Valid inputs are:

- A color for defining a uniform colored background.
- A texture for defining a (flat) textured background.
- Cube textures or equirectangular textures for defining a skybox.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>null</code>  
<a name="Scene+environment"></a>

### scene.environment : <code>Texture</code>
Sets the environment map for all physical materials in the scene. However,
it's not possible to overwrite an existing texture assigned to the `envMap`
material property.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>null</code>  
<a name="Scene+fog"></a>

### scene.fog : <code>Fog</code> \| <code>FogExp2</code>
A fog instance defining the type of fog that affects everything
rendered in the scene.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>null</code>  
<a name="Scene+backgroundBlurriness"></a>

### scene.backgroundBlurriness : <code>number</code>
Sets the blurriness of the background. Only influences environment maps
assigned to [background](#Scene+background). Valid input is a float between `0`
and `1`.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>0</code>  
<a name="Scene+backgroundIntensity"></a>

### scene.backgroundIntensity : <code>number</code>
Attenuates the color of the background. Only applies to background textures.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>1</code>  
<a name="Scene+backgroundRotation"></a>

### scene.backgroundRotation : <code>Euler</code>
The rotation of the background in radians. Only influences environment maps
assigned to [background](#Scene+background).

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>(0,0,0)</code>  
<a name="Scene+environmentIntensity"></a>

### scene.environmentIntensity : <code>number</code>
Attenuates the color of the environment. Only influences environment maps
assigned to [environment](#Scene+environment).

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>1</code>  
<a name="Scene+environmentRotation"></a>

### scene.environmentRotation : <code>Euler</code>
The rotation of the environment map in radians. Only influences physical materials
in the scene when [environment](#Scene+environment) is used.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>(0,0,0)</code>  
<a name="Scene+overrideMaterial"></a>

### scene.overrideMaterial : <code>Material</code>
Forces everything in the scene to be rendered with the defined material. It is possible
to exclude materials from override by setting [Material#allowOverride](Material#allowOverride) to `false`.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>null</code>  
<a name="CanvasTexture"></a>

## CanvasTexture ⇐ <code>Texture</code>
Creates a texture from a canvas element.

This is almost the same as the base texture class, except that it sets [Texture#needsUpdate](Texture#needsUpdate)
to `true` immediately since a canvas can directly be used for rendering.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [CanvasTexture](#CanvasTexture) ⇐ <code>Texture</code>
    * [new CanvasTexture([canvas], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])](#new_CanvasTexture_new)
    * [.isCanvasTexture](#CanvasTexture+isCanvasTexture) : <code>boolean</code>

<a name="new_CanvasTexture_new"></a>

### new CanvasTexture([canvas], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])
Constructs a new texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [canvas] | <code>HTMLCanvasElement</code> |  | The HTML canvas element. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearMipmapLinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |

<a name="CanvasTexture+isCanvasTexture"></a>

### canvasTexture.isCanvasTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CanvasTexture</code>](#CanvasTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedArrayTexture"></a>

## CompressedArrayTexture ⇐ <code>CompressedTexture</code>
Creates a texture 2D array based on data in compressed form.

These texture are usually loaded with [CompressedTextureLoader](CompressedTextureLoader).

**Kind**: global class  
**Extends**: <code>CompressedTexture</code>  

* [CompressedArrayTexture](#CompressedArrayTexture) ⇐ <code>CompressedTexture</code>
    * [new CompressedArrayTexture(mipmaps, width, height, depth, [format], [type])](#new_CompressedArrayTexture_new)
    * [.isCompressedArrayTexture](#CompressedArrayTexture+isCompressedArrayTexture) : <code>boolean</code>
    * [.image](#CompressedArrayTexture+image) : <code>Object</code>
    * [.wrapR](#CompressedArrayTexture+wrapR) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
    * [.layerUpdates](#CompressedArrayTexture+layerUpdates) : <code>Set.&lt;number&gt;</code>
    * [.addLayerUpdate(layerIndex)](#CompressedArrayTexture+addLayerUpdate)
    * [.clearLayerUpdates()](#CompressedArrayTexture+clearLayerUpdates)

<a name="new_CompressedArrayTexture_new"></a>

### new CompressedArrayTexture(mipmaps, width, height, depth, [format], [type])
Constructs a new compressed array texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mipmaps | <code>Array.&lt;Object&gt;</code> |  | This array holds for all mipmaps (including the bases mip) the data and dimensions. |
| width | <code>number</code> |  | The width of the texture. |
| height | <code>number</code> |  | The height of the texture. |
| depth | <code>number</code> |  | The depth of the texture. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The min filter value. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The min filter value. |

<a name="CompressedArrayTexture+isCompressedArrayTexture"></a>

### compressedArrayTexture.isCompressedArrayTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedArrayTexture+image"></a>

### compressedArrayTexture.image : <code>Object</code>
The image property of a compressed texture just defines its dimensions.

**Kind**: instance property of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
<a name="CompressedArrayTexture+wrapR"></a>

### compressedArrayTexture.wrapR : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped in the depth and corresponds to
*W* in UVW mapping.

**Kind**: instance property of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="CompressedArrayTexture+layerUpdates"></a>

### compressedArrayTexture.layerUpdates : <code>Set.&lt;number&gt;</code>
A set of all layers which need to be updated in the texture.

**Kind**: instance property of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
<a name="CompressedArrayTexture+addLayerUpdate"></a>

### compressedArrayTexture.addLayerUpdate(layerIndex)
Describes that a specific layer of the texture needs to be updated.
Normally when [Texture#needsUpdate](Texture#needsUpdate) is set to `true`, the
entire compressed texture array is sent to the GPU. Marking specific
layers will only transmit subsets of all mipmaps associated with a
specific depth in the array which is often much more performant.

**Kind**: instance method of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  

| Param | Type | Description |
| --- | --- | --- |
| layerIndex | <code>number</code> | The layer index that should be updated. |

<a name="CompressedArrayTexture+clearLayerUpdates"></a>

### compressedArrayTexture.clearLayerUpdates()
Resets the layer updates registry.

**Kind**: instance method of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
<a name="CompressedCubeTexture"></a>

## CompressedCubeTexture ⇐ <code>CompressedTexture</code>
Creates a cube texture based on data in compressed form.

These texture are usually loaded with [CompressedTextureLoader](CompressedTextureLoader).

**Kind**: global class  
**Extends**: <code>CompressedTexture</code>  

* [CompressedCubeTexture](#CompressedCubeTexture) ⇐ <code>CompressedTexture</code>
    * [new CompressedCubeTexture(images, [format], [type])](#new_CompressedCubeTexture_new)
    * [.isCompressedCubeTexture](#CompressedCubeTexture+isCompressedCubeTexture) : <code>boolean</code>
    * [.isCubeTexture](#CompressedCubeTexture+isCubeTexture) : <code>boolean</code>

<a name="new_CompressedCubeTexture_new"></a>

### new CompressedCubeTexture(images, [format], [type])
Constructs a new compressed texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| images | <code>Array.&lt;CompressedTexture&gt;</code> |  | An array of compressed textures. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |

<a name="CompressedCubeTexture+isCompressedCubeTexture"></a>

### compressedCubeTexture.isCompressedCubeTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CompressedCubeTexture</code>](#CompressedCubeTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedCubeTexture+isCubeTexture"></a>

### compressedCubeTexture.isCubeTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CompressedCubeTexture</code>](#CompressedCubeTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedTexture"></a>

## CompressedTexture ⇐ <code>Texture</code>
Creates a texture based on data in compressed form.

These texture are usually loaded with [CompressedTextureLoader](CompressedTextureLoader).

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [CompressedTexture](#CompressedTexture) ⇐ <code>Texture</code>
    * [new CompressedTexture(mipmaps, width, height, [format], [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [colorSpace])](#new_CompressedTexture_new)
    * [.isCompressedTexture](#CompressedTexture+isCompressedTexture) : <code>boolean</code>
    * [.image](#CompressedTexture+image) : <code>Object</code>
    * [.mipmaps](#CompressedTexture+mipmaps) : <code>Array.&lt;Object&gt;</code>
    * [.flipY](#CompressedTexture+flipY) : <code>boolean</code>
    * [.generateMipmaps](#CompressedTexture+generateMipmaps) : <code>boolean</code>

<a name="new_CompressedTexture_new"></a>

### new CompressedTexture(mipmaps, width, height, [format], [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [colorSpace])
Constructs a new compressed texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mipmaps | <code>Array.&lt;Object&gt;</code> |  | This array holds for all mipmaps (including the bases mip) the data and dimensions. |
| width | <code>number</code> |  | The width of the texture. |
| height | <code>number</code> |  | The height of the texture. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearMipmapLinearFilter</code> | The min filter value. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The color space. |

<a name="CompressedTexture+isCompressedTexture"></a>

### compressedTexture.isCompressedTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedTexture+image"></a>

### compressedTexture.image : <code>Object</code>
The image property of a compressed texture just defines its dimensions.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
<a name="CompressedTexture+mipmaps"></a>

### compressedTexture.mipmaps : <code>Array.&lt;Object&gt;</code>
This array holds for all mipmaps (including the bases mip) the data and dimensions.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
<a name="CompressedTexture+flipY"></a>

### compressedTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default since it is not possible to
flip compressed textures.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="CompressedTexture+generateMipmaps"></a>

### compressedTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default since it is not
possible to generate mipmaps for compressed data. Mipmaps
must be embedded in the compressed texture file.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="CubeTexture"></a>

## CubeTexture ⇐ <code>Texture</code>
Creates a cube texture made up of six images.

```js
const loader = new THREE.CubeTextureLoader();
loader.setPath( 'textures/cube/pisa/' );

const textureCube = loader.load( [
	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
] );

const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
```

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [CubeTexture](#CubeTexture) ⇐ <code>Texture</code>
    * [new CubeTexture([images], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy], [colorSpace])](#new_CubeTexture_new)
    * [.isCubeTexture](#CubeTexture+isCubeTexture) : <code>boolean</code>
    * [.flipY](#CubeTexture+flipY) : <code>boolean</code>
    * [.images](#CubeTexture+images) : <code>Array.&lt;Image&gt;</code>

<a name="new_CubeTexture_new"></a>

### new CubeTexture([images], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy], [colorSpace])
Constructs a new cube texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [images] | <code>Array.&lt;Image&gt;</code> | <code>[]</code> | An array holding a image for each side of a cube. |
| [mapping] | <code>number</code> | <code>CubeReflectionMapping</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearMipmapLinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The color space value. |

<a name="CubeTexture+isCubeTexture"></a>

### cubeTexture.isCubeTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubeTexture</code>](#CubeTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubeTexture+flipY"></a>

### cubeTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>CubeTexture</code>](#CubeTexture)  
**Default**: <code>false</code>  
<a name="CubeTexture+images"></a>

### cubeTexture.images : <code>Array.&lt;Image&gt;</code>
Alias for [CubeTexture#image](CubeTexture#image).

**Kind**: instance property of [<code>CubeTexture</code>](#CubeTexture)  
<a name="Data3DTexture"></a>

## Data3DTexture ⇐ <code>Texture</code>
Creates a three-dimensional texture from raw data, with parameters to
divide it into width, height, and depth.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [Data3DTexture](#Data3DTexture) ⇐ <code>Texture</code>
    * [new Data3DTexture([data], [width], [height], [depth])](#new_Data3DTexture_new)
    * [.isData3DTexture](#Data3DTexture+isData3DTexture) : <code>boolean</code>
    * [.image](#Data3DTexture+image) : <code>Object</code>
    * [.magFilter](#Data3DTexture+magFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.minFilter](#Data3DTexture+minFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.wrapR](#Data3DTexture+wrapR) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
    * [.generateMipmaps](#Data3DTexture+generateMipmaps) : <code>boolean</code>
    * [.flipY](#Data3DTexture+flipY) : <code>boolean</code>
    * [.unpackAlignment](#Data3DTexture+unpackAlignment) : <code>boolean</code>

<a name="new_Data3DTexture_new"></a>

### new Data3DTexture([data], [width], [height], [depth])
Constructs a new data array texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [data] | <code>TypedArray</code> | <code></code> | The buffer data. |
| [width] | <code>number</code> | <code>1</code> | The width of the texture. |
| [height] | <code>number</code> | <code>1</code> | The height of the texture. |
| [depth] | <code>number</code> | <code>1</code> | The depth of the texture. |

<a name="Data3DTexture+isData3DTexture"></a>

### data3DTexture.isData3DTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Data3DTexture+image"></a>

### data3DTexture.image : <code>Object</code>
The image definition of a data texture.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
<a name="Data3DTexture+magFilter"></a>

### data3DTexture.magFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers more than one pixel.

Overwritten and set to `NearestFilter` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>NearestFilter</code>  
<a name="Data3DTexture+minFilter"></a>

### data3DTexture.minFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers less than one pixel.

Overwritten and set to `NearestFilter` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>NearestFilter</code>  
<a name="Data3DTexture+wrapR"></a>

### data3DTexture.wrapR : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped in the depth and corresponds to
*W* in UVW mapping.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="Data3DTexture+generateMipmaps"></a>

### data3DTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>false</code>  
<a name="Data3DTexture+flipY"></a>

### data3DTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>false</code>  
<a name="Data3DTexture+unpackAlignment"></a>

### data3DTexture.unpackAlignment : <code>boolean</code>
Specifies the alignment requirements for the start of each pixel row in memory.

Overwritten and set to `1` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>1</code>  
<a name="DataArrayTexture"></a>

## DataArrayTexture ⇐ <code>Texture</code>
Creates an array of textures directly from raw buffer data.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [DataArrayTexture](#DataArrayTexture) ⇐ <code>Texture</code>
    * [new DataArrayTexture([data], [width], [height], [depth])](#new_DataArrayTexture_new)
    * [.isDataArrayTexture](#DataArrayTexture+isDataArrayTexture) : <code>boolean</code>
    * [.image](#DataArrayTexture+image) : <code>Object</code>
    * [.magFilter](#DataArrayTexture+magFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.minFilter](#DataArrayTexture+minFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.wrapR](#DataArrayTexture+wrapR) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
    * [.generateMipmaps](#DataArrayTexture+generateMipmaps) : <code>boolean</code>
    * [.flipY](#DataArrayTexture+flipY) : <code>boolean</code>
    * [.unpackAlignment](#DataArrayTexture+unpackAlignment) : <code>boolean</code>
    * [.layerUpdates](#DataArrayTexture+layerUpdates) : <code>Set.&lt;number&gt;</code>
    * [.addLayerUpdate(layerIndex)](#DataArrayTexture+addLayerUpdate)
    * [.clearLayerUpdates()](#DataArrayTexture+clearLayerUpdates)

<a name="new_DataArrayTexture_new"></a>

### new DataArrayTexture([data], [width], [height], [depth])
Constructs a new data array texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [data] | <code>TypedArray</code> | <code></code> | The buffer data. |
| [width] | <code>number</code> | <code>1</code> | The width of the texture. |
| [height] | <code>number</code> | <code>1</code> | The height of the texture. |
| [depth] | <code>number</code> | <code>1</code> | The depth of the texture. |

<a name="DataArrayTexture+isDataArrayTexture"></a>

### dataArrayTexture.isDataArrayTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DataArrayTexture+image"></a>

### dataArrayTexture.image : <code>Object</code>
The image definition of a data texture.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
<a name="DataArrayTexture+magFilter"></a>

### dataArrayTexture.magFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers more than one pixel.

Overwritten and set to `NearestFilter` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>NearestFilter</code>  
<a name="DataArrayTexture+minFilter"></a>

### dataArrayTexture.minFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers less than one pixel.

Overwritten and set to `NearestFilter` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>NearestFilter</code>  
<a name="DataArrayTexture+wrapR"></a>

### dataArrayTexture.wrapR : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped in the depth and corresponds to
*W* in UVW mapping.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="DataArrayTexture+generateMipmaps"></a>

### dataArrayTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>false</code>  
<a name="DataArrayTexture+flipY"></a>

### dataArrayTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>false</code>  
<a name="DataArrayTexture+unpackAlignment"></a>

### dataArrayTexture.unpackAlignment : <code>boolean</code>
Specifies the alignment requirements for the start of each pixel row in memory.

Overwritten and set to `1` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>1</code>  
<a name="DataArrayTexture+layerUpdates"></a>

### dataArrayTexture.layerUpdates : <code>Set.&lt;number&gt;</code>
A set of all layers which need to be updated in the texture.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
<a name="DataArrayTexture+addLayerUpdate"></a>

### dataArrayTexture.addLayerUpdate(layerIndex)
Describes that a specific layer of the texture needs to be updated.
Normally when [Texture#needsUpdate](Texture#needsUpdate) is set to `true`, the
entire data texture array is sent to the GPU. Marking specific
layers will only transmit subsets of all mipmaps associated with a
specific depth in the array which is often much more performant.

**Kind**: instance method of [<code>DataArrayTexture</code>](#DataArrayTexture)  

| Param | Type | Description |
| --- | --- | --- |
| layerIndex | <code>number</code> | The layer index that should be updated. |

<a name="DataArrayTexture+clearLayerUpdates"></a>

### dataArrayTexture.clearLayerUpdates()
Resets the layer updates registry.

**Kind**: instance method of [<code>DataArrayTexture</code>](#DataArrayTexture)  
<a name="DataTexture"></a>

## DataTexture ⇐ <code>Texture</code>
Creates a texture directly from raw buffer data.

The interpretation of the data depends on type and format: If the type is
`UnsignedByteType`, a `Uint8Array` will be useful for addressing the
texel data. If the format is `RGBAFormat`, data needs four values for
one texel; Red, Green, Blue and Alpha (typically the opacity).

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [DataTexture](#DataTexture) ⇐ <code>Texture</code>
    * [new DataTexture([data], [width], [height], [format], [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [colorSpace])](#new_DataTexture_new)
    * [.isDataTexture](#DataTexture+isDataTexture) : <code>boolean</code>
    * [.image](#DataTexture+image) : <code>Object</code>
    * [.generateMipmaps](#DataTexture+generateMipmaps) : <code>boolean</code>
    * [.flipY](#DataTexture+flipY) : <code>boolean</code>
    * [.unpackAlignment](#DataTexture+unpackAlignment) : <code>boolean</code>

<a name="new_DataTexture_new"></a>

### new DataTexture([data], [width], [height], [format], [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [colorSpace])
Constructs a new data texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [data] | <code>TypedArray</code> | <code></code> | The buffer data. |
| [width] | <code>number</code> | <code>1</code> | The width of the texture. |
| [height] | <code>number</code> | <code>1</code> | The height of the texture. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>NearestFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>NearestFilter</code> | The min filter value. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The color space. |

<a name="DataTexture+isDataTexture"></a>

### dataTexture.isDataTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DataTexture+image"></a>

### dataTexture.image : <code>Object</code>
The image definition of a data texture.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
<a name="DataTexture+generateMipmaps"></a>

### dataTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
**Default**: <code>false</code>  
<a name="DataTexture+flipY"></a>

### dataTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
**Default**: <code>false</code>  
<a name="DataTexture+unpackAlignment"></a>

### dataTexture.unpackAlignment : <code>boolean</code>
Specifies the alignment requirements for the start of each pixel row in memory.

Overwritten and set to `1` by default.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
**Default**: <code>1</code>  
<a name="DepthTexture"></a>

## DepthTexture ⇐ <code>Texture</code>
This class can be used to automatically save the depth information of a
rendering into a texture.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [DepthTexture](#DepthTexture) ⇐ <code>Texture</code>
    * [new DepthTexture(width, height, [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [format])](#new_DepthTexture_new)
    * [.isDepthTexture](#DepthTexture+isDepthTexture) : <code>boolean</code>
    * [.image](#DepthTexture+image) : <code>Object</code>
    * [.flipY](#DepthTexture+flipY) : <code>boolean</code>
    * [.generateMipmaps](#DepthTexture+generateMipmaps) : <code>boolean</code>
    * [.compareFunction](#DepthTexture+compareFunction) : <code>NeverCompare</code> \| <code>LessCompare</code> \| <code>EqualCompare</code> \| <code>LessEqualCompare</code> \| <code>GreaterCompare</code> \| <code>NotEqualCompare</code> \| <code>GreaterEqualCompare</code> \| <code>AlwaysCompare</code>

<a name="new_DepthTexture_new"></a>

### new DepthTexture(width, height, [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [format])
Constructs a new depth texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| width | <code>number</code> |  | The width of the texture. |
| height | <code>number</code> |  | The height of the texture. |
| [type] | <code>number</code> | <code>UnsignedIntType</code> | The texture type. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearFilter</code> | The min filter value. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [format] | <code>number</code> | <code>DepthFormat</code> | The texture format. |

<a name="DepthTexture+isDepthTexture"></a>

### depthTexture.isDepthTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DepthTexture+image"></a>

### depthTexture.image : <code>Object</code>
The image property of a depth texture just defines its dimensions.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
<a name="DepthTexture+flipY"></a>

### depthTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
**Default**: <code>false</code>  
<a name="DepthTexture+generateMipmaps"></a>

### depthTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
**Default**: <code>false</code>  
<a name="DepthTexture+compareFunction"></a>

### depthTexture.compareFunction : <code>NeverCompare</code> \| <code>LessCompare</code> \| <code>EqualCompare</code> \| <code>LessEqualCompare</code> \| <code>GreaterCompare</code> \| <code>NotEqualCompare</code> \| <code>GreaterEqualCompare</code> \| <code>AlwaysCompare</code>
The depth compare function.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
**Default**: <code>null</code>  
<a name="FramebufferTexture"></a>

## FramebufferTexture ⇐ <code>Texture</code>
This class can only be used in combination with `copyFramebufferToTexture()` methods
of renderers. It extracts the contents of the current bound framebuffer and provides it
as a texture for further usage.

```js
const pixelRatio = window.devicePixelRatio;
const textureSize = 128 * pixelRatio;

const frameTexture = new FramebufferTexture( textureSize, textureSize );

// calculate start position for copying part of the frame data
const vector = new Vector2();
vector.x = ( window.innerWidth * pixelRatio / 2 ) - ( textureSize / 2 );
vector.y = ( window.innerHeight * pixelRatio / 2 ) - ( textureSize / 2 );

renderer.render( scene, camera );

// copy part of the rendered frame into the framebuffer texture
renderer.copyFramebufferToTexture( frameTexture, vector );
```

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [FramebufferTexture](#FramebufferTexture) ⇐ <code>Texture</code>
    * [new FramebufferTexture(width, height)](#new_FramebufferTexture_new)
    * [.isFramebufferTexture](#FramebufferTexture+isFramebufferTexture) : <code>boolean</code>
    * [.magFilter](#FramebufferTexture+magFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.minFilter](#FramebufferTexture+minFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.generateMipmaps](#FramebufferTexture+generateMipmaps) : <code>boolean</code>

<a name="new_FramebufferTexture_new"></a>

### new FramebufferTexture(width, height)
Constructs a new framebuffer texture.


| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the texture. |
| height | <code>number</code> | The height of the texture. |

<a name="FramebufferTexture+isFramebufferTexture"></a>

### framebufferTexture.isFramebufferTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>FramebufferTexture</code>](#FramebufferTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="FramebufferTexture+magFilter"></a>

### framebufferTexture.magFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers more than one pixel.

Overwritten and set to `NearestFilter` by default to disable filtering.

**Kind**: instance property of [<code>FramebufferTexture</code>](#FramebufferTexture)  
**Default**: <code>NearestFilter</code>  
<a name="FramebufferTexture+minFilter"></a>

### framebufferTexture.minFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers less than one pixel.

Overwritten and set to `NearestFilter` by default to disable filtering.

**Kind**: instance property of [<code>FramebufferTexture</code>](#FramebufferTexture)  
**Default**: <code>NearestFilter</code>  
<a name="FramebufferTexture+generateMipmaps"></a>

### framebufferTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>FramebufferTexture</code>](#FramebufferTexture)  
**Default**: <code>false</code>  
<a name="Source"></a>

## Source
Represents the data source of a texture.

The main purpose of this class is to decouple the data definition from the texture
definition so the same data can be used with multiple texture instances.

**Kind**: global class  

* [Source](#Source)
    * [new Source([data])](#new_Source_new)
    * [.isSource](#Source+isSource) : <code>boolean</code>
    * [.id](#Source+id) : <code>number</code>
    * [.uuid](#Source+uuid) : <code>string</code>
    * [.data](#Source+data) : <code>any</code>
    * [.dataReady](#Source+dataReady) : <code>boolean</code>
    * [.version](#Source+version) : <code>number</code>
    * [.needsUpdate](#Source+needsUpdate) : <code>boolean</code>
    * [.toJSON(meta)](#Source+toJSON) ⇒ <code>Object</code>

<a name="new_Source_new"></a>

### new Source([data])
Constructs a new video texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [data] | <code>any</code> | <code></code> | The data definition of a texture. |

<a name="Source+isSource"></a>

### source.isSource : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Source+id"></a>

### source.id : <code>number</code>
The ID of the source.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Read only**: true  
<a name="Source+uuid"></a>

### source.uuid : <code>string</code>
The UUID of the source.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Read only**: true  
<a name="Source+data"></a>

### source.data : <code>any</code>
The data definition of a texture.

**Kind**: instance property of [<code>Source</code>](#Source)  
<a name="Source+dataReady"></a>

### source.dataReady : <code>boolean</code>
This property is only relevant when [needsUpdate](#Source+needsUpdate) is set to `true` and
provides more control on how texture data should be processed. When `dataReady` is set
to `false`, the engine performs the memory allocation (if necessary) but does not transfer
the data into the GPU memory.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Default**: <code>true</code>  
<a name="Source+version"></a>

### source.version : <code>number</code>
This starts at `0` and counts how many times [needsUpdate](#Source+needsUpdate) is set to `true`.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Source+needsUpdate"></a>

### source.needsUpdate : <code>boolean</code>
When the property is set to `true`, the engine allocates the memory
for the texture (if necessary) and triggers the actual texture upload
to the GPU next time the source is used.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Source+toJSON"></a>

### source.toJSON(meta) ⇒ <code>Object</code>
Serializes the source into JSON.

**Kind**: instance method of [<code>Source</code>](#Source)  
**Returns**: <code>Object</code> - A JSON object representing the serialized source.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Texture"></a>

## Texture ⇐ <code>EventDispatcher</code>
Base class for all textures.

Note: After the initial use of a texture, its dimensions, format, and type
cannot be changed. Instead, call [dispose](#Texture+dispose) on the texture and instantiate a new one.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [Texture](#Texture) ⇐ <code>EventDispatcher</code>
    * [new Texture([image], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy], [colorSpace])](#new_Texture_new)
    * _instance_
        * [.isTexture](#Texture+isTexture) : <code>boolean</code>
        * [.id](#Texture+id) : <code>number</code>
        * [.uuid](#Texture+uuid) : <code>string</code>
        * [.name](#Texture+name) : <code>string</code>
        * [.source](#Texture+source) : <code>Source</code>
        * [.mipmaps](#Texture+mipmaps) : <code>Array.&lt;Object&gt;</code>
        * [.mapping](#Texture+mapping) : <code>UVMapping</code> \| <code>CubeReflectionMapping</code> \| <code>CubeRefractionMapping</code> \| <code>EquirectangularReflectionMapping</code> \| <code>EquirectangularRefractionMapping</code> \| <code>CubeUVReflectionMapping</code>
        * [.channel](#Texture+channel) : <code>number</code>
        * [.wrapS](#Texture+wrapS) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
        * [.wrapT](#Texture+wrapT) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
        * [.magFilter](#Texture+magFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
        * [.minFilter](#Texture+minFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
        * [.anisotropy](#Texture+anisotropy) : <code>number</code>
        * [.format](#Texture+format) : <code>number</code>
        * [.internalFormat](#Texture+internalFormat) : <code>string</code>
        * [.type](#Texture+type) : <code>number</code>
        * [.offset](#Texture+offset) : <code>Vector2</code>
        * [.repeat](#Texture+repeat) : <code>Vector2</code>
        * [.center](#Texture+center) : <code>Vector2</code>
        * [.rotation](#Texture+rotation) : <code>number</code>
        * [.matrixAutoUpdate](#Texture+matrixAutoUpdate) : <code>boolean</code>
        * [.matrix](#Texture+matrix) : <code>Matrix3</code>
        * [.generateMipmaps](#Texture+generateMipmaps) : <code>boolean</code>
        * [.premultiplyAlpha](#Texture+premultiplyAlpha) : <code>boolean</code>
        * [.flipY](#Texture+flipY) : <code>boolean</code>
        * [.unpackAlignment](#Texture+unpackAlignment) : <code>number</code>
        * [.colorSpace](#Texture+colorSpace) : <code>string</code>
        * [.userData](#Texture+userData) : <code>Object</code>
        * [.version](#Texture+version) : <code>number</code>
        * [.onUpdate](#Texture+onUpdate) : <code>function</code>
        * [.renderTarget](#Texture+renderTarget) : <code>RenderTarget</code> \| <code>WebGLRenderTarget</code>
        * [.isRenderTargetTexture](#Texture+isRenderTargetTexture) : <code>boolean</code>
        * [.pmremVersion](#Texture+pmremVersion) : <code>number</code>
        * [.image](#Texture+image) : <code>Object</code>
        * [.needsUpdate](#Texture+needsUpdate) : <code>boolean</code>
        * [.needsPMREMUpdate](#Texture+needsPMREMUpdate) : <code>boolean</code>
        * [.updateMatrix()](#Texture+updateMatrix)
        * [.clone()](#Texture+clone) ⇒ [<code>Texture</code>](#Texture)
        * [.copy(source)](#Texture+copy) ⇒ [<code>Texture</code>](#Texture)
        * [.toJSON(meta)](#Texture+toJSON) ⇒ <code>Object</code>
        * [.dispose()](#Texture+dispose)
        * [.transformUv(uv)](#Texture+transformUv) ⇒ <code>Vector2</code>
        * ["dispose"](#Texture+event_dispose)
    * _static_
        * [.DEFAULT_IMAGE](#Texture.DEFAULT_IMAGE) : <code>Image</code>
        * [.DEFAULT_MAPPING](#Texture.DEFAULT_MAPPING) : <code>number</code>
        * [.DEFAULT_ANISOTROPY](#Texture.DEFAULT_ANISOTROPY) : <code>number</code>

<a name="new_Texture_new"></a>

### new Texture([image], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy], [colorSpace])
Constructs a new texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [image] | <code>Object</code> | <code>Texture.DEFAULT_IMAGE</code> | The image holding the texture data. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearMipmapLinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The color space. |

<a name="Texture+isTexture"></a>

### texture.isTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Texture+id"></a>

### texture.id : <code>number</code>
The ID of the texture.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Read only**: true  
<a name="Texture+uuid"></a>

### texture.uuid : <code>string</code>
The UUID of the material.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Read only**: true  
<a name="Texture+name"></a>

### texture.name : <code>string</code>
The name of the material.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+source"></a>

### texture.source : <code>Source</code>
The data definition of a texture. A reference to the data source can be
shared across textures. This is often useful in context of spritesheets
where multiple textures render the same data but with different texture
transformations.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+mipmaps"></a>

### texture.mipmaps : <code>Array.&lt;Object&gt;</code>
An array holding user-defined mipmaps.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+mapping"></a>

### texture.mapping : <code>UVMapping</code> \| <code>CubeReflectionMapping</code> \| <code>CubeRefractionMapping</code> \| <code>EquirectangularReflectionMapping</code> \| <code>EquirectangularRefractionMapping</code> \| <code>CubeUVReflectionMapping</code>
How the texture is applied to the object. The value `UVMapping`
is the default, where texture or uv coordinates are used to apply the map.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>UVMapping</code>  
<a name="Texture+channel"></a>

### texture.channel : <code>number</code>
Lets you select the uv attribute to map the texture to. `0` for `uv`,
`1` for `uv1`, `2` for `uv2` and `3` for `uv3`.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
<a name="Texture+wrapS"></a>

### texture.wrapS : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped horizontally and corresponds to
*U* in UV mapping.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="Texture+wrapT"></a>

### texture.wrapT : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped horizontally and corresponds to
*V* in UV mapping.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="Texture+magFilter"></a>

### texture.magFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers more than one pixel.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>LinearFilter</code>  
<a name="Texture+minFilter"></a>

### texture.minFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers less than one pixel.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>LinearMipmapLinearFilter</code>  
<a name="Texture+anisotropy"></a>

### texture.anisotropy : <code>number</code>
The number of samples taken along the axis through the pixel that has the
highest density of texels. By default, this value is `1`. A higher value
gives a less blurry result than a basic mipmap, at the cost of more
texture samples being used.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
<a name="Texture+format"></a>

### texture.format : <code>number</code>
The format of the texture.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>RGBAFormat</code>  
<a name="Texture+internalFormat"></a>

### texture.internalFormat : <code>string</code>
The default internal format is derived from [format](#Texture+format) and [type](#Texture+type) and
defines how the texture data is going to be stored on the GPU.

This property allows to overwrite the default format.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>&quot;null&quot;</code>  
<a name="Texture+type"></a>

### texture.type : <code>number</code>
The data type of the texture.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>UnsignedByteType</code>  
<a name="Texture+offset"></a>

### texture.offset : <code>Vector2</code>
How much a single repetition of the texture is offset from the beginning,
in each direction U and V. Typical range is `0.0` to `1.0`.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>(0,0)</code>  
<a name="Texture+repeat"></a>

### texture.repeat : <code>Vector2</code>
How many times the texture is repeated across the surface, in each
direction U and V. If repeat is set greater than `1` in either direction,
the corresponding wrap parameter should also be set to `RepeatWrapping`
or `MirroredRepeatWrapping` to achieve the desired tiling effect.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>(1,1)</code>  
<a name="Texture+center"></a>

### texture.center : <code>Vector2</code>
The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
to the center of the texture. Default is `(0, 0)`, the lower left.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>(0,0)</code>  
<a name="Texture+rotation"></a>

### texture.rotation : <code>number</code>
How much the texture is rotated around the center point, in radians.
Positive values are counter-clockwise.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
<a name="Texture+matrixAutoUpdate"></a>

### texture.matrixAutoUpdate : <code>boolean</code>
Whether to update the texture's uv-transformation [matrix](#Texture+matrix)
from the properties [offset](#Texture+offset), [repeat](#Texture+repeat),
[rotation](#Texture+rotation), and [center](#Texture+center).

Set this to `false` if you are specifying the uv-transform matrix directly.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>true</code>  
<a name="Texture+matrix"></a>

### texture.matrix : <code>Matrix3</code>
The uv-transformation matrix of the texture.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+generateMipmaps"></a>

### texture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Set this to `false` if you are creating mipmaps manually.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>true</code>  
<a name="Texture+premultiplyAlpha"></a>

### texture.premultiplyAlpha : <code>boolean</code>
If set to `true`, the alpha channel, if present, is multiplied into the
color channels when the texture is uploaded to the GPU.

Note that this property has no effect when using `ImageBitmap`. You need to
configure premultiply alpha on bitmap creation instead.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>false</code>  
<a name="Texture+flipY"></a>

### texture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Note that this property has no effect when using `ImageBitmap`. You need to
configure the flip on bitmap creation instead.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>true</code>  
<a name="Texture+unpackAlignment"></a>

### texture.unpackAlignment : <code>number</code>
Specifies the alignment requirements for the start of each pixel row in memory.
The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
`4` (word-alignment), and `8` (rows start on double-word boundaries).

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>4</code>  
<a name="Texture+colorSpace"></a>

### texture.colorSpace : <code>string</code>
Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>&quot;NoColorSpace&quot;</code>  
<a name="Texture+userData"></a>

### texture.userData : <code>Object</code>
An object that can be used to store custom data about the texture. It
should not hold references to functions as these will not be cloned.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+version"></a>

### texture.version : <code>number</code>
This starts at `0` and counts how many times [needsUpdate](#Texture+needsUpdate) is set to `true`.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Texture+onUpdate"></a>

### texture.onUpdate : <code>function</code>
A callback function, called when the texture is updated (e.g., when
[needsUpdate](#Texture+needsUpdate) has been set to true and then the texture is used).

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>null</code>  
<a name="Texture+renderTarget"></a>

### texture.renderTarget : <code>RenderTarget</code> \| <code>WebGLRenderTarget</code>
An optional back reference to the textures render target.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>null</code>  
<a name="Texture+isRenderTargetTexture"></a>

### texture.isRenderTargetTexture : <code>boolean</code>
Indicates whether a texture belongs to a render target or not.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="Texture+pmremVersion"></a>

### texture.pmremVersion : <code>number</code>
Indicates whether this texture should be processed by `PMREMGenerator` or not
(only relevant for render target textures).

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Texture+image"></a>

### texture.image : <code>Object</code>
The image object holding the texture data.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+needsUpdate"></a>

### texture.needsUpdate : <code>boolean</code>
Setting this property to `true` indicates the engine the texture
must be updated in the next render. This triggers a texture upload
to the GPU and ensures correct texture parameter configuration.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Texture+needsPMREMUpdate"></a>

### texture.needsPMREMUpdate : <code>boolean</code>
Setting this property to `true` indicates the engine the PMREM
must be regenerated.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Texture+updateMatrix"></a>

### texture.updateMatrix()
Updates the texture transformation matrix from the from the properties [offset](#Texture+offset),
[repeat](#Texture+repeat), [rotation](#Texture+rotation), and [center](#Texture+center).

**Kind**: instance method of [<code>Texture</code>](#Texture)  
<a name="Texture+clone"></a>

### texture.clone() ⇒ [<code>Texture</code>](#Texture)
Returns a new texture with copied values from this instance.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Returns**: [<code>Texture</code>](#Texture) - A clone of this instance.  
<a name="Texture+copy"></a>

### texture.copy(source) ⇒ [<code>Texture</code>](#Texture)
Copies the values of the given texture to this instance.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Returns**: [<code>Texture</code>](#Texture) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>Texture</code>](#Texture) | The texture to copy. |

<a name="Texture+toJSON"></a>

### texture.toJSON(meta) ⇒ <code>Object</code>
Serializes the texture into JSON.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Returns**: <code>Object</code> - A JSON object representing the serialized texture.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Texture+dispose"></a>

### texture.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Emits**: [<code>dispose</code>](#Texture+event_dispose)  
<a name="Texture+transformUv"></a>

### texture.transformUv(uv) ⇒ <code>Vector2</code>
Transforms the given uv vector with the textures uv transformation matrix.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Returns**: <code>Vector2</code> - The transformed uv vector.  

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Vector2</code> | The uv vector. |

<a name="Texture+event_dispose"></a>

### "dispose"
Fires when the texture has been disposed of.

**Kind**: event emitted by [<code>Texture</code>](#Texture)  
<a name="Texture.DEFAULT_IMAGE"></a>

### Texture.DEFAULT\_IMAGE : <code>Image</code>
The default image for all textures.

**Kind**: static property of [<code>Texture</code>](#Texture)  
**Default**: <code>null</code>  
<a name="Texture.DEFAULT_MAPPING"></a>

### Texture.DEFAULT\_MAPPING : <code>number</code>
The default mapping for all textures.

**Kind**: static property of [<code>Texture</code>](#Texture)  
**Default**: <code>UVMapping</code>  
<a name="Texture.DEFAULT_ANISOTROPY"></a>

### Texture.DEFAULT\_ANISOTROPY : <code>number</code>
The default anisotropy value for all textures.

**Kind**: static property of [<code>Texture</code>](#Texture)  
**Default**: <code>1</code>  
<a name="VideoFrameTexture"></a>

## VideoFrameTexture ⇐ <code>VideoTexture</code>
This class can be used as an alternative way to define video data. Instead of using
an instance of `HTMLVideoElement` like with `VideoTexture`, `VideoFrameTexture` expects each frame is
defined manually via [setFrame](#VideoFrameTexture+setFrame). A typical use case for this module is when
video frames are decoded with the WebCodecs API.

```js
const texture = new THREE.VideoFrameTexture();
texture.setFrame( frame );
```

**Kind**: global class  
**Extends**: <code>VideoTexture</code>  

* [VideoFrameTexture](#VideoFrameTexture) ⇐ <code>VideoTexture</code>
    * [new VideoFrameTexture([mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])](#new_VideoFrameTexture_new)
    * [.isVideoFrameTexture](#VideoFrameTexture+isVideoFrameTexture) : <code>boolean</code>
    * [.update()](#VideoFrameTexture+update)
    * [.setFrame(frame)](#VideoFrameTexture+setFrame)

<a name="new_VideoFrameTexture_new"></a>

### new VideoFrameTexture([mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])
Constructs a new video frame texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |

<a name="VideoFrameTexture+isVideoFrameTexture"></a>

### videoFrameTexture.isVideoFrameTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VideoFrameTexture</code>](#VideoFrameTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VideoFrameTexture+update"></a>

### videoFrameTexture.update()
This method overwritten with an empty implementation since
this type of texture is updated via `setFrame()`.

**Kind**: instance method of [<code>VideoFrameTexture</code>](#VideoFrameTexture)  
<a name="VideoFrameTexture+setFrame"></a>

### videoFrameTexture.setFrame(frame)
Sets the current frame of the video. This will automatically update the texture
so the data can be used for rendering.

**Kind**: instance method of [<code>VideoFrameTexture</code>](#VideoFrameTexture)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>VideoFrame</code> | The video frame. |

<a name="VideoTexture"></a>

## VideoTexture ⇐ <code>Texture</code>
A texture for use with a video.

```js
// assuming you have created a HTML video element with id="video"
const video = document.getElementById( 'video' );
const texture = new THREE.VideoTexture( video );
```

Note: After the initial use of a texture, its dimensions, format, and type
cannot be changed. Instead, call [Texture#dispose](Texture#dispose) on the texture and instantiate a new one.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [VideoTexture](#VideoTexture) ⇐ <code>Texture</code>
    * [new VideoTexture(video, [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])](#new_VideoTexture_new)
    * [.isVideoTexture](#VideoTexture+isVideoTexture) : <code>boolean</code>
    * [.generateMipmaps](#VideoTexture+generateMipmaps) : <code>boolean</code>
    * [.update()](#VideoTexture+update)

<a name="new_VideoTexture_new"></a>

### new VideoTexture(video, [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])
Constructs a new video texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| video | <code>Video</code> |  | The video element to use as a data source for the texture. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |

<a name="VideoTexture+isVideoTexture"></a>

### videoTexture.isVideoTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VideoTexture</code>](#VideoTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VideoTexture+generateMipmaps"></a>

### videoTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>VideoTexture</code>](#VideoTexture)  
**Default**: <code>false</code>  
<a name="VideoTexture+update"></a>

### videoTexture.update()
This method is called automatically by the renderer and sets [Texture#needsUpdate](Texture#needsUpdate)
to `true` every time a new frame is available.

Only relevant if `requestVideoFrameCallback` is not supported in the browser.

**Kind**: instance method of [<code>VideoTexture</code>](#VideoTexture)  
